[
  {
    "function_name": "traceprobe_define_arg_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
    "lines": "639-662",
    "snippet": "int traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t size_t offset, struct trace_probe *tp)\n{\n\tint ret, i;\n\n\t/* Set argument names as fields */\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tstruct probe_arg *parg = &tp->args[i];\n\t\tconst char *fmt = parg->type->fmttype;\n\t\tint size = parg->type->size;\n\n\t\tif (parg->fmt)\n\t\t\tfmt = parg->fmt;\n\t\tif (parg->count)\n\t\t\tsize *= parg->count;\n\t\tret = trace_define_field(event_call, fmt, parg->name,\n\t\t\t\t\t offset + parg->offset, size,\n\t\t\t\t\t parg->type->is_signed,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_define_field",
          "args": [
            "event_call",
            "fmt",
            "parg->name",
            "offset + parg->offset",
            "size",
            "parg->type->is_signed",
            "FILTER_OTHER"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "trace_define_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "139-151",
          "snippet": "int trace_define_field(struct trace_event_call *call, const char *type,\n\t\t       const char *name, int offset, int size, int is_signed,\n\t\t       int filter_type)\n{\n\tstruct list_head *head;\n\n\tif (WARN_ON(!call->class))\n\t\treturn 0;\n\n\thead = trace_get_fields(call);\n\treturn __trace_define_field(head, type, name, offset, size,\n\t\t\t\t    is_signed, filter_type);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_define_field(struct trace_event_call *call, const char *type,\n\t\t       const char *name, int offset, int size, int is_signed,\n\t\t       int filter_type)\n{\n\tstruct list_head *head;\n\n\tif (WARN_ON(!call->class))\n\t\treturn 0;\n\n\thead = trace_get_fields(call);\n\treturn __trace_define_field(head, type, name, offset, size,\n\t\t\t\t    is_signed, filter_type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_define_arg_fields(struct trace_event_call *event_call,\n\t\t\t\t size_t offset, struct trace_probe *tp)\n{\n\tint ret, i;\n\n\t/* Set argument names as fields */\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tstruct probe_arg *parg = &tp->args[i];\n\t\tconst char *fmt = parg->type->fmttype;\n\t\tint size = parg->type->size;\n\n\t\tif (parg->fmt)\n\t\t\tfmt = parg->fmt;\n\t\tif (parg->count)\n\t\t\tsize *= parg->count;\n\t\tret = trace_define_field(event_call, fmt, parg->name,\n\t\t\t\t\t offset + parg->offset, size,\n\t\t\t\t\t parg->type->is_signed,\n\t\t\t\t\t FILTER_OTHER);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "traceprobe_set_print_fmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
    "lines": "621-637",
    "snippet": "int traceprobe_set_print_fmt(struct trace_probe *tp, bool is_return)\n{\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, is_return);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, is_return);\n\ttp->call.print_fmt = print_fmt;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_print_fmt",
          "args": [
            "tp",
            "print_fmt",
            "len + 1",
            "is_return"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "__set_print_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "561-618",
          "snippet": "static int __set_print_fmt(struct trace_probe *tp, char *buf, int len,\n\t\t\t   bool is_return)\n{\n\tstruct probe_arg *parg;\n\tint i, j;\n\tint pos = 0;\n\tconst char *fmt, *arg;\n\n\tif (!is_return) {\n\t\tfmt = \"(%lx)\";\n\t\targ = \"REC->\" FIELD_STRING_IP;\n\t} else {\n\t\tfmt = \"(%lx <- %lx)\";\n\t\targ = \"REC->\" FIELD_STRING_FUNC \", REC->\" FIELD_STRING_RETIP;\n\t}\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"%s\", fmt);\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tparg = tp->args + i;\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \" %s=\", parg->name);\n\t\tif (parg->count) {\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"{%s\",\n\t\t\t\t\tparg->type->fmt);\n\t\t\tfor (j = 1; j < parg->count; j++)\n\t\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \",%s\",\n\t\t\t\t\t\tparg->type->fmt);\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"}\");\n\t\t} else\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s\",\n\t\t\t\t\tparg->type->fmt);\n\t}\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\", %s\", arg);\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tparg = tp->args + i;\n\t\tif (parg->count) {\n\t\t\tif (strcmp(parg->type->name, \"string\") == 0)\n\t\t\t\tfmt = \", __get_str(%s[%d])\";\n\t\t\telse\n\t\t\t\tfmt = \", REC->%s[%d]\";\n\t\t\tfor (j = 0; j < parg->count; j++)\n\t\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\t\tfmt, parg->name, j);\n\t\t} else {\n\t\t\tif (strcmp(parg->type->name, \"string\") == 0)\n\t\t\t\tfmt = \", __get_str(%s)\";\n\t\t\telse\n\t\t\t\tfmt = \", REC->%s\";\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\tfmt, parg->name);\n\t\t}\n\t}\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [
            "#define LEN_OR_ZERO (len ? len - pos : 0)"
          ],
          "globals_used": [
            "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\n\nstatic int __set_print_fmt(struct trace_probe *tp, char *buf, int len,\n\t\t\t   bool is_return)\n{\n\tstruct probe_arg *parg;\n\tint i, j;\n\tint pos = 0;\n\tconst char *fmt, *arg;\n\n\tif (!is_return) {\n\t\tfmt = \"(%lx)\";\n\t\targ = \"REC->\" FIELD_STRING_IP;\n\t} else {\n\t\tfmt = \"(%lx <- %lx)\";\n\t\targ = \"REC->\" FIELD_STRING_FUNC \", REC->\" FIELD_STRING_RETIP;\n\t}\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"%s\", fmt);\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tparg = tp->args + i;\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \" %s=\", parg->name);\n\t\tif (parg->count) {\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"{%s\",\n\t\t\t\t\tparg->type->fmt);\n\t\t\tfor (j = 1; j < parg->count; j++)\n\t\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \",%s\",\n\t\t\t\t\t\tparg->type->fmt);\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"}\");\n\t\t} else\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s\",\n\t\t\t\t\tparg->type->fmt);\n\t}\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\", %s\", arg);\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tparg = tp->args + i;\n\t\tif (parg->count) {\n\t\t\tif (strcmp(parg->type->name, \"string\") == 0)\n\t\t\t\tfmt = \", __get_str(%s[%d])\";\n\t\t\telse\n\t\t\t\tfmt = \", REC->%s[%d]\";\n\t\t\tfor (j = 0; j < parg->count; j++)\n\t\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\t\tfmt, parg->name, j);\n\t\t} else {\n\t\t\tif (strcmp(parg->type->name, \"string\") == 0)\n\t\t\t\tfmt = \", __get_str(%s)\";\n\t\t\telse\n\t\t\t\tfmt = \", REC->%s\";\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\tfmt, parg->name);\n\t\t}\n\t}\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len + 1",
            "GFP_KERNEL"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_set_print_fmt(struct trace_probe *tp, bool is_return)\n{\n\tint len;\n\tchar *print_fmt;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_print_fmt(tp, NULL, 0, is_return);\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_print_fmt(tp, print_fmt, len + 1, is_return);\n\ttp->call.print_fmt = print_fmt;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__set_print_fmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
    "lines": "561-618",
    "snippet": "static int __set_print_fmt(struct trace_probe *tp, char *buf, int len,\n\t\t\t   bool is_return)\n{\n\tstruct probe_arg *parg;\n\tint i, j;\n\tint pos = 0;\n\tconst char *fmt, *arg;\n\n\tif (!is_return) {\n\t\tfmt = \"(%lx)\";\n\t\targ = \"REC->\" FIELD_STRING_IP;\n\t} else {\n\t\tfmt = \"(%lx <- %lx)\";\n\t\targ = \"REC->\" FIELD_STRING_FUNC \", REC->\" FIELD_STRING_RETIP;\n\t}\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"%s\", fmt);\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tparg = tp->args + i;\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \" %s=\", parg->name);\n\t\tif (parg->count) {\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"{%s\",\n\t\t\t\t\tparg->type->fmt);\n\t\t\tfor (j = 1; j < parg->count; j++)\n\t\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \",%s\",\n\t\t\t\t\t\tparg->type->fmt);\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"}\");\n\t\t} else\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s\",\n\t\t\t\t\tparg->type->fmt);\n\t}\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\", %s\", arg);\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tparg = tp->args + i;\n\t\tif (parg->count) {\n\t\t\tif (strcmp(parg->type->name, \"string\") == 0)\n\t\t\t\tfmt = \", __get_str(%s[%d])\";\n\t\t\telse\n\t\t\t\tfmt = \", REC->%s[%d]\";\n\t\t\tfor (j = 0; j < parg->count; j++)\n\t\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\t\tfmt, parg->name, j);\n\t\t} else {\n\t\t\tif (strcmp(parg->type->name, \"string\") == 0)\n\t\t\t\tfmt = \", __get_str(%s)\";\n\t\t\telse\n\t\t\t\tfmt = \", REC->%s\";\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\tfmt, parg->name);\n\t\t}\n\t}\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [
      "#define LEN_OR_ZERO (len ? len - pos : 0)"
    ],
    "globals_used": [
      "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "fmt",
            "parg->name"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "parg->type->name",
            "\"string\""
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "fmt",
            "parg->name",
            "j"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "parg->type->name",
            "\"string\""
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"\\\", %s\"",
            "arg"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"%s\"",
            "parg->type->fmt"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"}\""
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\",%s\"",
            "parg->type->fmt"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"{%s\"",
            "parg->type->fmt"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\" %s=\"",
            "parg->name"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"\\\"%s\"",
            "fmt"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\n\nstatic int __set_print_fmt(struct trace_probe *tp, char *buf, int len,\n\t\t\t   bool is_return)\n{\n\tstruct probe_arg *parg;\n\tint i, j;\n\tint pos = 0;\n\tconst char *fmt, *arg;\n\n\tif (!is_return) {\n\t\tfmt = \"(%lx)\";\n\t\targ = \"REC->\" FIELD_STRING_IP;\n\t} else {\n\t\tfmt = \"(%lx <- %lx)\";\n\t\targ = \"REC->\" FIELD_STRING_FUNC \", REC->\" FIELD_STRING_RETIP;\n\t}\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"%s\", fmt);\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tparg = tp->args + i;\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \" %s=\", parg->name);\n\t\tif (parg->count) {\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"{%s\",\n\t\t\t\t\tparg->type->fmt);\n\t\t\tfor (j = 1; j < parg->count; j++)\n\t\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \",%s\",\n\t\t\t\t\t\tparg->type->fmt);\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"}\");\n\t\t} else\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s\",\n\t\t\t\t\tparg->type->fmt);\n\t}\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\", %s\", arg);\n\n\tfor (i = 0; i < tp->nr_args; i++) {\n\t\tparg = tp->args + i;\n\t\tif (parg->count) {\n\t\t\tif (strcmp(parg->type->name, \"string\") == 0)\n\t\t\t\tfmt = \", __get_str(%s[%d])\";\n\t\t\telse\n\t\t\t\tfmt = \", REC->%s[%d]\";\n\t\t\tfor (j = 0; j < parg->count; j++)\n\t\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\t\tfmt, parg->name, j);\n\t\t} else {\n\t\t\tif (strcmp(parg->type->name, \"string\") == 0)\n\t\t\t\tfmt = \", __get_str(%s)\";\n\t\t\telse\n\t\t\t\tfmt = \", REC->%s\";\n\t\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\tfmt, parg->name);\n\t\t}\n\t}\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}"
  },
  {
    "function_name": "traceprobe_update_arg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
    "lines": "525-557",
    "snippet": "int traceprobe_update_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\tlong offset;\n\tchar *tmp;\n\tchar c;\n\tint ret = 0;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL) {\n\t\t\tif (code[1].op != FETCH_OP_IMM)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttmp = strpbrk(\"+-\", code->data);\n\t\t\tif (tmp)\n\t\t\t\tc = *tmp;\n\t\t\tret = traceprobe_split_symbol_offset(code->data,\n\t\t\t\t\t\t\t     &offset);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcode[1].immediate =\n\t\t\t\t(unsigned long)kallsyms_lookup_name(code->data);\n\t\t\tif (tmp)\n\t\t\t\t*tmp = c;\n\t\t\tif (!code[1].immediate)\n\t\t\t\treturn -ENOENT;\n\t\t\tcode[1].immediate += offset;\n\t\t}\n\t\tcode++;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kallsyms_lookup_name",
          "args": [
            "code->data"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "module_kallsyms_lookup_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "4090-4111",
          "snippet": "unsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = mod_find_symname(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = mod_find_symname(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\n\nunsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = mod_find_symname(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = mod_find_symname(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "traceprobe_split_symbol_offset",
          "args": [
            "code->data",
            "&offset"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "traceprobe_split_symbol_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "137-155",
          "snippet": "int traceprobe_split_symbol_offset(char *symbol, long *offset)\n{\n\tchar *tmp;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -EINVAL;\n\n\ttmp = strpbrk(symbol, \"+-\");\n\tif (tmp) {\n\t\tret = kstrtol(tmp, 0, offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*tmp = '\\0';\n\t} else\n\t\t*offset = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";\n\nint traceprobe_split_symbol_offset(char *symbol, long *offset)\n{\n\tchar *tmp;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -EINVAL;\n\n\ttmp = strpbrk(symbol, \"+-\");\n\tif (tmp) {\n\t\tret = kstrtol(tmp, 0, offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*tmp = '\\0';\n\t} else\n\t\t*offset = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "\"+-\"",
            "code->data"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nint traceprobe_update_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\tlong offset;\n\tchar *tmp;\n\tchar c;\n\tint ret = 0;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL) {\n\t\t\tif (code[1].op != FETCH_OP_IMM)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttmp = strpbrk(\"+-\", code->data);\n\t\t\tif (tmp)\n\t\t\t\tc = *tmp;\n\t\t\tret = traceprobe_split_symbol_offset(code->data,\n\t\t\t\t\t\t\t     &offset);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcode[1].immediate =\n\t\t\t\t(unsigned long)kallsyms_lookup_name(code->data);\n\t\t\tif (tmp)\n\t\t\t\t*tmp = c;\n\t\t\tif (!code[1].immediate)\n\t\t\t\treturn -ENOENT;\n\t\t\tcode[1].immediate += offset;\n\t\t}\n\t\tcode++;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "traceprobe_free_probe_arg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
    "lines": "510-523",
    "snippet": "void traceprobe_free_probe_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL)\n\t\t\tkfree(code->data);\n\t\tcode++;\n\t}\n\tkfree(arg->code);\n\tkfree(arg->name);\n\tkfree(arg->comm);\n\tkfree(arg->fmt);\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "arg->fmt"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nvoid traceprobe_free_probe_arg(struct probe_arg *arg)\n{\n\tstruct fetch_insn *code = arg->code;\n\n\twhile (code && code->op != FETCH_OP_END) {\n\t\tif (code->op == FETCH_NOP_SYMBOL)\n\t\t\tkfree(code->data);\n\t\tcode++;\n\t}\n\tkfree(arg->code);\n\tkfree(arg->name);\n\tkfree(arg->comm);\n\tkfree(arg->fmt);\n}"
  },
  {
    "function_name": "traceprobe_conflict_field_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
    "lines": "494-508",
    "snippet": "int traceprobe_conflict_field_name(const char *name,\n\t\t\t       struct probe_arg *args, int narg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reserved_field_names); i++)\n\t\tif (strcmp(reserved_field_names[i], name) == 0)\n\t\t\treturn 1;\n\n\tfor (i = 0; i < narg; i++)\n\t\tif (strcmp(args[i].name, name) == 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const char *reserved_field_names[] = {\n\t\"common_type\",\n\t\"common_flags\",\n\t\"common_preempt_count\",\n\t\"common_pid\",\n\t\"common_tgid\",\n\tFIELD_STRING_IP,\n\tFIELD_STRING_RETIP,\n\tFIELD_STRING_FUNC,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args[i].name",
            "name"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "reserved_field_names[i]",
            "name"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "reserved_field_names"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char *reserved_field_names[] = {\n\t\"common_type\",\n\t\"common_flags\",\n\t\"common_preempt_count\",\n\t\"common_pid\",\n\t\"common_tgid\",\n\tFIELD_STRING_IP,\n\tFIELD_STRING_RETIP,\n\tFIELD_STRING_FUNC,\n};\n\nint traceprobe_conflict_field_name(const char *name,\n\t\t\t       struct probe_arg *args, int narg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reserved_field_names); i++)\n\t\tif (strcmp(reserved_field_names[i], name) == 0)\n\t\t\treturn 1;\n\n\tfor (i = 0; i < narg; i++)\n\t\tif (strcmp(args[i].name, name) == 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "traceprobe_parse_probe_arg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
    "lines": "351-491",
    "snippet": "int traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\tstruct probe_arg *parg, unsigned int flags)\n{\n\tstruct fetch_insn *code, *scode, *tmp = NULL;\n\tchar *t, *t2;\n\tint ret, len;\n\n\tif (strlen(arg) > MAX_ARGSTR_LEN) {\n\t\tpr_info(\"Argument is too long.: %s\\n\",  arg);\n\t\treturn -ENOSPC;\n\t}\n\tparg->comm = kstrdup(arg, GFP_KERNEL);\n\tif (!parg->comm) {\n\t\tpr_info(\"Failed to allocate memory for command '%s'.\\n\", arg);\n\t\treturn -ENOMEM;\n\t}\n\tt = strchr(arg, ':');\n\tif (t) {\n\t\t*t = '\\0';\n\t\tt2 = strchr(++t, '[');\n\t\tif (t2) {\n\t\t\t*t2 = '\\0';\n\t\t\tparg->count = simple_strtoul(t2 + 1, &t2, 0);\n\t\t\tif (strcmp(t2, \"]\") || parg->count == 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (parg->count > MAX_ARRAY_LEN)\n\t\t\t\treturn -E2BIG;\n\t\t}\n\t}\n\t/*\n\t * The default type of $comm should be \"string\", and it can't be\n\t * dereferenced.\n\t */\n\tif (!t && strcmp(arg, \"$comm\") == 0)\n\t\tparg->type = find_fetch_type(\"string\");\n\telse\n\t\tparg->type = find_fetch_type(t);\n\tif (!parg->type) {\n\t\tpr_info(\"Unsupported type: %s\\n\", t);\n\t\treturn -EINVAL;\n\t}\n\tparg->offset = *size;\n\t*size += parg->type->size * (parg->count ?: 1);\n\n\tif (parg->count) {\n\t\tlen = strlen(parg->type->fmttype) + 6;\n\t\tparg->fmt = kmalloc(len, GFP_KERNEL);\n\t\tif (!parg->fmt)\n\t\t\treturn -ENOMEM;\n\t\tsnprintf(parg->fmt, len, \"%s[%d]\", parg->type->fmttype,\n\t\t\t parg->count);\n\t}\n\n\tcode = tmp = kzalloc(sizeof(*code) * FETCH_INSN_MAX, GFP_KERNEL);\n\tif (!code)\n\t\treturn -ENOMEM;\n\tcode[FETCH_INSN_MAX - 1].op = FETCH_OP_END;\n\n\tret = parse_probe_arg(arg, parg->type, &code, &code[FETCH_INSN_MAX - 1],\n\t\t\t      flags);\n\tif (ret)\n\t\tgoto fail;\n\n\t/* Store operation */\n\tif (!strcmp(parg->type->name, \"string\")) {\n\t\tif (code->op != FETCH_OP_DEREF && code->op != FETCH_OP_IMM &&\n\t\t    code->op != FETCH_OP_COMM) {\n\t\t\tpr_info(\"string only accepts memory or address.\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (code->op != FETCH_OP_DEREF || parg->count) {\n\t\t\t/*\n\t\t\t * IMM and COMM is pointing actual address, those must\n\t\t\t * be kept, and if parg->count != 0, this is an array\n\t\t\t * of string pointers instead of string address itself.\n\t\t\t */\n\t\t\tcode++;\n\t\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tcode->op = FETCH_OP_ST_STRING;\t/* In DEREF case, replace it */\n\t\tcode->size = parg->type->size;\n\t\tparg->dynamic = true;\n\t} else if (code->op == FETCH_OP_DEREF) {\n\t\tcode->op = FETCH_OP_ST_MEM;\n\t\tcode->size = parg->type->size;\n\t} else {\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_ST_RAW;\n\t\tcode->size = parg->type->size;\n\t}\n\tscode = code;\n\t/* Modify operation */\n\tif (t != NULL) {\n\t\tret = __parse_bitfield_probe_arg(t, parg->type, &code);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\t/* Loop(Array) operation */\n\tif (parg->count) {\n\t\tif (scode->op != FETCH_OP_ST_MEM &&\n\t\t    scode->op != FETCH_OP_ST_STRING) {\n\t\t\tpr_info(\"array only accepts memory or address\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_LP_ARRAY;\n\t\tcode->param = parg->count;\n\t}\n\tcode++;\n\tcode->op = FETCH_OP_END;\n\n\t/* Shrink down the code buffer */\n\tparg->code = kzalloc(sizeof(*code) * (code - tmp + 1), GFP_KERNEL);\n\tif (!parg->code)\n\t\tret = -ENOMEM;\n\telse\n\t\tmemcpy(parg->code, tmp, sizeof(*code) * (code - tmp + 1));\n\nfail:\n\tif (ret) {\n\t\tfor (code = tmp; code < tmp + FETCH_INSN_MAX; code++)\n\t\t\tif (code->op == FETCH_NOP_SYMBOL)\n\t\t\t\tkfree(code->data);\n\t}\n\tkfree(tmp);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "parg->code",
            "tmp",
            "sizeof(*code) * (code - tmp + 1)"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*code) * (code - tmp + 1)",
            "GFP_KERNEL"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"array only accepts memory or address\\n\""
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__parse_bitfield_probe_arg",
          "args": [
            "t",
            "parg->type",
            "&code"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_bitfield_probe_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "316-348",
          "snippet": "static int __parse_bitfield_probe_arg(const char *bf,\n\t\t\t\t      const struct fetch_type *t,\n\t\t\t\t      struct fetch_insn **pcode)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long bw, bo;\n\tchar *tail;\n\n\tif (*bf != 'b')\n\t\treturn 0;\n\n\tbw = simple_strtoul(bf + 1, &tail, 0);\t/* Use simple one */\n\n\tif (bw == 0 || *tail != '@')\n\t\treturn -EINVAL;\n\n\tbf = tail + 1;\n\tbo = simple_strtoul(bf, &tail, 0);\n\n\tif (tail == bf || *tail != '/')\n\t\treturn -EINVAL;\n\tcode++;\n\tif (code->op != FETCH_OP_NOP)\n\t\treturn -E2BIG;\n\t*pcode = code;\n\n\tcode->op = FETCH_OP_MOD_BF;\n\tcode->lshift = BYTES_TO_BITS(t->size) - (bw + bo);\n\tcode->rshift = BYTES_TO_BITS(t->size) - bw;\n\tcode->basesize = t->size;\n\n\treturn (BYTES_TO_BITS(t->size) < (bw + bo)) ? -EINVAL : 0;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic int __parse_bitfield_probe_arg(const char *bf,\n\t\t\t\t      const struct fetch_type *t,\n\t\t\t\t      struct fetch_insn **pcode)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long bw, bo;\n\tchar *tail;\n\n\tif (*bf != 'b')\n\t\treturn 0;\n\n\tbw = simple_strtoul(bf + 1, &tail, 0);\t/* Use simple one */\n\n\tif (bw == 0 || *tail != '@')\n\t\treturn -EINVAL;\n\n\tbf = tail + 1;\n\tbo = simple_strtoul(bf, &tail, 0);\n\n\tif (tail == bf || *tail != '/')\n\t\treturn -EINVAL;\n\tcode++;\n\tif (code->op != FETCH_OP_NOP)\n\t\treturn -E2BIG;\n\t*pcode = code;\n\n\tcode->op = FETCH_OP_MOD_BF;\n\tcode->lshift = BYTES_TO_BITS(t->size) - (bw + bo);\n\tcode->rshift = BYTES_TO_BITS(t->size) - bw;\n\tcode->basesize = t->size;\n\n\treturn (BYTES_TO_BITS(t->size) < (bw + bo)) ? -EINVAL : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"string only accepts memory or address.\\n\""
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "parg->type->name",
            "\"string\""
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_probe_arg",
          "args": [
            "arg",
            "parg->type",
            "&code",
            "&code[FETCH_INSN_MAX - 1]",
            "flags"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "parse_probe_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "205-311",
          "snippet": "static int\nparse_probe_arg(char *arg, const struct fetch_type *type,\n\t\tstruct fetch_insn **pcode, struct fetch_insn *end,\n\t\tunsigned int flags)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long param;\n\tlong offset = 0;\n\tchar *tmp;\n\tint ret = 0;\n\n\tswitch (arg[0]) {\n\tcase '$':\n\t\tret = parse_probe_vars(arg + 1, type, code, flags);\n\t\tbreak;\n\n\tcase '%':\t/* named register */\n\t\tret = regs_query_register_offset(arg + 1);\n\t\tif (ret >= 0) {\n\t\t\tcode->op = FETCH_OP_REG;\n\t\t\tcode->param = (unsigned int)ret;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase '@':\t/* memory, file-offset or symbol */\n\t\tif (isdigit(arg[1])) {\n\t\t\tret = kstrtoul(arg + 1, 0, &param);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\t/* load address */\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = param;\n\t\t} else if (arg[1] == '+') {\n\t\t\t/* kprobes don't support file offsets */\n\t\t\tif (flags & TPARG_FL_KERNEL)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tret = kstrtol(arg + 2, 0, &offset);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tcode->op = FETCH_OP_FOFFS;\n\t\t\tcode->immediate = (unsigned long)offset;  // imm64?\n\t\t} else {\n\t\t\t/* uprobes don't support symbols */\n\t\t\tif (!(flags & TPARG_FL_KERNEL))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* Preserve symbol for updating */\n\t\t\tcode->op = FETCH_NOP_SYMBOL;\n\t\t\tcode->data = kstrdup(arg + 1, GFP_KERNEL);\n\t\t\tif (!code->data)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (++code == end)\n\t\t\t\treturn -E2BIG;\n\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = 0;\n\t\t}\n\t\t/* These are fetching from memory */\n\t\tif (++code == end)\n\t\t\treturn -E2BIG;\n\t\t*pcode = code;\n\t\tcode->op = FETCH_OP_DEREF;\n\t\tcode->offset = offset;\n\t\tbreak;\n\n\tcase '+':\t/* deref memory */\n\t\targ++;\t/* Skip '+', because kstrtol() rejects it. */\n\tcase '-':\n\t\ttmp = strchr(arg, '(');\n\t\tif (!tmp)\n\t\t\treturn -EINVAL;\n\n\t\t*tmp = '\\0';\n\t\tret = kstrtol(arg, 0, &offset);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\targ = tmp + 1;\n\t\ttmp = strrchr(arg, ')');\n\n\t\tif (tmp) {\n\t\t\tconst struct fetch_type *t2 = find_fetch_type(NULL);\n\n\t\t\t*tmp = '\\0';\n\t\t\tret = parse_probe_arg(arg, t2, &code, end, flags);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (code->op == FETCH_OP_COMM)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (++code == end)\n\t\t\t\treturn -E2BIG;\n\t\t\t*pcode = code;\n\n\t\t\tcode->op = FETCH_OP_DEREF;\n\t\t\tcode->offset = offset;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!ret && code->op == FETCH_OP_NOP) {\n\t\t/* Parsed, but do not find fetch method */\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";\n\nstatic int\nparse_probe_arg(char *arg, const struct fetch_type *type,\n\t\tstruct fetch_insn **pcode, struct fetch_insn *end,\n\t\tunsigned int flags)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long param;\n\tlong offset = 0;\n\tchar *tmp;\n\tint ret = 0;\n\n\tswitch (arg[0]) {\n\tcase '$':\n\t\tret = parse_probe_vars(arg + 1, type, code, flags);\n\t\tbreak;\n\n\tcase '%':\t/* named register */\n\t\tret = regs_query_register_offset(arg + 1);\n\t\tif (ret >= 0) {\n\t\t\tcode->op = FETCH_OP_REG;\n\t\t\tcode->param = (unsigned int)ret;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase '@':\t/* memory, file-offset or symbol */\n\t\tif (isdigit(arg[1])) {\n\t\t\tret = kstrtoul(arg + 1, 0, &param);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\t/* load address */\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = param;\n\t\t} else if (arg[1] == '+') {\n\t\t\t/* kprobes don't support file offsets */\n\t\t\tif (flags & TPARG_FL_KERNEL)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tret = kstrtol(arg + 2, 0, &offset);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tcode->op = FETCH_OP_FOFFS;\n\t\t\tcode->immediate = (unsigned long)offset;  // imm64?\n\t\t} else {\n\t\t\t/* uprobes don't support symbols */\n\t\t\tif (!(flags & TPARG_FL_KERNEL))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* Preserve symbol for updating */\n\t\t\tcode->op = FETCH_NOP_SYMBOL;\n\t\t\tcode->data = kstrdup(arg + 1, GFP_KERNEL);\n\t\t\tif (!code->data)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (++code == end)\n\t\t\t\treturn -E2BIG;\n\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = 0;\n\t\t}\n\t\t/* These are fetching from memory */\n\t\tif (++code == end)\n\t\t\treturn -E2BIG;\n\t\t*pcode = code;\n\t\tcode->op = FETCH_OP_DEREF;\n\t\tcode->offset = offset;\n\t\tbreak;\n\n\tcase '+':\t/* deref memory */\n\t\targ++;\t/* Skip '+', because kstrtol() rejects it. */\n\tcase '-':\n\t\ttmp = strchr(arg, '(');\n\t\tif (!tmp)\n\t\t\treturn -EINVAL;\n\n\t\t*tmp = '\\0';\n\t\tret = kstrtol(arg, 0, &offset);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\targ = tmp + 1;\n\t\ttmp = strrchr(arg, ')');\n\n\t\tif (tmp) {\n\t\t\tconst struct fetch_type *t2 = find_fetch_type(NULL);\n\n\t\t\t*tmp = '\\0';\n\t\t\tret = parse_probe_arg(arg, t2, &code, end, flags);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (code->op == FETCH_OP_COMM)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (++code == end)\n\t\t\t\treturn -E2BIG;\n\t\t\t*pcode = code;\n\n\t\t\tcode->op = FETCH_OP_DEREF;\n\t\t\tcode->offset = offset;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!ret && code->op == FETCH_OP_NOP) {\n\t\t/* Parsed, but do not find fetch method */\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*code) * FETCH_INSN_MAX",
            "GFP_KERNEL"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "parg->fmt",
            "len",
            "\"%s[%d]\"",
            "parg->type->fmttype",
            "parg->count"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "parg->type->fmttype"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Unsupported type: %s\\n\"",
            "t"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_fetch_type",
          "args": [
            "t"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "find_fetch_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "94-134",
          "snippet": "static const struct fetch_type *find_fetch_type(const char *type)\n{\n\tint i;\n\n\tif (!type)\n\t\ttype = DEFAULT_FETCH_TYPE_STR;\n\n\t/* Special case: bitfield */\n\tif (*type == 'b') {\n\t\tunsigned long bs;\n\n\t\ttype = strchr(type, '/');\n\t\tif (!type)\n\t\t\tgoto fail;\n\n\t\ttype++;\n\t\tif (kstrtoul(type, 0, &bs))\n\t\t\tgoto fail;\n\n\t\tswitch (bs) {\n\t\tcase 8:\n\t\t\treturn find_fetch_type(\"u8\");\n\t\tcase 16:\n\t\t\treturn find_fetch_type(\"u16\");\n\t\tcase 32:\n\t\t\treturn find_fetch_type(\"u32\");\n\t\tcase 64:\n\t\t\treturn find_fetch_type(\"u64\");\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (i = 0; probe_fetch_types[i].name; i++) {\n\t\tif (strcmp(type, probe_fetch_types[i].name) == 0)\n\t\t\treturn &probe_fetch_types[i];\n\t}\n\nfail:\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fetch_type probe_fetch_types[] = {\n\t/* Special types */\n\t__ASSIGN_FETCH_TYPE(\"string\", string, string, sizeof(u32), 1,\n\t\t\t    \"__data_loc char[]\"),\n\t/* Basic types */\n\tASSIGN_FETCH_TYPE(u8,  u8,  0),\n\tASSIGN_FETCH_TYPE(u16, u16, 0),\n\tASSIGN_FETCH_TYPE(u32, u32, 0),\n\tASSIGN_FETCH_TYPE(u64, u64, 0),\n\tASSIGN_FETCH_TYPE(s8,  u8,  1),\n\tASSIGN_FETCH_TYPE(s16, u16, 1),\n\tASSIGN_FETCH_TYPE(s32, u32, 1),\n\tASSIGN_FETCH_TYPE(s64, u64, 1),\n\tASSIGN_FETCH_TYPE_ALIAS(x8,  u8,  u8,  0),\n\tASSIGN_FETCH_TYPE_ALIAS(x16, u16, u16, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x32, u32, u32, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x64, u64, u64, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(symbol, ADDR_FETCH_TYPE, ADDR_FETCH_TYPE, 0),\n\n\tASSIGN_FETCH_TYPE_END\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const struct fetch_type probe_fetch_types[] = {\n\t/* Special types */\n\t__ASSIGN_FETCH_TYPE(\"string\", string, string, sizeof(u32), 1,\n\t\t\t    \"__data_loc char[]\"),\n\t/* Basic types */\n\tASSIGN_FETCH_TYPE(u8,  u8,  0),\n\tASSIGN_FETCH_TYPE(u16, u16, 0),\n\tASSIGN_FETCH_TYPE(u32, u32, 0),\n\tASSIGN_FETCH_TYPE(u64, u64, 0),\n\tASSIGN_FETCH_TYPE(s8,  u8,  1),\n\tASSIGN_FETCH_TYPE(s16, u16, 1),\n\tASSIGN_FETCH_TYPE(s32, u32, 1),\n\tASSIGN_FETCH_TYPE(s64, u64, 1),\n\tASSIGN_FETCH_TYPE_ALIAS(x8,  u8,  u8,  0),\n\tASSIGN_FETCH_TYPE_ALIAS(x16, u16, u16, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x32, u32, u32, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x64, u64, u64, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(symbol, ADDR_FETCH_TYPE, ADDR_FETCH_TYPE, 0),\n\n\tASSIGN_FETCH_TYPE_END\n};\n\nstatic const struct fetch_type *find_fetch_type(const char *type)\n{\n\tint i;\n\n\tif (!type)\n\t\ttype = DEFAULT_FETCH_TYPE_STR;\n\n\t/* Special case: bitfield */\n\tif (*type == 'b') {\n\t\tunsigned long bs;\n\n\t\ttype = strchr(type, '/');\n\t\tif (!type)\n\t\t\tgoto fail;\n\n\t\ttype++;\n\t\tif (kstrtoul(type, 0, &bs))\n\t\t\tgoto fail;\n\n\t\tswitch (bs) {\n\t\tcase 8:\n\t\t\treturn find_fetch_type(\"u8\");\n\t\tcase 16:\n\t\t\treturn find_fetch_type(\"u16\");\n\t\tcase 32:\n\t\t\treturn find_fetch_type(\"u32\");\n\t\tcase 64:\n\t\t\treturn find_fetch_type(\"u64\");\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (i = 0; probe_fetch_types[i].name; i++) {\n\t\tif (strcmp(type, probe_fetch_types[i].name) == 0)\n\t\t\treturn &probe_fetch_types[i];\n\t}\n\nfail:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"$comm\""
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "t2",
            "\"]\""
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "t2 + 1",
            "&t2",
            "0"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "++t",
            "'['"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "arg",
            "':'"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Failed to allocate memory for command '%s'.\\n\"",
            "arg"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "arg",
            "GFP_KERNEL"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Argument is too long.: %s\\n\"",
            "arg"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\n\nint traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\tstruct probe_arg *parg, unsigned int flags)\n{\n\tstruct fetch_insn *code, *scode, *tmp = NULL;\n\tchar *t, *t2;\n\tint ret, len;\n\n\tif (strlen(arg) > MAX_ARGSTR_LEN) {\n\t\tpr_info(\"Argument is too long.: %s\\n\",  arg);\n\t\treturn -ENOSPC;\n\t}\n\tparg->comm = kstrdup(arg, GFP_KERNEL);\n\tif (!parg->comm) {\n\t\tpr_info(\"Failed to allocate memory for command '%s'.\\n\", arg);\n\t\treturn -ENOMEM;\n\t}\n\tt = strchr(arg, ':');\n\tif (t) {\n\t\t*t = '\\0';\n\t\tt2 = strchr(++t, '[');\n\t\tif (t2) {\n\t\t\t*t2 = '\\0';\n\t\t\tparg->count = simple_strtoul(t2 + 1, &t2, 0);\n\t\t\tif (strcmp(t2, \"]\") || parg->count == 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (parg->count > MAX_ARRAY_LEN)\n\t\t\t\treturn -E2BIG;\n\t\t}\n\t}\n\t/*\n\t * The default type of $comm should be \"string\", and it can't be\n\t * dereferenced.\n\t */\n\tif (!t && strcmp(arg, \"$comm\") == 0)\n\t\tparg->type = find_fetch_type(\"string\");\n\telse\n\t\tparg->type = find_fetch_type(t);\n\tif (!parg->type) {\n\t\tpr_info(\"Unsupported type: %s\\n\", t);\n\t\treturn -EINVAL;\n\t}\n\tparg->offset = *size;\n\t*size += parg->type->size * (parg->count ?: 1);\n\n\tif (parg->count) {\n\t\tlen = strlen(parg->type->fmttype) + 6;\n\t\tparg->fmt = kmalloc(len, GFP_KERNEL);\n\t\tif (!parg->fmt)\n\t\t\treturn -ENOMEM;\n\t\tsnprintf(parg->fmt, len, \"%s[%d]\", parg->type->fmttype,\n\t\t\t parg->count);\n\t}\n\n\tcode = tmp = kzalloc(sizeof(*code) * FETCH_INSN_MAX, GFP_KERNEL);\n\tif (!code)\n\t\treturn -ENOMEM;\n\tcode[FETCH_INSN_MAX - 1].op = FETCH_OP_END;\n\n\tret = parse_probe_arg(arg, parg->type, &code, &code[FETCH_INSN_MAX - 1],\n\t\t\t      flags);\n\tif (ret)\n\t\tgoto fail;\n\n\t/* Store operation */\n\tif (!strcmp(parg->type->name, \"string\")) {\n\t\tif (code->op != FETCH_OP_DEREF && code->op != FETCH_OP_IMM &&\n\t\t    code->op != FETCH_OP_COMM) {\n\t\t\tpr_info(\"string only accepts memory or address.\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (code->op != FETCH_OP_DEREF || parg->count) {\n\t\t\t/*\n\t\t\t * IMM and COMM is pointing actual address, those must\n\t\t\t * be kept, and if parg->count != 0, this is an array\n\t\t\t * of string pointers instead of string address itself.\n\t\t\t */\n\t\t\tcode++;\n\t\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tcode->op = FETCH_OP_ST_STRING;\t/* In DEREF case, replace it */\n\t\tcode->size = parg->type->size;\n\t\tparg->dynamic = true;\n\t} else if (code->op == FETCH_OP_DEREF) {\n\t\tcode->op = FETCH_OP_ST_MEM;\n\t\tcode->size = parg->type->size;\n\t} else {\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_ST_RAW;\n\t\tcode->size = parg->type->size;\n\t}\n\tscode = code;\n\t/* Modify operation */\n\tif (t != NULL) {\n\t\tret = __parse_bitfield_probe_arg(t, parg->type, &code);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\t/* Loop(Array) operation */\n\tif (parg->count) {\n\t\tif (scode->op != FETCH_OP_ST_MEM &&\n\t\t    scode->op != FETCH_OP_ST_STRING) {\n\t\t\tpr_info(\"array only accepts memory or address\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tcode++;\n\t\tif (code->op != FETCH_OP_NOP) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto fail;\n\t\t}\n\t\tcode->op = FETCH_OP_LP_ARRAY;\n\t\tcode->param = parg->count;\n\t}\n\tcode++;\n\tcode->op = FETCH_OP_END;\n\n\t/* Shrink down the code buffer */\n\tparg->code = kzalloc(sizeof(*code) * (code - tmp + 1), GFP_KERNEL);\n\tif (!parg->code)\n\t\tret = -ENOMEM;\n\telse\n\t\tmemcpy(parg->code, tmp, sizeof(*code) * (code - tmp + 1));\n\nfail:\n\tif (ret) {\n\t\tfor (code = tmp; code < tmp + FETCH_INSN_MAX; code++)\n\t\t\tif (code->op == FETCH_NOP_SYMBOL)\n\t\t\t\tkfree(code->data);\n\t}\n\tkfree(tmp);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__parse_bitfield_probe_arg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
    "lines": "316-348",
    "snippet": "static int __parse_bitfield_probe_arg(const char *bf,\n\t\t\t\t      const struct fetch_type *t,\n\t\t\t\t      struct fetch_insn **pcode)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long bw, bo;\n\tchar *tail;\n\n\tif (*bf != 'b')\n\t\treturn 0;\n\n\tbw = simple_strtoul(bf + 1, &tail, 0);\t/* Use simple one */\n\n\tif (bw == 0 || *tail != '@')\n\t\treturn -EINVAL;\n\n\tbf = tail + 1;\n\tbo = simple_strtoul(bf, &tail, 0);\n\n\tif (tail == bf || *tail != '/')\n\t\treturn -EINVAL;\n\tcode++;\n\tif (code->op != FETCH_OP_NOP)\n\t\treturn -E2BIG;\n\t*pcode = code;\n\n\tcode->op = FETCH_OP_MOD_BF;\n\tcode->lshift = BYTES_TO_BITS(t->size) - (bw + bo);\n\tcode->rshift = BYTES_TO_BITS(t->size) - bw;\n\tcode->basesize = t->size;\n\n\treturn (BYTES_TO_BITS(t->size) < (bw + bo)) ? -EINVAL : 0;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BYTES_TO_BITS",
          "args": [
            "t->size"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BYTES_TO_BITS",
          "args": [
            "t->size"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BYTES_TO_BITS",
          "args": [
            "t->size"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "bf",
            "&tail",
            "0"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "bf + 1",
            "&tail",
            "0"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic int __parse_bitfield_probe_arg(const char *bf,\n\t\t\t\t      const struct fetch_type *t,\n\t\t\t\t      struct fetch_insn **pcode)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long bw, bo;\n\tchar *tail;\n\n\tif (*bf != 'b')\n\t\treturn 0;\n\n\tbw = simple_strtoul(bf + 1, &tail, 0);\t/* Use simple one */\n\n\tif (bw == 0 || *tail != '@')\n\t\treturn -EINVAL;\n\n\tbf = tail + 1;\n\tbo = simple_strtoul(bf, &tail, 0);\n\n\tif (tail == bf || *tail != '/')\n\t\treturn -EINVAL;\n\tcode++;\n\tif (code->op != FETCH_OP_NOP)\n\t\treturn -E2BIG;\n\t*pcode = code;\n\n\tcode->op = FETCH_OP_MOD_BF;\n\tcode->lshift = BYTES_TO_BITS(t->size) - (bw + bo);\n\tcode->rshift = BYTES_TO_BITS(t->size) - bw;\n\tcode->basesize = t->size;\n\n\treturn (BYTES_TO_BITS(t->size) < (bw + bo)) ? -EINVAL : 0;\n}"
  },
  {
    "function_name": "parse_probe_arg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
    "lines": "205-311",
    "snippet": "static int\nparse_probe_arg(char *arg, const struct fetch_type *type,\n\t\tstruct fetch_insn **pcode, struct fetch_insn *end,\n\t\tunsigned int flags)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long param;\n\tlong offset = 0;\n\tchar *tmp;\n\tint ret = 0;\n\n\tswitch (arg[0]) {\n\tcase '$':\n\t\tret = parse_probe_vars(arg + 1, type, code, flags);\n\t\tbreak;\n\n\tcase '%':\t/* named register */\n\t\tret = regs_query_register_offset(arg + 1);\n\t\tif (ret >= 0) {\n\t\t\tcode->op = FETCH_OP_REG;\n\t\t\tcode->param = (unsigned int)ret;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase '@':\t/* memory, file-offset or symbol */\n\t\tif (isdigit(arg[1])) {\n\t\t\tret = kstrtoul(arg + 1, 0, &param);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\t/* load address */\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = param;\n\t\t} else if (arg[1] == '+') {\n\t\t\t/* kprobes don't support file offsets */\n\t\t\tif (flags & TPARG_FL_KERNEL)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tret = kstrtol(arg + 2, 0, &offset);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tcode->op = FETCH_OP_FOFFS;\n\t\t\tcode->immediate = (unsigned long)offset;  // imm64?\n\t\t} else {\n\t\t\t/* uprobes don't support symbols */\n\t\t\tif (!(flags & TPARG_FL_KERNEL))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* Preserve symbol for updating */\n\t\t\tcode->op = FETCH_NOP_SYMBOL;\n\t\t\tcode->data = kstrdup(arg + 1, GFP_KERNEL);\n\t\t\tif (!code->data)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (++code == end)\n\t\t\t\treturn -E2BIG;\n\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = 0;\n\t\t}\n\t\t/* These are fetching from memory */\n\t\tif (++code == end)\n\t\t\treturn -E2BIG;\n\t\t*pcode = code;\n\t\tcode->op = FETCH_OP_DEREF;\n\t\tcode->offset = offset;\n\t\tbreak;\n\n\tcase '+':\t/* deref memory */\n\t\targ++;\t/* Skip '+', because kstrtol() rejects it. */\n\tcase '-':\n\t\ttmp = strchr(arg, '(');\n\t\tif (!tmp)\n\t\t\treturn -EINVAL;\n\n\t\t*tmp = '\\0';\n\t\tret = kstrtol(arg, 0, &offset);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\targ = tmp + 1;\n\t\ttmp = strrchr(arg, ')');\n\n\t\tif (tmp) {\n\t\t\tconst struct fetch_type *t2 = find_fetch_type(NULL);\n\n\t\t\t*tmp = '\\0';\n\t\t\tret = parse_probe_arg(arg, t2, &code, end, flags);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (code->op == FETCH_OP_COMM)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (++code == end)\n\t\t\t\treturn -E2BIG;\n\t\t\t*pcode = code;\n\n\t\t\tcode->op = FETCH_OP_DEREF;\n\t\t\tcode->offset = offset;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!ret && code->op == FETCH_OP_NOP) {\n\t\t/* Parsed, but do not find fetch method */\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_probe_arg",
          "args": [
            "arg",
            "t2",
            "&code",
            "end",
            "flags"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "parse_probe_arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "205-311",
          "snippet": "static int\nparse_probe_arg(char *arg, const struct fetch_type *type,\n\t\tstruct fetch_insn **pcode, struct fetch_insn *end,\n\t\tunsigned int flags)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long param;\n\tlong offset = 0;\n\tchar *tmp;\n\tint ret = 0;\n\n\tswitch (arg[0]) {\n\tcase '$':\n\t\tret = parse_probe_vars(arg + 1, type, code, flags);\n\t\tbreak;\n\n\tcase '%':\t/* named register */\n\t\tret = regs_query_register_offset(arg + 1);\n\t\tif (ret >= 0) {\n\t\t\tcode->op = FETCH_OP_REG;\n\t\t\tcode->param = (unsigned int)ret;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase '@':\t/* memory, file-offset or symbol */\n\t\tif (isdigit(arg[1])) {\n\t\t\tret = kstrtoul(arg + 1, 0, &param);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\t/* load address */\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = param;\n\t\t} else if (arg[1] == '+') {\n\t\t\t/* kprobes don't support file offsets */\n\t\t\tif (flags & TPARG_FL_KERNEL)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tret = kstrtol(arg + 2, 0, &offset);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tcode->op = FETCH_OP_FOFFS;\n\t\t\tcode->immediate = (unsigned long)offset;  // imm64?\n\t\t} else {\n\t\t\t/* uprobes don't support symbols */\n\t\t\tif (!(flags & TPARG_FL_KERNEL))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* Preserve symbol for updating */\n\t\t\tcode->op = FETCH_NOP_SYMBOL;\n\t\t\tcode->data = kstrdup(arg + 1, GFP_KERNEL);\n\t\t\tif (!code->data)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (++code == end)\n\t\t\t\treturn -E2BIG;\n\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = 0;\n\t\t}\n\t\t/* These are fetching from memory */\n\t\tif (++code == end)\n\t\t\treturn -E2BIG;\n\t\t*pcode = code;\n\t\tcode->op = FETCH_OP_DEREF;\n\t\tcode->offset = offset;\n\t\tbreak;\n\n\tcase '+':\t/* deref memory */\n\t\targ++;\t/* Skip '+', because kstrtol() rejects it. */\n\tcase '-':\n\t\ttmp = strchr(arg, '(');\n\t\tif (!tmp)\n\t\t\treturn -EINVAL;\n\n\t\t*tmp = '\\0';\n\t\tret = kstrtol(arg, 0, &offset);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\targ = tmp + 1;\n\t\ttmp = strrchr(arg, ')');\n\n\t\tif (tmp) {\n\t\t\tconst struct fetch_type *t2 = find_fetch_type(NULL);\n\n\t\t\t*tmp = '\\0';\n\t\t\tret = parse_probe_arg(arg, t2, &code, end, flags);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (code->op == FETCH_OP_COMM)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (++code == end)\n\t\t\t\treturn -E2BIG;\n\t\t\t*pcode = code;\n\n\t\t\tcode->op = FETCH_OP_DEREF;\n\t\t\tcode->offset = offset;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!ret && code->op == FETCH_OP_NOP) {\n\t\t/* Parsed, but do not find fetch method */\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "find_fetch_type",
          "args": [
            "NULL"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "find_fetch_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "94-134",
          "snippet": "static const struct fetch_type *find_fetch_type(const char *type)\n{\n\tint i;\n\n\tif (!type)\n\t\ttype = DEFAULT_FETCH_TYPE_STR;\n\n\t/* Special case: bitfield */\n\tif (*type == 'b') {\n\t\tunsigned long bs;\n\n\t\ttype = strchr(type, '/');\n\t\tif (!type)\n\t\t\tgoto fail;\n\n\t\ttype++;\n\t\tif (kstrtoul(type, 0, &bs))\n\t\t\tgoto fail;\n\n\t\tswitch (bs) {\n\t\tcase 8:\n\t\t\treturn find_fetch_type(\"u8\");\n\t\tcase 16:\n\t\t\treturn find_fetch_type(\"u16\");\n\t\tcase 32:\n\t\t\treturn find_fetch_type(\"u32\");\n\t\tcase 64:\n\t\t\treturn find_fetch_type(\"u64\");\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (i = 0; probe_fetch_types[i].name; i++) {\n\t\tif (strcmp(type, probe_fetch_types[i].name) == 0)\n\t\t\treturn &probe_fetch_types[i];\n\t}\n\nfail:\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fetch_type probe_fetch_types[] = {\n\t/* Special types */\n\t__ASSIGN_FETCH_TYPE(\"string\", string, string, sizeof(u32), 1,\n\t\t\t    \"__data_loc char[]\"),\n\t/* Basic types */\n\tASSIGN_FETCH_TYPE(u8,  u8,  0),\n\tASSIGN_FETCH_TYPE(u16, u16, 0),\n\tASSIGN_FETCH_TYPE(u32, u32, 0),\n\tASSIGN_FETCH_TYPE(u64, u64, 0),\n\tASSIGN_FETCH_TYPE(s8,  u8,  1),\n\tASSIGN_FETCH_TYPE(s16, u16, 1),\n\tASSIGN_FETCH_TYPE(s32, u32, 1),\n\tASSIGN_FETCH_TYPE(s64, u64, 1),\n\tASSIGN_FETCH_TYPE_ALIAS(x8,  u8,  u8,  0),\n\tASSIGN_FETCH_TYPE_ALIAS(x16, u16, u16, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x32, u32, u32, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x64, u64, u64, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(symbol, ADDR_FETCH_TYPE, ADDR_FETCH_TYPE, 0),\n\n\tASSIGN_FETCH_TYPE_END\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const struct fetch_type probe_fetch_types[] = {\n\t/* Special types */\n\t__ASSIGN_FETCH_TYPE(\"string\", string, string, sizeof(u32), 1,\n\t\t\t    \"__data_loc char[]\"),\n\t/* Basic types */\n\tASSIGN_FETCH_TYPE(u8,  u8,  0),\n\tASSIGN_FETCH_TYPE(u16, u16, 0),\n\tASSIGN_FETCH_TYPE(u32, u32, 0),\n\tASSIGN_FETCH_TYPE(u64, u64, 0),\n\tASSIGN_FETCH_TYPE(s8,  u8,  1),\n\tASSIGN_FETCH_TYPE(s16, u16, 1),\n\tASSIGN_FETCH_TYPE(s32, u32, 1),\n\tASSIGN_FETCH_TYPE(s64, u64, 1),\n\tASSIGN_FETCH_TYPE_ALIAS(x8,  u8,  u8,  0),\n\tASSIGN_FETCH_TYPE_ALIAS(x16, u16, u16, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x32, u32, u32, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x64, u64, u64, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(symbol, ADDR_FETCH_TYPE, ADDR_FETCH_TYPE, 0),\n\n\tASSIGN_FETCH_TYPE_END\n};\n\nstatic const struct fetch_type *find_fetch_type(const char *type)\n{\n\tint i;\n\n\tif (!type)\n\t\ttype = DEFAULT_FETCH_TYPE_STR;\n\n\t/* Special case: bitfield */\n\tif (*type == 'b') {\n\t\tunsigned long bs;\n\n\t\ttype = strchr(type, '/');\n\t\tif (!type)\n\t\t\tgoto fail;\n\n\t\ttype++;\n\t\tif (kstrtoul(type, 0, &bs))\n\t\t\tgoto fail;\n\n\t\tswitch (bs) {\n\t\tcase 8:\n\t\t\treturn find_fetch_type(\"u8\");\n\t\tcase 16:\n\t\t\treturn find_fetch_type(\"u16\");\n\t\tcase 32:\n\t\t\treturn find_fetch_type(\"u32\");\n\t\tcase 64:\n\t\t\treturn find_fetch_type(\"u64\");\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (i = 0; probe_fetch_types[i].name; i++) {\n\t\tif (strcmp(type, probe_fetch_types[i].name) == 0)\n\t\t\treturn &probe_fetch_types[i];\n\t}\n\nfail:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "arg",
            "')'"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtol",
          "args": [
            "arg",
            "0",
            "&offset"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "arg",
            "'('"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "arg + 1",
            "GFP_KERNEL"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtol",
          "args": [
            "arg + 2",
            "0",
            "&offset"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "arg + 1",
            "0",
            "&param"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "arg[1]"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regs_query_register_offset",
          "args": [
            "arg + 1"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_probe_vars",
          "args": [
            "arg + 1",
            "type",
            "code",
            "flags"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "parse_probe_vars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "159-202",
          "snippet": "static int parse_probe_vars(char *arg, const struct fetch_type *t,\n\t\t\t    struct fetch_insn *code, unsigned int flags)\n{\n\tint ret = 0;\n\tunsigned long param;\n\n\tif (strcmp(arg, \"retval\") == 0) {\n\t\tif (flags & TPARG_FL_RETURN)\n\t\t\tcode->op = FETCH_OP_RETVAL;\n\t\telse\n\t\t\tret = -EINVAL;\n\t} else if (strncmp(arg, \"stack\", 5) == 0) {\n\t\tif (arg[5] == '\\0') {\n\t\t\tcode->op = FETCH_OP_STACKP;\n\t\t} else if (isdigit(arg[5])) {\n\t\t\tret = kstrtoul(arg + 5, 10, &param);\n\t\t\tif (ret || ((flags & TPARG_FL_KERNEL) &&\n\t\t\t\t    param > PARAM_MAX_STACK))\n\t\t\t\tret = -EINVAL;\n\t\t\telse {\n\t\t\t\tcode->op = FETCH_OP_STACK;\n\t\t\t\tcode->param = (unsigned int)param;\n\t\t\t}\n\t\t} else\n\t\t\tret = -EINVAL;\n\t} else if (strcmp(arg, \"comm\") == 0) {\n\t\tcode->op = FETCH_OP_COMM;\n#ifdef CONFIG_HAVE_FUNCTION_ARG_ACCESS_API\n\t} else if (((flags & TPARG_FL_MASK) ==\n\t\t    (TPARG_FL_KERNEL | TPARG_FL_FENTRY)) &&\n\t\t   strncmp(arg, \"arg\", 3) == 0) {\n\t\tif (!isdigit(arg[3]))\n\t\t\treturn -EINVAL;\n\t\tret = kstrtoul(arg + 3, 10, &param);\n\t\tif (ret || !param || param > PARAM_MAX_STACK)\n\t\t\treturn -EINVAL;\n\t\tcode->op = FETCH_OP_ARG;\n\t\tcode->param = (unsigned int)param - 1;\n#endif\n\t} else\n\t\tret = -EINVAL;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe.h\""
          ],
          "macros_used": [
            "#define PARAM_MAX_STACK (THREAD_SIZE / sizeof(unsigned long))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n\n#define PARAM_MAX_STACK (THREAD_SIZE / sizeof(unsigned long))\n\nstatic int parse_probe_vars(char *arg, const struct fetch_type *t,\n\t\t\t    struct fetch_insn *code, unsigned int flags)\n{\n\tint ret = 0;\n\tunsigned long param;\n\n\tif (strcmp(arg, \"retval\") == 0) {\n\t\tif (flags & TPARG_FL_RETURN)\n\t\t\tcode->op = FETCH_OP_RETVAL;\n\t\telse\n\t\t\tret = -EINVAL;\n\t} else if (strncmp(arg, \"stack\", 5) == 0) {\n\t\tif (arg[5] == '\\0') {\n\t\t\tcode->op = FETCH_OP_STACKP;\n\t\t} else if (isdigit(arg[5])) {\n\t\t\tret = kstrtoul(arg + 5, 10, &param);\n\t\t\tif (ret || ((flags & TPARG_FL_KERNEL) &&\n\t\t\t\t    param > PARAM_MAX_STACK))\n\t\t\t\tret = -EINVAL;\n\t\t\telse {\n\t\t\t\tcode->op = FETCH_OP_STACK;\n\t\t\t\tcode->param = (unsigned int)param;\n\t\t\t}\n\t\t} else\n\t\t\tret = -EINVAL;\n\t} else if (strcmp(arg, \"comm\") == 0) {\n\t\tcode->op = FETCH_OP_COMM;\n#ifdef CONFIG_HAVE_FUNCTION_ARG_ACCESS_API\n\t} else if (((flags & TPARG_FL_MASK) ==\n\t\t    (TPARG_FL_KERNEL | TPARG_FL_FENTRY)) &&\n\t\t   strncmp(arg, \"arg\", 3) == 0) {\n\t\tif (!isdigit(arg[3]))\n\t\t\treturn -EINVAL;\n\t\tret = kstrtoul(arg + 3, 10, &param);\n\t\tif (ret || !param || param > PARAM_MAX_STACK)\n\t\t\treturn -EINVAL;\n\t\tcode->op = FETCH_OP_ARG;\n\t\tcode->param = (unsigned int)param - 1;\n#endif\n\t} else\n\t\tret = -EINVAL;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";\n\nstatic int\nparse_probe_arg(char *arg, const struct fetch_type *type,\n\t\tstruct fetch_insn **pcode, struct fetch_insn *end,\n\t\tunsigned int flags)\n{\n\tstruct fetch_insn *code = *pcode;\n\tunsigned long param;\n\tlong offset = 0;\n\tchar *tmp;\n\tint ret = 0;\n\n\tswitch (arg[0]) {\n\tcase '$':\n\t\tret = parse_probe_vars(arg + 1, type, code, flags);\n\t\tbreak;\n\n\tcase '%':\t/* named register */\n\t\tret = regs_query_register_offset(arg + 1);\n\t\tif (ret >= 0) {\n\t\t\tcode->op = FETCH_OP_REG;\n\t\t\tcode->param = (unsigned int)ret;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase '@':\t/* memory, file-offset or symbol */\n\t\tif (isdigit(arg[1])) {\n\t\t\tret = kstrtoul(arg + 1, 0, &param);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\t/* load address */\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = param;\n\t\t} else if (arg[1] == '+') {\n\t\t\t/* kprobes don't support file offsets */\n\t\t\tif (flags & TPARG_FL_KERNEL)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tret = kstrtol(arg + 2, 0, &offset);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tcode->op = FETCH_OP_FOFFS;\n\t\t\tcode->immediate = (unsigned long)offset;  // imm64?\n\t\t} else {\n\t\t\t/* uprobes don't support symbols */\n\t\t\tif (!(flags & TPARG_FL_KERNEL))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* Preserve symbol for updating */\n\t\t\tcode->op = FETCH_NOP_SYMBOL;\n\t\t\tcode->data = kstrdup(arg + 1, GFP_KERNEL);\n\t\t\tif (!code->data)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (++code == end)\n\t\t\t\treturn -E2BIG;\n\n\t\t\tcode->op = FETCH_OP_IMM;\n\t\t\tcode->immediate = 0;\n\t\t}\n\t\t/* These are fetching from memory */\n\t\tif (++code == end)\n\t\t\treturn -E2BIG;\n\t\t*pcode = code;\n\t\tcode->op = FETCH_OP_DEREF;\n\t\tcode->offset = offset;\n\t\tbreak;\n\n\tcase '+':\t/* deref memory */\n\t\targ++;\t/* Skip '+', because kstrtol() rejects it. */\n\tcase '-':\n\t\ttmp = strchr(arg, '(');\n\t\tif (!tmp)\n\t\t\treturn -EINVAL;\n\n\t\t*tmp = '\\0';\n\t\tret = kstrtol(arg, 0, &offset);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\targ = tmp + 1;\n\t\ttmp = strrchr(arg, ')');\n\n\t\tif (tmp) {\n\t\t\tconst struct fetch_type *t2 = find_fetch_type(NULL);\n\n\t\t\t*tmp = '\\0';\n\t\t\tret = parse_probe_arg(arg, t2, &code, end, flags);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (code->op == FETCH_OP_COMM)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (++code == end)\n\t\t\t\treturn -E2BIG;\n\t\t\t*pcode = code;\n\n\t\t\tcode->op = FETCH_OP_DEREF;\n\t\t\tcode->offset = offset;\n\t\t}\n\t\tbreak;\n\t}\n\tif (!ret && code->op == FETCH_OP_NOP) {\n\t\t/* Parsed, but do not find fetch method */\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "parse_probe_vars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
    "lines": "159-202",
    "snippet": "static int parse_probe_vars(char *arg, const struct fetch_type *t,\n\t\t\t    struct fetch_insn *code, unsigned int flags)\n{\n\tint ret = 0;\n\tunsigned long param;\n\n\tif (strcmp(arg, \"retval\") == 0) {\n\t\tif (flags & TPARG_FL_RETURN)\n\t\t\tcode->op = FETCH_OP_RETVAL;\n\t\telse\n\t\t\tret = -EINVAL;\n\t} else if (strncmp(arg, \"stack\", 5) == 0) {\n\t\tif (arg[5] == '\\0') {\n\t\t\tcode->op = FETCH_OP_STACKP;\n\t\t} else if (isdigit(arg[5])) {\n\t\t\tret = kstrtoul(arg + 5, 10, &param);\n\t\t\tif (ret || ((flags & TPARG_FL_KERNEL) &&\n\t\t\t\t    param > PARAM_MAX_STACK))\n\t\t\t\tret = -EINVAL;\n\t\t\telse {\n\t\t\t\tcode->op = FETCH_OP_STACK;\n\t\t\t\tcode->param = (unsigned int)param;\n\t\t\t}\n\t\t} else\n\t\t\tret = -EINVAL;\n\t} else if (strcmp(arg, \"comm\") == 0) {\n\t\tcode->op = FETCH_OP_COMM;\n#ifdef CONFIG_HAVE_FUNCTION_ARG_ACCESS_API\n\t} else if (((flags & TPARG_FL_MASK) ==\n\t\t    (TPARG_FL_KERNEL | TPARG_FL_FENTRY)) &&\n\t\t   strncmp(arg, \"arg\", 3) == 0) {\n\t\tif (!isdigit(arg[3]))\n\t\t\treturn -EINVAL;\n\t\tret = kstrtoul(arg + 3, 10, &param);\n\t\tif (ret || !param || param > PARAM_MAX_STACK)\n\t\t\treturn -EINVAL;\n\t\tcode->op = FETCH_OP_ARG;\n\t\tcode->param = (unsigned int)param - 1;\n#endif\n\t} else\n\t\tret = -EINVAL;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [
      "#define PARAM_MAX_STACK (THREAD_SIZE / sizeof(unsigned long))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "arg + 3",
            "10",
            "&param"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "arg[3]"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "arg",
            "\"arg\"",
            "3"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"comm\""
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "arg + 5",
            "10",
            "&param"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "arg[5]"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "arg",
            "\"stack\"",
            "5"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"retval\""
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\n#define PARAM_MAX_STACK (THREAD_SIZE / sizeof(unsigned long))\n\nstatic int parse_probe_vars(char *arg, const struct fetch_type *t,\n\t\t\t    struct fetch_insn *code, unsigned int flags)\n{\n\tint ret = 0;\n\tunsigned long param;\n\n\tif (strcmp(arg, \"retval\") == 0) {\n\t\tif (flags & TPARG_FL_RETURN)\n\t\t\tcode->op = FETCH_OP_RETVAL;\n\t\telse\n\t\t\tret = -EINVAL;\n\t} else if (strncmp(arg, \"stack\", 5) == 0) {\n\t\tif (arg[5] == '\\0') {\n\t\t\tcode->op = FETCH_OP_STACKP;\n\t\t} else if (isdigit(arg[5])) {\n\t\t\tret = kstrtoul(arg + 5, 10, &param);\n\t\t\tif (ret || ((flags & TPARG_FL_KERNEL) &&\n\t\t\t\t    param > PARAM_MAX_STACK))\n\t\t\t\tret = -EINVAL;\n\t\t\telse {\n\t\t\t\tcode->op = FETCH_OP_STACK;\n\t\t\t\tcode->param = (unsigned int)param;\n\t\t\t}\n\t\t} else\n\t\t\tret = -EINVAL;\n\t} else if (strcmp(arg, \"comm\") == 0) {\n\t\tcode->op = FETCH_OP_COMM;\n#ifdef CONFIG_HAVE_FUNCTION_ARG_ACCESS_API\n\t} else if (((flags & TPARG_FL_MASK) ==\n\t\t    (TPARG_FL_KERNEL | TPARG_FL_FENTRY)) &&\n\t\t   strncmp(arg, \"arg\", 3) == 0) {\n\t\tif (!isdigit(arg[3]))\n\t\t\treturn -EINVAL;\n\t\tret = kstrtoul(arg + 3, 10, &param);\n\t\tif (ret || !param || param > PARAM_MAX_STACK)\n\t\t\treturn -EINVAL;\n\t\tcode->op = FETCH_OP_ARG;\n\t\tcode->param = (unsigned int)param - 1;\n#endif\n\t} else\n\t\tret = -EINVAL;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "traceprobe_split_symbol_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
    "lines": "137-155",
    "snippet": "int traceprobe_split_symbol_offset(char *symbol, long *offset)\n{\n\tchar *tmp;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -EINVAL;\n\n\ttmp = strpbrk(symbol, \"+-\");\n\tif (tmp) {\n\t\tret = kstrtol(tmp, 0, offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*tmp = '\\0';\n\t} else\n\t\t*offset = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtol",
          "args": [
            "tmp",
            "0",
            "offset"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "symbol",
            "\"+-\""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";\n\nint traceprobe_split_symbol_offset(char *symbol, long *offset)\n{\n\tchar *tmp;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -EINVAL;\n\n\ttmp = strpbrk(symbol, \"+-\");\n\tif (tmp) {\n\t\tret = kstrtol(tmp, 0, offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*tmp = '\\0';\n\t} else\n\t\t*offset = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "find_fetch_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
    "lines": "94-134",
    "snippet": "static const struct fetch_type *find_fetch_type(const char *type)\n{\n\tint i;\n\n\tif (!type)\n\t\ttype = DEFAULT_FETCH_TYPE_STR;\n\n\t/* Special case: bitfield */\n\tif (*type == 'b') {\n\t\tunsigned long bs;\n\n\t\ttype = strchr(type, '/');\n\t\tif (!type)\n\t\t\tgoto fail;\n\n\t\ttype++;\n\t\tif (kstrtoul(type, 0, &bs))\n\t\t\tgoto fail;\n\n\t\tswitch (bs) {\n\t\tcase 8:\n\t\t\treturn find_fetch_type(\"u8\");\n\t\tcase 16:\n\t\t\treturn find_fetch_type(\"u16\");\n\t\tcase 32:\n\t\t\treturn find_fetch_type(\"u32\");\n\t\tcase 64:\n\t\t\treturn find_fetch_type(\"u64\");\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (i = 0; probe_fetch_types[i].name; i++) {\n\t\tif (strcmp(type, probe_fetch_types[i].name) == 0)\n\t\t\treturn &probe_fetch_types[i];\n\t}\n\nfail:\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fetch_type probe_fetch_types[] = {\n\t/* Special types */\n\t__ASSIGN_FETCH_TYPE(\"string\", string, string, sizeof(u32), 1,\n\t\t\t    \"__data_loc char[]\"),\n\t/* Basic types */\n\tASSIGN_FETCH_TYPE(u8,  u8,  0),\n\tASSIGN_FETCH_TYPE(u16, u16, 0),\n\tASSIGN_FETCH_TYPE(u32, u32, 0),\n\tASSIGN_FETCH_TYPE(u64, u64, 0),\n\tASSIGN_FETCH_TYPE(s8,  u8,  1),\n\tASSIGN_FETCH_TYPE(s16, u16, 1),\n\tASSIGN_FETCH_TYPE(s32, u32, 1),\n\tASSIGN_FETCH_TYPE(s64, u64, 1),\n\tASSIGN_FETCH_TYPE_ALIAS(x8,  u8,  u8,  0),\n\tASSIGN_FETCH_TYPE_ALIAS(x16, u16, u16, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x32, u32, u32, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x64, u64, u64, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(symbol, ADDR_FETCH_TYPE, ADDR_FETCH_TYPE, 0),\n\n\tASSIGN_FETCH_TYPE_END\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "probe_fetch_types[i].name"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_fetch_type",
          "args": [
            "\"u64\""
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "find_fetch_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
          "lines": "94-134",
          "snippet": "static const struct fetch_type *find_fetch_type(const char *type)\n{\n\tint i;\n\n\tif (!type)\n\t\ttype = DEFAULT_FETCH_TYPE_STR;\n\n\t/* Special case: bitfield */\n\tif (*type == 'b') {\n\t\tunsigned long bs;\n\n\t\ttype = strchr(type, '/');\n\t\tif (!type)\n\t\t\tgoto fail;\n\n\t\ttype++;\n\t\tif (kstrtoul(type, 0, &bs))\n\t\t\tgoto fail;\n\n\t\tswitch (bs) {\n\t\tcase 8:\n\t\t\treturn find_fetch_type(\"u8\");\n\t\tcase 16:\n\t\t\treturn find_fetch_type(\"u16\");\n\t\tcase 32:\n\t\t\treturn find_fetch_type(\"u32\");\n\t\tcase 64:\n\t\t\treturn find_fetch_type(\"u64\");\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (i = 0; probe_fetch_types[i].name; i++) {\n\t\tif (strcmp(type, probe_fetch_types[i].name) == 0)\n\t\t\treturn &probe_fetch_types[i];\n\t}\n\nfail:\n\treturn NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "type",
            "0",
            "&bs"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "type",
            "'/'"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nstatic const struct fetch_type probe_fetch_types[] = {\n\t/* Special types */\n\t__ASSIGN_FETCH_TYPE(\"string\", string, string, sizeof(u32), 1,\n\t\t\t    \"__data_loc char[]\"),\n\t/* Basic types */\n\tASSIGN_FETCH_TYPE(u8,  u8,  0),\n\tASSIGN_FETCH_TYPE(u16, u16, 0),\n\tASSIGN_FETCH_TYPE(u32, u32, 0),\n\tASSIGN_FETCH_TYPE(u64, u64, 0),\n\tASSIGN_FETCH_TYPE(s8,  u8,  1),\n\tASSIGN_FETCH_TYPE(s16, u16, 1),\n\tASSIGN_FETCH_TYPE(s32, u32, 1),\n\tASSIGN_FETCH_TYPE(s64, u64, 1),\n\tASSIGN_FETCH_TYPE_ALIAS(x8,  u8,  u8,  0),\n\tASSIGN_FETCH_TYPE_ALIAS(x16, u16, u16, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x32, u32, u32, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(x64, u64, u64, 0),\n\tASSIGN_FETCH_TYPE_ALIAS(symbol, ADDR_FETCH_TYPE, ADDR_FETCH_TYPE, 0),\n\n\tASSIGN_FETCH_TYPE_END\n};\n\nstatic const struct fetch_type *find_fetch_type(const char *type)\n{\n\tint i;\n\n\tif (!type)\n\t\ttype = DEFAULT_FETCH_TYPE_STR;\n\n\t/* Special case: bitfield */\n\tif (*type == 'b') {\n\t\tunsigned long bs;\n\n\t\ttype = strchr(type, '/');\n\t\tif (!type)\n\t\t\tgoto fail;\n\n\t\ttype++;\n\t\tif (kstrtoul(type, 0, &bs))\n\t\t\tgoto fail;\n\n\t\tswitch (bs) {\n\t\tcase 8:\n\t\t\treturn find_fetch_type(\"u8\");\n\t\tcase 16:\n\t\t\treturn find_fetch_type(\"u16\");\n\t\tcase 32:\n\t\t\treturn find_fetch_type(\"u32\");\n\t\tcase 64:\n\t\t\treturn find_fetch_type(\"u64\");\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tfor (i = 0; probe_fetch_types[i].name; i++) {\n\t\tif (strcmp(type, probe_fetch_types[i].name) == 0)\n\t\t\treturn &probe_fetch_types[i];\n\t}\n\nfail:\n\treturn NULL;\n}"
  },
  {
    "function_name": "PRINT_TYPE_FUNC_NAME",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
    "lines": "57-67",
    "snippet": "int PRINT_TYPE_FUNC_NAME(string)(struct trace_seq *s, void *data, void *ent)\n{\n\tint len = *(u32 *)data >> 16;\n\n\tif (!len)\n\t\ttrace_seq_puts(s, \"(fault)\");\n\telse\n\t\ttrace_seq_printf(s, \"\\\"%s\\\"\",\n\t\t\t\t (const char *)get_loc_data(data, ent));\n\treturn !trace_seq_has_overflowed(s);\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"\\\"%s\\\"\"",
            "(const char *)get_loc_data(data, ent)"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_loc_data",
          "args": [
            "data",
            "ent"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "get_loc_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.h",
          "lines": "65-68",
          "snippet": "static nokprobe_inline void *get_loc_data(u32 *dl, void *ent)\n{\n\treturn (u8 *)ent + get_loc_offs(*dl);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <asm/bitsperlong.h>",
            "#include <linux/bitops.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/limits.h>",
            "#include <linux/stringify.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <asm/bitsperlong.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/limits.h>\n#include <linux/stringify.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/tracefs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\nstatic nokprobe_inline void *get_loc_data(u32 *dl, void *ent)\n{\n\treturn (u8 *)ent + get_loc_offs(*dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\"(fault)\""
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char PRINT_TYPE_FMT_NAME(string)[] = \"\\\\\\\"%s\\\\\\\"\";\n\nint PRINT_TYPE_FUNC_NAME(string)(struct trace_seq *s, void *data, void *ent)\n{\n\tint len = *(u32 *)data >> 16;\n\n\tif (!len)\n\t\ttrace_seq_puts(s, \"(fault)\");\n\telse\n\t\ttrace_seq_printf(s, \"\\\"%s\\\"\",\n\t\t\t\t (const char *)get_loc_data(data, ent));\n\treturn !trace_seq_has_overflowed(s);\n}"
  },
  {
    "function_name": "PRINT_TYPE_FUNC_NAME",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_probe.c",
    "lines": "49-53",
    "snippet": "int PRINT_TYPE_FUNC_NAME(symbol)(struct trace_seq *s, void *data, void *ent)\n{\n\ttrace_seq_printf(s, \"%pS\", (void *)*(unsigned long *)data);\n\treturn !trace_seq_has_overflowed(s);\n}",
    "includes": [
      "#include \"trace_probe.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%pS\"",
            "(void *)*(unsigned long *)data"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n\nconst char PRINT_TYPE_FMT_NAME(symbol)[] = \"%pS\";\n\nint PRINT_TYPE_FUNC_NAME(symbol)(struct trace_seq *s, void *data, void *ent)\n{\n\ttrace_seq_printf(s, \"%pS\", (void *)*(unsigned long *)data);\n\treturn !trace_seq_has_overflowed(s);\n}"
  }
]