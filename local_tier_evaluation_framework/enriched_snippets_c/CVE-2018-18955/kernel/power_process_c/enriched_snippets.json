[
  {
    "function_name": "thaw_kernel_threads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/process.c",
    "lines": "227-245",
    "snippet": "void thaw_kernel_threads(void)\n{\n\tstruct task_struct *g, *p;\n\n\tpm_nosig_freezing = false;\n\tpr_info(\"Restarting kernel threads ... \");\n\n\tthaw_workqueues();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\tif (p->flags & (PF_KTHREAD | PF_WQ_WORKER))\n\t\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n}",
    "includes": [
      "#include <linux/cpuset.h>",
      "#include <trace/events/power.h>",
      "#include <linux/kmod.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/delay.h>",
      "#include <linux/freezer.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/module.h>",
      "#include <linux/suspend.h>",
      "#include <linux/oom.h>",
      "#include <linux/interrupt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"done.\\n\""
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__thaw_task",
          "args": [
            "p"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "__thaw_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/freezer.c",
          "lines": "151-159",
          "snippet": "void __thaw_task(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (frozen(p))\n\t\twake_up_process(p);\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(freezer_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nstatic DEFINE_SPINLOCK(freezer_lock);\n\nvoid __thaw_task(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (frozen(p))\n\t\twake_up_process(p);\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "thaw_workqueues",
          "args": [],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "thaw_workqueues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5014-5036",
          "snippet": "void thaw_workqueues(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tif (!workqueue_freezing)\n\t\tgoto out_unlock;\n\n\tworkqueue_freezing = false;\n\n\t/* restore max_active and repopulate worklist */\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tmutex_lock(&wq->mutex);\n\t\tfor_each_pwq(pwq, wq)\n\t\t\tpwq_adjust_max_active(pwq);\n\t\tmutex_unlock(&wq->mutex);\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq_pool_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static LIST_HEAD(workqueues);",
            "static bool workqueue_freezing;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid thaw_workqueues(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tif (!workqueue_freezing)\n\t\tgoto out_unlock;\n\n\tworkqueue_freezing = false;\n\n\t/* restore max_active and repopulate worklist */\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tmutex_lock(&wq->mutex);\n\t\tfor_each_pwq(pwq, wq)\n\t\t\tpwq_adjust_max_active(pwq);\n\t\tmutex_unlock(&wq->mutex);\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq_pool_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Restarting kernel threads ... \""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cpuset.h>\n#include <trace/events/power.h>\n#include <linux/kmod.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/suspend.h>\n#include <linux/oom.h>\n#include <linux/interrupt.h>\n\nvoid thaw_kernel_threads(void)\n{\n\tstruct task_struct *g, *p;\n\n\tpm_nosig_freezing = false;\n\tpr_info(\"Restarting kernel threads ... \");\n\n\tthaw_workqueues();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\tif (p->flags & (PF_KTHREAD | PF_WQ_WORKER))\n\t\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n}"
  },
  {
    "function_name": "thaw_processes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/process.c",
    "lines": "189-225",
    "snippet": "void thaw_processes(void)\n{\n\tstruct task_struct *g, *p;\n\tstruct task_struct *curr = current;\n\n\ttrace_suspend_resume(TPS(\"thaw_processes\"), 0, true);\n\tif (pm_freezing)\n\t\tatomic_dec(&system_freezing_cnt);\n\tpm_freezing = false;\n\tpm_nosig_freezing = false;\n\n\toom_killer_enable();\n\n\tpr_info(\"Restarting tasks ... \");\n\n\t__usermodehelper_set_disable_depth(UMH_FREEZING);\n\tthaw_workqueues();\n\n\tcpuset_wait_for_hotplug();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\t/* No other threads should have PF_SUSPEND_TASK set */\n\t\tWARN_ON((p != curr) && (p->flags & PF_SUSPEND_TASK));\n\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tWARN_ON(!(curr->flags & PF_SUSPEND_TASK));\n\tcurr->flags &= ~PF_SUSPEND_TASK;\n\n\tusermodehelper_enable();\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n\ttrace_suspend_resume(TPS(\"thaw_processes\"), 0, false);\n}",
    "includes": [
      "#include <linux/cpuset.h>",
      "#include <trace/events/power.h>",
      "#include <linux/kmod.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/delay.h>",
      "#include <linux/freezer.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/module.h>",
      "#include <linux/suspend.h>",
      "#include <linux/oom.h>",
      "#include <linux/interrupt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_suspend_resume",
          "args": [
            "TPS(\"thaw_processes\")",
            "0",
            "false"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"thaw_processes\""
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"done.\\n\""
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usermodehelper_enable",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(curr->flags & PF_SUSPEND_TASK)"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__thaw_task",
          "args": [
            "p"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "__thaw_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/freezer.c",
          "lines": "151-159",
          "snippet": "void __thaw_task(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (frozen(p))\n\t\twake_up_process(p);\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(freezer_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nstatic DEFINE_SPINLOCK(freezer_lock);\n\nvoid __thaw_task(struct task_struct *p)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&freezer_lock, flags);\n\tif (frozen(p))\n\t\twake_up_process(p);\n\tspin_unlock_irqrestore(&freezer_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "(p != curr) && (p->flags & PF_SUSPEND_TASK)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_wait_for_hotplug",
          "args": [],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_wait_for_hotplug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cpuset.c",
          "lines": "2371-2374",
          "snippet": "void cpuset_wait_for_hotplug(void)\n{\n\tflush_work(&cpuset_hotplug_work);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nvoid cpuset_wait_for_hotplug(void)\n{\n\tflush_work(&cpuset_hotplug_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thaw_workqueues",
          "args": [],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "thaw_workqueues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5014-5036",
          "snippet": "void thaw_workqueues(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tif (!workqueue_freezing)\n\t\tgoto out_unlock;\n\n\tworkqueue_freezing = false;\n\n\t/* restore max_active and repopulate worklist */\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tmutex_lock(&wq->mutex);\n\t\tfor_each_pwq(pwq, wq)\n\t\t\tpwq_adjust_max_active(pwq);\n\t\tmutex_unlock(&wq->mutex);\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq_pool_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static LIST_HEAD(workqueues);",
            "static bool workqueue_freezing;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid thaw_workqueues(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tif (!workqueue_freezing)\n\t\tgoto out_unlock;\n\n\tworkqueue_freezing = false;\n\n\t/* restore max_active and repopulate worklist */\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tmutex_lock(&wq->mutex);\n\t\tfor_each_pwq(pwq, wq)\n\t\t\tpwq_adjust_max_active(pwq);\n\t\tmutex_unlock(&wq->mutex);\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq_pool_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__usermodehelper_set_disable_depth",
          "args": [
            "UMH_FREEZING"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "__usermodehelper_set_disable_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "298-304",
          "snippet": "void __usermodehelper_set_disable_depth(enum umh_disable_depth depth)\n{\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\twake_up(&usermodehelper_disabled_waitq);\n\tup_write(&umhelper_sem);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nvoid __usermodehelper_set_disable_depth(enum umh_disable_depth depth)\n{\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\twake_up(&usermodehelper_disabled_waitq);\n\tup_write(&umhelper_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Restarting tasks ... \""
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oom_killer_enable",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&system_freezing_cnt"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_suspend_resume",
          "args": [
            "TPS(\"thaw_processes\")",
            "0",
            "true"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TPS",
          "args": [
            "\"thaw_processes\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cpuset.h>\n#include <trace/events/power.h>\n#include <linux/kmod.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/suspend.h>\n#include <linux/oom.h>\n#include <linux/interrupt.h>\n\nvoid thaw_processes(void)\n{\n\tstruct task_struct *g, *p;\n\tstruct task_struct *curr = current;\n\n\ttrace_suspend_resume(TPS(\"thaw_processes\"), 0, true);\n\tif (pm_freezing)\n\t\tatomic_dec(&system_freezing_cnt);\n\tpm_freezing = false;\n\tpm_nosig_freezing = false;\n\n\toom_killer_enable();\n\n\tpr_info(\"Restarting tasks ... \");\n\n\t__usermodehelper_set_disable_depth(UMH_FREEZING);\n\tthaw_workqueues();\n\n\tcpuset_wait_for_hotplug();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\t/* No other threads should have PF_SUSPEND_TASK set */\n\t\tWARN_ON((p != curr) && (p->flags & PF_SUSPEND_TASK));\n\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tWARN_ON(!(curr->flags & PF_SUSPEND_TASK));\n\tcurr->flags &= ~PF_SUSPEND_TASK;\n\n\tusermodehelper_enable();\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n\ttrace_suspend_resume(TPS(\"thaw_processes\"), 0, false);\n}"
  },
  {
    "function_name": "freeze_kernel_threads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/process.c",
    "lines": "170-187",
    "snippet": "int freeze_kernel_threads(void)\n{\n\tint error;\n\n\tpr_info(\"Freezing remaining freezable tasks ... \");\n\n\tpm_nosig_freezing = true;\n\terror = try_to_freeze_tasks(false);\n\tif (!error)\n\t\tpr_cont(\"done.\");\n\n\tpr_cont(\"\\n\");\n\tBUG_ON(in_atomic());\n\n\tif (error)\n\t\tthaw_kernel_threads();\n\treturn error;\n}",
    "includes": [
      "#include <linux/cpuset.h>",
      "#include <trace/events/power.h>",
      "#include <linux/kmod.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/delay.h>",
      "#include <linux/freezer.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/module.h>",
      "#include <linux/suspend.h>",
      "#include <linux/oom.h>",
      "#include <linux/interrupt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "thaw_kernel_threads",
          "args": [],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "thaw_kernel_threads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/process.c",
          "lines": "227-245",
          "snippet": "void thaw_kernel_threads(void)\n{\n\tstruct task_struct *g, *p;\n\n\tpm_nosig_freezing = false;\n\tpr_info(\"Restarting kernel threads ... \");\n\n\tthaw_workqueues();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\tif (p->flags & (PF_KTHREAD | PF_WQ_WORKER))\n\t\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n}",
          "includes": [
            "#include <linux/cpuset.h>",
            "#include <trace/events/power.h>",
            "#include <linux/kmod.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/delay.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/suspend.h>",
            "#include <linux/oom.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuset.h>\n#include <trace/events/power.h>\n#include <linux/kmod.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/suspend.h>\n#include <linux/oom.h>\n#include <linux/interrupt.h>\n\nvoid thaw_kernel_threads(void)\n{\n\tstruct task_struct *g, *p;\n\n\tpm_nosig_freezing = false;\n\tpr_info(\"Restarting kernel threads ... \");\n\n\tthaw_workqueues();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\tif (p->flags & (PF_KTHREAD | PF_WQ_WORKER))\n\t\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "in_atomic()"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_atomic",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_freeze_tasks",
          "args": [
            "false"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_freeze_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/process.c",
          "lines": "31-114",
          "snippet": "static int try_to_freeze_tasks(bool user_only)\n{\n\tstruct task_struct *g, *p;\n\tunsigned long end_time;\n\tunsigned int todo;\n\tbool wq_busy = false;\n\tktime_t start, end, elapsed;\n\tunsigned int elapsed_msecs;\n\tbool wakeup = false;\n\tint sleep_usecs = USEC_PER_MSEC;\n\n\tstart = ktime_get_boottime();\n\n\tend_time = jiffies + msecs_to_jiffies(freeze_timeout_msecs);\n\n\tif (!user_only)\n\t\tfreeze_workqueues_begin();\n\n\twhile (true) {\n\t\ttodo = 0;\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(g, p) {\n\t\t\tif (p == current || !freeze_task(p))\n\t\t\t\tcontinue;\n\n\t\t\tif (!freezer_should_skip(p))\n\t\t\t\ttodo++;\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\n\t\tif (!user_only) {\n\t\t\twq_busy = freeze_workqueues_busy();\n\t\t\ttodo += wq_busy;\n\t\t}\n\n\t\tif (!todo || time_after(jiffies, end_time))\n\t\t\tbreak;\n\n\t\tif (pm_wakeup_pending()) {\n\t\t\twakeup = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We need to retry, but first give the freezing tasks some\n\t\t * time to enter the refrigerator.  Start with an initial\n\t\t * 1 ms sleep followed by exponential backoff until 8 ms.\n\t\t */\n\t\tusleep_range(sleep_usecs / 2, sleep_usecs);\n\t\tif (sleep_usecs < 8 * USEC_PER_MSEC)\n\t\t\tsleep_usecs *= 2;\n\t}\n\n\tend = ktime_get_boottime();\n\telapsed = ktime_sub(end, start);\n\telapsed_msecs = ktime_to_ms(elapsed);\n\n\tif (todo) {\n\t\tpr_cont(\"\\n\");\n\t\tpr_err(\"Freezing of tasks %s after %d.%03d seconds \"\n\t\t       \"(%d tasks refusing to freeze, wq_busy=%d):\\n\",\n\t\t       wakeup ? \"aborted\" : \"failed\",\n\t\t       elapsed_msecs / 1000, elapsed_msecs % 1000,\n\t\t       todo - wq_busy, wq_busy);\n\n\t\tif (wq_busy)\n\t\t\tshow_workqueue_state();\n\n\t\tif (!wakeup || pm_debug_messages_on) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tfor_each_process_thread(g, p) {\n\t\t\t\tif (p != current && !freezer_should_skip(p)\n\t\t\t\t    && freezing(p) && !frozen(p))\n\t\t\t\t\tsched_show_task(p);\n\t\t\t}\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\t} else {\n\t\tpr_cont(\"(elapsed %d.%03d seconds) \", elapsed_msecs / 1000,\n\t\t\telapsed_msecs % 1000);\n\t}\n\n\treturn todo ? -EBUSY : 0;\n}",
          "includes": [
            "#include <linux/cpuset.h>",
            "#include <trace/events/power.h>",
            "#include <linux/kmod.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/delay.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/suspend.h>",
            "#include <linux/oom.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuset.h>\n#include <trace/events/power.h>\n#include <linux/kmod.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/suspend.h>\n#include <linux/oom.h>\n#include <linux/interrupt.h>\n\nstatic int try_to_freeze_tasks(bool user_only)\n{\n\tstruct task_struct *g, *p;\n\tunsigned long end_time;\n\tunsigned int todo;\n\tbool wq_busy = false;\n\tktime_t start, end, elapsed;\n\tunsigned int elapsed_msecs;\n\tbool wakeup = false;\n\tint sleep_usecs = USEC_PER_MSEC;\n\n\tstart = ktime_get_boottime();\n\n\tend_time = jiffies + msecs_to_jiffies(freeze_timeout_msecs);\n\n\tif (!user_only)\n\t\tfreeze_workqueues_begin();\n\n\twhile (true) {\n\t\ttodo = 0;\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(g, p) {\n\t\t\tif (p == current || !freeze_task(p))\n\t\t\t\tcontinue;\n\n\t\t\tif (!freezer_should_skip(p))\n\t\t\t\ttodo++;\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\n\t\tif (!user_only) {\n\t\t\twq_busy = freeze_workqueues_busy();\n\t\t\ttodo += wq_busy;\n\t\t}\n\n\t\tif (!todo || time_after(jiffies, end_time))\n\t\t\tbreak;\n\n\t\tif (pm_wakeup_pending()) {\n\t\t\twakeup = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We need to retry, but first give the freezing tasks some\n\t\t * time to enter the refrigerator.  Start with an initial\n\t\t * 1 ms sleep followed by exponential backoff until 8 ms.\n\t\t */\n\t\tusleep_range(sleep_usecs / 2, sleep_usecs);\n\t\tif (sleep_usecs < 8 * USEC_PER_MSEC)\n\t\t\tsleep_usecs *= 2;\n\t}\n\n\tend = ktime_get_boottime();\n\telapsed = ktime_sub(end, start);\n\telapsed_msecs = ktime_to_ms(elapsed);\n\n\tif (todo) {\n\t\tpr_cont(\"\\n\");\n\t\tpr_err(\"Freezing of tasks %s after %d.%03d seconds \"\n\t\t       \"(%d tasks refusing to freeze, wq_busy=%d):\\n\",\n\t\t       wakeup ? \"aborted\" : \"failed\",\n\t\t       elapsed_msecs / 1000, elapsed_msecs % 1000,\n\t\t       todo - wq_busy, wq_busy);\n\n\t\tif (wq_busy)\n\t\t\tshow_workqueue_state();\n\n\t\tif (!wakeup || pm_debug_messages_on) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tfor_each_process_thread(g, p) {\n\t\t\t\tif (p != current && !freezer_should_skip(p)\n\t\t\t\t    && freezing(p) && !frozen(p))\n\t\t\t\t\tsched_show_task(p);\n\t\t\t}\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\t} else {\n\t\tpr_cont(\"(elapsed %d.%03d seconds) \", elapsed_msecs / 1000,\n\t\t\telapsed_msecs % 1000);\n\t}\n\n\treturn todo ? -EBUSY : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Freezing remaining freezable tasks ... \""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cpuset.h>\n#include <trace/events/power.h>\n#include <linux/kmod.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/suspend.h>\n#include <linux/oom.h>\n#include <linux/interrupt.h>\n\nint freeze_kernel_threads(void)\n{\n\tint error;\n\n\tpr_info(\"Freezing remaining freezable tasks ... \");\n\n\tpm_nosig_freezing = true;\n\terror = try_to_freeze_tasks(false);\n\tif (!error)\n\t\tpr_cont(\"done.\");\n\n\tpr_cont(\"\\n\");\n\tBUG_ON(in_atomic());\n\n\tif (error)\n\t\tthaw_kernel_threads();\n\treturn error;\n}"
  },
  {
    "function_name": "freeze_processes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/process.c",
    "lines": "123-160",
    "snippet": "int freeze_processes(void)\n{\n\tint error;\n\n\terror = __usermodehelper_disable(UMH_FREEZING);\n\tif (error)\n\t\treturn error;\n\n\t/* Make sure this task doesn't get frozen */\n\tcurrent->flags |= PF_SUSPEND_TASK;\n\n\tif (!pm_freezing)\n\t\tatomic_inc(&system_freezing_cnt);\n\n\tpm_wakeup_clear(true);\n\tpr_info(\"Freezing user space processes ... \");\n\tpm_freezing = true;\n\terror = try_to_freeze_tasks(true);\n\tif (!error) {\n\t\t__usermodehelper_set_disable_depth(UMH_DISABLED);\n\t\tpr_cont(\"done.\");\n\t}\n\tpr_cont(\"\\n\");\n\tBUG_ON(in_atomic());\n\n\t/*\n\t * Now that the whole userspace is frozen we need to disbale\n\t * the OOM killer to disallow any further interference with\n\t * killable tasks. There is no guarantee oom victims will\n\t * ever reach a point they go away we have to wait with a timeout.\n\t */\n\tif (!error && !oom_killer_disable(msecs_to_jiffies(freeze_timeout_msecs)))\n\t\terror = -EBUSY;\n\n\tif (error)\n\t\tthaw_processes();\n\treturn error;\n}",
    "includes": [
      "#include <linux/cpuset.h>",
      "#include <trace/events/power.h>",
      "#include <linux/kmod.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/delay.h>",
      "#include <linux/freezer.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/module.h>",
      "#include <linux/suspend.h>",
      "#include <linux/oom.h>",
      "#include <linux/interrupt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "thaw_processes",
          "args": [],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "thaw_processes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/process.c",
          "lines": "189-225",
          "snippet": "void thaw_processes(void)\n{\n\tstruct task_struct *g, *p;\n\tstruct task_struct *curr = current;\n\n\ttrace_suspend_resume(TPS(\"thaw_processes\"), 0, true);\n\tif (pm_freezing)\n\t\tatomic_dec(&system_freezing_cnt);\n\tpm_freezing = false;\n\tpm_nosig_freezing = false;\n\n\toom_killer_enable();\n\n\tpr_info(\"Restarting tasks ... \");\n\n\t__usermodehelper_set_disable_depth(UMH_FREEZING);\n\tthaw_workqueues();\n\n\tcpuset_wait_for_hotplug();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\t/* No other threads should have PF_SUSPEND_TASK set */\n\t\tWARN_ON((p != curr) && (p->flags & PF_SUSPEND_TASK));\n\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tWARN_ON(!(curr->flags & PF_SUSPEND_TASK));\n\tcurr->flags &= ~PF_SUSPEND_TASK;\n\n\tusermodehelper_enable();\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n\ttrace_suspend_resume(TPS(\"thaw_processes\"), 0, false);\n}",
          "includes": [
            "#include <linux/cpuset.h>",
            "#include <trace/events/power.h>",
            "#include <linux/kmod.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/delay.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/suspend.h>",
            "#include <linux/oom.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuset.h>\n#include <trace/events/power.h>\n#include <linux/kmod.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/suspend.h>\n#include <linux/oom.h>\n#include <linux/interrupt.h>\n\nvoid thaw_processes(void)\n{\n\tstruct task_struct *g, *p;\n\tstruct task_struct *curr = current;\n\n\ttrace_suspend_resume(TPS(\"thaw_processes\"), 0, true);\n\tif (pm_freezing)\n\t\tatomic_dec(&system_freezing_cnt);\n\tpm_freezing = false;\n\tpm_nosig_freezing = false;\n\n\toom_killer_enable();\n\n\tpr_info(\"Restarting tasks ... \");\n\n\t__usermodehelper_set_disable_depth(UMH_FREEZING);\n\tthaw_workqueues();\n\n\tcpuset_wait_for_hotplug();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\t/* No other threads should have PF_SUSPEND_TASK set */\n\t\tWARN_ON((p != curr) && (p->flags & PF_SUSPEND_TASK));\n\t\t__thaw_task(p);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tWARN_ON(!(curr->flags & PF_SUSPEND_TASK));\n\tcurr->flags &= ~PF_SUSPEND_TASK;\n\n\tusermodehelper_enable();\n\n\tschedule();\n\tpr_cont(\"done.\\n\");\n\ttrace_suspend_resume(TPS(\"thaw_processes\"), 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "oom_killer_disable",
          "args": [
            "msecs_to_jiffies(freeze_timeout_msecs)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "freeze_timeout_msecs"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "__msecs_to_jiffies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "565-573",
          "snippet": "unsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "in_atomic()"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_atomic",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__usermodehelper_set_disable_depth",
          "args": [
            "UMH_DISABLED"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "__usermodehelper_set_disable_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "298-304",
          "snippet": "void __usermodehelper_set_disable_depth(enum umh_disable_depth depth)\n{\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\twake_up(&usermodehelper_disabled_waitq);\n\tup_write(&umhelper_sem);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nvoid __usermodehelper_set_disable_depth(enum umh_disable_depth depth)\n{\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\twake_up(&usermodehelper_disabled_waitq);\n\tup_write(&umhelper_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_freeze_tasks",
          "args": [
            "true"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_freeze_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/process.c",
          "lines": "31-114",
          "snippet": "static int try_to_freeze_tasks(bool user_only)\n{\n\tstruct task_struct *g, *p;\n\tunsigned long end_time;\n\tunsigned int todo;\n\tbool wq_busy = false;\n\tktime_t start, end, elapsed;\n\tunsigned int elapsed_msecs;\n\tbool wakeup = false;\n\tint sleep_usecs = USEC_PER_MSEC;\n\n\tstart = ktime_get_boottime();\n\n\tend_time = jiffies + msecs_to_jiffies(freeze_timeout_msecs);\n\n\tif (!user_only)\n\t\tfreeze_workqueues_begin();\n\n\twhile (true) {\n\t\ttodo = 0;\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(g, p) {\n\t\t\tif (p == current || !freeze_task(p))\n\t\t\t\tcontinue;\n\n\t\t\tif (!freezer_should_skip(p))\n\t\t\t\ttodo++;\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\n\t\tif (!user_only) {\n\t\t\twq_busy = freeze_workqueues_busy();\n\t\t\ttodo += wq_busy;\n\t\t}\n\n\t\tif (!todo || time_after(jiffies, end_time))\n\t\t\tbreak;\n\n\t\tif (pm_wakeup_pending()) {\n\t\t\twakeup = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We need to retry, but first give the freezing tasks some\n\t\t * time to enter the refrigerator.  Start with an initial\n\t\t * 1 ms sleep followed by exponential backoff until 8 ms.\n\t\t */\n\t\tusleep_range(sleep_usecs / 2, sleep_usecs);\n\t\tif (sleep_usecs < 8 * USEC_PER_MSEC)\n\t\t\tsleep_usecs *= 2;\n\t}\n\n\tend = ktime_get_boottime();\n\telapsed = ktime_sub(end, start);\n\telapsed_msecs = ktime_to_ms(elapsed);\n\n\tif (todo) {\n\t\tpr_cont(\"\\n\");\n\t\tpr_err(\"Freezing of tasks %s after %d.%03d seconds \"\n\t\t       \"(%d tasks refusing to freeze, wq_busy=%d):\\n\",\n\t\t       wakeup ? \"aborted\" : \"failed\",\n\t\t       elapsed_msecs / 1000, elapsed_msecs % 1000,\n\t\t       todo - wq_busy, wq_busy);\n\n\t\tif (wq_busy)\n\t\t\tshow_workqueue_state();\n\n\t\tif (!wakeup || pm_debug_messages_on) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tfor_each_process_thread(g, p) {\n\t\t\t\tif (p != current && !freezer_should_skip(p)\n\t\t\t\t    && freezing(p) && !frozen(p))\n\t\t\t\t\tsched_show_task(p);\n\t\t\t}\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\t} else {\n\t\tpr_cont(\"(elapsed %d.%03d seconds) \", elapsed_msecs / 1000,\n\t\t\telapsed_msecs % 1000);\n\t}\n\n\treturn todo ? -EBUSY : 0;\n}",
          "includes": [
            "#include <linux/cpuset.h>",
            "#include <trace/events/power.h>",
            "#include <linux/kmod.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/delay.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/suspend.h>",
            "#include <linux/oom.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cpuset.h>\n#include <trace/events/power.h>\n#include <linux/kmod.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/suspend.h>\n#include <linux/oom.h>\n#include <linux/interrupt.h>\n\nstatic int try_to_freeze_tasks(bool user_only)\n{\n\tstruct task_struct *g, *p;\n\tunsigned long end_time;\n\tunsigned int todo;\n\tbool wq_busy = false;\n\tktime_t start, end, elapsed;\n\tunsigned int elapsed_msecs;\n\tbool wakeup = false;\n\tint sleep_usecs = USEC_PER_MSEC;\n\n\tstart = ktime_get_boottime();\n\n\tend_time = jiffies + msecs_to_jiffies(freeze_timeout_msecs);\n\n\tif (!user_only)\n\t\tfreeze_workqueues_begin();\n\n\twhile (true) {\n\t\ttodo = 0;\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(g, p) {\n\t\t\tif (p == current || !freeze_task(p))\n\t\t\t\tcontinue;\n\n\t\t\tif (!freezer_should_skip(p))\n\t\t\t\ttodo++;\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\n\t\tif (!user_only) {\n\t\t\twq_busy = freeze_workqueues_busy();\n\t\t\ttodo += wq_busy;\n\t\t}\n\n\t\tif (!todo || time_after(jiffies, end_time))\n\t\t\tbreak;\n\n\t\tif (pm_wakeup_pending()) {\n\t\t\twakeup = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We need to retry, but first give the freezing tasks some\n\t\t * time to enter the refrigerator.  Start with an initial\n\t\t * 1 ms sleep followed by exponential backoff until 8 ms.\n\t\t */\n\t\tusleep_range(sleep_usecs / 2, sleep_usecs);\n\t\tif (sleep_usecs < 8 * USEC_PER_MSEC)\n\t\t\tsleep_usecs *= 2;\n\t}\n\n\tend = ktime_get_boottime();\n\telapsed = ktime_sub(end, start);\n\telapsed_msecs = ktime_to_ms(elapsed);\n\n\tif (todo) {\n\t\tpr_cont(\"\\n\");\n\t\tpr_err(\"Freezing of tasks %s after %d.%03d seconds \"\n\t\t       \"(%d tasks refusing to freeze, wq_busy=%d):\\n\",\n\t\t       wakeup ? \"aborted\" : \"failed\",\n\t\t       elapsed_msecs / 1000, elapsed_msecs % 1000,\n\t\t       todo - wq_busy, wq_busy);\n\n\t\tif (wq_busy)\n\t\t\tshow_workqueue_state();\n\n\t\tif (!wakeup || pm_debug_messages_on) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tfor_each_process_thread(g, p) {\n\t\t\t\tif (p != current && !freezer_should_skip(p)\n\t\t\t\t    && freezing(p) && !frozen(p))\n\t\t\t\t\tsched_show_task(p);\n\t\t\t}\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\t} else {\n\t\tpr_cont(\"(elapsed %d.%03d seconds) \", elapsed_msecs / 1000,\n\t\t\telapsed_msecs % 1000);\n\t}\n\n\treturn todo ? -EBUSY : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Freezing user space processes ... \""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_wakeup_clear",
          "args": [
            "true"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&system_freezing_cnt"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__usermodehelper_disable",
          "args": [
            "UMH_FREEZING"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "__usermodehelper_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "312-337",
          "snippet": "int __usermodehelper_disable(enum umh_disable_depth depth)\n{\n\tlong retval;\n\n\tif (!depth)\n\t\treturn -EINVAL;\n\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\tup_write(&umhelper_sem);\n\n\t/*\n\t * From now on call_usermodehelper_exec() won't start any new\n\t * helpers, so it is sufficient if running_helpers turns out to\n\t * be zero at one point (it may be increased later, but that\n\t * doesn't matter).\n\t */\n\tretval = wait_event_timeout(running_helpers_waitq,\n\t\t\t\t\tatomic_read(&running_helpers) == 0,\n\t\t\t\t\tRUNNING_HELPERS_TIMEOUT);\n\tif (retval)\n\t\treturn 0;\n\n\t__usermodehelper_set_disable_depth(UMH_ENABLED);\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RUNNING_HELPERS_TIMEOUT\t(5 * HZ)"
          ],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static atomic_t running_helpers = ATOMIC_INIT(0);",
            "static DECLARE_WAIT_QUEUE_HEAD(running_helpers_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define RUNNING_HELPERS_TIMEOUT\t(5 * HZ)\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic atomic_t running_helpers = ATOMIC_INIT(0);\nstatic DECLARE_WAIT_QUEUE_HEAD(running_helpers_waitq);\n\nint __usermodehelper_disable(enum umh_disable_depth depth)\n{\n\tlong retval;\n\n\tif (!depth)\n\t\treturn -EINVAL;\n\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\tup_write(&umhelper_sem);\n\n\t/*\n\t * From now on call_usermodehelper_exec() won't start any new\n\t * helpers, so it is sufficient if running_helpers turns out to\n\t * be zero at one point (it may be increased later, but that\n\t * doesn't matter).\n\t */\n\tretval = wait_event_timeout(running_helpers_waitq,\n\t\t\t\t\tatomic_read(&running_helpers) == 0,\n\t\t\t\t\tRUNNING_HELPERS_TIMEOUT);\n\tif (retval)\n\t\treturn 0;\n\n\t__usermodehelper_set_disable_depth(UMH_ENABLED);\n\treturn -EAGAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cpuset.h>\n#include <trace/events/power.h>\n#include <linux/kmod.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/suspend.h>\n#include <linux/oom.h>\n#include <linux/interrupt.h>\n\nint freeze_processes(void)\n{\n\tint error;\n\n\terror = __usermodehelper_disable(UMH_FREEZING);\n\tif (error)\n\t\treturn error;\n\n\t/* Make sure this task doesn't get frozen */\n\tcurrent->flags |= PF_SUSPEND_TASK;\n\n\tif (!pm_freezing)\n\t\tatomic_inc(&system_freezing_cnt);\n\n\tpm_wakeup_clear(true);\n\tpr_info(\"Freezing user space processes ... \");\n\tpm_freezing = true;\n\terror = try_to_freeze_tasks(true);\n\tif (!error) {\n\t\t__usermodehelper_set_disable_depth(UMH_DISABLED);\n\t\tpr_cont(\"done.\");\n\t}\n\tpr_cont(\"\\n\");\n\tBUG_ON(in_atomic());\n\n\t/*\n\t * Now that the whole userspace is frozen we need to disbale\n\t * the OOM killer to disallow any further interference with\n\t * killable tasks. There is no guarantee oom victims will\n\t * ever reach a point they go away we have to wait with a timeout.\n\t */\n\tif (!error && !oom_killer_disable(msecs_to_jiffies(freeze_timeout_msecs)))\n\t\terror = -EBUSY;\n\n\tif (error)\n\t\tthaw_processes();\n\treturn error;\n}"
  },
  {
    "function_name": "try_to_freeze_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/process.c",
    "lines": "31-114",
    "snippet": "static int try_to_freeze_tasks(bool user_only)\n{\n\tstruct task_struct *g, *p;\n\tunsigned long end_time;\n\tunsigned int todo;\n\tbool wq_busy = false;\n\tktime_t start, end, elapsed;\n\tunsigned int elapsed_msecs;\n\tbool wakeup = false;\n\tint sleep_usecs = USEC_PER_MSEC;\n\n\tstart = ktime_get_boottime();\n\n\tend_time = jiffies + msecs_to_jiffies(freeze_timeout_msecs);\n\n\tif (!user_only)\n\t\tfreeze_workqueues_begin();\n\n\twhile (true) {\n\t\ttodo = 0;\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(g, p) {\n\t\t\tif (p == current || !freeze_task(p))\n\t\t\t\tcontinue;\n\n\t\t\tif (!freezer_should_skip(p))\n\t\t\t\ttodo++;\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\n\t\tif (!user_only) {\n\t\t\twq_busy = freeze_workqueues_busy();\n\t\t\ttodo += wq_busy;\n\t\t}\n\n\t\tif (!todo || time_after(jiffies, end_time))\n\t\t\tbreak;\n\n\t\tif (pm_wakeup_pending()) {\n\t\t\twakeup = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We need to retry, but first give the freezing tasks some\n\t\t * time to enter the refrigerator.  Start with an initial\n\t\t * 1 ms sleep followed by exponential backoff until 8 ms.\n\t\t */\n\t\tusleep_range(sleep_usecs / 2, sleep_usecs);\n\t\tif (sleep_usecs < 8 * USEC_PER_MSEC)\n\t\t\tsleep_usecs *= 2;\n\t}\n\n\tend = ktime_get_boottime();\n\telapsed = ktime_sub(end, start);\n\telapsed_msecs = ktime_to_ms(elapsed);\n\n\tif (todo) {\n\t\tpr_cont(\"\\n\");\n\t\tpr_err(\"Freezing of tasks %s after %d.%03d seconds \"\n\t\t       \"(%d tasks refusing to freeze, wq_busy=%d):\\n\",\n\t\t       wakeup ? \"aborted\" : \"failed\",\n\t\t       elapsed_msecs / 1000, elapsed_msecs % 1000,\n\t\t       todo - wq_busy, wq_busy);\n\n\t\tif (wq_busy)\n\t\t\tshow_workqueue_state();\n\n\t\tif (!wakeup || pm_debug_messages_on) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tfor_each_process_thread(g, p) {\n\t\t\t\tif (p != current && !freezer_should_skip(p)\n\t\t\t\t    && freezing(p) && !frozen(p))\n\t\t\t\t\tsched_show_task(p);\n\t\t\t}\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\t} else {\n\t\tpr_cont(\"(elapsed %d.%03d seconds) \", elapsed_msecs / 1000,\n\t\t\telapsed_msecs % 1000);\n\t}\n\n\treturn todo ? -EBUSY : 0;\n}",
    "includes": [
      "#include <linux/cpuset.h>",
      "#include <trace/events/power.h>",
      "#include <linux/kmod.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/delay.h>",
      "#include <linux/freezer.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/module.h>",
      "#include <linux/suspend.h>",
      "#include <linux/oom.h>",
      "#include <linux/interrupt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"(elapsed %d.%03d seconds) \"",
            "elapsed_msecs / 1000",
            "elapsed_msecs % 1000"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_show_task",
          "args": [
            "p"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "sched_show_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "5268-5295",
          "snippet": "void sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%-15.15s %c\", p->comm, task_state_to_char(p));\n\n\tif (p->state == TASK_RUNNING)\n\t\tprintk(KERN_CONT \"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprintk(KERN_CONT \"%5lu %5d %6d 0x%08lx\\n\", free,\n\t\ttask_pid_nr(p), ppid,\n\t\t(unsigned long)task_thread_info(p)->flags);\n\n\tprint_worker_info(KERN_INFO, p);\n\tshow_stack(p, NULL);\n\tput_task_stack(p);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tprintk(KERN_INFO \"%-15.15s %c\", p->comm, task_state_to_char(p));\n\n\tif (p->state == TASK_RUNNING)\n\t\tprintk(KERN_CONT \"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprintk(KERN_CONT \"%5lu %5d %6d 0x%08lx\\n\", free,\n\t\ttask_pid_nr(p), ppid,\n\t\t(unsigned long)task_thread_info(p)->flags);\n\n\tprint_worker_info(KERN_INFO, p);\n\tshow_stack(p, NULL);\n\tput_task_stack(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "frozen",
          "args": [
            "p"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "update_if_frozen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/freezer.c",
          "lines": "244-289",
          "snippet": "static void update_if_frozen(struct cgroup_subsys_state *css)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\tstruct cgroup_subsys_state *pos;\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&freezer_mutex);\n\n\tif (!(freezer->state & CGROUP_FREEZING) ||\n\t    (freezer->state & CGROUP_FROZEN))\n\t\treturn;\n\n\t/* are all (live) children frozen? */\n\trcu_read_lock();\n\tcss_for_each_child(pos, css) {\n\t\tstruct freezer *child = css_freezer(pos);\n\n\t\tif ((child->state & CGROUP_FREEZER_ONLINE) &&\n\t\t    !(child->state & CGROUP_FROZEN)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/* are all tasks frozen? */\n\tcss_task_iter_start(css, 0, &it);\n\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tif (freezing(task)) {\n\t\t\t/*\n\t\t\t * freezer_should_skip() indicates that the task\n\t\t\t * should be skipped when determining freezing\n\t\t\t * completion.  Consider it frozen in addition to\n\t\t\t * the usual frozen condition.\n\t\t\t */\n\t\t\tif (!frozen(task) && !freezer_should_skip(task))\n\t\t\t\tgoto out_iter_end;\n\t\t}\n\t}\n\n\tfreezer->state |= CGROUP_FROZEN;\nout_iter_end:\n\tcss_task_iter_end(&it);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(freezer_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(freezer_mutex);\n\nstatic void update_if_frozen(struct cgroup_subsys_state *css)\n{\n\tstruct freezer *freezer = css_freezer(css);\n\tstruct cgroup_subsys_state *pos;\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tlockdep_assert_held(&freezer_mutex);\n\n\tif (!(freezer->state & CGROUP_FREEZING) ||\n\t    (freezer->state & CGROUP_FROZEN))\n\t\treturn;\n\n\t/* are all (live) children frozen? */\n\trcu_read_lock();\n\tcss_for_each_child(pos, css) {\n\t\tstruct freezer *child = css_freezer(pos);\n\n\t\tif ((child->state & CGROUP_FREEZER_ONLINE) &&\n\t\t    !(child->state & CGROUP_FROZEN)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/* are all tasks frozen? */\n\tcss_task_iter_start(css, 0, &it);\n\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tif (freezing(task)) {\n\t\t\t/*\n\t\t\t * freezer_should_skip() indicates that the task\n\t\t\t * should be skipped when determining freezing\n\t\t\t * completion.  Consider it frozen in addition to\n\t\t\t * the usual frozen condition.\n\t\t\t */\n\t\t\tif (!frozen(task) && !freezer_should_skip(task))\n\t\t\t\tgoto out_iter_end;\n\t\t}\n\t}\n\n\tfreezer->state |= CGROUP_FROZEN;\nout_iter_end:\n\tcss_task_iter_end(&it);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezing",
          "args": [
            "p"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "freezing_slow_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/freezer.c",
          "lines": "42-57",
          "snippet": "bool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool pm_freezing;",
            "bool pm_nosig_freezing;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nbool pm_freezing;\nbool pm_nosig_freezing;\n\nbool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezer_should_skip",
          "args": [
            "p"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_workqueue_state",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "show_workqueue_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4530-4603",
          "snippet": "void show_workqueue_state(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct worker_pool *pool;\n\tunsigned long flags;\n\tint pi;\n\n\trcu_read_lock_sched();\n\n\tpr_info(\"Showing busy workqueues and worker pools:\\n\");\n\n\tlist_for_each_entry_rcu(wq, &workqueues, list) {\n\t\tstruct pool_workqueue *pwq;\n\t\tbool idle = true;\n\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tif (pwq->nr_active || !list_empty(&pwq->delayed_works)) {\n\t\t\t\tidle = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idle)\n\t\t\tcontinue;\n\n\t\tpr_info(\"workqueue %s: flags=0x%x\\n\", wq->name, wq->flags);\n\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\t\t\tif (pwq->nr_active || !list_empty(&pwq->delayed_works))\n\t\t\t\tshow_pwq(pwq);\n\t\t\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n\t\t\t/*\n\t\t\t * We could be printing a lot from atomic context, e.g.\n\t\t\t * sysrq-t -> show_workqueue_state(). Avoid triggering\n\t\t\t * hard lockup.\n\t\t\t */\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t}\n\n\tfor_each_pool(pool, pi) {\n\t\tstruct worker *worker;\n\t\tbool first = true;\n\n\t\tspin_lock_irqsave(&pool->lock, flags);\n\t\tif (pool->nr_workers == pool->nr_idle)\n\t\t\tgoto next_pool;\n\n\t\tpr_info(\"pool %d:\", pool->id);\n\t\tpr_cont_pool_info(pool);\n\t\tpr_cont(\" hung=%us workers=%d\",\n\t\t\tjiffies_to_msecs(jiffies - pool->watchdog_ts) / 1000,\n\t\t\tpool->nr_workers);\n\t\tif (pool->manager)\n\t\t\tpr_cont(\" manager: %d\",\n\t\t\t\ttask_pid_nr(pool->manager->task));\n\t\tlist_for_each_entry(worker, &pool->idle_list, entry) {\n\t\t\tpr_cont(\" %s%d\", first ? \"idle: \" : \"\",\n\t\t\t\ttask_pid_nr(worker->task));\n\t\t\tfirst = false;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\tnext_pool:\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t/*\n\t\t * We could be printing a lot from atomic context, e.g.\n\t\t * sysrq-t -> show_workqueue_state(). Avoid triggering\n\t\t * hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t}\n\n\trcu_read_unlock_sched();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid show_workqueue_state(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct worker_pool *pool;\n\tunsigned long flags;\n\tint pi;\n\n\trcu_read_lock_sched();\n\n\tpr_info(\"Showing busy workqueues and worker pools:\\n\");\n\n\tlist_for_each_entry_rcu(wq, &workqueues, list) {\n\t\tstruct pool_workqueue *pwq;\n\t\tbool idle = true;\n\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tif (pwq->nr_active || !list_empty(&pwq->delayed_works)) {\n\t\t\t\tidle = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idle)\n\t\t\tcontinue;\n\n\t\tpr_info(\"workqueue %s: flags=0x%x\\n\", wq->name, wq->flags);\n\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\t\t\tif (pwq->nr_active || !list_empty(&pwq->delayed_works))\n\t\t\t\tshow_pwq(pwq);\n\t\t\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n\t\t\t/*\n\t\t\t * We could be printing a lot from atomic context, e.g.\n\t\t\t * sysrq-t -> show_workqueue_state(). Avoid triggering\n\t\t\t * hard lockup.\n\t\t\t */\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t}\n\n\tfor_each_pool(pool, pi) {\n\t\tstruct worker *worker;\n\t\tbool first = true;\n\n\t\tspin_lock_irqsave(&pool->lock, flags);\n\t\tif (pool->nr_workers == pool->nr_idle)\n\t\t\tgoto next_pool;\n\n\t\tpr_info(\"pool %d:\", pool->id);\n\t\tpr_cont_pool_info(pool);\n\t\tpr_cont(\" hung=%us workers=%d\",\n\t\t\tjiffies_to_msecs(jiffies - pool->watchdog_ts) / 1000,\n\t\t\tpool->nr_workers);\n\t\tif (pool->manager)\n\t\t\tpr_cont(\" manager: %d\",\n\t\t\t\ttask_pid_nr(pool->manager->task));\n\t\tlist_for_each_entry(worker, &pool->idle_list, entry) {\n\t\t\tpr_cont(\" %s%d\", first ? \"idle: \" : \"\",\n\t\t\t\ttask_pid_nr(worker->task));\n\t\t\tfirst = false;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\tnext_pool:\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t/*\n\t\t * We could be printing a lot from atomic context, e.g.\n\t\t * sysrq-t -> show_workqueue_state(). Avoid triggering\n\t\t * hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t}\n\n\trcu_read_unlock_sched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Freezing of tasks %s after %d.%03d seconds \"\n\t\t       \"(%d tasks refusing to freeze, wq_busy=%d):\\n\"",
            "wakeup ? \"aborted\" : \"failed\"",
            "elapsed_msecs / 1000",
            "elapsed_msecs % 1000",
            "todo - wq_busy",
            "wq_busy"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ms",
          "args": [
            "elapsed"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "end",
            "start"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_boottime",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep_range",
          "args": [
            "sleep_usecs / 2",
            "sleep_usecs"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "usleep_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1987-1998",
          "snippet": "void __sched usleep_range(unsigned long min, unsigned long max)\n{\n\tktime_t exp = ktime_add_us(ktime_get(), min);\n\tu64 delta = (u64)(max - min) * NSEC_PER_USEC;\n\n\tfor (;;) {\n\t\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\t\t/* Do not return before the requested sleep time has elapsed */\n\t\tif (!schedule_hrtimeout_range(&exp, delta, HRTIMER_MODE_ABS))\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__visible u64"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n__visible u64;\n\nvoid __sched usleep_range(unsigned long min, unsigned long max)\n{\n\tktime_t exp = ktime_add_us(ktime_get(), min);\n\tu64 delta = (u64)(max - min) * NSEC_PER_USEC;\n\n\tfor (;;) {\n\t\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\t\t/* Do not return before the requested sleep time has elapsed */\n\t\tif (!schedule_hrtimeout_range(&exp, delta, HRTIMER_MODE_ABS))\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_wakeup_pending",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "end_time"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeze_workqueues_busy",
          "args": [],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "freeze_workqueues_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4972-5003",
          "snippet": "bool freeze_workqueues_busy(void)\n{\n\tbool busy = false;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tWARN_ON_ONCE(!workqueue_freezing);\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tif (!(wq->flags & WQ_FREEZABLE))\n\t\t\tcontinue;\n\t\t/*\n\t\t * nr_active is monotonically decreasing.  It's safe\n\t\t * to peek without lock.\n\t\t */\n\t\trcu_read_lock_sched();\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tWARN_ON_ONCE(pwq->nr_active < 0);\n\t\t\tif (pwq->nr_active) {\n\t\t\t\tbusy = true;\n\t\t\t\trcu_read_unlock_sched();\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock_sched();\n\t}\nout_unlock:\n\tmutex_unlock(&wq_pool_mutex);\n\treturn busy;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static LIST_HEAD(workqueues);",
            "static bool workqueue_freezing;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool freeze_workqueues_busy(void)\n{\n\tbool busy = false;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tWARN_ON_ONCE(!workqueue_freezing);\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tif (!(wq->flags & WQ_FREEZABLE))\n\t\t\tcontinue;\n\t\t/*\n\t\t * nr_active is monotonically decreasing.  It's safe\n\t\t * to peek without lock.\n\t\t */\n\t\trcu_read_lock_sched();\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tWARN_ON_ONCE(pwq->nr_active < 0);\n\t\t\tif (pwq->nr_active) {\n\t\t\t\tbusy = true;\n\t\t\t\trcu_read_unlock_sched();\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock_sched();\n\t}\nout_unlock:\n\tmutex_unlock(&wq_pool_mutex);\n\treturn busy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezer_should_skip",
          "args": [
            "p"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeze_task",
          "args": [
            "p"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_freeze_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/process.c",
          "lines": "31-114",
          "snippet": "static int try_to_freeze_tasks(bool user_only)\n{\n\tstruct task_struct *g, *p;\n\tunsigned long end_time;\n\tunsigned int todo;\n\tbool wq_busy = false;\n\tktime_t start, end, elapsed;\n\tunsigned int elapsed_msecs;\n\tbool wakeup = false;\n\tint sleep_usecs = USEC_PER_MSEC;\n\n\tstart = ktime_get_boottime();\n\n\tend_time = jiffies + msecs_to_jiffies(freeze_timeout_msecs);\n\n\tif (!user_only)\n\t\tfreeze_workqueues_begin();\n\n\twhile (true) {\n\t\ttodo = 0;\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(g, p) {\n\t\t\tif (p == current || !freeze_task(p))\n\t\t\t\tcontinue;\n\n\t\t\tif (!freezer_should_skip(p))\n\t\t\t\ttodo++;\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\n\t\tif (!user_only) {\n\t\t\twq_busy = freeze_workqueues_busy();\n\t\t\ttodo += wq_busy;\n\t\t}\n\n\t\tif (!todo || time_after(jiffies, end_time))\n\t\t\tbreak;\n\n\t\tif (pm_wakeup_pending()) {\n\t\t\twakeup = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We need to retry, but first give the freezing tasks some\n\t\t * time to enter the refrigerator.  Start with an initial\n\t\t * 1 ms sleep followed by exponential backoff until 8 ms.\n\t\t */\n\t\tusleep_range(sleep_usecs / 2, sleep_usecs);\n\t\tif (sleep_usecs < 8 * USEC_PER_MSEC)\n\t\t\tsleep_usecs *= 2;\n\t}\n\n\tend = ktime_get_boottime();\n\telapsed = ktime_sub(end, start);\n\telapsed_msecs = ktime_to_ms(elapsed);\n\n\tif (todo) {\n\t\tpr_cont(\"\\n\");\n\t\tpr_err(\"Freezing of tasks %s after %d.%03d seconds \"\n\t\t       \"(%d tasks refusing to freeze, wq_busy=%d):\\n\",\n\t\t       wakeup ? \"aborted\" : \"failed\",\n\t\t       elapsed_msecs / 1000, elapsed_msecs % 1000,\n\t\t       todo - wq_busy, wq_busy);\n\n\t\tif (wq_busy)\n\t\t\tshow_workqueue_state();\n\n\t\tif (!wakeup || pm_debug_messages_on) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tfor_each_process_thread(g, p) {\n\t\t\t\tif (p != current && !freezer_should_skip(p)\n\t\t\t\t    && freezing(p) && !frozen(p))\n\t\t\t\t\tsched_show_task(p);\n\t\t\t}\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\t} else {\n\t\tpr_cont(\"(elapsed %d.%03d seconds) \", elapsed_msecs / 1000,\n\t\t\telapsed_msecs % 1000);\n\t}\n\n\treturn todo ? -EBUSY : 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeze_workqueues_begin",
          "args": [],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "freeze_workqueues_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4939-4957",
          "snippet": "void freeze_workqueues_begin(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tWARN_ON_ONCE(workqueue_freezing);\n\tworkqueue_freezing = true;\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tmutex_lock(&wq->mutex);\n\t\tfor_each_pwq(pwq, wq)\n\t\t\tpwq_adjust_max_active(pwq);\n\t\tmutex_unlock(&wq->mutex);\n\t}\n\n\tmutex_unlock(&wq_pool_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static LIST_HEAD(workqueues);",
            "static bool workqueue_freezing;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid freeze_workqueues_begin(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tWARN_ON_ONCE(workqueue_freezing);\n\tworkqueue_freezing = true;\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tmutex_lock(&wq->mutex);\n\t\tfor_each_pwq(pwq, wq)\n\t\t\tpwq_adjust_max_active(pwq);\n\t\tmutex_unlock(&wq->mutex);\n\t}\n\n\tmutex_unlock(&wq_pool_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "freeze_timeout_msecs"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "__msecs_to_jiffies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "565-573",
          "snippet": "unsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_boottime",
          "args": [],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cpuset.h>\n#include <trace/events/power.h>\n#include <linux/kmod.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/suspend.h>\n#include <linux/oom.h>\n#include <linux/interrupt.h>\n\nstatic int try_to_freeze_tasks(bool user_only)\n{\n\tstruct task_struct *g, *p;\n\tunsigned long end_time;\n\tunsigned int todo;\n\tbool wq_busy = false;\n\tktime_t start, end, elapsed;\n\tunsigned int elapsed_msecs;\n\tbool wakeup = false;\n\tint sleep_usecs = USEC_PER_MSEC;\n\n\tstart = ktime_get_boottime();\n\n\tend_time = jiffies + msecs_to_jiffies(freeze_timeout_msecs);\n\n\tif (!user_only)\n\t\tfreeze_workqueues_begin();\n\n\twhile (true) {\n\t\ttodo = 0;\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(g, p) {\n\t\t\tif (p == current || !freeze_task(p))\n\t\t\t\tcontinue;\n\n\t\t\tif (!freezer_should_skip(p))\n\t\t\t\ttodo++;\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\n\t\tif (!user_only) {\n\t\t\twq_busy = freeze_workqueues_busy();\n\t\t\ttodo += wq_busy;\n\t\t}\n\n\t\tif (!todo || time_after(jiffies, end_time))\n\t\t\tbreak;\n\n\t\tif (pm_wakeup_pending()) {\n\t\t\twakeup = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We need to retry, but first give the freezing tasks some\n\t\t * time to enter the refrigerator.  Start with an initial\n\t\t * 1 ms sleep followed by exponential backoff until 8 ms.\n\t\t */\n\t\tusleep_range(sleep_usecs / 2, sleep_usecs);\n\t\tif (sleep_usecs < 8 * USEC_PER_MSEC)\n\t\t\tsleep_usecs *= 2;\n\t}\n\n\tend = ktime_get_boottime();\n\telapsed = ktime_sub(end, start);\n\telapsed_msecs = ktime_to_ms(elapsed);\n\n\tif (todo) {\n\t\tpr_cont(\"\\n\");\n\t\tpr_err(\"Freezing of tasks %s after %d.%03d seconds \"\n\t\t       \"(%d tasks refusing to freeze, wq_busy=%d):\\n\",\n\t\t       wakeup ? \"aborted\" : \"failed\",\n\t\t       elapsed_msecs / 1000, elapsed_msecs % 1000,\n\t\t       todo - wq_busy, wq_busy);\n\n\t\tif (wq_busy)\n\t\t\tshow_workqueue_state();\n\n\t\tif (!wakeup || pm_debug_messages_on) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tfor_each_process_thread(g, p) {\n\t\t\t\tif (p != current && !freezer_should_skip(p)\n\t\t\t\t    && freezing(p) && !frozen(p))\n\t\t\t\t\tsched_show_task(p);\n\t\t\t}\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\t} else {\n\t\tpr_cont(\"(elapsed %d.%03d seconds) \", elapsed_msecs / 1000,\n\t\t\telapsed_msecs % 1000);\n\t}\n\n\treturn todo ? -EBUSY : 0;\n}"
  }
]