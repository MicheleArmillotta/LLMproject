[
  {
    "function_name": "sched_clock_syscore_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
    "lines": "303-308",
    "snippet": "static int __init sched_clock_syscore_init(void)\n{\n\tregister_syscore_ops(&sched_clock_ops);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct syscore_ops sched_clock_ops = {\n\t.suspend\t= sched_clock_suspend,\n\t.resume\t\t= sched_clock_resume,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_syscore_ops",
          "args": [
            "&sched_clock_ops"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic struct syscore_ops sched_clock_ops = {\n\t.suspend\t= sched_clock_suspend,\n\t.resume\t\t= sched_clock_resume,\n};\n\nstatic int __init sched_clock_syscore_init(void)\n{\n\tregister_syscore_ops(&sched_clock_ops);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_clock_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
    "lines": "289-296",
    "snippet": "static void sched_clock_resume(void)\n{\n\tstruct clock_read_data *rd = &cd.read_data[0];\n\n\trd->epoch_cyc = cd.actual_read_sched_clock();\n\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL);\n\trd->read_sched_clock = cd.actual_read_sched_clock;\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hrtimer sched_clock_timer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&sched_clock_timer",
            "cd.wrap_kt",
            "HRTIMER_MODE_REL"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cd.actual_read_sched_clock",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic struct hrtimer sched_clock_timer;\n\nstatic void sched_clock_resume(void)\n{\n\tstruct clock_read_data *rd = &cd.read_data[0];\n\n\trd->epoch_cyc = cd.actual_read_sched_clock();\n\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL);\n\trd->read_sched_clock = cd.actual_read_sched_clock;\n}"
  },
  {
    "function_name": "sched_clock_suspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
    "lines": "278-287",
    "snippet": "static int sched_clock_suspend(void)\n{\n\tstruct clock_read_data *rd = &cd.read_data[0];\n\n\tupdate_sched_clock();\n\thrtimer_cancel(&sched_clock_timer);\n\trd->read_sched_clock = suspended_sched_clock_read;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hrtimer sched_clock_timer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&sched_clock_timer"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1167-1176",
          "snippet": "int hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_sched_clock",
          "args": [],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "update_sched_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
          "lines": "143-158",
          "snippet": "static void update_sched_clock(void)\n{\n\tu64 cyc;\n\tu64 ns;\n\tstruct clock_read_data rd;\n\n\trd = cd.read_data[0];\n\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\n\trd.epoch_ns = ns;\n\trd.epoch_cyc = cyc;\n\n\tupdate_clock_read_data(&rd);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic void update_sched_clock(void)\n{\n\tu64 cyc;\n\tu64 ns;\n\tstruct clock_read_data rd;\n\n\trd = cd.read_data[0];\n\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\n\trd.epoch_ns = ns;\n\trd.epoch_cyc = cyc;\n\n\tupdate_clock_read_data(&rd);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic struct hrtimer sched_clock_timer;\n\nstatic int sched_clock_suspend(void)\n{\n\tstruct clock_read_data *rd = &cd.read_data[0];\n\n\tupdate_sched_clock();\n\thrtimer_cancel(&sched_clock_timer);\n\trd->read_sched_clock = suspended_sched_clock_read;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "suspended_sched_clock_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
    "lines": "271-276",
    "snippet": "static u64 notrace suspended_sched_clock_read(void)\n{\n\tunsigned long seq = raw_read_seqcount(&cd.seq);\n\n\treturn cd.read_data[seq & 1].epoch_cyc;\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_read_seqcount",
          "args": [
            "&cd.seq"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic u64 notrace suspended_sched_clock_read(void)\n{\n\tunsigned long seq = raw_read_seqcount(&cd.seq);\n\n\treturn cd.read_data[seq & 1].epoch_cyc;\n}"
  },
  {
    "function_name": "generic_sched_clock_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
    "lines": "240-258",
    "snippet": "void __init generic_sched_clock_init(void)\n{\n\t/*\n\t * If no sched_clock() function has been provided at that point,\n\t * make it the final one one.\n\t */\n\tif (cd.actual_read_sched_clock == jiffy_sched_clock_read)\n\t\tsched_clock_register(jiffy_sched_clock_read, BITS_PER_LONG, HZ);\n\n\tupdate_sched_clock();\n\n\t/*\n\t * Start the timer to keep sched_clock() properly updated and\n\t * sets the initial epoch.\n\t */\n\thrtimer_init(&sched_clock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tsched_clock_timer.function = sched_clock_poll;\n\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL);\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hrtimer sched_clock_timer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&sched_clock_timer",
            "cd.wrap_kt",
            "HRTIMER_MODE_REL"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&sched_clock_timer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_REL"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1305-1310",
          "snippet": "void hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_sched_clock",
          "args": [],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "update_sched_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
          "lines": "143-158",
          "snippet": "static void update_sched_clock(void)\n{\n\tu64 cyc;\n\tu64 ns;\n\tstruct clock_read_data rd;\n\n\trd = cd.read_data[0];\n\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\n\trd.epoch_ns = ns;\n\trd.epoch_cyc = cyc;\n\n\tupdate_clock_read_data(&rd);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic void update_sched_clock(void)\n{\n\tu64 cyc;\n\tu64 ns;\n\tstruct clock_read_data rd;\n\n\trd = cd.read_data[0];\n\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\n\trd.epoch_ns = ns;\n\trd.epoch_cyc = cyc;\n\n\tupdate_clock_read_data(&rd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_clock_register",
          "args": [
            "jiffy_sched_clock_read",
            "BITS_PER_LONG",
            "HZ"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
          "lines": "168-238",
          "snippet": "void __init\nsched_clock_register(u64 (*read)(void), int bits, unsigned long rate)\n{\n\tu64 res, wrap, new_mask, new_epoch, cyc, ns;\n\tu32 new_mult, new_shift;\n\tunsigned long r;\n\tchar r_unit;\n\tstruct clock_read_data rd;\n\n\tif (cd.rate > rate)\n\t\treturn;\n\n\tWARN_ON(!irqs_disabled());\n\n\t/* Calculate the mult/shift to convert counter ticks to ns. */\n\tclocks_calc_mult_shift(&new_mult, &new_shift, rate, NSEC_PER_SEC, 3600);\n\n\tnew_mask = CLOCKSOURCE_MASK(bits);\n\tcd.rate = rate;\n\n\t/* Calculate how many nanosecs until we risk wrapping */\n\twrap = clocks_calc_max_nsecs(new_mult, new_shift, 0, new_mask, NULL);\n\tcd.wrap_kt = ns_to_ktime(wrap);\n\n\trd = cd.read_data[0];\n\n\t/* Update epoch for new counter and update 'epoch_ns' from old counter*/\n\tnew_epoch = read();\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\tcd.actual_read_sched_clock = read;\n\n\trd.read_sched_clock\t= read;\n\trd.sched_clock_mask\t= new_mask;\n\trd.mult\t\t\t= new_mult;\n\trd.shift\t\t= new_shift;\n\trd.epoch_cyc\t\t= new_epoch;\n\trd.epoch_ns\t\t= ns;\n\n\tupdate_clock_read_data(&rd);\n\n\tif (sched_clock_timer.function != NULL) {\n\t\t/* update timeout for clock wrap */\n\t\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL);\n\t}\n\n\tr = rate;\n\tif (r >= 4000000) {\n\t\tr /= 1000000;\n\t\tr_unit = 'M';\n\t} else {\n\t\tif (r >= 1000) {\n\t\t\tr /= 1000;\n\t\t\tr_unit = 'k';\n\t\t} else {\n\t\t\tr_unit = ' ';\n\t\t}\n\t}\n\n\t/* Calculate the ns resolution of this counter */\n\tres = cyc_to_ns(1ULL, new_mult, new_shift);\n\n\tpr_info(\"sched_clock: %u bits at %lu%cHz, resolution %lluns, wraps every %lluns\\n\",\n\t\tbits, r, r_unit, res, wrap);\n\n\t/* Enable IRQ time accounting if we have a fast enough sched_clock() */\n\tif (irqtime > 0 || (irqtime == -1 && rate >= 1000000))\n\t\tenable_sched_clock_irqtime();\n\n\tpr_debug(\"Registered %pF as sched_clock source\\n\", read);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hrtimer sched_clock_timer;",
            "static int irqtime = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic struct hrtimer sched_clock_timer;\nstatic int irqtime = -1;\n\nvoid __init\nsched_clock_register(u64 (*read)(void), int bits, unsigned long rate)\n{\n\tu64 res, wrap, new_mask, new_epoch, cyc, ns;\n\tu32 new_mult, new_shift;\n\tunsigned long r;\n\tchar r_unit;\n\tstruct clock_read_data rd;\n\n\tif (cd.rate > rate)\n\t\treturn;\n\n\tWARN_ON(!irqs_disabled());\n\n\t/* Calculate the mult/shift to convert counter ticks to ns. */\n\tclocks_calc_mult_shift(&new_mult, &new_shift, rate, NSEC_PER_SEC, 3600);\n\n\tnew_mask = CLOCKSOURCE_MASK(bits);\n\tcd.rate = rate;\n\n\t/* Calculate how many nanosecs until we risk wrapping */\n\twrap = clocks_calc_max_nsecs(new_mult, new_shift, 0, new_mask, NULL);\n\tcd.wrap_kt = ns_to_ktime(wrap);\n\n\trd = cd.read_data[0];\n\n\t/* Update epoch for new counter and update 'epoch_ns' from old counter*/\n\tnew_epoch = read();\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\tcd.actual_read_sched_clock = read;\n\n\trd.read_sched_clock\t= read;\n\trd.sched_clock_mask\t= new_mask;\n\trd.mult\t\t\t= new_mult;\n\trd.shift\t\t= new_shift;\n\trd.epoch_cyc\t\t= new_epoch;\n\trd.epoch_ns\t\t= ns;\n\n\tupdate_clock_read_data(&rd);\n\n\tif (sched_clock_timer.function != NULL) {\n\t\t/* update timeout for clock wrap */\n\t\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL);\n\t}\n\n\tr = rate;\n\tif (r >= 4000000) {\n\t\tr /= 1000000;\n\t\tr_unit = 'M';\n\t} else {\n\t\tif (r >= 1000) {\n\t\t\tr /= 1000;\n\t\t\tr_unit = 'k';\n\t\t} else {\n\t\t\tr_unit = ' ';\n\t\t}\n\t}\n\n\t/* Calculate the ns resolution of this counter */\n\tres = cyc_to_ns(1ULL, new_mult, new_shift);\n\n\tpr_info(\"sched_clock: %u bits at %lu%cHz, resolution %lluns, wraps every %lluns\\n\",\n\t\tbits, r, r_unit, res, wrap);\n\n\t/* Enable IRQ time accounting if we have a fast enough sched_clock() */\n\tif (irqtime > 0 || (irqtime == -1 && rate >= 1000000))\n\t\tenable_sched_clock_irqtime();\n\n\tpr_debug(\"Registered %pF as sched_clock source\\n\", read);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic struct hrtimer sched_clock_timer;\n\nvoid __init generic_sched_clock_init(void)\n{\n\t/*\n\t * If no sched_clock() function has been provided at that point,\n\t * make it the final one one.\n\t */\n\tif (cd.actual_read_sched_clock == jiffy_sched_clock_read)\n\t\tsched_clock_register(jiffy_sched_clock_read, BITS_PER_LONG, HZ);\n\n\tupdate_sched_clock();\n\n\t/*\n\t * Start the timer to keep sched_clock() properly updated and\n\t * sets the initial epoch.\n\t */\n\thrtimer_init(&sched_clock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tsched_clock_timer.function = sched_clock_poll;\n\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL);\n}"
  },
  {
    "function_name": "sched_clock_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
    "lines": "168-238",
    "snippet": "void __init\nsched_clock_register(u64 (*read)(void), int bits, unsigned long rate)\n{\n\tu64 res, wrap, new_mask, new_epoch, cyc, ns;\n\tu32 new_mult, new_shift;\n\tunsigned long r;\n\tchar r_unit;\n\tstruct clock_read_data rd;\n\n\tif (cd.rate > rate)\n\t\treturn;\n\n\tWARN_ON(!irqs_disabled());\n\n\t/* Calculate the mult/shift to convert counter ticks to ns. */\n\tclocks_calc_mult_shift(&new_mult, &new_shift, rate, NSEC_PER_SEC, 3600);\n\n\tnew_mask = CLOCKSOURCE_MASK(bits);\n\tcd.rate = rate;\n\n\t/* Calculate how many nanosecs until we risk wrapping */\n\twrap = clocks_calc_max_nsecs(new_mult, new_shift, 0, new_mask, NULL);\n\tcd.wrap_kt = ns_to_ktime(wrap);\n\n\trd = cd.read_data[0];\n\n\t/* Update epoch for new counter and update 'epoch_ns' from old counter*/\n\tnew_epoch = read();\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\tcd.actual_read_sched_clock = read;\n\n\trd.read_sched_clock\t= read;\n\trd.sched_clock_mask\t= new_mask;\n\trd.mult\t\t\t= new_mult;\n\trd.shift\t\t= new_shift;\n\trd.epoch_cyc\t\t= new_epoch;\n\trd.epoch_ns\t\t= ns;\n\n\tupdate_clock_read_data(&rd);\n\n\tif (sched_clock_timer.function != NULL) {\n\t\t/* update timeout for clock wrap */\n\t\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL);\n\t}\n\n\tr = rate;\n\tif (r >= 4000000) {\n\t\tr /= 1000000;\n\t\tr_unit = 'M';\n\t} else {\n\t\tif (r >= 1000) {\n\t\t\tr /= 1000;\n\t\t\tr_unit = 'k';\n\t\t} else {\n\t\t\tr_unit = ' ';\n\t\t}\n\t}\n\n\t/* Calculate the ns resolution of this counter */\n\tres = cyc_to_ns(1ULL, new_mult, new_shift);\n\n\tpr_info(\"sched_clock: %u bits at %lu%cHz, resolution %lluns, wraps every %lluns\\n\",\n\t\tbits, r, r_unit, res, wrap);\n\n\t/* Enable IRQ time accounting if we have a fast enough sched_clock() */\n\tif (irqtime > 0 || (irqtime == -1 && rate >= 1000000))\n\t\tenable_sched_clock_irqtime();\n\n\tpr_debug(\"Registered %pF as sched_clock source\\n\", read);\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hrtimer sched_clock_timer;",
      "static int irqtime = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Registered %pF as sched_clock source\\n\"",
            "read"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enable_sched_clock_irqtime",
          "args": [],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "enable_sched_clock_irqtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "23-26",
          "snippet": "void enable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 1;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define sched_clock_irqtime\t(0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid enable_sched_clock_irqtime(void)\n{\n\tsched_clock_irqtime = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"sched_clock: %u bits at %lu%cHz, resolution %lluns, wraps every %lluns\\n\"",
            "bits",
            "r",
            "r_unit",
            "res",
            "wrap"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cyc_to_ns",
          "args": [
            "1ULL",
            "new_mult",
            "new_shift"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "cyc_to_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
          "lines": "92-95",
          "snippet": "static inline u64 notrace cyc_to_ns(u64 cyc, u32 mult, u32 shift)\n{\n\treturn (cyc * mult) >> shift;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 notrace cyc_to_ns(u64 cyc, u32 mult, u32 shift)\n{\n\treturn (cyc * mult) >> shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&sched_clock_timer",
            "cd.wrap_kt",
            "HRTIMER_MODE_REL"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_clock_read_data",
          "args": [
            "&rd"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "update_clock_read_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
          "lines": "125-138",
          "snippet": "static void update_clock_read_data(struct clock_read_data *rd)\n{\n\t/* update the backup (odd) copy with the new data */\n\tcd.read_data[1] = *rd;\n\n\t/* steer readers towards the odd copy */\n\traw_write_seqcount_latch(&cd.seq);\n\n\t/* now its safe for us to update the normal (even) copy */\n\tcd.read_data[0] = *rd;\n\n\t/* switch readers back to the even copy */\n\traw_write_seqcount_latch(&cd.seq);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic void update_clock_read_data(struct clock_read_data *rd)\n{\n\t/* update the backup (odd) copy with the new data */\n\tcd.read_data[1] = *rd;\n\n\t/* steer readers towards the odd copy */\n\traw_write_seqcount_latch(&cd.seq);\n\n\t/* now its safe for us to update the normal (even) copy */\n\tcd.read_data[0] = *rd;\n\n\t/* switch readers back to the even copy */\n\traw_write_seqcount_latch(&cd.seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cd.actual_read_sched_clock",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "suspended_sched_clock_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
          "lines": "271-276",
          "snippet": "static u64 notrace suspended_sched_clock_read(void)\n{\n\tunsigned long seq = raw_read_seqcount(&cd.seq);\n\n\treturn cd.read_data[seq & 1].epoch_cyc;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic u64 notrace suspended_sched_clock_read(void)\n{\n\tunsigned long seq = raw_read_seqcount(&cd.seq);\n\n\treturn cd.read_data[seq & 1].epoch_cyc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_to_ktime",
          "args": [
            "wrap"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocks_calc_max_nsecs",
          "args": [
            "new_mult",
            "new_shift",
            "0",
            "new_mask",
            "NULL"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "clocks_calc_max_nsecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "677-705",
          "snippet": "u64 clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 *max_cyc)\n{\n\tu64 max_nsecs, max_cycles;\n\n\t/*\n\t * Calculate the maximum number of cycles that we can pass to the\n\t * cyc2ns() function without overflowing a 64-bit result.\n\t */\n\tmax_cycles = ULLONG_MAX;\n\tdo_div(max_cycles, mult+maxadj);\n\n\t/*\n\t * The actual maximum number of cycles we can defer the clocksource is\n\t * determined by the minimum of max_cycles and mask.\n\t * Note: Here we subtract the maxadj to make sure we don't sleep for\n\t * too long if there's a large negative adjustment.\n\t */\n\tmax_cycles = min(max_cycles, mask);\n\tmax_nsecs = clocksource_cyc2ns(max_cycles, mult - maxadj, shift);\n\n\t/* return the max_cycles value as well if requested */\n\tif (max_cyc)\n\t\t*max_cyc = max_cycles;\n\n\t/* Return 50% of the actual maximum, so we can detect bad values */\n\tmax_nsecs >>= 1;\n\n\treturn max_nsecs;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nu64 clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 *max_cyc)\n{\n\tu64 max_nsecs, max_cycles;\n\n\t/*\n\t * Calculate the maximum number of cycles that we can pass to the\n\t * cyc2ns() function without overflowing a 64-bit result.\n\t */\n\tmax_cycles = ULLONG_MAX;\n\tdo_div(max_cycles, mult+maxadj);\n\n\t/*\n\t * The actual maximum number of cycles we can defer the clocksource is\n\t * determined by the minimum of max_cycles and mask.\n\t * Note: Here we subtract the maxadj to make sure we don't sleep for\n\t * too long if there's a large negative adjustment.\n\t */\n\tmax_cycles = min(max_cycles, mask);\n\tmax_nsecs = clocksource_cyc2ns(max_cycles, mult - maxadj, shift);\n\n\t/* return the max_cycles value as well if requested */\n\tif (max_cyc)\n\t\t*max_cyc = max_cycles;\n\n\t/* Return 50% of the actual maximum, so we can detect bad values */\n\tmax_nsecs >>= 1;\n\n\treturn max_nsecs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CLOCKSOURCE_MASK",
          "args": [
            "bits"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocks_calc_mult_shift",
          "args": [
            "&new_mult",
            "&new_shift",
            "rate",
            "NSEC_PER_SEC",
            "3600"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "clocks_calc_mult_shift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "62-91",
          "snippet": "void\nclocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 maxsec)\n{\n\tu64 tmp;\n\tu32 sft, sftacc= 32;\n\n\t/*\n\t * Calculate the shift factor which is limiting the conversion\n\t * range:\n\t */\n\ttmp = ((u64)maxsec * from) >> 32;\n\twhile (tmp) {\n\t\ttmp >>=1;\n\t\tsftacc--;\n\t}\n\n\t/*\n\t * Find the conversion shift/mult pair which has the best\n\t * accuracy and fits the maxsec conversion range:\n\t */\n\tfor (sft = 32; sft > 0; sft--) {\n\t\ttmp = (u64) to << sft;\n\t\ttmp += from / 2;\n\t\tdo_div(tmp, from);\n\t\tif ((tmp >> sftacc) == 0)\n\t\t\tbreak;\n\t}\n\t*mult = tmp;\n\t*shift = sft;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nvoid\nclocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 maxsec)\n{\n\tu64 tmp;\n\tu32 sft, sftacc= 32;\n\n\t/*\n\t * Calculate the shift factor which is limiting the conversion\n\t * range:\n\t */\n\ttmp = ((u64)maxsec * from) >> 32;\n\twhile (tmp) {\n\t\ttmp >>=1;\n\t\tsftacc--;\n\t}\n\n\t/*\n\t * Find the conversion shift/mult pair which has the best\n\t * accuracy and fits the maxsec conversion range:\n\t */\n\tfor (sft = 32; sft > 0; sft--) {\n\t\ttmp = (u64) to << sft;\n\t\ttmp += from / 2;\n\t\tdo_div(tmp, from);\n\t\tif ((tmp >> sftacc) == 0)\n\t\t\tbreak;\n\t}\n\t*mult = tmp;\n\t*shift = sft;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic struct hrtimer sched_clock_timer;\nstatic int irqtime = -1;\n\nvoid __init\nsched_clock_register(u64 (*read)(void), int bits, unsigned long rate)\n{\n\tu64 res, wrap, new_mask, new_epoch, cyc, ns;\n\tu32 new_mult, new_shift;\n\tunsigned long r;\n\tchar r_unit;\n\tstruct clock_read_data rd;\n\n\tif (cd.rate > rate)\n\t\treturn;\n\n\tWARN_ON(!irqs_disabled());\n\n\t/* Calculate the mult/shift to convert counter ticks to ns. */\n\tclocks_calc_mult_shift(&new_mult, &new_shift, rate, NSEC_PER_SEC, 3600);\n\n\tnew_mask = CLOCKSOURCE_MASK(bits);\n\tcd.rate = rate;\n\n\t/* Calculate how many nanosecs until we risk wrapping */\n\twrap = clocks_calc_max_nsecs(new_mult, new_shift, 0, new_mask, NULL);\n\tcd.wrap_kt = ns_to_ktime(wrap);\n\n\trd = cd.read_data[0];\n\n\t/* Update epoch for new counter and update 'epoch_ns' from old counter*/\n\tnew_epoch = read();\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\tcd.actual_read_sched_clock = read;\n\n\trd.read_sched_clock\t= read;\n\trd.sched_clock_mask\t= new_mask;\n\trd.mult\t\t\t= new_mult;\n\trd.shift\t\t= new_shift;\n\trd.epoch_cyc\t\t= new_epoch;\n\trd.epoch_ns\t\t= ns;\n\n\tupdate_clock_read_data(&rd);\n\n\tif (sched_clock_timer.function != NULL) {\n\t\t/* update timeout for clock wrap */\n\t\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL);\n\t}\n\n\tr = rate;\n\tif (r >= 4000000) {\n\t\tr /= 1000000;\n\t\tr_unit = 'M';\n\t} else {\n\t\tif (r >= 1000) {\n\t\t\tr /= 1000;\n\t\t\tr_unit = 'k';\n\t\t} else {\n\t\t\tr_unit = ' ';\n\t\t}\n\t}\n\n\t/* Calculate the ns resolution of this counter */\n\tres = cyc_to_ns(1ULL, new_mult, new_shift);\n\n\tpr_info(\"sched_clock: %u bits at %lu%cHz, resolution %lluns, wraps every %lluns\\n\",\n\t\tbits, r, r_unit, res, wrap);\n\n\t/* Enable IRQ time accounting if we have a fast enough sched_clock() */\n\tif (irqtime > 0 || (irqtime == -1 && rate >= 1000000))\n\t\tenable_sched_clock_irqtime();\n\n\tpr_debug(\"Registered %pF as sched_clock source\\n\", read);\n}"
  },
  {
    "function_name": "sched_clock_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
    "lines": "160-166",
    "snippet": "static enum hrtimer_restart sched_clock_poll(struct hrtimer *hrt)\n{\n\tupdate_sched_clock();\n\thrtimer_forward_now(hrt, cd.wrap_kt);\n\n\treturn HRTIMER_RESTART;\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_forward_now",
          "args": [
            "hrt",
            "cd.wrap_kt"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_sched_clock",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "update_sched_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
          "lines": "143-158",
          "snippet": "static void update_sched_clock(void)\n{\n\tu64 cyc;\n\tu64 ns;\n\tstruct clock_read_data rd;\n\n\trd = cd.read_data[0];\n\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\n\trd.epoch_ns = ns;\n\trd.epoch_cyc = cyc;\n\n\tupdate_clock_read_data(&rd);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic void update_sched_clock(void)\n{\n\tu64 cyc;\n\tu64 ns;\n\tstruct clock_read_data rd;\n\n\trd = cd.read_data[0];\n\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\n\trd.epoch_ns = ns;\n\trd.epoch_cyc = cyc;\n\n\tupdate_clock_read_data(&rd);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic enum hrtimer_restart sched_clock_poll(struct hrtimer *hrt)\n{\n\tupdate_sched_clock();\n\thrtimer_forward_now(hrt, cd.wrap_kt);\n\n\treturn HRTIMER_RESTART;\n}"
  },
  {
    "function_name": "update_sched_clock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
    "lines": "143-158",
    "snippet": "static void update_sched_clock(void)\n{\n\tu64 cyc;\n\tu64 ns;\n\tstruct clock_read_data rd;\n\n\trd = cd.read_data[0];\n\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\n\trd.epoch_ns = ns;\n\trd.epoch_cyc = cyc;\n\n\tupdate_clock_read_data(&rd);\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_clock_read_data",
          "args": [
            "&rd"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "update_clock_read_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
          "lines": "125-138",
          "snippet": "static void update_clock_read_data(struct clock_read_data *rd)\n{\n\t/* update the backup (odd) copy with the new data */\n\tcd.read_data[1] = *rd;\n\n\t/* steer readers towards the odd copy */\n\traw_write_seqcount_latch(&cd.seq);\n\n\t/* now its safe for us to update the normal (even) copy */\n\tcd.read_data[0] = *rd;\n\n\t/* switch readers back to the even copy */\n\traw_write_seqcount_latch(&cd.seq);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic void update_clock_read_data(struct clock_read_data *rd)\n{\n\t/* update the backup (odd) copy with the new data */\n\tcd.read_data[1] = *rd;\n\n\t/* steer readers towards the odd copy */\n\traw_write_seqcount_latch(&cd.seq);\n\n\t/* now its safe for us to update the normal (even) copy */\n\tcd.read_data[0] = *rd;\n\n\t/* switch readers back to the even copy */\n\traw_write_seqcount_latch(&cd.seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cyc_to_ns",
          "args": [
            "(cyc - rd.epoch_cyc) & rd.sched_clock_mask",
            "rd.mult",
            "rd.shift"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "cyc_to_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
          "lines": "92-95",
          "snippet": "static inline u64 notrace cyc_to_ns(u64 cyc, u32 mult, u32 shift)\n{\n\treturn (cyc * mult) >> shift;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 notrace cyc_to_ns(u64 cyc, u32 mult, u32 shift)\n{\n\treturn (cyc * mult) >> shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cd.actual_read_sched_clock",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic void update_sched_clock(void)\n{\n\tu64 cyc;\n\tu64 ns;\n\tstruct clock_read_data rd;\n\n\trd = cd.read_data[0];\n\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\n\trd.epoch_ns = ns;\n\trd.epoch_cyc = cyc;\n\n\tupdate_clock_read_data(&rd);\n}"
  },
  {
    "function_name": "update_clock_read_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
    "lines": "125-138",
    "snippet": "static void update_clock_read_data(struct clock_read_data *rd)\n{\n\t/* update the backup (odd) copy with the new data */\n\tcd.read_data[1] = *rd;\n\n\t/* steer readers towards the odd copy */\n\traw_write_seqcount_latch(&cd.seq);\n\n\t/* now its safe for us to update the normal (even) copy */\n\tcd.read_data[0] = *rd;\n\n\t/* switch readers back to the even copy */\n\traw_write_seqcount_latch(&cd.seq);\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_write_seqcount_latch",
          "args": [
            "&cd.seq"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_write_seqcount_latch",
          "args": [
            "&cd.seq"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic void update_clock_read_data(struct clock_read_data *rd)\n{\n\t/* update the backup (odd) copy with the new data */\n\tcd.read_data[1] = *rd;\n\n\t/* steer readers towards the odd copy */\n\traw_write_seqcount_latch(&cd.seq);\n\n\t/* now its safe for us to update the normal (even) copy */\n\tcd.read_data[0] = *rd;\n\n\t/* switch readers back to the even copy */\n\traw_write_seqcount_latch(&cd.seq);\n}"
  },
  {
    "function_name": "sched_clock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
    "lines": "97-113",
    "snippet": "unsigned long long notrace sched_clock(void)\n{\n\tu64 cyc, res;\n\tunsigned long seq;\n\tstruct clock_read_data *rd;\n\n\tdo {\n\t\tseq = raw_read_seqcount(&cd.seq);\n\t\trd = cd.read_data + (seq & 1);\n\n\t\tcyc = (rd->read_sched_clock() - rd->epoch_cyc) &\n\t\t      rd->sched_clock_mask;\n\t\tres = rd->epoch_ns + cyc_to_ns(cyc, rd->mult, rd->shift);\n\t} while (read_seqcount_retry(&cd.seq, seq));\n\n\treturn res;\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&cd.seq",
            "seq"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cyc_to_ns",
          "args": [
            "cyc",
            "rd->mult",
            "rd->shift"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "cyc_to_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
          "lines": "92-95",
          "snippet": "static inline u64 notrace cyc_to_ns(u64 cyc, u32 mult, u32 shift)\n{\n\treturn (cyc * mult) >> shift;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 notrace cyc_to_ns(u64 cyc, u32 mult, u32 shift)\n{\n\treturn (cyc * mult) >> shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rd->read_sched_clock",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_read_seqcount",
          "args": [
            "&cd.seq"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nunsigned long long notrace sched_clock(void)\n{\n\tu64 cyc, res;\n\tunsigned long seq;\n\tstruct clock_read_data *rd;\n\n\tdo {\n\t\tseq = raw_read_seqcount(&cd.seq);\n\t\trd = cd.read_data + (seq & 1);\n\n\t\tcyc = (rd->read_sched_clock() - rd->epoch_cyc) &\n\t\t      rd->sched_clock_mask;\n\t\tres = rd->epoch_ns + cyc_to_ns(cyc, rd->mult, rd->shift);\n\t} while (read_seqcount_retry(&cd.seq, seq));\n\n\treturn res;\n}"
  },
  {
    "function_name": "cyc_to_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
    "lines": "92-95",
    "snippet": "static inline u64 notrace cyc_to_ns(u64 cyc, u32 mult, u32 shift)\n{\n\treturn (cyc * mult) >> shift;\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 notrace cyc_to_ns(u64 cyc, u32 mult, u32 shift)\n{\n\treturn (cyc * mult) >> shift;\n}"
  },
  {
    "function_name": "jiffy_sched_clock_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
    "lines": "77-84",
    "snippet": "static u64 notrace jiffy_sched_clock_read(void)\n{\n\t/*\n\t * We don't need to use get_jiffies_64 on 32-bit arches here\n\t * because we register with BITS_PER_LONG\n\t */\n\treturn (u64)(jiffies - INITIAL_JIFFIES);\n}",
    "includes": [
      "#include <linux/bitops.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/sched_clock.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>",
      "#include <linux/ktime.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "jiffies - INITIAL_JIFFIES"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic u64 notrace jiffy_sched_clock_read(void)\n{\n\t/*\n\t * We don't need to use get_jiffies_64 on 32-bit arches here\n\t * because we register with BITS_PER_LONG\n\t */\n\treturn (u64)(jiffies - INITIAL_JIFFIES);\n}"
  }
]