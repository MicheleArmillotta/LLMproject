[
  {
    "function_name": "show_interrupts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "452-528",
    "snippet": "int show_interrupts(struct seq_file *p, void *v)\n{\n\tstatic int prec;\n\n\tunsigned long flags, any_count = 0;\n\tint i = *(loff_t *) v, j;\n\tstruct irqaction *action;\n\tstruct irq_desc *desc;\n\n\tif (i > ACTUAL_NR_IRQS)\n\t\treturn 0;\n\n\tif (i == ACTUAL_NR_IRQS)\n\t\treturn arch_show_interrupts(p, prec);\n\n\t/* print header and calculate the width of the first column */\n\tif (i == 0) {\n\t\tfor (prec = 3, j = 1000; prec < 10 && j <= nr_irqs; ++prec)\n\t\t\tj *= 10;\n\n\t\tseq_printf(p, \"%*s\", prec + 8, \"\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"CPU%-8d\", j);\n\t\tseq_putc(p, '\\n');\n\t}\n\n\trcu_read_lock();\n\tdesc = irq_to_desc(i);\n\tif (!desc)\n\t\tgoto outsparse;\n\n\tif (desc->kstat_irqs)\n\t\tfor_each_online_cpu(j)\n\t\t\tany_count |= *per_cpu_ptr(desc->kstat_irqs, j);\n\n\tif ((!desc->action || irq_desc_is_chained(desc)) && !any_count)\n\t\tgoto outsparse;\n\n\tseq_printf(p, \"%*d: \", prec, i);\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", desc->kstat_irqs ?\n\t\t\t\t\t*per_cpu_ptr(desc->kstat_irqs, j) : 0);\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tif (desc->irq_data.chip) {\n\t\tif (desc->irq_data.chip->irq_print_chip)\n\t\t\tdesc->irq_data.chip->irq_print_chip(&desc->irq_data, p);\n\t\telse if (desc->irq_data.chip->name)\n\t\t\tseq_printf(p, \" %8s\", desc->irq_data.chip->name);\n\t\telse\n\t\t\tseq_printf(p, \" %8s\", \"-\");\n\t} else {\n\t\tseq_printf(p, \" %8s\", \"None\");\n\t}\n\tif (desc->irq_data.domain)\n\t\tseq_printf(p, \" %*d\", prec, (int) desc->irq_data.hwirq);\n\telse\n\t\tseq_printf(p, \" %*s\", prec, \"\");\n#ifdef CONFIG_GENERIC_IRQ_SHOW_LEVEL\n\tseq_printf(p, \" %-8s\", irqd_is_level_type(&desc->irq_data) ? \"Level\" : \"Edge\");\n#endif\n\tif (desc->name)\n\t\tseq_printf(p, \"-%-8s\", desc->name);\n\n\taction = desc->action;\n\tif (action) {\n\t\tseq_printf(p, \"  %s\", action->name);\n\t\twhile ((action = action->next) != NULL)\n\t\t\tseq_printf(p, \", %s\", action->name);\n\t}\n\n\tseq_putc(p, '\\n');\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\noutsparse:\n\trcu_read_unlock();\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "p",
            "'\\n'"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\", %s\"",
            "action->name"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_is_level_type",
          "args": [
            "&desc->irq_data"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "desc->irq_data.chip->irq_print_chip",
          "args": [
            "&desc->irq_data",
            "p"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "desc->kstat_irqs",
            "j"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_is_chained",
          "args": [
            "desc"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "irq_desc_is_chained",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "256-259",
          "snippet": "static inline int irq_desc_is_chained(struct irq_desc *desc)\n{\n\treturn (desc->action && desc->action == &chained_action);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct irqaction chained_action;",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "void __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern struct irqaction chained_action;\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nvoid __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline int irq_desc_is_chained(struct irq_desc *desc)\n{\n\treturn (desc->action && desc->action == &chained_action);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "desc->kstat_irqs",
            "j"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_online_cpu",
          "args": [
            "j"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "i"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "561-564",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_show_interrupts",
          "args": [
            "p",
            "prec"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "arch_show_interrupts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
          "lines": "443-446",
          "snippet": "int __weak arch_show_interrupts(struct seq_file *p, int prec)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nint __weak arch_show_interrupts(struct seq_file *p, int prec)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nint show_interrupts(struct seq_file *p, void *v)\n{\n\tstatic int prec;\n\n\tunsigned long flags, any_count = 0;\n\tint i = *(loff_t *) v, j;\n\tstruct irqaction *action;\n\tstruct irq_desc *desc;\n\n\tif (i > ACTUAL_NR_IRQS)\n\t\treturn 0;\n\n\tif (i == ACTUAL_NR_IRQS)\n\t\treturn arch_show_interrupts(p, prec);\n\n\t/* print header and calculate the width of the first column */\n\tif (i == 0) {\n\t\tfor (prec = 3, j = 1000; prec < 10 && j <= nr_irqs; ++prec)\n\t\t\tj *= 10;\n\n\t\tseq_printf(p, \"%*s\", prec + 8, \"\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"CPU%-8d\", j);\n\t\tseq_putc(p, '\\n');\n\t}\n\n\trcu_read_lock();\n\tdesc = irq_to_desc(i);\n\tif (!desc)\n\t\tgoto outsparse;\n\n\tif (desc->kstat_irqs)\n\t\tfor_each_online_cpu(j)\n\t\t\tany_count |= *per_cpu_ptr(desc->kstat_irqs, j);\n\n\tif ((!desc->action || irq_desc_is_chained(desc)) && !any_count)\n\t\tgoto outsparse;\n\n\tseq_printf(p, \"%*d: \", prec, i);\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", desc->kstat_irqs ?\n\t\t\t\t\t*per_cpu_ptr(desc->kstat_irqs, j) : 0);\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tif (desc->irq_data.chip) {\n\t\tif (desc->irq_data.chip->irq_print_chip)\n\t\t\tdesc->irq_data.chip->irq_print_chip(&desc->irq_data, p);\n\t\telse if (desc->irq_data.chip->name)\n\t\t\tseq_printf(p, \" %8s\", desc->irq_data.chip->name);\n\t\telse\n\t\t\tseq_printf(p, \" %8s\", \"-\");\n\t} else {\n\t\tseq_printf(p, \" %8s\", \"None\");\n\t}\n\tif (desc->irq_data.domain)\n\t\tseq_printf(p, \" %*d\", prec, (int) desc->irq_data.hwirq);\n\telse\n\t\tseq_printf(p, \" %*s\", prec, \"\");\n#ifdef CONFIG_GENERIC_IRQ_SHOW_LEVEL\n\tseq_printf(p, \" %-8s\", irqd_is_level_type(&desc->irq_data) ? \"Level\" : \"Edge\");\n#endif\n\tif (desc->name)\n\t\tseq_printf(p, \"-%-8s\", desc->name);\n\n\taction = desc->action;\n\tif (action) {\n\t\tseq_printf(p, \"  %s\", action->name);\n\t\twhile ((action = action->next) != NULL)\n\t\t\tseq_printf(p, \", %s\", action->name);\n\t}\n\n\tseq_putc(p, '\\n');\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\noutsparse:\n\trcu_read_unlock();\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_show_interrupts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "443-446",
    "snippet": "int __weak arch_show_interrupts(struct seq_file *p, int prec)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nint __weak arch_show_interrupts(struct seq_file *p, int prec)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "init_irq_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "422-439",
    "snippet": "void init_irq_proc(void)\n{\n\tunsigned int irq;\n\tstruct irq_desc *desc;\n\n\t/* create /proc/irq */\n\troot_irq_dir = proc_mkdir(\"irq\", NULL);\n\tif (!root_irq_dir)\n\t\treturn;\n\n\tregister_default_affinity_proc();\n\n\t/*\n\t * Create entries for all existing IRQs.\n\t */\n\tfor_each_irq_desc(irq, desc)\n\t\tregister_irq_proc(irq, desc);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct proc_dir_entry *root_irq_dir;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_irq_proc",
          "args": [
            "irq",
            "desc"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_irq_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
          "lines": "385-405",
          "snippet": "void unregister_irq_proc(unsigned int irq, struct irq_desc *desc)\n{\n\tchar name [MAX_NAMELEN];\n\n\tif (!root_irq_dir || !desc->dir)\n\t\treturn;\n#ifdef CONFIG_SMP\n\tremove_proc_entry(\"smp_affinity\", desc->dir);\n\tremove_proc_entry(\"affinity_hint\", desc->dir);\n\tremove_proc_entry(\"smp_affinity_list\", desc->dir);\n\tremove_proc_entry(\"node\", desc->dir);\n# ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\tremove_proc_entry(\"effective_affinity\", desc->dir);\n\tremove_proc_entry(\"effective_affinity_list\", desc->dir);\n# endif\n#endif\n\tremove_proc_entry(\"spurious\", desc->dir);\n\n\tsprintf(name, \"%u\", irq);\n\tremove_proc_entry(name, root_irq_dir);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [
            "#define MAX_NAMELEN 10",
            "#define MAX_NAMELEN 128"
          ],
          "globals_used": [
            "static struct proc_dir_entry *root_irq_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\n#define MAX_NAMELEN 10\n#define MAX_NAMELEN 128\n\nstatic struct proc_dir_entry *root_irq_dir;\n\nvoid unregister_irq_proc(unsigned int irq, struct irq_desc *desc)\n{\n\tchar name [MAX_NAMELEN];\n\n\tif (!root_irq_dir || !desc->dir)\n\t\treturn;\n#ifdef CONFIG_SMP\n\tremove_proc_entry(\"smp_affinity\", desc->dir);\n\tremove_proc_entry(\"affinity_hint\", desc->dir);\n\tremove_proc_entry(\"smp_affinity_list\", desc->dir);\n\tremove_proc_entry(\"node\", desc->dir);\n# ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\tremove_proc_entry(\"effective_affinity\", desc->dir);\n\tremove_proc_entry(\"effective_affinity_list\", desc->dir);\n# endif\n#endif\n\tremove_proc_entry(\"spurious\", desc->dir);\n\n\tsprintf(name, \"%u\", irq);\n\tremove_proc_entry(name, root_irq_dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_irq_desc",
          "args": [
            "irq",
            "desc"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_default_affinity_proc",
          "args": [],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "register_default_affinity_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
          "lines": "414-420",
          "snippet": "static void register_default_affinity_proc(void)\n{\n#ifdef CONFIG_SMP\n\tproc_create(\"irq/default_smp_affinity\", 0644, NULL,\n\t\t    &default_affinity_proc_fops);\n#endif\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic void register_default_affinity_proc(void)\n{\n#ifdef CONFIG_SMP\n\tproc_create(\"irq/default_smp_affinity\", 0644, NULL,\n\t\t    &default_affinity_proc_fops);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "\"irq\"",
            "NULL"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic struct proc_dir_entry *root_irq_dir;\n\nvoid init_irq_proc(void)\n{\n\tunsigned int irq;\n\tstruct irq_desc *desc;\n\n\t/* create /proc/irq */\n\troot_irq_dir = proc_mkdir(\"irq\", NULL);\n\tif (!root_irq_dir)\n\t\treturn;\n\n\tregister_default_affinity_proc();\n\n\t/*\n\t * Create entries for all existing IRQs.\n\t */\n\tfor_each_irq_desc(irq, desc)\n\t\tregister_irq_proc(irq, desc);\n}"
  },
  {
    "function_name": "register_default_affinity_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "414-420",
    "snippet": "static void register_default_affinity_proc(void)\n{\n#ifdef CONFIG_SMP\n\tproc_create(\"irq/default_smp_affinity\", 0644, NULL,\n\t\t    &default_affinity_proc_fops);\n#endif\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"irq/default_smp_affinity\"",
            "0644",
            "NULL",
            "&default_affinity_proc_fops"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic void register_default_affinity_proc(void)\n{\n#ifdef CONFIG_SMP\n\tproc_create(\"irq/default_smp_affinity\", 0644, NULL,\n\t\t    &default_affinity_proc_fops);\n#endif\n}"
  },
  {
    "function_name": "unregister_handler_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "409-412",
    "snippet": "void unregister_handler_proc(unsigned int irq, struct irqaction *action)\n{\n\tproc_remove(action->dir);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_remove",
          "args": [
            "action->dir"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nvoid unregister_handler_proc(unsigned int irq, struct irqaction *action)\n{\n\tproc_remove(action->dir);\n}"
  },
  {
    "function_name": "unregister_irq_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "385-405",
    "snippet": "void unregister_irq_proc(unsigned int irq, struct irq_desc *desc)\n{\n\tchar name [MAX_NAMELEN];\n\n\tif (!root_irq_dir || !desc->dir)\n\t\treturn;\n#ifdef CONFIG_SMP\n\tremove_proc_entry(\"smp_affinity\", desc->dir);\n\tremove_proc_entry(\"affinity_hint\", desc->dir);\n\tremove_proc_entry(\"smp_affinity_list\", desc->dir);\n\tremove_proc_entry(\"node\", desc->dir);\n# ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\tremove_proc_entry(\"effective_affinity\", desc->dir);\n\tremove_proc_entry(\"effective_affinity_list\", desc->dir);\n# endif\n#endif\n\tremove_proc_entry(\"spurious\", desc->dir);\n\n\tsprintf(name, \"%u\", irq);\n\tremove_proc_entry(name, root_irq_dir);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [
      "#define MAX_NAMELEN 10",
      "#define MAX_NAMELEN 128"
    ],
    "globals_used": [
      "static struct proc_dir_entry *root_irq_dir;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "name",
            "root_irq_dir"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "name",
            "\"%u\"",
            "irq"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"spurious\"",
            "desc->dir"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"effective_affinity_list\"",
            "desc->dir"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"effective_affinity\"",
            "desc->dir"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"node\"",
            "desc->dir"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"smp_affinity_list\"",
            "desc->dir"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"affinity_hint\"",
            "desc->dir"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"smp_affinity\"",
            "desc->dir"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\n#define MAX_NAMELEN 10\n#define MAX_NAMELEN 128\n\nstatic struct proc_dir_entry *root_irq_dir;\n\nvoid unregister_irq_proc(unsigned int irq, struct irq_desc *desc)\n{\n\tchar name [MAX_NAMELEN];\n\n\tif (!root_irq_dir || !desc->dir)\n\t\treturn;\n#ifdef CONFIG_SMP\n\tremove_proc_entry(\"smp_affinity\", desc->dir);\n\tremove_proc_entry(\"affinity_hint\", desc->dir);\n\tremove_proc_entry(\"smp_affinity_list\", desc->dir);\n\tremove_proc_entry(\"node\", desc->dir);\n# ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\tremove_proc_entry(\"effective_affinity\", desc->dir);\n\tremove_proc_entry(\"effective_affinity_list\", desc->dir);\n# endif\n#endif\n\tremove_proc_entry(\"spurious\", desc->dir);\n\n\tsprintf(name, \"%u\", irq);\n\tremove_proc_entry(name, root_irq_dir);\n}"
  },
  {
    "function_name": "register_irq_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "330-383",
    "snippet": "void register_irq_proc(unsigned int irq, struct irq_desc *desc)\n{\n\tstatic DEFINE_MUTEX(register_lock);\n\tvoid __maybe_unused *irqp = (void *)(unsigned long) irq;\n\tchar name [MAX_NAMELEN];\n\n\tif (!root_irq_dir || (desc->irq_data.chip == &no_irq_chip))\n\t\treturn;\n\n\t/*\n\t * irq directories are registered only when a handler is\n\t * added, not when the descriptor is created, so multiple\n\t * tasks might try to register at the same time.\n\t */\n\tmutex_lock(&register_lock);\n\n\tif (desc->dir)\n\t\tgoto out_unlock;\n\n\tsprintf(name, \"%d\", irq);\n\n\t/* create /proc/irq/1234 */\n\tdesc->dir = proc_mkdir(name, root_irq_dir);\n\tif (!desc->dir)\n\t\tgoto out_unlock;\n\n#ifdef CONFIG_SMP\n\t/* create /proc/irq/<irq>/smp_affinity */\n\tproc_create_data(\"smp_affinity\", 0644, desc->dir,\n\t\t\t &irq_affinity_proc_fops, irqp);\n\n\t/* create /proc/irq/<irq>/affinity_hint */\n\tproc_create_single_data(\"affinity_hint\", 0444, desc->dir,\n\t\t\tirq_affinity_hint_proc_show, irqp);\n\n\t/* create /proc/irq/<irq>/smp_affinity_list */\n\tproc_create_data(\"smp_affinity_list\", 0644, desc->dir,\n\t\t\t &irq_affinity_list_proc_fops, irqp);\n\n\tproc_create_single_data(\"node\", 0444, desc->dir, irq_node_proc_show,\n\t\t\tirqp);\n# ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\tproc_create_single_data(\"effective_affinity\", 0444, desc->dir,\n\t\t\tirq_effective_aff_proc_show, irqp);\n\tproc_create_single_data(\"effective_affinity_list\", 0444, desc->dir,\n\t\t\tirq_effective_aff_list_proc_show, irqp);\n# endif\n#endif\n\tproc_create_single_data(\"spurious\", 0444, desc->dir,\n\t\t\tirq_spurious_proc_show, (void *)(long)irq);\n\nout_unlock:\n\tmutex_unlock(&register_lock);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [
      "#define MAX_NAMELEN 10",
      "#define MAX_NAMELEN 128"
    ],
    "globals_used": [
      "static struct proc_dir_entry *root_irq_dir;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&register_lock"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_create_single_data",
          "args": [
            "\"spurious\"",
            "0444",
            "desc->dir",
            "irq_spurious_proc_show",
            "(void *)(long)irq"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_single_data",
          "args": [
            "\"effective_affinity_list\"",
            "0444",
            "desc->dir",
            "irq_effective_aff_list_proc_show",
            "irqp"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_single_data",
          "args": [
            "\"effective_affinity\"",
            "0444",
            "desc->dir",
            "irq_effective_aff_proc_show",
            "irqp"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_single_data",
          "args": [
            "\"node\"",
            "0444",
            "desc->dir",
            "irq_node_proc_show",
            "irqp"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_data",
          "args": [
            "\"smp_affinity_list\"",
            "0644",
            "desc->dir",
            "&irq_affinity_list_proc_fops",
            "irqp"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_single_data",
          "args": [
            "\"affinity_hint\"",
            "0444",
            "desc->dir",
            "irq_affinity_hint_proc_show",
            "irqp"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_data",
          "args": [
            "\"smp_affinity\"",
            "0644",
            "desc->dir",
            "&irq_affinity_proc_fops",
            "irqp"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "name",
            "root_irq_dir"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "name",
            "\"%d\"",
            "irq"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&register_lock"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\n#define MAX_NAMELEN 10\n#define MAX_NAMELEN 128\n\nstatic struct proc_dir_entry *root_irq_dir;\n\nvoid register_irq_proc(unsigned int irq, struct irq_desc *desc)\n{\n\tstatic DEFINE_MUTEX(register_lock);\n\tvoid __maybe_unused *irqp = (void *)(unsigned long) irq;\n\tchar name [MAX_NAMELEN];\n\n\tif (!root_irq_dir || (desc->irq_data.chip == &no_irq_chip))\n\t\treturn;\n\n\t/*\n\t * irq directories are registered only when a handler is\n\t * added, not when the descriptor is created, so multiple\n\t * tasks might try to register at the same time.\n\t */\n\tmutex_lock(&register_lock);\n\n\tif (desc->dir)\n\t\tgoto out_unlock;\n\n\tsprintf(name, \"%d\", irq);\n\n\t/* create /proc/irq/1234 */\n\tdesc->dir = proc_mkdir(name, root_irq_dir);\n\tif (!desc->dir)\n\t\tgoto out_unlock;\n\n#ifdef CONFIG_SMP\n\t/* create /proc/irq/<irq>/smp_affinity */\n\tproc_create_data(\"smp_affinity\", 0644, desc->dir,\n\t\t\t &irq_affinity_proc_fops, irqp);\n\n\t/* create /proc/irq/<irq>/affinity_hint */\n\tproc_create_single_data(\"affinity_hint\", 0444, desc->dir,\n\t\t\tirq_affinity_hint_proc_show, irqp);\n\n\t/* create /proc/irq/<irq>/smp_affinity_list */\n\tproc_create_data(\"smp_affinity_list\", 0644, desc->dir,\n\t\t\t &irq_affinity_list_proc_fops, irqp);\n\n\tproc_create_single_data(\"node\", 0444, desc->dir, irq_node_proc_show,\n\t\t\tirqp);\n# ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\tproc_create_single_data(\"effective_affinity\", 0444, desc->dir,\n\t\t\tirq_effective_aff_proc_show, irqp);\n\tproc_create_single_data(\"effective_affinity_list\", 0444, desc->dir,\n\t\t\tirq_effective_aff_list_proc_show, irqp);\n# endif\n#endif\n\tproc_create_single_data(\"spurious\", 0444, desc->dir,\n\t\t\tirq_spurious_proc_show, (void *)(long)irq);\n\nout_unlock:\n\tmutex_unlock(&register_lock);\n}"
  },
  {
    "function_name": "register_handler_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "311-324",
    "snippet": "void register_handler_proc(unsigned int irq, struct irqaction *action)\n{\n\tchar name [MAX_NAMELEN];\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (!desc->dir || action->dir || !action->name ||\n\t\t\t\t\t!name_unique(irq, action))\n\t\treturn;\n\n\tsnprintf(name, MAX_NAMELEN, \"%s\", action->name);\n\n\t/* create /proc/irq/1234/handler/ */\n\taction->dir = proc_mkdir(name, desc->dir);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [
      "#define MAX_NAMELEN 10",
      "#define MAX_NAMELEN 128"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "name",
            "desc->dir"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "MAX_NAMELEN",
            "\"%s\"",
            "action->name"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_unique",
          "args": [
            "irq",
            "action"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "name_unique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
          "lines": "292-309",
          "snippet": "static int name_unique(unsigned int irq, struct irqaction *new_action)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\tint ret = 1;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tfor_each_action_of_desc(desc, action) {\n\t\tif ((action != new_action) && action->name &&\n\t\t\t\t!strcmp(new_action->name, action->name)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int name_unique(unsigned int irq, struct irqaction *new_action)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\tint ret = 1;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tfor_each_action_of_desc(desc, action) {\n\t\tif ((action != new_action) && action->name &&\n\t\t\t\t!strcmp(new_action->name, action->name)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "561-564",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\n#define MAX_NAMELEN 10\n#define MAX_NAMELEN 128\n\nvoid register_handler_proc(unsigned int irq, struct irqaction *action)\n{\n\tchar name [MAX_NAMELEN];\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (!desc->dir || action->dir || !action->name ||\n\t\t\t\t\t!name_unique(irq, action))\n\t\treturn;\n\n\tsnprintf(name, MAX_NAMELEN, \"%s\", action->name);\n\n\t/* create /proc/irq/1234/handler/ */\n\taction->dir = proc_mkdir(name, desc->dir);\n}"
  },
  {
    "function_name": "name_unique",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "292-309",
    "snippet": "static int name_unique(unsigned int irq, struct irqaction *new_action)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\tint ret = 1;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tfor_each_action_of_desc(desc, action) {\n\t\tif ((action != new_action) && action->name &&\n\t\t\t\t!strcmp(new_action->name, action->name)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "new_action->name",
            "action->name"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_action_of_desc",
          "args": [
            "desc",
            "action"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "561-564",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int name_unique(unsigned int irq, struct irqaction *new_action)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\tint ret = 1;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tfor_each_action_of_desc(desc, action) {\n\t\tif ((action != new_action) && action->name &&\n\t\t\t\t!strcmp(new_action->name, action->name)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_spurious_proc_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "280-288",
    "snippet": "static int irq_spurious_proc_show(struct seq_file *m, void *v)\n{\n\tstruct irq_desc *desc = irq_to_desc((long) m->private);\n\n\tseq_printf(m, \"count %u\\n\" \"unhandled %u\\n\" \"last_unhandled %u ms\\n\",\n\t\t   desc->irq_count, desc->irqs_unhandled,\n\t\t   jiffies_to_msecs(desc->last_unhandled));\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"count %u\\n\" \"unhandled %u\\n\" \"last_unhandled %u ms\\n\"",
            "desc->irq_count",
            "desc->irqs_unhandled",
            "jiffies_to_msecs(desc->last_unhandled)"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jiffies_to_msecs",
          "args": [
            "desc->last_unhandled"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "jiffies_to_msecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "311-325",
          "snippet": "unsigned int jiffies_to_msecs(const unsigned long j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>\n\t       HZ_TO_MSEC_SHR32;\n# else\n\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n# endif\n#endif\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned int jiffies_to_msecs(const unsigned long j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>\n\t       HZ_TO_MSEC_SHR32;\n# else\n\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n# endif\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "(long) m->private"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "561-564",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int irq_spurious_proc_show(struct seq_file *m, void *v)\n{\n\tstruct irq_desc *desc = irq_to_desc((long) m->private);\n\n\tseq_printf(m, \"count %u\\n\" \"unhandled %u\\n\" \"last_unhandled %u ms\\n\",\n\t\t   desc->irq_count, desc->irqs_unhandled,\n\t\t   jiffies_to_msecs(desc->last_unhandled));\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_node_proc_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "271-277",
    "snippet": "static int irq_node_proc_show(struct seq_file *m, void *v)\n{\n\tstruct irq_desc *desc = irq_to_desc((long) m->private);\n\n\tseq_printf(m, \"%d\\n\", irq_desc_get_node(desc));\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%d\\n\"",
            "irq_desc_get_node(desc)"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_get_node",
          "args": [
            "desc"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "irq_desc_get_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "251-254",
          "snippet": "static inline int irq_desc_get_node(struct irq_desc *desc)\n{\n\treturn irq_common_data_get_node(&desc->irq_common_data);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline int irq_desc_get_node(struct irq_desc *desc)\n{\n\treturn irq_common_data_get_node(&desc->irq_common_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "(long) m->private"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "561-564",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int irq_node_proc_show(struct seq_file *m, void *v)\n{\n\tstruct irq_desc *desc = irq_to_desc((long) m->private);\n\n\tseq_printf(m, \"%d\\n\", irq_desc_get_node(desc));\n\treturn 0;\n}"
  },
  {
    "function_name": "default_affinity_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "258-261",
    "snippet": "static int default_affinity_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, default_affinity_show, PDE_DATA(inode));\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "default_affinity_show",
            "PDE_DATA(inode)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDE_DATA",
          "args": [
            "inode"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int default_affinity_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, default_affinity_show, PDE_DATA(inode));\n}"
  },
  {
    "function_name": "default_affinity_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "222-256",
    "snippet": "static ssize_t default_affinity_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *ppos)\n{\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!alloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (err)\n\t\tgoto out;\n\n\tif (!is_affinity_mask_valid(new_value)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do not allow disabling IRQs completely - it's a too easy\n\t * way to make the system unusable accidentally :-) At least\n\t * one online CPU still has to be targeted.\n\t */\n\tif (!cpumask_intersects(new_value, cpu_online_mask)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcpumask_copy(irq_default_affinity, new_value);\n\terr = count;\n\nout:\n\tfree_cpumask_var(new_value);\n\treturn err;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "new_value"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "irq_default_affinity",
            "new_value"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "new_value",
            "cpu_online_mask"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_affinity_mask_valid",
          "args": [
            "new_value"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_parse_user",
          "args": [
            "buffer",
            "count",
            "new_value"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&new_value",
            "GFP_KERNEL"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic ssize_t default_affinity_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *ppos)\n{\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!alloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (err)\n\t\tgoto out;\n\n\tif (!is_affinity_mask_valid(new_value)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do not allow disabling IRQs completely - it's a too easy\n\t * way to make the system unusable accidentally :-) At least\n\t * one online CPU still has to be targeted.\n\t */\n\tif (!cpumask_intersects(new_value, cpu_online_mask)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcpumask_copy(irq_default_affinity, new_value);\n\terr = count;\n\nout:\n\tfree_cpumask_var(new_value);\n\treturn err;\n}"
  },
  {
    "function_name": "default_affinity_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "216-220",
    "snippet": "static int default_affinity_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(irq_default_affinity));\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%*pb\\n\"",
            "cpumask_pr_args(irq_default_affinity)"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "irq_default_affinity"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int default_affinity_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(irq_default_affinity));\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_effective_aff_list_proc_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "210-213",
    "snippet": "static int irq_effective_aff_list_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(EFFECTIVE_LIST, m);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_irq_affinity",
          "args": [
            "EFFECTIVE_LIST",
            "m"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "show_irq_affinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
          "lines": "46-81",
          "snippet": "static int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int irq_effective_aff_list_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(EFFECTIVE_LIST, m);\n}"
  },
  {
    "function_name": "irq_effective_aff_proc_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "205-208",
    "snippet": "static int irq_effective_aff_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(EFFECTIVE, m);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_irq_affinity",
          "args": [
            "EFFECTIVE",
            "m"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "show_irq_affinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
          "lines": "46-81",
          "snippet": "static int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int irq_effective_aff_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(EFFECTIVE, m);\n}"
  },
  {
    "function_name": "irq_affinity_list_proc_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "183-186",
    "snippet": "static int irq_affinity_list_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, irq_affinity_list_proc_show, PDE_DATA(inode));\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "irq_affinity_list_proc_show",
            "PDE_DATA(inode)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDE_DATA",
          "args": [
            "inode"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int irq_affinity_list_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, irq_affinity_list_proc_show, PDE_DATA(inode));\n}"
  },
  {
    "function_name": "irq_affinity_proc_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "178-181",
    "snippet": "static int irq_affinity_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, irq_affinity_proc_show, PDE_DATA(inode));\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "irq_affinity_proc_show",
            "PDE_DATA(inode)"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PDE_DATA",
          "args": [
            "inode"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int irq_affinity_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, irq_affinity_proc_show, PDE_DATA(inode));\n}"
  },
  {
    "function_name": "irq_affinity_list_proc_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "172-176",
    "snippet": "static ssize_t irq_affinity_list_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\treturn write_irq_affinity(1, file, buffer, count, pos);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_irq_affinity",
          "args": [
            "1",
            "file",
            "buffer",
            "count",
            "pos"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "write_irq_affinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
          "lines": "119-164",
          "snippet": "static ssize_t write_irq_affinity(int type, struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tunsigned int irq = (int)(long)PDE_DATA(file_inode(file));\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!irq_can_set_affinity_usr(irq) || no_irq_affinity)\n\t\treturn -EIO;\n\n\tif (!alloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (type)\n\t\terr = cpumask_parselist_user(buffer, count, new_value);\n\telse\n\t\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (err)\n\t\tgoto free_cpumask;\n\n\tif (!is_affinity_mask_valid(new_value)) {\n\t\terr = -EINVAL;\n\t\tgoto free_cpumask;\n\t}\n\n\t/*\n\t * Do not allow disabling IRQs completely - it's a too easy\n\t * way to make the system unusable accidentally :-) At least\n\t * one online CPU still has to be targeted.\n\t */\n\tif (!cpumask_intersects(new_value, cpu_online_mask)) {\n\t\t/*\n\t\t * Special case for empty set - allow the architecture code\n\t\t * to set default SMP affinity.\n\t\t */\n\t\terr = irq_select_affinity_usr(irq) ? -EINVAL : count;\n\t} else {\n\t\terr = irq_set_affinity(irq, new_value);\n\t\tif (!err)\n\t\t\terr = count;\n\t}\n\nfree_cpumask:\n\tfree_cpumask_var(new_value);\n\treturn err;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic ssize_t write_irq_affinity(int type, struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tunsigned int irq = (int)(long)PDE_DATA(file_inode(file));\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!irq_can_set_affinity_usr(irq) || no_irq_affinity)\n\t\treturn -EIO;\n\n\tif (!alloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (type)\n\t\terr = cpumask_parselist_user(buffer, count, new_value);\n\telse\n\t\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (err)\n\t\tgoto free_cpumask;\n\n\tif (!is_affinity_mask_valid(new_value)) {\n\t\terr = -EINVAL;\n\t\tgoto free_cpumask;\n\t}\n\n\t/*\n\t * Do not allow disabling IRQs completely - it's a too easy\n\t * way to make the system unusable accidentally :-) At least\n\t * one online CPU still has to be targeted.\n\t */\n\tif (!cpumask_intersects(new_value, cpu_online_mask)) {\n\t\t/*\n\t\t * Special case for empty set - allow the architecture code\n\t\t * to set default SMP affinity.\n\t\t */\n\t\terr = irq_select_affinity_usr(irq) ? -EINVAL : count;\n\t} else {\n\t\terr = irq_set_affinity(irq, new_value);\n\t\tif (!err)\n\t\t\terr = count;\n\t}\n\nfree_cpumask:\n\tfree_cpumask_var(new_value);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic ssize_t irq_affinity_list_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\treturn write_irq_affinity(1, file, buffer, count, pos);\n}"
  },
  {
    "function_name": "irq_affinity_proc_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "166-170",
    "snippet": "static ssize_t irq_affinity_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\treturn write_irq_affinity(0, file, buffer, count, pos);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_irq_affinity",
          "args": [
            "0",
            "file",
            "buffer",
            "count",
            "pos"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "write_irq_affinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
          "lines": "119-164",
          "snippet": "static ssize_t write_irq_affinity(int type, struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tunsigned int irq = (int)(long)PDE_DATA(file_inode(file));\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!irq_can_set_affinity_usr(irq) || no_irq_affinity)\n\t\treturn -EIO;\n\n\tif (!alloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (type)\n\t\terr = cpumask_parselist_user(buffer, count, new_value);\n\telse\n\t\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (err)\n\t\tgoto free_cpumask;\n\n\tif (!is_affinity_mask_valid(new_value)) {\n\t\terr = -EINVAL;\n\t\tgoto free_cpumask;\n\t}\n\n\t/*\n\t * Do not allow disabling IRQs completely - it's a too easy\n\t * way to make the system unusable accidentally :-) At least\n\t * one online CPU still has to be targeted.\n\t */\n\tif (!cpumask_intersects(new_value, cpu_online_mask)) {\n\t\t/*\n\t\t * Special case for empty set - allow the architecture code\n\t\t * to set default SMP affinity.\n\t\t */\n\t\terr = irq_select_affinity_usr(irq) ? -EINVAL : count;\n\t} else {\n\t\terr = irq_set_affinity(irq, new_value);\n\t\tif (!err)\n\t\t\terr = count;\n\t}\n\nfree_cpumask:\n\tfree_cpumask_var(new_value);\n\treturn err;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic ssize_t write_irq_affinity(int type, struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tunsigned int irq = (int)(long)PDE_DATA(file_inode(file));\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!irq_can_set_affinity_usr(irq) || no_irq_affinity)\n\t\treturn -EIO;\n\n\tif (!alloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (type)\n\t\terr = cpumask_parselist_user(buffer, count, new_value);\n\telse\n\t\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (err)\n\t\tgoto free_cpumask;\n\n\tif (!is_affinity_mask_valid(new_value)) {\n\t\terr = -EINVAL;\n\t\tgoto free_cpumask;\n\t}\n\n\t/*\n\t * Do not allow disabling IRQs completely - it's a too easy\n\t * way to make the system unusable accidentally :-) At least\n\t * one online CPU still has to be targeted.\n\t */\n\tif (!cpumask_intersects(new_value, cpu_online_mask)) {\n\t\t/*\n\t\t * Special case for empty set - allow the architecture code\n\t\t * to set default SMP affinity.\n\t\t */\n\t\terr = irq_select_affinity_usr(irq) ? -EINVAL : count;\n\t} else {\n\t\terr = irq_set_affinity(irq, new_value);\n\t\tif (!err)\n\t\t\terr = count;\n\t}\n\nfree_cpumask:\n\tfree_cpumask_var(new_value);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic ssize_t irq_affinity_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\treturn write_irq_affinity(0, file, buffer, count, pos);\n}"
  },
  {
    "function_name": "write_irq_affinity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "119-164",
    "snippet": "static ssize_t write_irq_affinity(int type, struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tunsigned int irq = (int)(long)PDE_DATA(file_inode(file));\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!irq_can_set_affinity_usr(irq) || no_irq_affinity)\n\t\treturn -EIO;\n\n\tif (!alloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (type)\n\t\terr = cpumask_parselist_user(buffer, count, new_value);\n\telse\n\t\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (err)\n\t\tgoto free_cpumask;\n\n\tif (!is_affinity_mask_valid(new_value)) {\n\t\terr = -EINVAL;\n\t\tgoto free_cpumask;\n\t}\n\n\t/*\n\t * Do not allow disabling IRQs completely - it's a too easy\n\t * way to make the system unusable accidentally :-) At least\n\t * one online CPU still has to be targeted.\n\t */\n\tif (!cpumask_intersects(new_value, cpu_online_mask)) {\n\t\t/*\n\t\t * Special case for empty set - allow the architecture code\n\t\t * to set default SMP affinity.\n\t\t */\n\t\terr = irq_select_affinity_usr(irq) ? -EINVAL : count;\n\t} else {\n\t\terr = irq_set_affinity(irq, new_value);\n\t\tif (!err)\n\t\t\terr = count;\n\t}\n\nfree_cpumask:\n\tfree_cpumask_var(new_value);\n\treturn err;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "new_value"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_set_affinity",
          "args": [
            "irq",
            "new_value"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_affinity_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/manage.c",
          "lines": "334-363",
          "snippet": "int\nirq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irq_affinity_notify *old_notify;\n\tunsigned long flags;\n\n\t/* The release function is promised process context */\n\tmight_sleep();\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\t/* Complete initialisation of *notify */\n\tif (notify) {\n\t\tnotify->irq = irq;\n\t\tkref_init(&notify->kref);\n\t\tINIT_WORK(&notify->work, irq_affinity_notify);\n\t}\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_notify = desc->affinity_notify;\n\tdesc->affinity_notify = notify;\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (old_notify)\n\t\tkref_put(&old_notify->kref, old_notify->release);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint\nirq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irq_affinity_notify *old_notify;\n\tunsigned long flags;\n\n\t/* The release function is promised process context */\n\tmight_sleep();\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\t/* Complete initialisation of *notify */\n\tif (notify) {\n\t\tnotify->irq = irq;\n\t\tkref_init(&notify->kref);\n\t\tINIT_WORK(&notify->work, irq_affinity_notify);\n\t}\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_notify = desc->affinity_notify;\n\tdesc->affinity_notify = notify;\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (old_notify)\n\t\tkref_put(&old_notify->kref, old_notify->release);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_select_affinity_usr",
          "args": [
            "irq"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "irq_select_affinity_usr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/manage.c",
          "lines": "418-428",
          "snippet": "int irq_select_affinity_usr(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tunsigned long flags;\n\tint ret;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tret = irq_setup_affinity(desc);\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint irq_select_affinity_usr(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tunsigned long flags;\n\tint ret;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tret = irq_setup_affinity(desc);\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "new_value",
            "cpu_online_mask"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_affinity_mask_valid",
          "args": [
            "new_value"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_parse_user",
          "args": [
            "buffer",
            "count",
            "new_value"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_parselist_user",
          "args": [
            "buffer",
            "count",
            "new_value"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&new_value",
            "GFP_KERNEL"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_can_set_affinity_usr",
          "args": [
            "irq"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "irq_can_set_affinity_usr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/manage.c",
          "lines": "145-151",
          "snippet": "bool irq_can_set_affinity_usr(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn __irq_can_set_affinity(desc) &&\n\t\t!irqd_affinity_is_managed(&desc->irq_data);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nbool irq_can_set_affinity_usr(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn __irq_can_set_affinity(desc) &&\n\t\t!irqd_affinity_is_managed(&desc->irq_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDE_DATA",
          "args": [
            "file_inode(file)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic ssize_t write_irq_affinity(int type, struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tunsigned int irq = (int)(long)PDE_DATA(file_inode(file));\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!irq_can_set_affinity_usr(irq) || no_irq_affinity)\n\t\treturn -EIO;\n\n\tif (!alloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (type)\n\t\terr = cpumask_parselist_user(buffer, count, new_value);\n\telse\n\t\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (err)\n\t\tgoto free_cpumask;\n\n\tif (!is_affinity_mask_valid(new_value)) {\n\t\terr = -EINVAL;\n\t\tgoto free_cpumask;\n\t}\n\n\t/*\n\t * Do not allow disabling IRQs completely - it's a too easy\n\t * way to make the system unusable accidentally :-) At least\n\t * one online CPU still has to be targeted.\n\t */\n\tif (!cpumask_intersects(new_value, cpu_online_mask)) {\n\t\t/*\n\t\t * Special case for empty set - allow the architecture code\n\t\t * to set default SMP affinity.\n\t\t */\n\t\terr = irq_select_affinity_usr(irq) ? -EINVAL : count;\n\t} else {\n\t\terr = irq_set_affinity(irq, new_value);\n\t\tif (!err)\n\t\t\terr = count;\n\t}\n\nfree_cpumask:\n\tfree_cpumask_var(new_value);\n\treturn err;\n}"
  },
  {
    "function_name": "irq_affinity_list_proc_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "113-116",
    "snippet": "static int irq_affinity_list_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(AFFINITY_LIST, m);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_irq_affinity",
          "args": [
            "AFFINITY_LIST",
            "m"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "show_irq_affinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
          "lines": "46-81",
          "snippet": "static int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int irq_affinity_list_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(AFFINITY_LIST, m);\n}"
  },
  {
    "function_name": "irq_affinity_proc_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "108-111",
    "snippet": "static int irq_affinity_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(AFFINITY, m);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_irq_affinity",
          "args": [
            "AFFINITY",
            "m"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "show_irq_affinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
          "lines": "46-81",
          "snippet": "static int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int irq_affinity_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(AFFINITY, m);\n}"
  },
  {
    "function_name": "irq_affinity_hint_proc_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "83-101",
    "snippet": "static int irq_affinity_hint_proc_show(struct seq_file *m, void *v)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tunsigned long flags;\n\tcpumask_var_t mask;\n\n\tif (!zalloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tif (desc->affinity_hint)\n\t\tcpumask_copy(mask, desc->affinity_hint);\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\tfree_cpumask_var(mask);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "mask"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%*pb\\n\"",
            "cpumask_pr_args(mask)"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "mask"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "mask",
            "desc->affinity_hint"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&mask",
            "GFP_KERNEL"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "(long)m->private"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "561-564",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int irq_affinity_hint_proc_show(struct seq_file *m, void *v)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tunsigned long flags;\n\tcpumask_var_t mask;\n\n\tif (!zalloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tif (desc->affinity_hint)\n\t\tcpumask_copy(mask, desc->affinity_hint);\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\tfree_cpumask_var(mask);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "show_irq_affinity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/proc.c",
    "lines": "46-81",
    "snippet": "static int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%*pb\\n\"",
            "cpumask_pr_args(mask)"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "mask"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "mask"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_effective_affinity_mask",
          "args": [
            "&desc->irq_data"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_is_setaffinity_pending",
          "args": [
            "&desc->irq_data"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "(long)m->private"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "561-564",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  }
]