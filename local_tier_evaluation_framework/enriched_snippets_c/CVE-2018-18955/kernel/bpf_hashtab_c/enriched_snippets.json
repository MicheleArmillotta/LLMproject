[
  {
    "function_name": "htab_of_map_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1453-1457",
    "snippet": "static void htab_of_map_free(struct bpf_map *map)\n{\n\tbpf_map_meta_free(map->inner_map_meta);\n\tfd_htab_map_free(map);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fd_htab_map_free",
          "args": [
            "map"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "fd_htab_map_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "1346-1365",
          "snippet": "static void fd_htab_map_free(struct bpf_map *map)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_node *n;\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tint i;\n\n\tfor (i = 0; i < htab->n_buckets; i++) {\n\t\thead = select_bucket(htab, i);\n\n\t\thlist_nulls_for_each_entry_safe(l, n, head, hash_node) {\n\t\t\tvoid *ptr = fd_htab_map_get_ptr(map, l);\n\n\t\t\tmap->ops->map_fd_put_ptr(ptr);\n\t\t}\n\t}\n\n\thtab_map_free(map);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void fd_htab_map_free(struct bpf_map *map)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_node *n;\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tint i;\n\n\tfor (i = 0; i < htab->n_buckets; i++) {\n\t\thead = select_bucket(htab, i);\n\n\t\thlist_nulls_for_each_entry_safe(l, n, head, hash_node) {\n\t\t\tvoid *ptr = fd_htab_map_get_ptr(map, l);\n\n\t\t\tmap->ops->map_fd_put_ptr(ptr);\n\t\t}\n\t}\n\n\thtab_map_free(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_meta_free",
          "args": [
            "map->inner_map_meta"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_meta_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/map_in_map.c",
          "lines": "56-59",
          "snippet": "void bpf_map_meta_free(struct bpf_map *map_meta)\n{\n\tkfree(map_meta);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/bpf.h>\n#include <linux/slab.h>\n\nvoid bpf_map_meta_free(struct bpf_map *map_meta)\n{\n\tkfree(map_meta);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void htab_of_map_free(struct bpf_map *map)\n{\n\tbpf_map_meta_free(map->inner_map_meta);\n\tfd_htab_map_free(map);\n}"
  },
  {
    "function_name": "htab_of_map_gen_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1435-1451",
    "snippet": "static u32 htab_of_map_gen_lookup(struct bpf_map *map,\n\t\t\t\t  struct bpf_insn *insn_buf)\n{\n\tstruct bpf_insn *insn = insn_buf;\n\tconst int ret = BPF_REG_0;\n\n\tBUILD_BUG_ON(!__same_type(&__htab_map_lookup_elem,\n\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t*insn++ = BPF_EMIT_CALL(BPF_CAST_CALL(__htab_map_lookup_elem));\n\t*insn++ = BPF_JMP_IMM(BPF_JEQ, ret, 0, 2);\n\t*insn++ = BPF_ALU64_IMM(BPF_ADD, ret,\n\t\t\t\toffsetof(struct htab_elem, key) +\n\t\t\t\tround_up(map->key_size, 8));\n\t*insn++ = BPF_LDX_MEM(BPF_DW, ret, ret, 0);\n\n\treturn insn - insn_buf;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BPF_LDX_MEM",
          "args": [
            "BPF_DW",
            "ret",
            "ret",
            "0"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_IMM",
          "args": [
            "BPF_ADD",
            "ret",
            "offsetof(struct htab_elem, key) +\n\t\t\t\tround_up(map->key_size, 8)"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "map->key_size",
            "8"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JMP_IMM",
          "args": [
            "BPF_JEQ",
            "ret",
            "0",
            "2"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_EMIT_CALL",
          "args": [
            "BPF_CAST_CALL(__htab_map_lookup_elem)"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_CAST_CALL",
          "args": [
            "__htab_map_lookup_elem"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "!__same_type(&__htab_map_lookup_elem,\n\t\t     (void *(*)(struct bpf_map *map, void *key))NULL)"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__same_type",
          "args": [
            "&__htab_map_lookup_elem",
            "(void *(*)(struct bpf_map *map, void *key))NULL"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic u32 htab_of_map_gen_lookup(struct bpf_map *map,\n\t\t\t\t  struct bpf_insn *insn_buf)\n{\n\tstruct bpf_insn *insn = insn_buf;\n\tconst int ret = BPF_REG_0;\n\n\tBUILD_BUG_ON(!__same_type(&__htab_map_lookup_elem,\n\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t*insn++ = BPF_EMIT_CALL(BPF_CAST_CALL(__htab_map_lookup_elem));\n\t*insn++ = BPF_JMP_IMM(BPF_JEQ, ret, 0, 2);\n\t*insn++ = BPF_ALU64_IMM(BPF_ADD, ret,\n\t\t\t\toffsetof(struct htab_elem, key) +\n\t\t\t\tround_up(map->key_size, 8));\n\t*insn++ = BPF_LDX_MEM(BPF_DW, ret, ret, 0);\n\n\treturn insn - insn_buf;\n}"
  },
  {
    "function_name": "htab_of_map_lookup_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1425-1433",
    "snippet": "static void *htab_of_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_map **inner_map  = htab_map_lookup_elem(map, key);\n\n\tif (!inner_map)\n\t\treturn NULL;\n\n\treturn READ_ONCE(*inner_map);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*inner_map"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htab_map_lookup_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "htab_map_lookup_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "485-493",
          "snippet": "static void *htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct htab_elem *l = __htab_map_lookup_elem(map, key);\n\n\tif (l)\n\t\treturn l->key + round_up(map->key_size, 8);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct htab_elem *l = __htab_map_lookup_elem(map, key);\n\n\tif (l)\n\t\treturn l->key + round_up(map->key_size, 8);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *htab_of_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_map **inner_map  = htab_map_lookup_elem(map, key);\n\n\tif (!inner_map)\n\t\treturn NULL;\n\n\treturn READ_ONCE(*inner_map);\n}"
  },
  {
    "function_name": "htab_of_map_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1406-1423",
    "snippet": "static struct bpf_map *htab_of_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_map *map, *inner_map_meta;\n\n\tinner_map_meta = bpf_map_meta_alloc(attr->inner_map_fd);\n\tif (IS_ERR(inner_map_meta))\n\t\treturn inner_map_meta;\n\n\tmap = htab_map_alloc(attr);\n\tif (IS_ERR(map)) {\n\t\tbpf_map_meta_free(inner_map_meta);\n\t\treturn map;\n\t}\n\n\tmap->inner_map_meta = inner_map_meta;\n\n\treturn map;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_meta_free",
          "args": [
            "inner_map_meta"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_meta_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/map_in_map.c",
          "lines": "56-59",
          "snippet": "void bpf_map_meta_free(struct bpf_map *map_meta)\n{\n\tkfree(map_meta);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/bpf.h>\n#include <linux/slab.h>\n\nvoid bpf_map_meta_free(struct bpf_map *map_meta)\n{\n\tkfree(map_meta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htab_map_alloc",
          "args": [
            "attr"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "fd_htab_map_alloc_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "1339-1344",
          "snippet": "static int fd_htab_map_alloc_check(union bpf_attr *attr)\n{\n\tif (attr->value_size != sizeof(u32))\n\t\treturn -EINVAL;\n\treturn htab_map_alloc_check(attr);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int fd_htab_map_alloc_check(union bpf_attr *attr)\n{\n\tif (attr->value_size != sizeof(u32))\n\t\treturn -EINVAL;\n\treturn htab_map_alloc_check(attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inner_map_meta"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_meta_alloc",
          "args": [
            "attr->inner_map_fd"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_meta_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/map_in_map.c",
          "lines": "12-54",
          "snippet": "struct bpf_map *bpf_map_meta_alloc(int inner_map_ufd)\n{\n\tstruct bpf_map *inner_map, *inner_map_meta;\n\tstruct fd f;\n\n\tf = fdget(inner_map_ufd);\n\tinner_map = __bpf_map_get(f);\n\tif (IS_ERR(inner_map))\n\t\treturn inner_map;\n\n\t/* prog_array->owner_prog_type and owner_jited\n\t * is a runtime binding.  Doing static check alone\n\t * in the verifier is not enough.\n\t */\n\tif (inner_map->map_type == BPF_MAP_TYPE_PROG_ARRAY ||\n\t    inner_map->map_type == BPF_MAP_TYPE_CGROUP_STORAGE ||\n\t    inner_map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-ENOTSUPP);\n\t}\n\n\t/* Does not support >1 level map-in-map */\n\tif (inner_map->inner_map_meta) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tinner_map_meta = kzalloc(sizeof(*inner_map_meta), GFP_USER);\n\tif (!inner_map_meta) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinner_map_meta->map_type = inner_map->map_type;\n\tinner_map_meta->key_size = inner_map->key_size;\n\tinner_map_meta->value_size = inner_map->value_size;\n\tinner_map_meta->map_flags = inner_map->map_flags;\n\tinner_map_meta->ops = inner_map->ops;\n\tinner_map_meta->max_entries = inner_map->max_entries;\n\n\tfdput(f);\n\treturn inner_map_meta;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/bpf.h>\n#include <linux/slab.h>\n\nstruct bpf_map *bpf_map_meta_alloc(int inner_map_ufd)\n{\n\tstruct bpf_map *inner_map, *inner_map_meta;\n\tstruct fd f;\n\n\tf = fdget(inner_map_ufd);\n\tinner_map = __bpf_map_get(f);\n\tif (IS_ERR(inner_map))\n\t\treturn inner_map;\n\n\t/* prog_array->owner_prog_type and owner_jited\n\t * is a runtime binding.  Doing static check alone\n\t * in the verifier is not enough.\n\t */\n\tif (inner_map->map_type == BPF_MAP_TYPE_PROG_ARRAY ||\n\t    inner_map->map_type == BPF_MAP_TYPE_CGROUP_STORAGE ||\n\t    inner_map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-ENOTSUPP);\n\t}\n\n\t/* Does not support >1 level map-in-map */\n\tif (inner_map->inner_map_meta) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tinner_map_meta = kzalloc(sizeof(*inner_map_meta), GFP_USER);\n\tif (!inner_map_meta) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinner_map_meta->map_type = inner_map->map_type;\n\tinner_map_meta->key_size = inner_map->key_size;\n\tinner_map_meta->value_size = inner_map->value_size;\n\tinner_map_meta->map_flags = inner_map->map_flags;\n\tinner_map_meta->ops = inner_map->ops;\n\tinner_map_meta->max_entries = inner_map->max_entries;\n\n\tfdput(f);\n\treturn inner_map_meta;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_map *htab_of_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_map *map, *inner_map_meta;\n\n\tinner_map_meta = bpf_map_meta_alloc(attr->inner_map_fd);\n\tif (IS_ERR(inner_map_meta))\n\t\treturn inner_map_meta;\n\n\tmap = htab_map_alloc(attr);\n\tif (IS_ERR(map)) {\n\t\tbpf_map_meta_free(inner_map_meta);\n\t\treturn map;\n\t}\n\n\tmap->inner_map_meta = inner_map_meta;\n\n\treturn map;\n}"
  },
  {
    "function_name": "bpf_fd_htab_map_update_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1388-1404",
    "snippet": "int bpf_fd_htab_map_update_elem(struct bpf_map *map, struct file *map_file,\n\t\t\t\tvoid *key, void *value, u64 map_flags)\n{\n\tvoid *ptr;\n\tint ret;\n\tu32 ufd = *(u32 *)value;\n\n\tptr = map->ops->map_fd_get_ptr(map, map_file, ufd);\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\n\tret = htab_map_update_elem(map, key, &ptr, map_flags);\n\tif (ret)\n\t\tmap->ops->map_fd_put_ptr(ptr);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->ops->map_fd_put_ptr",
          "args": [
            "ptr"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htab_map_update_elem",
          "args": [
            "map",
            "key",
            "&ptr",
            "map_flags"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "htab_map_update_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "811-865",
          "snippet": "static int htab_map_update_elem(struct bpf_map *map, void *key, void *value,\n\t\t\t\tu64 map_flags)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l_new = NULL, *l_old;\n\tstruct hlist_nulls_head *head;\n\tunsigned long flags;\n\tstruct bucket *b;\n\tu32 key_size, hash;\n\tint ret;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\t/* bpf_map_update_elem() can be called in_irq() */\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl_old = lookup_elem_raw(head, hash, key, key_size);\n\n\tret = check_flags(htab, l_old, map_flags);\n\tif (ret)\n\t\tgoto err;\n\n\tl_new = alloc_htab_elem(htab, key, value, key_size, hash, false, false,\n\t\t\t\tl_old);\n\tif (IS_ERR(l_new)) {\n\t\t/* all pre-allocated elements are in use or memory exhausted */\n\t\tret = PTR_ERR(l_new);\n\t\tgoto err;\n\t}\n\n\t/* add new element to the head of the list, so that\n\t * concurrent search will find it before old elem\n\t */\n\thlist_nulls_add_head_rcu(&l_new->hash_node, head);\n\tif (l_old) {\n\t\thlist_nulls_del_rcu(&l_old->hash_node);\n\t\tif (!htab_is_prealloc(htab))\n\t\t\tfree_htab_elem(htab, l_old);\n\t}\n\tret = 0;\nerr:\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int htab_map_update_elem(struct bpf_map *map, void *key, void *value,\n\t\t\t\tu64 map_flags)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l_new = NULL, *l_old;\n\tstruct hlist_nulls_head *head;\n\tunsigned long flags;\n\tstruct bucket *b;\n\tu32 key_size, hash;\n\tint ret;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\t/* bpf_map_update_elem() can be called in_irq() */\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl_old = lookup_elem_raw(head, hash, key, key_size);\n\n\tret = check_flags(htab, l_old, map_flags);\n\tif (ret)\n\t\tgoto err;\n\n\tl_new = alloc_htab_elem(htab, key, value, key_size, hash, false, false,\n\t\t\t\tl_old);\n\tif (IS_ERR(l_new)) {\n\t\t/* all pre-allocated elements are in use or memory exhausted */\n\t\tret = PTR_ERR(l_new);\n\t\tgoto err;\n\t}\n\n\t/* add new element to the head of the list, so that\n\t * concurrent search will find it before old elem\n\t */\n\thlist_nulls_add_head_rcu(&l_new->hash_node, head);\n\tif (l_old) {\n\t\thlist_nulls_del_rcu(&l_old->hash_node);\n\t\tif (!htab_is_prealloc(htab))\n\t\t\tfree_htab_elem(htab, l_old);\n\t}\n\tret = 0;\nerr:\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ptr"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ptr"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map->ops->map_fd_get_ptr",
          "args": [
            "map",
            "map_file",
            "ufd"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_fd_htab_map_update_elem(struct bpf_map *map, struct file *map_file,\n\t\t\t\tvoid *key, void *value, u64 map_flags)\n{\n\tvoid *ptr;\n\tint ret;\n\tu32 ufd = *(u32 *)value;\n\n\tptr = map->ops->map_fd_get_ptr(map, map_file, ufd);\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\n\tret = htab_map_update_elem(map, key, &ptr, map_flags);\n\tif (ret)\n\t\tmap->ops->map_fd_put_ptr(ptr);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "bpf_fd_htab_map_lookup_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1368-1385",
    "snippet": "int bpf_fd_htab_map_lookup_elem(struct bpf_map *map, void *key, u32 *value)\n{\n\tvoid **ptr;\n\tint ret = 0;\n\n\tif (!map->ops->map_fd_sys_lookup_elem)\n\t\treturn -ENOTSUPP;\n\n\trcu_read_lock();\n\tptr = htab_map_lookup_elem(map, key);\n\tif (ptr)\n\t\t*value = map->ops->map_fd_sys_lookup_elem(READ_ONCE(*ptr));\n\telse\n\t\tret = -ENOENT;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_fd_sys_lookup_elem",
          "args": [
            "READ_ONCE(*ptr)"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*ptr"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htab_map_lookup_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "htab_map_lookup_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "485-493",
          "snippet": "static void *htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct htab_elem *l = __htab_map_lookup_elem(map, key);\n\n\tif (l)\n\t\treturn l->key + round_up(map->key_size, 8);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct htab_elem *l = __htab_map_lookup_elem(map, key);\n\n\tif (l)\n\t\treturn l->key + round_up(map->key_size, 8);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_fd_htab_map_lookup_elem(struct bpf_map *map, void *key, u32 *value)\n{\n\tvoid **ptr;\n\tint ret = 0;\n\n\tif (!map->ops->map_fd_sys_lookup_elem)\n\t\treturn -ENOTSUPP;\n\n\trcu_read_lock();\n\tptr = htab_map_lookup_elem(map, key);\n\tif (ptr)\n\t\t*value = map->ops->map_fd_sys_lookup_elem(READ_ONCE(*ptr));\n\telse\n\t\tret = -ENOENT;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fd_htab_map_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1346-1365",
    "snippet": "static void fd_htab_map_free(struct bpf_map *map)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_node *n;\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tint i;\n\n\tfor (i = 0; i < htab->n_buckets; i++) {\n\t\thead = select_bucket(htab, i);\n\n\t\thlist_nulls_for_each_entry_safe(l, n, head, hash_node) {\n\t\t\tvoid *ptr = fd_htab_map_get_ptr(map, l);\n\n\t\t\tmap->ops->map_fd_put_ptr(ptr);\n\t\t}\n\t}\n\n\thtab_map_free(map);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htab_map_free",
          "args": [
            "map"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "fd_htab_map_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "1346-1365",
          "snippet": "static void fd_htab_map_free(struct bpf_map *map)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_node *n;\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tint i;\n\n\tfor (i = 0; i < htab->n_buckets; i++) {\n\t\thead = select_bucket(htab, i);\n\n\t\thlist_nulls_for_each_entry_safe(l, n, head, hash_node) {\n\t\t\tvoid *ptr = fd_htab_map_get_ptr(map, l);\n\n\t\t\tmap->ops->map_fd_put_ptr(ptr);\n\t\t}\n\t}\n\n\thtab_map_free(map);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_fd_put_ptr",
          "args": [
            "ptr"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd_htab_map_get_ptr",
          "args": [
            "map",
            "l"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "fd_htab_map_get_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "98-101",
          "snippet": "static void *fd_htab_map_get_ptr(const struct bpf_map *map, struct htab_elem *l)\n{\n\treturn *(void **)(l->key + roundup(map->key_size, 8));\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *fd_htab_map_get_ptr(const struct bpf_map *map, struct htab_elem *l)\n{\n\treturn *(void **)(l->key + roundup(map->key_size, 8));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_nulls_for_each_entry_safe",
          "args": [
            "l",
            "n",
            "head",
            "hash_node"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select_bucket",
          "args": [
            "htab",
            "i"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "select_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "418-421",
          "snippet": "static inline struct hlist_nulls_head *select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &__select_bucket(htab, hash)->head;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline struct hlist_nulls_head *select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &__select_bucket(htab, hash)->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_htab",
            "map"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void fd_htab_map_free(struct bpf_map *map)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_node *n;\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tint i;\n\n\tfor (i = 0; i < htab->n_buckets; i++) {\n\t\thead = select_bucket(htab, i);\n\n\t\thlist_nulls_for_each_entry_safe(l, n, head, hash_node) {\n\t\t\tvoid *ptr = fd_htab_map_get_ptr(map, l);\n\n\t\t\tmap->ops->map_fd_put_ptr(ptr);\n\t\t}\n\t}\n\n\thtab_map_free(map);\n}"
  },
  {
    "function_name": "fd_htab_map_alloc_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1339-1344",
    "snippet": "static int fd_htab_map_alloc_check(union bpf_attr *attr)\n{\n\tif (attr->value_size != sizeof(u32))\n\t\treturn -EINVAL;\n\treturn htab_map_alloc_check(attr);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htab_map_alloc_check",
          "args": [
            "attr"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "fd_htab_map_alloc_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "1339-1344",
          "snippet": "static int fd_htab_map_alloc_check(union bpf_attr *attr)\n{\n\tif (attr->value_size != sizeof(u32))\n\t\treturn -EINVAL;\n\treturn htab_map_alloc_check(attr);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int fd_htab_map_alloc_check(union bpf_attr *attr)\n{\n\tif (attr->value_size != sizeof(u32))\n\t\treturn -EINVAL;\n\treturn htab_map_alloc_check(attr);\n}"
  },
  {
    "function_name": "htab_percpu_map_seq_show_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1288-1315",
    "snippet": "static void htab_percpu_map_seq_show_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t  struct seq_file *m)\n{\n\tstruct htab_elem *l;\n\tvoid __percpu *pptr;\n\tint cpu;\n\n\trcu_read_lock();\n\n\tl = __htab_map_lookup_elem(map, key);\n\tif (!l) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tbtf_type_seq_show(map->btf, map->btf_key_type_id, key, m);\n\tseq_puts(m, \": {\\n\");\n\tpptr = htab_elem_get_ptr(l, map->key_size);\n\tfor_each_possible_cpu(cpu) {\n\t\tseq_printf(m, \"\\tcpu%d: \", cpu);\n\t\tbtf_type_seq_show(map->btf, map->btf_value_type_id,\n\t\t\t\t  per_cpu_ptr(pptr, cpu), m);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\tseq_puts(m, \"}\\n\");\n\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"}\\n\""
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_seq_show",
          "args": [
            "map->btf",
            "map->btf_value_type_id",
            "per_cpu_ptr(pptr, cpu)",
            "m"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_seq_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "2224-2230",
          "snippet": "void btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, type_id);\n\n\tbtf_type_ops(t)->seq_show(btf, t, type_id, obj, 0, m);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, type_id);\n\n\tbtf_type_ops(t)->seq_show(btf, t, type_id, obj, 0, m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pptr",
            "cpu"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\tcpu%d: \"",
            "cpu"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_elem_get_ptr",
          "args": [
            "l",
            "map->key_size"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "htab_elem_get_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "93-96",
          "snippet": "static inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__htab_map_lookup_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "__htab_map_lookup_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "464-483",
          "snippet": "static void *__htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tu32 hash, key_size;\n\n\t/* Must be called with rcu_read_lock. */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\thead = select_bucket(htab, hash);\n\n\tl = lookup_nulls_elem_raw(head, hash, key, key_size, htab->n_buckets);\n\n\treturn l;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *__htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tu32 hash, key_size;\n\n\t/* Must be called with rcu_read_lock. */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\thead = select_bucket(htab, hash);\n\n\tl = lookup_nulls_elem_raw(head, hash, key, key_size, htab->n_buckets);\n\n\treturn l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void htab_percpu_map_seq_show_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t  struct seq_file *m)\n{\n\tstruct htab_elem *l;\n\tvoid __percpu *pptr;\n\tint cpu;\n\n\trcu_read_lock();\n\n\tl = __htab_map_lookup_elem(map, key);\n\tif (!l) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tbtf_type_seq_show(map->btf, map->btf_key_type_id, key, m);\n\tseq_puts(m, \": {\\n\");\n\tpptr = htab_elem_get_ptr(l, map->key_size);\n\tfor_each_possible_cpu(cpu) {\n\t\tseq_printf(m, \"\\tcpu%d: \", cpu);\n\t\tbtf_type_seq_show(map->btf, map->btf_value_type_id,\n\t\t\t\t  per_cpu_ptr(pptr, cpu), m);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\tseq_puts(m, \"}\\n\");\n\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "bpf_percpu_hash_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1270-1286",
    "snippet": "int bpf_percpu_hash_update(struct bpf_map *map, void *key, void *value,\n\t\t\t   u64 map_flags)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tint ret;\n\n\trcu_read_lock();\n\tif (htab_is_lru(htab))\n\t\tret = __htab_lru_percpu_map_update_elem(map, key, value,\n\t\t\t\t\t\t\tmap_flags, true);\n\telse\n\t\tret = __htab_percpu_map_update_elem(map, key, value, map_flags,\n\t\t\t\t\t\t    true);\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "__htab_percpu_map_update_elem",
          "args": [
            "map",
            "key",
            "value",
            "map_flags",
            "true"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "__htab_percpu_map_update_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "931-982",
          "snippet": "static int __htab_percpu_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t void *value, u64 map_flags,\n\t\t\t\t\t bool onallcpus)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l_new = NULL, *l_old;\n\tstruct hlist_nulls_head *head;\n\tunsigned long flags;\n\tstruct bucket *b;\n\tu32 key_size, hash;\n\tint ret;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\t/* bpf_map_update_elem() can be called in_irq() */\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl_old = lookup_elem_raw(head, hash, key, key_size);\n\n\tret = check_flags(htab, l_old, map_flags);\n\tif (ret)\n\t\tgoto err;\n\n\tif (l_old) {\n\t\t/* per-cpu hash map can update value in-place */\n\t\tpcpu_copy_value(htab, htab_elem_get_ptr(l_old, key_size),\n\t\t\t\tvalue, onallcpus);\n\t} else {\n\t\tl_new = alloc_htab_elem(htab, key, value, key_size,\n\t\t\t\t\thash, true, onallcpus, NULL);\n\t\tif (IS_ERR(l_new)) {\n\t\t\tret = PTR_ERR(l_new);\n\t\t\tgoto err;\n\t\t}\n\t\thlist_nulls_add_head_rcu(&l_new->hash_node, head);\n\t}\n\tret = 0;\nerr:\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int __htab_percpu_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t void *value, u64 map_flags,\n\t\t\t\t\t bool onallcpus)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l_new = NULL, *l_old;\n\tstruct hlist_nulls_head *head;\n\tunsigned long flags;\n\tstruct bucket *b;\n\tu32 key_size, hash;\n\tint ret;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\t/* bpf_map_update_elem() can be called in_irq() */\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl_old = lookup_elem_raw(head, hash, key, key_size);\n\n\tret = check_flags(htab, l_old, map_flags);\n\tif (ret)\n\t\tgoto err;\n\n\tif (l_old) {\n\t\t/* per-cpu hash map can update value in-place */\n\t\tpcpu_copy_value(htab, htab_elem_get_ptr(l_old, key_size),\n\t\t\t\tvalue, onallcpus);\n\t} else {\n\t\tl_new = alloc_htab_elem(htab, key, value, key_size,\n\t\t\t\t\thash, true, onallcpus, NULL);\n\t\tif (IS_ERR(l_new)) {\n\t\t\tret = PTR_ERR(l_new);\n\t\t\tgoto err;\n\t\t}\n\t\thlist_nulls_add_head_rcu(&l_new->hash_node, head);\n\t}\n\tret = 0;\nerr:\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__htab_lru_percpu_map_update_elem",
          "args": [
            "map",
            "key",
            "value",
            "map_flags",
            "true"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "__htab_lru_percpu_map_update_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "984-1047",
          "snippet": "static int __htab_lru_percpu_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t     void *value, u64 map_flags,\n\t\t\t\t\t     bool onallcpus)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l_new = NULL, *l_old;\n\tstruct hlist_nulls_head *head;\n\tunsigned long flags;\n\tstruct bucket *b;\n\tu32 key_size, hash;\n\tint ret;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\t/* For LRU, we need to alloc before taking bucket's\n\t * spinlock because LRU's elem alloc may need\n\t * to remove older elem from htab and this removal\n\t * operation will need a bucket lock.\n\t */\n\tif (map_flags != BPF_EXIST) {\n\t\tl_new = prealloc_lru_pop(htab, key, hash);\n\t\tif (!l_new)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* bpf_map_update_elem() can be called in_irq() */\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl_old = lookup_elem_raw(head, hash, key, key_size);\n\n\tret = check_flags(htab, l_old, map_flags);\n\tif (ret)\n\t\tgoto err;\n\n\tif (l_old) {\n\t\tbpf_lru_node_set_ref(&l_old->lru_node);\n\n\t\t/* per-cpu hash map can update value in-place */\n\t\tpcpu_copy_value(htab, htab_elem_get_ptr(l_old, key_size),\n\t\t\t\tvalue, onallcpus);\n\t} else {\n\t\tpcpu_copy_value(htab, htab_elem_get_ptr(l_new, key_size),\n\t\t\t\tvalue, onallcpus);\n\t\thlist_nulls_add_head_rcu(&l_new->hash_node, head);\n\t\tl_new = NULL;\n\t}\n\tret = 0;\nerr:\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\tif (l_new)\n\t\tbpf_lru_push_free(&htab->lru, &l_new->lru_node);\n\treturn ret;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int __htab_lru_percpu_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t     void *value, u64 map_flags,\n\t\t\t\t\t     bool onallcpus)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l_new = NULL, *l_old;\n\tstruct hlist_nulls_head *head;\n\tunsigned long flags;\n\tstruct bucket *b;\n\tu32 key_size, hash;\n\tint ret;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\t/* For LRU, we need to alloc before taking bucket's\n\t * spinlock because LRU's elem alloc may need\n\t * to remove older elem from htab and this removal\n\t * operation will need a bucket lock.\n\t */\n\tif (map_flags != BPF_EXIST) {\n\t\tl_new = prealloc_lru_pop(htab, key, hash);\n\t\tif (!l_new)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* bpf_map_update_elem() can be called in_irq() */\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl_old = lookup_elem_raw(head, hash, key, key_size);\n\n\tret = check_flags(htab, l_old, map_flags);\n\tif (ret)\n\t\tgoto err;\n\n\tif (l_old) {\n\t\tbpf_lru_node_set_ref(&l_old->lru_node);\n\n\t\t/* per-cpu hash map can update value in-place */\n\t\tpcpu_copy_value(htab, htab_elem_get_ptr(l_old, key_size),\n\t\t\t\tvalue, onallcpus);\n\t} else {\n\t\tpcpu_copy_value(htab, htab_elem_get_ptr(l_new, key_size),\n\t\t\t\tvalue, onallcpus);\n\t\thlist_nulls_add_head_rcu(&l_new->hash_node, head);\n\t\tl_new = NULL;\n\t}\n\tret = 0;\nerr:\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\tif (l_new)\n\t\tbpf_lru_push_free(&htab->lru, &l_new->lru_node);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_is_lru",
          "args": [
            "htab"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "htab_is_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "70-74",
          "snippet": "static bool htab_is_lru(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t\thtab->map.map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool htab_is_lru(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t\thtab->map.map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_htab",
            "map"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_percpu_hash_update(struct bpf_map *map, void *key, void *value,\n\t\t\t   u64 map_flags)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tint ret;\n\n\trcu_read_lock();\n\tif (htab_is_lru(htab))\n\t\tret = __htab_lru_percpu_map_update_elem(map, key, value,\n\t\t\t\t\t\t\tmap_flags, true);\n\telse\n\t\tret = __htab_percpu_map_update_elem(map, key, value, map_flags,\n\t\t\t\t\t\t    true);\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "bpf_percpu_hash_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1238-1268",
    "snippet": "int bpf_percpu_hash_copy(struct bpf_map *map, void *key, void *value)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l;\n\tvoid __percpu *pptr;\n\tint ret = -ENOENT;\n\tint cpu, off = 0;\n\tu32 size;\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(map->value_size, 8);\n\trcu_read_lock();\n\tl = __htab_map_lookup_elem(map, key);\n\tif (!l)\n\t\tgoto out;\n\tif (htab_is_lru(htab))\n\t\tbpf_lru_node_set_ref(&l->lru_node);\n\tpptr = htab_elem_get_ptr(l, map->key_size);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off,\n\t\t\t\tper_cpu_ptr(pptr, cpu), size);\n\t\toff += size;\n\t}\n\tret = 0;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_long_memcpy",
          "args": [
            "value + off",
            "per_cpu_ptr(pptr, cpu)",
            "size"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pptr",
            "cpu"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htab_elem_get_ptr",
          "args": [
            "l",
            "map->key_size"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "htab_elem_get_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "93-96",
          "snippet": "static inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_node_set_ref",
          "args": [
            "&l->lru_node"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_node_set_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.h",
          "lines": "67-74",
          "snippet": "static inline void bpf_lru_node_set_ref(struct bpf_lru_node *node)\n{\n\t/* ref is an approximation on access frequency.  It does not\n\t * have to be very accurate.  Hence, no protection is used.\n\t */\n\tif (!node->ref)\n\t\tnode->ref = 1;\n}",
          "includes": [
            "#include <linux/spinlock_types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock_types.h>\n#include <linux/list.h>\n\nstatic inline void bpf_lru_node_set_ref(struct bpf_lru_node *node)\n{\n\t/* ref is an approximation on access frequency.  It does not\n\t * have to be very accurate.  Hence, no protection is used.\n\t */\n\tif (!node->ref)\n\t\tnode->ref = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_is_lru",
          "args": [
            "htab"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "htab_is_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "70-74",
          "snippet": "static bool htab_is_lru(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t\thtab->map.map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool htab_is_lru(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t\thtab->map.map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__htab_map_lookup_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "__htab_map_lookup_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "464-483",
          "snippet": "static void *__htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tu32 hash, key_size;\n\n\t/* Must be called with rcu_read_lock. */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\thead = select_bucket(htab, hash);\n\n\tl = lookup_nulls_elem_raw(head, hash, key, key_size, htab->n_buckets);\n\n\treturn l;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *__htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tu32 hash, key_size;\n\n\t/* Must be called with rcu_read_lock. */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\thead = select_bucket(htab, hash);\n\n\tl = lookup_nulls_elem_raw(head, hash, key, key_size, htab->n_buckets);\n\n\treturn l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "map->value_size",
            "8"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_htab",
            "map"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_percpu_hash_copy(struct bpf_map *map, void *key, void *value)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l;\n\tvoid __percpu *pptr;\n\tint ret = -ENOENT;\n\tint cpu, off = 0;\n\tu32 size;\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(map->value_size, 8);\n\trcu_read_lock();\n\tl = __htab_map_lookup_elem(map, key);\n\tif (!l)\n\t\tgoto out;\n\tif (htab_is_lru(htab))\n\t\tbpf_lru_node_set_ref(&l->lru_node);\n\tpptr = htab_elem_get_ptr(l, map->key_size);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off,\n\t\t\t\tper_cpu_ptr(pptr, cpu), size);\n\t\toff += size;\n\t}\n\tret = 0;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "htab_lru_percpu_map_lookup_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1226-1236",
    "snippet": "static void *htab_lru_percpu_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct htab_elem *l = __htab_map_lookup_elem(map, key);\n\n\tif (l) {\n\t\tbpf_lru_node_set_ref(&l->lru_node);\n\t\treturn this_cpu_ptr(htab_elem_get_ptr(l, map->key_size));\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "htab_elem_get_ptr(l, map->key_size)"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htab_elem_get_ptr",
          "args": [
            "l",
            "map->key_size"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "htab_elem_get_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "93-96",
          "snippet": "static inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_node_set_ref",
          "args": [
            "&l->lru_node"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_node_set_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.h",
          "lines": "67-74",
          "snippet": "static inline void bpf_lru_node_set_ref(struct bpf_lru_node *node)\n{\n\t/* ref is an approximation on access frequency.  It does not\n\t * have to be very accurate.  Hence, no protection is used.\n\t */\n\tif (!node->ref)\n\t\tnode->ref = 1;\n}",
          "includes": [
            "#include <linux/spinlock_types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock_types.h>\n#include <linux/list.h>\n\nstatic inline void bpf_lru_node_set_ref(struct bpf_lru_node *node)\n{\n\t/* ref is an approximation on access frequency.  It does not\n\t * have to be very accurate.  Hence, no protection is used.\n\t */\n\tif (!node->ref)\n\t\tnode->ref = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__htab_map_lookup_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "__htab_map_lookup_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "464-483",
          "snippet": "static void *__htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tu32 hash, key_size;\n\n\t/* Must be called with rcu_read_lock. */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\thead = select_bucket(htab, hash);\n\n\tl = lookup_nulls_elem_raw(head, hash, key, key_size, htab->n_buckets);\n\n\treturn l;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *__htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tu32 hash, key_size;\n\n\t/* Must be called with rcu_read_lock. */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\thead = select_bucket(htab, hash);\n\n\tl = lookup_nulls_elem_raw(head, hash, key, key_size, htab->n_buckets);\n\n\treturn l;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *htab_lru_percpu_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct htab_elem *l = __htab_map_lookup_elem(map, key);\n\n\tif (l) {\n\t\tbpf_lru_node_set_ref(&l->lru_node);\n\t\treturn this_cpu_ptr(htab_elem_get_ptr(l, map->key_size));\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "htab_percpu_map_lookup_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1216-1224",
    "snippet": "static void *htab_percpu_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct htab_elem *l = __htab_map_lookup_elem(map, key);\n\n\tif (l)\n\t\treturn this_cpu_ptr(htab_elem_get_ptr(l, map->key_size));\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "htab_elem_get_ptr(l, map->key_size)"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htab_elem_get_ptr",
          "args": [
            "l",
            "map->key_size"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "htab_elem_get_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "93-96",
          "snippet": "static inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__htab_map_lookup_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "__htab_map_lookup_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "464-483",
          "snippet": "static void *__htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tu32 hash, key_size;\n\n\t/* Must be called with rcu_read_lock. */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\thead = select_bucket(htab, hash);\n\n\tl = lookup_nulls_elem_raw(head, hash, key, key_size, htab->n_buckets);\n\n\treturn l;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *__htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tu32 hash, key_size;\n\n\t/* Must be called with rcu_read_lock. */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\thead = select_bucket(htab, hash);\n\n\tl = lookup_nulls_elem_raw(head, hash, key, key_size, htab->n_buckets);\n\n\treturn l;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *htab_percpu_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct htab_elem *l = __htab_map_lookup_elem(map, key);\n\n\tif (l)\n\t\treturn this_cpu_ptr(htab_elem_get_ptr(l, map->key_size));\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "htab_map_seq_show_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1170-1189",
    "snippet": "static void htab_map_seq_show_elem(struct bpf_map *map, void *key,\n\t\t\t\t   struct seq_file *m)\n{\n\tvoid *value;\n\n\trcu_read_lock();\n\n\tvalue = htab_map_lookup_elem(map, key);\n\tif (!value) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tbtf_type_seq_show(map->btf, map->btf_key_type_id, key, m);\n\tseq_puts(m, \": \");\n\tbtf_type_seq_show(map->btf, map->btf_value_type_id, value, m);\n\tseq_puts(m, \"\\n\");\n\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_seq_show",
          "args": [
            "map->btf",
            "map->btf_value_type_id",
            "value",
            "m"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_seq_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "2224-2230",
          "snippet": "void btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, type_id);\n\n\tbtf_type_ops(t)->seq_show(btf, t, type_id, obj, 0, m);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, type_id);\n\n\tbtf_type_ops(t)->seq_show(btf, t, type_id, obj, 0, m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_map_lookup_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "htab_map_lookup_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "485-493",
          "snippet": "static void *htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct htab_elem *l = __htab_map_lookup_elem(map, key);\n\n\tif (l)\n\t\treturn l->key + round_up(map->key_size, 8);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct htab_elem *l = __htab_map_lookup_elem(map, key);\n\n\tif (l)\n\t\treturn l->key + round_up(map->key_size, 8);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void htab_map_seq_show_elem(struct bpf_map *map, void *key,\n\t\t\t\t   struct seq_file *m)\n{\n\tvoid *value;\n\n\trcu_read_lock();\n\n\tvalue = htab_map_lookup_elem(map, key);\n\tif (!value) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tbtf_type_seq_show(map->btf, map->btf_key_type_id, key, m);\n\tseq_puts(m, \": \");\n\tbtf_type_seq_show(map->btf, map->btf_value_type_id, value, m);\n\tseq_puts(m, \"\\n\");\n\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "htab_map_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1145-1168",
    "snippet": "static void htab_map_free(struct bpf_map *map)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\n\t/* at this point bpf_prog->aux->refcnt == 0 and this map->refcnt == 0,\n\t * so the programs (can be more than one that used this map) were\n\t * disconnected from events. Wait for outstanding critical sections in\n\t * these programs to complete\n\t */\n\tsynchronize_rcu();\n\n\t/* some of free_htab_elem() callbacks for elements of this map may\n\t * not have executed. Wait for them.\n\t */\n\trcu_barrier();\n\tif (!htab_is_prealloc(htab))\n\t\tdelete_all_elements(htab);\n\telse\n\t\tprealloc_destroy(htab);\n\n\tfree_percpu(htab->extra_elems);\n\tbpf_map_area_free(htab->buckets);\n\tkfree(htab);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "htab"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_area_free",
          "args": [
            "htab->buckets"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "156-159",
          "snippet": "void bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "htab->extra_elems"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prealloc_destroy",
          "args": [
            "htab"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "prealloc_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "200-208",
          "snippet": "static void prealloc_destroy(struct bpf_htab *htab)\n{\n\thtab_free_elems(htab);\n\n\tif (htab_is_lru(htab))\n\t\tbpf_lru_destroy(&htab->lru);\n\telse\n\t\tpcpu_freelist_destroy(&htab->freelist);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void prealloc_destroy(struct bpf_htab *htab)\n{\n\thtab_free_elems(htab);\n\n\tif (htab_is_lru(htab))\n\t\tbpf_lru_destroy(&htab->lru);\n\telse\n\t\tpcpu_freelist_destroy(&htab->freelist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delete_all_elements",
          "args": [
            "htab"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "delete_all_elements",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "1128-1142",
          "snippet": "static void delete_all_elements(struct bpf_htab *htab)\n{\n\tint i;\n\n\tfor (i = 0; i < htab->n_buckets; i++) {\n\t\tstruct hlist_nulls_head *head = select_bucket(htab, i);\n\t\tstruct hlist_nulls_node *n;\n\t\tstruct htab_elem *l;\n\n\t\thlist_nulls_for_each_entry_safe(l, n, head, hash_node) {\n\t\t\thlist_nulls_del_rcu(&l->hash_node);\n\t\t\thtab_elem_free(htab, l);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void delete_all_elements(struct bpf_htab *htab)\n{\n\tint i;\n\n\tfor (i = 0; i < htab->n_buckets; i++) {\n\t\tstruct hlist_nulls_head *head = select_bucket(htab, i);\n\t\tstruct hlist_nulls_node *n;\n\t\tstruct htab_elem *l;\n\n\t\thlist_nulls_for_each_entry_safe(l, n, head, hash_node) {\n\t\t\thlist_nulls_del_rcu(&l->hash_node);\n\t\t\thtab_elem_free(htab, l);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_is_prealloc",
          "args": [
            "htab"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "htab_is_prealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "82-85",
          "snippet": "static bool htab_is_prealloc(const struct bpf_htab *htab)\n{\n\treturn !(htab->map.map_flags & BPF_F_NO_PREALLOC);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool htab_is_prealloc(const struct bpf_htab *htab)\n{\n\treturn !(htab->map.map_flags & BPF_F_NO_PREALLOC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "620-624",
          "snippet": "void rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "603-611",
          "snippet": "void synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_htab",
            "map"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void htab_map_free(struct bpf_map *map)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\n\t/* at this point bpf_prog->aux->refcnt == 0 and this map->refcnt == 0,\n\t * so the programs (can be more than one that used this map) were\n\t * disconnected from events. Wait for outstanding critical sections in\n\t * these programs to complete\n\t */\n\tsynchronize_rcu();\n\n\t/* some of free_htab_elem() callbacks for elements of this map may\n\t * not have executed. Wait for them.\n\t */\n\trcu_barrier();\n\tif (!htab_is_prealloc(htab))\n\t\tdelete_all_elements(htab);\n\telse\n\t\tprealloc_destroy(htab);\n\n\tfree_percpu(htab->extra_elems);\n\tbpf_map_area_free(htab->buckets);\n\tkfree(htab);\n}"
  },
  {
    "function_name": "delete_all_elements",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1128-1142",
    "snippet": "static void delete_all_elements(struct bpf_htab *htab)\n{\n\tint i;\n\n\tfor (i = 0; i < htab->n_buckets; i++) {\n\t\tstruct hlist_nulls_head *head = select_bucket(htab, i);\n\t\tstruct hlist_nulls_node *n;\n\t\tstruct htab_elem *l;\n\n\t\thlist_nulls_for_each_entry_safe(l, n, head, hash_node) {\n\t\t\thlist_nulls_del_rcu(&l->hash_node);\n\t\t\thtab_elem_free(htab, l);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htab_elem_free",
          "args": [
            "htab",
            "l"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "htab_elem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "646-651",
          "snippet": "static void htab_elem_free(struct bpf_htab *htab, struct htab_elem *l)\n{\n\tif (htab->map.map_type == BPF_MAP_TYPE_PERCPU_HASH)\n\t\tfree_percpu(htab_elem_get_ptr(l, htab->map.key_size));\n\tkfree(l);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void htab_elem_free(struct bpf_htab *htab, struct htab_elem *l)\n{\n\tif (htab->map.map_type == BPF_MAP_TYPE_PERCPU_HASH)\n\t\tfree_percpu(htab_elem_get_ptr(l, htab->map.key_size));\n\tkfree(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_nulls_del_rcu",
          "args": [
            "&l->hash_node"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_nulls_for_each_entry_safe",
          "args": [
            "l",
            "n",
            "head",
            "hash_node"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select_bucket",
          "args": [
            "htab",
            "i"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "select_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "418-421",
          "snippet": "static inline struct hlist_nulls_head *select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &__select_bucket(htab, hash)->head;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline struct hlist_nulls_head *select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &__select_bucket(htab, hash)->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void delete_all_elements(struct bpf_htab *htab)\n{\n\tint i;\n\n\tfor (i = 0; i < htab->n_buckets; i++) {\n\t\tstruct hlist_nulls_head *head = select_bucket(htab, i);\n\t\tstruct hlist_nulls_node *n;\n\t\tstruct htab_elem *l;\n\n\t\thlist_nulls_for_each_entry_safe(l, n, head, hash_node) {\n\t\t\thlist_nulls_del_rcu(&l->hash_node);\n\t\t\thtab_elem_free(htab, l);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "htab_lru_map_delete_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1095-1126",
    "snippet": "static int htab_lru_map_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct bucket *b;\n\tstruct htab_elem *l;\n\tunsigned long flags;\n\tu32 hash, key_size;\n\tint ret = -ENOENT;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl = lookup_elem_raw(head, hash, key, key_size);\n\n\tif (l) {\n\t\thlist_nulls_del_rcu(&l->hash_node);\n\t\tret = 0;\n\t}\n\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\tif (l)\n\t\tbpf_lru_push_free(&htab->lru, &l->lru_node);\n\treturn ret;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_lru_push_free",
          "args": [
            "&htab->lru",
            "&l->lru_node"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_push_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "553-559",
          "snippet": "void bpf_lru_push_free(struct bpf_lru *lru, struct bpf_lru_node *node)\n{\n\tif (lru->percpu)\n\t\tbpf_percpu_lru_push_free(lru, node);\n\telse\n\t\tbpf_common_lru_push_free(lru, node);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nvoid bpf_lru_push_free(struct bpf_lru *lru, struct bpf_lru_node *node)\n{\n\tif (lru->percpu)\n\t\tbpf_percpu_lru_push_free(lru, node);\n\telse\n\t\tbpf_common_lru_push_free(lru, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&b->lock",
            "flags"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_nulls_del_rcu",
          "args": [
            "&l->hash_node"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_elem_raw",
          "args": [
            "head",
            "hash",
            "key",
            "key_size"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_elem_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "424-435",
          "snippet": "static struct htab_elem *lookup_elem_raw(struct hlist_nulls_head *head, u32 hash,\n\t\t\t\t\t void *key, u32 key_size)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct htab_elem *lookup_elem_raw(struct hlist_nulls_head *head, u32 hash,\n\t\t\t\t\t void *key, u32 key_size)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&b->lock",
            "flags"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__select_bucket",
          "args": [
            "htab",
            "hash"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "__select_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "413-416",
          "snippet": "static inline struct bucket *__select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &htab->buckets[hash & (htab->n_buckets - 1)];\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline struct bucket *__select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &htab->buckets[hash & (htab->n_buckets - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_map_hash",
          "args": [
            "key",
            "key_size",
            "htab->hashrnd"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "htab_map_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "408-411",
          "snippet": "static inline u32 htab_map_hash(const void *key, u32 key_len, u32 hashrnd)\n{\n\treturn jhash(key, key_len, hashrnd);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline u32 htab_map_hash(const void *key, u32 key_len, u32 hashrnd)\n{\n\treturn jhash(key, key_len, hashrnd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_read_lock_held()"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_held",
          "args": [],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "273-282",
          "snippet": "int rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_htab",
            "map"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int htab_lru_map_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct bucket *b;\n\tstruct htab_elem *l;\n\tunsigned long flags;\n\tu32 hash, key_size;\n\tint ret = -ENOENT;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl = lookup_elem_raw(head, hash, key, key_size);\n\n\tif (l) {\n\t\thlist_nulls_del_rcu(&l->hash_node);\n\t\tret = 0;\n\t}\n\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\tif (l)\n\t\tbpf_lru_push_free(&htab->lru, &l->lru_node);\n\treturn ret;\n}"
  },
  {
    "function_name": "htab_map_delete_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1063-1093",
    "snippet": "static int htab_map_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct bucket *b;\n\tstruct htab_elem *l;\n\tunsigned long flags;\n\tu32 hash, key_size;\n\tint ret = -ENOENT;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl = lookup_elem_raw(head, hash, key, key_size);\n\n\tif (l) {\n\t\thlist_nulls_del_rcu(&l->hash_node);\n\t\tfree_htab_elem(htab, l);\n\t\tret = 0;\n\t}\n\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&b->lock",
            "flags"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_htab_elem",
          "args": [
            "htab",
            "l"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "free_htab_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "669-686",
          "snippet": "static void free_htab_elem(struct bpf_htab *htab, struct htab_elem *l)\n{\n\tstruct bpf_map *map = &htab->map;\n\n\tif (map->ops->map_fd_put_ptr) {\n\t\tvoid *ptr = fd_htab_map_get_ptr(map, l);\n\n\t\tmap->ops->map_fd_put_ptr(ptr);\n\t}\n\n\tif (htab_is_prealloc(htab)) {\n\t\tpcpu_freelist_push(&htab->freelist, &l->fnode);\n\t} else {\n\t\tatomic_dec(&htab->count);\n\t\tl->htab = htab;\n\t\tcall_rcu(&l->rcu, htab_elem_free_rcu);\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void free_htab_elem(struct bpf_htab *htab, struct htab_elem *l)\n{\n\tstruct bpf_map *map = &htab->map;\n\n\tif (map->ops->map_fd_put_ptr) {\n\t\tvoid *ptr = fd_htab_map_get_ptr(map, l);\n\n\t\tmap->ops->map_fd_put_ptr(ptr);\n\t}\n\n\tif (htab_is_prealloc(htab)) {\n\t\tpcpu_freelist_push(&htab->freelist, &l->fnode);\n\t} else {\n\t\tatomic_dec(&htab->count);\n\t\tl->htab = htab;\n\t\tcall_rcu(&l->rcu, htab_elem_free_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_nulls_del_rcu",
          "args": [
            "&l->hash_node"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_elem_raw",
          "args": [
            "head",
            "hash",
            "key",
            "key_size"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_elem_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "424-435",
          "snippet": "static struct htab_elem *lookup_elem_raw(struct hlist_nulls_head *head, u32 hash,\n\t\t\t\t\t void *key, u32 key_size)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct htab_elem *lookup_elem_raw(struct hlist_nulls_head *head, u32 hash,\n\t\t\t\t\t void *key, u32 key_size)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&b->lock",
            "flags"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__select_bucket",
          "args": [
            "htab",
            "hash"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "__select_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "413-416",
          "snippet": "static inline struct bucket *__select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &htab->buckets[hash & (htab->n_buckets - 1)];\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline struct bucket *__select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &htab->buckets[hash & (htab->n_buckets - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_map_hash",
          "args": [
            "key",
            "key_size",
            "htab->hashrnd"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "htab_map_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "408-411",
          "snippet": "static inline u32 htab_map_hash(const void *key, u32 key_len, u32 hashrnd)\n{\n\treturn jhash(key, key_len, hashrnd);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline u32 htab_map_hash(const void *key, u32 key_len, u32 hashrnd)\n{\n\treturn jhash(key, key_len, hashrnd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_read_lock_held()"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_held",
          "args": [],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "273-282",
          "snippet": "int rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_htab",
            "map"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int htab_map_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct bucket *b;\n\tstruct htab_elem *l;\n\tunsigned long flags;\n\tu32 hash, key_size;\n\tint ret = -ENOENT;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl = lookup_elem_raw(head, hash, key, key_size);\n\n\tif (l) {\n\t\thlist_nulls_del_rcu(&l->hash_node);\n\t\tfree_htab_elem(htab, l);\n\t\tret = 0;\n\t}\n\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "htab_lru_percpu_map_update_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1055-1060",
    "snippet": "static int htab_lru_percpu_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t   void *value, u64 map_flags)\n{\n\treturn __htab_lru_percpu_map_update_elem(map, key, value, map_flags,\n\t\t\t\t\t\t false);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__htab_lru_percpu_map_update_elem",
          "args": [
            "map",
            "key",
            "value",
            "map_flags",
            "false"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "__htab_lru_percpu_map_update_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "984-1047",
          "snippet": "static int __htab_lru_percpu_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t     void *value, u64 map_flags,\n\t\t\t\t\t     bool onallcpus)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l_new = NULL, *l_old;\n\tstruct hlist_nulls_head *head;\n\tunsigned long flags;\n\tstruct bucket *b;\n\tu32 key_size, hash;\n\tint ret;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\t/* For LRU, we need to alloc before taking bucket's\n\t * spinlock because LRU's elem alloc may need\n\t * to remove older elem from htab and this removal\n\t * operation will need a bucket lock.\n\t */\n\tif (map_flags != BPF_EXIST) {\n\t\tl_new = prealloc_lru_pop(htab, key, hash);\n\t\tif (!l_new)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* bpf_map_update_elem() can be called in_irq() */\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl_old = lookup_elem_raw(head, hash, key, key_size);\n\n\tret = check_flags(htab, l_old, map_flags);\n\tif (ret)\n\t\tgoto err;\n\n\tif (l_old) {\n\t\tbpf_lru_node_set_ref(&l_old->lru_node);\n\n\t\t/* per-cpu hash map can update value in-place */\n\t\tpcpu_copy_value(htab, htab_elem_get_ptr(l_old, key_size),\n\t\t\t\tvalue, onallcpus);\n\t} else {\n\t\tpcpu_copy_value(htab, htab_elem_get_ptr(l_new, key_size),\n\t\t\t\tvalue, onallcpus);\n\t\thlist_nulls_add_head_rcu(&l_new->hash_node, head);\n\t\tl_new = NULL;\n\t}\n\tret = 0;\nerr:\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\tif (l_new)\n\t\tbpf_lru_push_free(&htab->lru, &l_new->lru_node);\n\treturn ret;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int __htab_lru_percpu_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t     void *value, u64 map_flags,\n\t\t\t\t\t     bool onallcpus)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l_new = NULL, *l_old;\n\tstruct hlist_nulls_head *head;\n\tunsigned long flags;\n\tstruct bucket *b;\n\tu32 key_size, hash;\n\tint ret;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\t/* For LRU, we need to alloc before taking bucket's\n\t * spinlock because LRU's elem alloc may need\n\t * to remove older elem from htab and this removal\n\t * operation will need a bucket lock.\n\t */\n\tif (map_flags != BPF_EXIST) {\n\t\tl_new = prealloc_lru_pop(htab, key, hash);\n\t\tif (!l_new)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* bpf_map_update_elem() can be called in_irq() */\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl_old = lookup_elem_raw(head, hash, key, key_size);\n\n\tret = check_flags(htab, l_old, map_flags);\n\tif (ret)\n\t\tgoto err;\n\n\tif (l_old) {\n\t\tbpf_lru_node_set_ref(&l_old->lru_node);\n\n\t\t/* per-cpu hash map can update value in-place */\n\t\tpcpu_copy_value(htab, htab_elem_get_ptr(l_old, key_size),\n\t\t\t\tvalue, onallcpus);\n\t} else {\n\t\tpcpu_copy_value(htab, htab_elem_get_ptr(l_new, key_size),\n\t\t\t\tvalue, onallcpus);\n\t\thlist_nulls_add_head_rcu(&l_new->hash_node, head);\n\t\tl_new = NULL;\n\t}\n\tret = 0;\nerr:\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\tif (l_new)\n\t\tbpf_lru_push_free(&htab->lru, &l_new->lru_node);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int htab_lru_percpu_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t   void *value, u64 map_flags)\n{\n\treturn __htab_lru_percpu_map_update_elem(map, key, value, map_flags,\n\t\t\t\t\t\t false);\n}"
  },
  {
    "function_name": "htab_percpu_map_update_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "1049-1053",
    "snippet": "static int htab_percpu_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value, u64 map_flags)\n{\n\treturn __htab_percpu_map_update_elem(map, key, value, map_flags, false);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__htab_percpu_map_update_elem",
          "args": [
            "map",
            "key",
            "value",
            "map_flags",
            "false"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "__htab_percpu_map_update_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "931-982",
          "snippet": "static int __htab_percpu_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t void *value, u64 map_flags,\n\t\t\t\t\t bool onallcpus)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l_new = NULL, *l_old;\n\tstruct hlist_nulls_head *head;\n\tunsigned long flags;\n\tstruct bucket *b;\n\tu32 key_size, hash;\n\tint ret;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\t/* bpf_map_update_elem() can be called in_irq() */\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl_old = lookup_elem_raw(head, hash, key, key_size);\n\n\tret = check_flags(htab, l_old, map_flags);\n\tif (ret)\n\t\tgoto err;\n\n\tif (l_old) {\n\t\t/* per-cpu hash map can update value in-place */\n\t\tpcpu_copy_value(htab, htab_elem_get_ptr(l_old, key_size),\n\t\t\t\tvalue, onallcpus);\n\t} else {\n\t\tl_new = alloc_htab_elem(htab, key, value, key_size,\n\t\t\t\t\thash, true, onallcpus, NULL);\n\t\tif (IS_ERR(l_new)) {\n\t\t\tret = PTR_ERR(l_new);\n\t\t\tgoto err;\n\t\t}\n\t\thlist_nulls_add_head_rcu(&l_new->hash_node, head);\n\t}\n\tret = 0;\nerr:\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int __htab_percpu_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t void *value, u64 map_flags,\n\t\t\t\t\t bool onallcpus)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l_new = NULL, *l_old;\n\tstruct hlist_nulls_head *head;\n\tunsigned long flags;\n\tstruct bucket *b;\n\tu32 key_size, hash;\n\tint ret;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\t/* bpf_map_update_elem() can be called in_irq() */\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl_old = lookup_elem_raw(head, hash, key, key_size);\n\n\tret = check_flags(htab, l_old, map_flags);\n\tif (ret)\n\t\tgoto err;\n\n\tif (l_old) {\n\t\t/* per-cpu hash map can update value in-place */\n\t\tpcpu_copy_value(htab, htab_elem_get_ptr(l_old, key_size),\n\t\t\t\tvalue, onallcpus);\n\t} else {\n\t\tl_new = alloc_htab_elem(htab, key, value, key_size,\n\t\t\t\t\thash, true, onallcpus, NULL);\n\t\tif (IS_ERR(l_new)) {\n\t\t\tret = PTR_ERR(l_new);\n\t\t\tgoto err;\n\t\t}\n\t\thlist_nulls_add_head_rcu(&l_new->hash_node, head);\n\t}\n\tret = 0;\nerr:\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int htab_percpu_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value, u64 map_flags)\n{\n\treturn __htab_percpu_map_update_elem(map, key, value, map_flags, false);\n}"
  },
  {
    "function_name": "__htab_lru_percpu_map_update_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "984-1047",
    "snippet": "static int __htab_lru_percpu_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t     void *value, u64 map_flags,\n\t\t\t\t\t     bool onallcpus)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l_new = NULL, *l_old;\n\tstruct hlist_nulls_head *head;\n\tunsigned long flags;\n\tstruct bucket *b;\n\tu32 key_size, hash;\n\tint ret;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\t/* For LRU, we need to alloc before taking bucket's\n\t * spinlock because LRU's elem alloc may need\n\t * to remove older elem from htab and this removal\n\t * operation will need a bucket lock.\n\t */\n\tif (map_flags != BPF_EXIST) {\n\t\tl_new = prealloc_lru_pop(htab, key, hash);\n\t\tif (!l_new)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* bpf_map_update_elem() can be called in_irq() */\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl_old = lookup_elem_raw(head, hash, key, key_size);\n\n\tret = check_flags(htab, l_old, map_flags);\n\tif (ret)\n\t\tgoto err;\n\n\tif (l_old) {\n\t\tbpf_lru_node_set_ref(&l_old->lru_node);\n\n\t\t/* per-cpu hash map can update value in-place */\n\t\tpcpu_copy_value(htab, htab_elem_get_ptr(l_old, key_size),\n\t\t\t\tvalue, onallcpus);\n\t} else {\n\t\tpcpu_copy_value(htab, htab_elem_get_ptr(l_new, key_size),\n\t\t\t\tvalue, onallcpus);\n\t\thlist_nulls_add_head_rcu(&l_new->hash_node, head);\n\t\tl_new = NULL;\n\t}\n\tret = 0;\nerr:\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\tif (l_new)\n\t\tbpf_lru_push_free(&htab->lru, &l_new->lru_node);\n\treturn ret;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_lru_push_free",
          "args": [
            "&htab->lru",
            "&l_new->lru_node"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_push_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "553-559",
          "snippet": "void bpf_lru_push_free(struct bpf_lru *lru, struct bpf_lru_node *node)\n{\n\tif (lru->percpu)\n\t\tbpf_percpu_lru_push_free(lru, node);\n\telse\n\t\tbpf_common_lru_push_free(lru, node);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nvoid bpf_lru_push_free(struct bpf_lru *lru, struct bpf_lru_node *node)\n{\n\tif (lru->percpu)\n\t\tbpf_percpu_lru_push_free(lru, node);\n\telse\n\t\tbpf_common_lru_push_free(lru, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&b->lock",
            "flags"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_nulls_add_head_rcu",
          "args": [
            "&l_new->hash_node",
            "head"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_copy_value",
          "args": [
            "htab",
            "htab_elem_get_ptr(l_new, key_size)",
            "value",
            "onallcpus"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_copy_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "688-704",
          "snippet": "static void pcpu_copy_value(struct bpf_htab *htab, void __percpu *pptr,\n\t\t\t    void *value, bool onallcpus)\n{\n\tif (!onallcpus) {\n\t\t/* copy true value_size bytes */\n\t\tmemcpy(this_cpu_ptr(pptr), value, htab->map.value_size);\n\t} else {\n\t\tu32 size = round_up(htab->map.value_size, 8);\n\t\tint off = 0, cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tbpf_long_memcpy(per_cpu_ptr(pptr, cpu),\n\t\t\t\t\tvalue + off, size);\n\t\t\toff += size;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void pcpu_copy_value(struct bpf_htab *htab, void __percpu *pptr,\n\t\t\t    void *value, bool onallcpus)\n{\n\tif (!onallcpus) {\n\t\t/* copy true value_size bytes */\n\t\tmemcpy(this_cpu_ptr(pptr), value, htab->map.value_size);\n\t} else {\n\t\tu32 size = round_up(htab->map.value_size, 8);\n\t\tint off = 0, cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tbpf_long_memcpy(per_cpu_ptr(pptr, cpu),\n\t\t\t\t\tvalue + off, size);\n\t\t\toff += size;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_elem_get_ptr",
          "args": [
            "l_new",
            "key_size"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "htab_elem_get_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "93-96",
          "snippet": "static inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_node_set_ref",
          "args": [
            "&l_old->lru_node"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_node_set_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.h",
          "lines": "67-74",
          "snippet": "static inline void bpf_lru_node_set_ref(struct bpf_lru_node *node)\n{\n\t/* ref is an approximation on access frequency.  It does not\n\t * have to be very accurate.  Hence, no protection is used.\n\t */\n\tif (!node->ref)\n\t\tnode->ref = 1;\n}",
          "includes": [
            "#include <linux/spinlock_types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock_types.h>\n#include <linux/list.h>\n\nstatic inline void bpf_lru_node_set_ref(struct bpf_lru_node *node)\n{\n\t/* ref is an approximation on access frequency.  It does not\n\t * have to be very accurate.  Hence, no protection is used.\n\t */\n\tif (!node->ref)\n\t\tnode->ref = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "htab",
            "l_old",
            "map_flags"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "796-808",
          "snippet": "static int check_flags(struct bpf_htab *htab, struct htab_elem *l_old,\n\t\t       u64 map_flags)\n{\n\tif (l_old && map_flags == BPF_NOEXIST)\n\t\t/* elem already exists */\n\t\treturn -EEXIST;\n\n\tif (!l_old && map_flags == BPF_EXIST)\n\t\t/* elem doesn't exist, cannot update it */\n\t\treturn -ENOENT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int check_flags(struct bpf_htab *htab, struct htab_elem *l_old,\n\t\t       u64 map_flags)\n{\n\tif (l_old && map_flags == BPF_NOEXIST)\n\t\t/* elem already exists */\n\t\treturn -EEXIST;\n\n\tif (!l_old && map_flags == BPF_EXIST)\n\t\t/* elem doesn't exist, cannot update it */\n\t\treturn -ENOENT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_elem_raw",
          "args": [
            "head",
            "hash",
            "key",
            "key_size"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_elem_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "424-435",
          "snippet": "static struct htab_elem *lookup_elem_raw(struct hlist_nulls_head *head, u32 hash,\n\t\t\t\t\t void *key, u32 key_size)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct htab_elem *lookup_elem_raw(struct hlist_nulls_head *head, u32 hash,\n\t\t\t\t\t void *key, u32 key_size)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&b->lock",
            "flags"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prealloc_lru_pop",
          "args": [
            "htab",
            "key",
            "hash"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "prealloc_lru_pop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "127-140",
          "snippet": "static struct htab_elem *prealloc_lru_pop(struct bpf_htab *htab, void *key,\n\t\t\t\t\t  u32 hash)\n{\n\tstruct bpf_lru_node *node = bpf_lru_pop_free(&htab->lru, hash);\n\tstruct htab_elem *l;\n\n\tif (node) {\n\t\tl = container_of(node, struct htab_elem, lru_node);\n\t\tmemcpy(l->key, key, htab->map.key_size);\n\t\treturn l;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool htab_lru_map_delete_node(void *arg, struct bpf_lru_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool htab_lru_map_delete_node(void *arg, struct bpf_lru_node *node);\n\nstatic struct htab_elem *prealloc_lru_pop(struct bpf_htab *htab, void *key,\n\t\t\t\t\t  u32 hash)\n{\n\tstruct bpf_lru_node *node = bpf_lru_pop_free(&htab->lru, hash);\n\tstruct htab_elem *l;\n\n\tif (node) {\n\t\tl = container_of(node, struct htab_elem, lru_node);\n\t\tmemcpy(l->key, key, htab->map.key_size);\n\t\treturn l;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__select_bucket",
          "args": [
            "htab",
            "hash"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "__select_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "413-416",
          "snippet": "static inline struct bucket *__select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &htab->buckets[hash & (htab->n_buckets - 1)];\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline struct bucket *__select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &htab->buckets[hash & (htab->n_buckets - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_map_hash",
          "args": [
            "key",
            "key_size",
            "htab->hashrnd"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "htab_map_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "408-411",
          "snippet": "static inline u32 htab_map_hash(const void *key, u32 key_len, u32 hashrnd)\n{\n\treturn jhash(key, key_len, hashrnd);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline u32 htab_map_hash(const void *key, u32 key_len, u32 hashrnd)\n{\n\treturn jhash(key, key_len, hashrnd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_read_lock_held()"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_held",
          "args": [],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "273-282",
          "snippet": "int rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "map_flags > BPF_EXIST"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_htab",
            "map"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int __htab_lru_percpu_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t     void *value, u64 map_flags,\n\t\t\t\t\t     bool onallcpus)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l_new = NULL, *l_old;\n\tstruct hlist_nulls_head *head;\n\tunsigned long flags;\n\tstruct bucket *b;\n\tu32 key_size, hash;\n\tint ret;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\t/* For LRU, we need to alloc before taking bucket's\n\t * spinlock because LRU's elem alloc may need\n\t * to remove older elem from htab and this removal\n\t * operation will need a bucket lock.\n\t */\n\tif (map_flags != BPF_EXIST) {\n\t\tl_new = prealloc_lru_pop(htab, key, hash);\n\t\tif (!l_new)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* bpf_map_update_elem() can be called in_irq() */\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl_old = lookup_elem_raw(head, hash, key, key_size);\n\n\tret = check_flags(htab, l_old, map_flags);\n\tif (ret)\n\t\tgoto err;\n\n\tif (l_old) {\n\t\tbpf_lru_node_set_ref(&l_old->lru_node);\n\n\t\t/* per-cpu hash map can update value in-place */\n\t\tpcpu_copy_value(htab, htab_elem_get_ptr(l_old, key_size),\n\t\t\t\tvalue, onallcpus);\n\t} else {\n\t\tpcpu_copy_value(htab, htab_elem_get_ptr(l_new, key_size),\n\t\t\t\tvalue, onallcpus);\n\t\thlist_nulls_add_head_rcu(&l_new->hash_node, head);\n\t\tl_new = NULL;\n\t}\n\tret = 0;\nerr:\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\tif (l_new)\n\t\tbpf_lru_push_free(&htab->lru, &l_new->lru_node);\n\treturn ret;\n}"
  },
  {
    "function_name": "__htab_percpu_map_update_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "931-982",
    "snippet": "static int __htab_percpu_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t void *value, u64 map_flags,\n\t\t\t\t\t bool onallcpus)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l_new = NULL, *l_old;\n\tstruct hlist_nulls_head *head;\n\tunsigned long flags;\n\tstruct bucket *b;\n\tu32 key_size, hash;\n\tint ret;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\t/* bpf_map_update_elem() can be called in_irq() */\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl_old = lookup_elem_raw(head, hash, key, key_size);\n\n\tret = check_flags(htab, l_old, map_flags);\n\tif (ret)\n\t\tgoto err;\n\n\tif (l_old) {\n\t\t/* per-cpu hash map can update value in-place */\n\t\tpcpu_copy_value(htab, htab_elem_get_ptr(l_old, key_size),\n\t\t\t\tvalue, onallcpus);\n\t} else {\n\t\tl_new = alloc_htab_elem(htab, key, value, key_size,\n\t\t\t\t\thash, true, onallcpus, NULL);\n\t\tif (IS_ERR(l_new)) {\n\t\t\tret = PTR_ERR(l_new);\n\t\t\tgoto err;\n\t\t}\n\t\thlist_nulls_add_head_rcu(&l_new->hash_node, head);\n\t}\n\tret = 0;\nerr:\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&b->lock",
            "flags"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_nulls_add_head_rcu",
          "args": [
            "&l_new->hash_node",
            "head"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "l_new"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "l_new"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_htab_elem",
          "args": [
            "htab",
            "key",
            "value",
            "key_size",
            "hash",
            "true",
            "onallcpus",
            "NULL"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_htab_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "721-794",
          "snippet": "static struct htab_elem *alloc_htab_elem(struct bpf_htab *htab, void *key,\n\t\t\t\t\t void *value, u32 key_size, u32 hash,\n\t\t\t\t\t bool percpu, bool onallcpus,\n\t\t\t\t\t struct htab_elem *old_elem)\n{\n\tu32 size = htab_size_value(htab, percpu);\n\tbool prealloc = htab_is_prealloc(htab);\n\tstruct htab_elem *l_new, **pl_new;\n\tvoid __percpu *pptr;\n\n\tif (prealloc) {\n\t\tif (old_elem) {\n\t\t\t/* if we're updating the existing element,\n\t\t\t * use per-cpu extra elems to avoid freelist_pop/push\n\t\t\t */\n\t\t\tpl_new = this_cpu_ptr(htab->extra_elems);\n\t\t\tl_new = *pl_new;\n\t\t\t*pl_new = old_elem;\n\t\t} else {\n\t\t\tstruct pcpu_freelist_node *l;\n\n\t\t\tl = pcpu_freelist_pop(&htab->freelist);\n\t\t\tif (!l)\n\t\t\t\treturn ERR_PTR(-E2BIG);\n\t\t\tl_new = container_of(l, struct htab_elem, fnode);\n\t\t}\n\t} else {\n\t\tif (atomic_inc_return(&htab->count) > htab->map.max_entries)\n\t\t\tif (!old_elem) {\n\t\t\t\t/* when map is full and update() is replacing\n\t\t\t\t * old element, it's ok to allocate, since\n\t\t\t\t * old element will be freed immediately.\n\t\t\t\t * Otherwise return an error\n\t\t\t\t */\n\t\t\t\tl_new = ERR_PTR(-E2BIG);\n\t\t\t\tgoto dec_count;\n\t\t\t}\n\t\tl_new = kmalloc_node(htab->elem_size, GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t\t     htab->map.numa_node);\n\t\tif (!l_new) {\n\t\t\tl_new = ERR_PTR(-ENOMEM);\n\t\t\tgoto dec_count;\n\t\t}\n\t}\n\n\tmemcpy(l_new->key, key, key_size);\n\tif (percpu) {\n\t\tif (prealloc) {\n\t\t\tpptr = htab_elem_get_ptr(l_new, key_size);\n\t\t} else {\n\t\t\t/* alloc_percpu zero-fills */\n\t\t\tpptr = __alloc_percpu_gfp(size, 8,\n\t\t\t\t\t\t  GFP_ATOMIC | __GFP_NOWARN);\n\t\t\tif (!pptr) {\n\t\t\t\tkfree(l_new);\n\t\t\t\tl_new = ERR_PTR(-ENOMEM);\n\t\t\t\tgoto dec_count;\n\t\t\t}\n\t\t}\n\n\t\tpcpu_copy_value(htab, pptr, value, onallcpus);\n\n\t\tif (!prealloc)\n\t\t\thtab_elem_set_ptr(l_new, key_size, pptr);\n\t} else {\n\t\tmemcpy(l_new->key + round_up(key_size, 8), value, size);\n\t}\n\n\tl_new->hash = hash;\n\treturn l_new;\ndec_count:\n\tatomic_dec(&htab->count);\n\treturn l_new;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct htab_elem *alloc_htab_elem(struct bpf_htab *htab, void *key,\n\t\t\t\t\t void *value, u32 key_size, u32 hash,\n\t\t\t\t\t bool percpu, bool onallcpus,\n\t\t\t\t\t struct htab_elem *old_elem)\n{\n\tu32 size = htab_size_value(htab, percpu);\n\tbool prealloc = htab_is_prealloc(htab);\n\tstruct htab_elem *l_new, **pl_new;\n\tvoid __percpu *pptr;\n\n\tif (prealloc) {\n\t\tif (old_elem) {\n\t\t\t/* if we're updating the existing element,\n\t\t\t * use per-cpu extra elems to avoid freelist_pop/push\n\t\t\t */\n\t\t\tpl_new = this_cpu_ptr(htab->extra_elems);\n\t\t\tl_new = *pl_new;\n\t\t\t*pl_new = old_elem;\n\t\t} else {\n\t\t\tstruct pcpu_freelist_node *l;\n\n\t\t\tl = pcpu_freelist_pop(&htab->freelist);\n\t\t\tif (!l)\n\t\t\t\treturn ERR_PTR(-E2BIG);\n\t\t\tl_new = container_of(l, struct htab_elem, fnode);\n\t\t}\n\t} else {\n\t\tif (atomic_inc_return(&htab->count) > htab->map.max_entries)\n\t\t\tif (!old_elem) {\n\t\t\t\t/* when map is full and update() is replacing\n\t\t\t\t * old element, it's ok to allocate, since\n\t\t\t\t * old element will be freed immediately.\n\t\t\t\t * Otherwise return an error\n\t\t\t\t */\n\t\t\t\tl_new = ERR_PTR(-E2BIG);\n\t\t\t\tgoto dec_count;\n\t\t\t}\n\t\tl_new = kmalloc_node(htab->elem_size, GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t\t     htab->map.numa_node);\n\t\tif (!l_new) {\n\t\t\tl_new = ERR_PTR(-ENOMEM);\n\t\t\tgoto dec_count;\n\t\t}\n\t}\n\n\tmemcpy(l_new->key, key, key_size);\n\tif (percpu) {\n\t\tif (prealloc) {\n\t\t\tpptr = htab_elem_get_ptr(l_new, key_size);\n\t\t} else {\n\t\t\t/* alloc_percpu zero-fills */\n\t\t\tpptr = __alloc_percpu_gfp(size, 8,\n\t\t\t\t\t\t  GFP_ATOMIC | __GFP_NOWARN);\n\t\t\tif (!pptr) {\n\t\t\t\tkfree(l_new);\n\t\t\t\tl_new = ERR_PTR(-ENOMEM);\n\t\t\t\tgoto dec_count;\n\t\t\t}\n\t\t}\n\n\t\tpcpu_copy_value(htab, pptr, value, onallcpus);\n\n\t\tif (!prealloc)\n\t\t\thtab_elem_set_ptr(l_new, key_size, pptr);\n\t} else {\n\t\tmemcpy(l_new->key + round_up(key_size, 8), value, size);\n\t}\n\n\tl_new->hash = hash;\n\treturn l_new;\ndec_count:\n\tatomic_dec(&htab->count);\n\treturn l_new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_copy_value",
          "args": [
            "htab",
            "htab_elem_get_ptr(l_old, key_size)",
            "value",
            "onallcpus"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_copy_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "688-704",
          "snippet": "static void pcpu_copy_value(struct bpf_htab *htab, void __percpu *pptr,\n\t\t\t    void *value, bool onallcpus)\n{\n\tif (!onallcpus) {\n\t\t/* copy true value_size bytes */\n\t\tmemcpy(this_cpu_ptr(pptr), value, htab->map.value_size);\n\t} else {\n\t\tu32 size = round_up(htab->map.value_size, 8);\n\t\tint off = 0, cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tbpf_long_memcpy(per_cpu_ptr(pptr, cpu),\n\t\t\t\t\tvalue + off, size);\n\t\t\toff += size;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void pcpu_copy_value(struct bpf_htab *htab, void __percpu *pptr,\n\t\t\t    void *value, bool onallcpus)\n{\n\tif (!onallcpus) {\n\t\t/* copy true value_size bytes */\n\t\tmemcpy(this_cpu_ptr(pptr), value, htab->map.value_size);\n\t} else {\n\t\tu32 size = round_up(htab->map.value_size, 8);\n\t\tint off = 0, cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tbpf_long_memcpy(per_cpu_ptr(pptr, cpu),\n\t\t\t\t\tvalue + off, size);\n\t\t\toff += size;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_elem_get_ptr",
          "args": [
            "l_old",
            "key_size"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "htab_elem_get_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "93-96",
          "snippet": "static inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "htab",
            "l_old",
            "map_flags"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "796-808",
          "snippet": "static int check_flags(struct bpf_htab *htab, struct htab_elem *l_old,\n\t\t       u64 map_flags)\n{\n\tif (l_old && map_flags == BPF_NOEXIST)\n\t\t/* elem already exists */\n\t\treturn -EEXIST;\n\n\tif (!l_old && map_flags == BPF_EXIST)\n\t\t/* elem doesn't exist, cannot update it */\n\t\treturn -ENOENT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int check_flags(struct bpf_htab *htab, struct htab_elem *l_old,\n\t\t       u64 map_flags)\n{\n\tif (l_old && map_flags == BPF_NOEXIST)\n\t\t/* elem already exists */\n\t\treturn -EEXIST;\n\n\tif (!l_old && map_flags == BPF_EXIST)\n\t\t/* elem doesn't exist, cannot update it */\n\t\treturn -ENOENT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_elem_raw",
          "args": [
            "head",
            "hash",
            "key",
            "key_size"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_elem_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "424-435",
          "snippet": "static struct htab_elem *lookup_elem_raw(struct hlist_nulls_head *head, u32 hash,\n\t\t\t\t\t void *key, u32 key_size)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct htab_elem *lookup_elem_raw(struct hlist_nulls_head *head, u32 hash,\n\t\t\t\t\t void *key, u32 key_size)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&b->lock",
            "flags"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__select_bucket",
          "args": [
            "htab",
            "hash"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "__select_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "413-416",
          "snippet": "static inline struct bucket *__select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &htab->buckets[hash & (htab->n_buckets - 1)];\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline struct bucket *__select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &htab->buckets[hash & (htab->n_buckets - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_map_hash",
          "args": [
            "key",
            "key_size",
            "htab->hashrnd"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "htab_map_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "408-411",
          "snippet": "static inline u32 htab_map_hash(const void *key, u32 key_len, u32 hashrnd)\n{\n\treturn jhash(key, key_len, hashrnd);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline u32 htab_map_hash(const void *key, u32 key_len, u32 hashrnd)\n{\n\treturn jhash(key, key_len, hashrnd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_read_lock_held()"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_held",
          "args": [],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "273-282",
          "snippet": "int rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "map_flags > BPF_EXIST"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_htab",
            "map"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int __htab_percpu_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t void *value, u64 map_flags,\n\t\t\t\t\t bool onallcpus)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l_new = NULL, *l_old;\n\tstruct hlist_nulls_head *head;\n\tunsigned long flags;\n\tstruct bucket *b;\n\tu32 key_size, hash;\n\tint ret;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\t/* bpf_map_update_elem() can be called in_irq() */\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl_old = lookup_elem_raw(head, hash, key, key_size);\n\n\tret = check_flags(htab, l_old, map_flags);\n\tif (ret)\n\t\tgoto err;\n\n\tif (l_old) {\n\t\t/* per-cpu hash map can update value in-place */\n\t\tpcpu_copy_value(htab, htab_elem_get_ptr(l_old, key_size),\n\t\t\t\tvalue, onallcpus);\n\t} else {\n\t\tl_new = alloc_htab_elem(htab, key, value, key_size,\n\t\t\t\t\thash, true, onallcpus, NULL);\n\t\tif (IS_ERR(l_new)) {\n\t\t\tret = PTR_ERR(l_new);\n\t\t\tgoto err;\n\t\t}\n\t\thlist_nulls_add_head_rcu(&l_new->hash_node, head);\n\t}\n\tret = 0;\nerr:\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "htab_lru_map_update_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "867-929",
    "snippet": "static int htab_lru_map_update_elem(struct bpf_map *map, void *key, void *value,\n\t\t\t\t    u64 map_flags)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l_new, *l_old = NULL;\n\tstruct hlist_nulls_head *head;\n\tunsigned long flags;\n\tstruct bucket *b;\n\tu32 key_size, hash;\n\tint ret;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\t/* For LRU, we need to alloc before taking bucket's\n\t * spinlock because getting free nodes from LRU may need\n\t * to remove older elements from htab and this removal\n\t * operation will need a bucket lock.\n\t */\n\tl_new = prealloc_lru_pop(htab, key, hash);\n\tif (!l_new)\n\t\treturn -ENOMEM;\n\tmemcpy(l_new->key + round_up(map->key_size, 8), value, map->value_size);\n\n\t/* bpf_map_update_elem() can be called in_irq() */\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl_old = lookup_elem_raw(head, hash, key, key_size);\n\n\tret = check_flags(htab, l_old, map_flags);\n\tif (ret)\n\t\tgoto err;\n\n\t/* add new element to the head of the list, so that\n\t * concurrent search will find it before old elem\n\t */\n\thlist_nulls_add_head_rcu(&l_new->hash_node, head);\n\tif (l_old) {\n\t\tbpf_lru_node_set_ref(&l_new->lru_node);\n\t\thlist_nulls_del_rcu(&l_old->hash_node);\n\t}\n\tret = 0;\n\nerr:\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\n\tif (ret)\n\t\tbpf_lru_push_free(&htab->lru, &l_new->lru_node);\n\telse if (l_old)\n\t\tbpf_lru_push_free(&htab->lru, &l_old->lru_node);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_lru_push_free",
          "args": [
            "&htab->lru",
            "&l_old->lru_node"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_push_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "553-559",
          "snippet": "void bpf_lru_push_free(struct bpf_lru *lru, struct bpf_lru_node *node)\n{\n\tif (lru->percpu)\n\t\tbpf_percpu_lru_push_free(lru, node);\n\telse\n\t\tbpf_common_lru_push_free(lru, node);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nvoid bpf_lru_push_free(struct bpf_lru *lru, struct bpf_lru_node *node)\n{\n\tif (lru->percpu)\n\t\tbpf_percpu_lru_push_free(lru, node);\n\telse\n\t\tbpf_common_lru_push_free(lru, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&b->lock",
            "flags"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_nulls_del_rcu",
          "args": [
            "&l_old->hash_node"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_lru_node_set_ref",
          "args": [
            "&l_new->lru_node"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_node_set_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.h",
          "lines": "67-74",
          "snippet": "static inline void bpf_lru_node_set_ref(struct bpf_lru_node *node)\n{\n\t/* ref is an approximation on access frequency.  It does not\n\t * have to be very accurate.  Hence, no protection is used.\n\t */\n\tif (!node->ref)\n\t\tnode->ref = 1;\n}",
          "includes": [
            "#include <linux/spinlock_types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock_types.h>\n#include <linux/list.h>\n\nstatic inline void bpf_lru_node_set_ref(struct bpf_lru_node *node)\n{\n\t/* ref is an approximation on access frequency.  It does not\n\t * have to be very accurate.  Hence, no protection is used.\n\t */\n\tif (!node->ref)\n\t\tnode->ref = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_nulls_add_head_rcu",
          "args": [
            "&l_new->hash_node",
            "head"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "htab",
            "l_old",
            "map_flags"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "796-808",
          "snippet": "static int check_flags(struct bpf_htab *htab, struct htab_elem *l_old,\n\t\t       u64 map_flags)\n{\n\tif (l_old && map_flags == BPF_NOEXIST)\n\t\t/* elem already exists */\n\t\treturn -EEXIST;\n\n\tif (!l_old && map_flags == BPF_EXIST)\n\t\t/* elem doesn't exist, cannot update it */\n\t\treturn -ENOENT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int check_flags(struct bpf_htab *htab, struct htab_elem *l_old,\n\t\t       u64 map_flags)\n{\n\tif (l_old && map_flags == BPF_NOEXIST)\n\t\t/* elem already exists */\n\t\treturn -EEXIST;\n\n\tif (!l_old && map_flags == BPF_EXIST)\n\t\t/* elem doesn't exist, cannot update it */\n\t\treturn -ENOENT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_elem_raw",
          "args": [
            "head",
            "hash",
            "key",
            "key_size"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_elem_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "424-435",
          "snippet": "static struct htab_elem *lookup_elem_raw(struct hlist_nulls_head *head, u32 hash,\n\t\t\t\t\t void *key, u32 key_size)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct htab_elem *lookup_elem_raw(struct hlist_nulls_head *head, u32 hash,\n\t\t\t\t\t void *key, u32 key_size)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&b->lock",
            "flags"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "l_new->key + round_up(map->key_size, 8)",
            "value",
            "map->value_size"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "map->key_size",
            "8"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prealloc_lru_pop",
          "args": [
            "htab",
            "key",
            "hash"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "prealloc_lru_pop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "127-140",
          "snippet": "static struct htab_elem *prealloc_lru_pop(struct bpf_htab *htab, void *key,\n\t\t\t\t\t  u32 hash)\n{\n\tstruct bpf_lru_node *node = bpf_lru_pop_free(&htab->lru, hash);\n\tstruct htab_elem *l;\n\n\tif (node) {\n\t\tl = container_of(node, struct htab_elem, lru_node);\n\t\tmemcpy(l->key, key, htab->map.key_size);\n\t\treturn l;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool htab_lru_map_delete_node(void *arg, struct bpf_lru_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool htab_lru_map_delete_node(void *arg, struct bpf_lru_node *node);\n\nstatic struct htab_elem *prealloc_lru_pop(struct bpf_htab *htab, void *key,\n\t\t\t\t\t  u32 hash)\n{\n\tstruct bpf_lru_node *node = bpf_lru_pop_free(&htab->lru, hash);\n\tstruct htab_elem *l;\n\n\tif (node) {\n\t\tl = container_of(node, struct htab_elem, lru_node);\n\t\tmemcpy(l->key, key, htab->map.key_size);\n\t\treturn l;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__select_bucket",
          "args": [
            "htab",
            "hash"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "__select_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "413-416",
          "snippet": "static inline struct bucket *__select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &htab->buckets[hash & (htab->n_buckets - 1)];\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline struct bucket *__select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &htab->buckets[hash & (htab->n_buckets - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_map_hash",
          "args": [
            "key",
            "key_size",
            "htab->hashrnd"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "htab_map_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "408-411",
          "snippet": "static inline u32 htab_map_hash(const void *key, u32 key_len, u32 hashrnd)\n{\n\treturn jhash(key, key_len, hashrnd);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline u32 htab_map_hash(const void *key, u32 key_len, u32 hashrnd)\n{\n\treturn jhash(key, key_len, hashrnd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_read_lock_held()"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_held",
          "args": [],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "273-282",
          "snippet": "int rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "map_flags > BPF_EXIST"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_htab",
            "map"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int htab_lru_map_update_elem(struct bpf_map *map, void *key, void *value,\n\t\t\t\t    u64 map_flags)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l_new, *l_old = NULL;\n\tstruct hlist_nulls_head *head;\n\tunsigned long flags;\n\tstruct bucket *b;\n\tu32 key_size, hash;\n\tint ret;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\t/* For LRU, we need to alloc before taking bucket's\n\t * spinlock because getting free nodes from LRU may need\n\t * to remove older elements from htab and this removal\n\t * operation will need a bucket lock.\n\t */\n\tl_new = prealloc_lru_pop(htab, key, hash);\n\tif (!l_new)\n\t\treturn -ENOMEM;\n\tmemcpy(l_new->key + round_up(map->key_size, 8), value, map->value_size);\n\n\t/* bpf_map_update_elem() can be called in_irq() */\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl_old = lookup_elem_raw(head, hash, key, key_size);\n\n\tret = check_flags(htab, l_old, map_flags);\n\tif (ret)\n\t\tgoto err;\n\n\t/* add new element to the head of the list, so that\n\t * concurrent search will find it before old elem\n\t */\n\thlist_nulls_add_head_rcu(&l_new->hash_node, head);\n\tif (l_old) {\n\t\tbpf_lru_node_set_ref(&l_new->lru_node);\n\t\thlist_nulls_del_rcu(&l_old->hash_node);\n\t}\n\tret = 0;\n\nerr:\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\n\tif (ret)\n\t\tbpf_lru_push_free(&htab->lru, &l_new->lru_node);\n\telse if (l_old)\n\t\tbpf_lru_push_free(&htab->lru, &l_old->lru_node);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "htab_map_update_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "811-865",
    "snippet": "static int htab_map_update_elem(struct bpf_map *map, void *key, void *value,\n\t\t\t\tu64 map_flags)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l_new = NULL, *l_old;\n\tstruct hlist_nulls_head *head;\n\tunsigned long flags;\n\tstruct bucket *b;\n\tu32 key_size, hash;\n\tint ret;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\t/* bpf_map_update_elem() can be called in_irq() */\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl_old = lookup_elem_raw(head, hash, key, key_size);\n\n\tret = check_flags(htab, l_old, map_flags);\n\tif (ret)\n\t\tgoto err;\n\n\tl_new = alloc_htab_elem(htab, key, value, key_size, hash, false, false,\n\t\t\t\tl_old);\n\tif (IS_ERR(l_new)) {\n\t\t/* all pre-allocated elements are in use or memory exhausted */\n\t\tret = PTR_ERR(l_new);\n\t\tgoto err;\n\t}\n\n\t/* add new element to the head of the list, so that\n\t * concurrent search will find it before old elem\n\t */\n\thlist_nulls_add_head_rcu(&l_new->hash_node, head);\n\tif (l_old) {\n\t\thlist_nulls_del_rcu(&l_old->hash_node);\n\t\tif (!htab_is_prealloc(htab))\n\t\t\tfree_htab_elem(htab, l_old);\n\t}\n\tret = 0;\nerr:\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&b->lock",
            "flags"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_htab_elem",
          "args": [
            "htab",
            "l_old"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "free_htab_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "669-686",
          "snippet": "static void free_htab_elem(struct bpf_htab *htab, struct htab_elem *l)\n{\n\tstruct bpf_map *map = &htab->map;\n\n\tif (map->ops->map_fd_put_ptr) {\n\t\tvoid *ptr = fd_htab_map_get_ptr(map, l);\n\n\t\tmap->ops->map_fd_put_ptr(ptr);\n\t}\n\n\tif (htab_is_prealloc(htab)) {\n\t\tpcpu_freelist_push(&htab->freelist, &l->fnode);\n\t} else {\n\t\tatomic_dec(&htab->count);\n\t\tl->htab = htab;\n\t\tcall_rcu(&l->rcu, htab_elem_free_rcu);\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void free_htab_elem(struct bpf_htab *htab, struct htab_elem *l)\n{\n\tstruct bpf_map *map = &htab->map;\n\n\tif (map->ops->map_fd_put_ptr) {\n\t\tvoid *ptr = fd_htab_map_get_ptr(map, l);\n\n\t\tmap->ops->map_fd_put_ptr(ptr);\n\t}\n\n\tif (htab_is_prealloc(htab)) {\n\t\tpcpu_freelist_push(&htab->freelist, &l->fnode);\n\t} else {\n\t\tatomic_dec(&htab->count);\n\t\tl->htab = htab;\n\t\tcall_rcu(&l->rcu, htab_elem_free_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_is_prealloc",
          "args": [
            "htab"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "htab_is_prealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "82-85",
          "snippet": "static bool htab_is_prealloc(const struct bpf_htab *htab)\n{\n\treturn !(htab->map.map_flags & BPF_F_NO_PREALLOC);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool htab_is_prealloc(const struct bpf_htab *htab)\n{\n\treturn !(htab->map.map_flags & BPF_F_NO_PREALLOC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_nulls_del_rcu",
          "args": [
            "&l_old->hash_node"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_nulls_add_head_rcu",
          "args": [
            "&l_new->hash_node",
            "head"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "l_new"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "l_new"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_htab_elem",
          "args": [
            "htab",
            "key",
            "value",
            "key_size",
            "hash",
            "false",
            "false",
            "l_old"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_htab_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "721-794",
          "snippet": "static struct htab_elem *alloc_htab_elem(struct bpf_htab *htab, void *key,\n\t\t\t\t\t void *value, u32 key_size, u32 hash,\n\t\t\t\t\t bool percpu, bool onallcpus,\n\t\t\t\t\t struct htab_elem *old_elem)\n{\n\tu32 size = htab_size_value(htab, percpu);\n\tbool prealloc = htab_is_prealloc(htab);\n\tstruct htab_elem *l_new, **pl_new;\n\tvoid __percpu *pptr;\n\n\tif (prealloc) {\n\t\tif (old_elem) {\n\t\t\t/* if we're updating the existing element,\n\t\t\t * use per-cpu extra elems to avoid freelist_pop/push\n\t\t\t */\n\t\t\tpl_new = this_cpu_ptr(htab->extra_elems);\n\t\t\tl_new = *pl_new;\n\t\t\t*pl_new = old_elem;\n\t\t} else {\n\t\t\tstruct pcpu_freelist_node *l;\n\n\t\t\tl = pcpu_freelist_pop(&htab->freelist);\n\t\t\tif (!l)\n\t\t\t\treturn ERR_PTR(-E2BIG);\n\t\t\tl_new = container_of(l, struct htab_elem, fnode);\n\t\t}\n\t} else {\n\t\tif (atomic_inc_return(&htab->count) > htab->map.max_entries)\n\t\t\tif (!old_elem) {\n\t\t\t\t/* when map is full and update() is replacing\n\t\t\t\t * old element, it's ok to allocate, since\n\t\t\t\t * old element will be freed immediately.\n\t\t\t\t * Otherwise return an error\n\t\t\t\t */\n\t\t\t\tl_new = ERR_PTR(-E2BIG);\n\t\t\t\tgoto dec_count;\n\t\t\t}\n\t\tl_new = kmalloc_node(htab->elem_size, GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t\t     htab->map.numa_node);\n\t\tif (!l_new) {\n\t\t\tl_new = ERR_PTR(-ENOMEM);\n\t\t\tgoto dec_count;\n\t\t}\n\t}\n\n\tmemcpy(l_new->key, key, key_size);\n\tif (percpu) {\n\t\tif (prealloc) {\n\t\t\tpptr = htab_elem_get_ptr(l_new, key_size);\n\t\t} else {\n\t\t\t/* alloc_percpu zero-fills */\n\t\t\tpptr = __alloc_percpu_gfp(size, 8,\n\t\t\t\t\t\t  GFP_ATOMIC | __GFP_NOWARN);\n\t\t\tif (!pptr) {\n\t\t\t\tkfree(l_new);\n\t\t\t\tl_new = ERR_PTR(-ENOMEM);\n\t\t\t\tgoto dec_count;\n\t\t\t}\n\t\t}\n\n\t\tpcpu_copy_value(htab, pptr, value, onallcpus);\n\n\t\tif (!prealloc)\n\t\t\thtab_elem_set_ptr(l_new, key_size, pptr);\n\t} else {\n\t\tmemcpy(l_new->key + round_up(key_size, 8), value, size);\n\t}\n\n\tl_new->hash = hash;\n\treturn l_new;\ndec_count:\n\tatomic_dec(&htab->count);\n\treturn l_new;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct htab_elem *alloc_htab_elem(struct bpf_htab *htab, void *key,\n\t\t\t\t\t void *value, u32 key_size, u32 hash,\n\t\t\t\t\t bool percpu, bool onallcpus,\n\t\t\t\t\t struct htab_elem *old_elem)\n{\n\tu32 size = htab_size_value(htab, percpu);\n\tbool prealloc = htab_is_prealloc(htab);\n\tstruct htab_elem *l_new, **pl_new;\n\tvoid __percpu *pptr;\n\n\tif (prealloc) {\n\t\tif (old_elem) {\n\t\t\t/* if we're updating the existing element,\n\t\t\t * use per-cpu extra elems to avoid freelist_pop/push\n\t\t\t */\n\t\t\tpl_new = this_cpu_ptr(htab->extra_elems);\n\t\t\tl_new = *pl_new;\n\t\t\t*pl_new = old_elem;\n\t\t} else {\n\t\t\tstruct pcpu_freelist_node *l;\n\n\t\t\tl = pcpu_freelist_pop(&htab->freelist);\n\t\t\tif (!l)\n\t\t\t\treturn ERR_PTR(-E2BIG);\n\t\t\tl_new = container_of(l, struct htab_elem, fnode);\n\t\t}\n\t} else {\n\t\tif (atomic_inc_return(&htab->count) > htab->map.max_entries)\n\t\t\tif (!old_elem) {\n\t\t\t\t/* when map is full and update() is replacing\n\t\t\t\t * old element, it's ok to allocate, since\n\t\t\t\t * old element will be freed immediately.\n\t\t\t\t * Otherwise return an error\n\t\t\t\t */\n\t\t\t\tl_new = ERR_PTR(-E2BIG);\n\t\t\t\tgoto dec_count;\n\t\t\t}\n\t\tl_new = kmalloc_node(htab->elem_size, GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t\t     htab->map.numa_node);\n\t\tif (!l_new) {\n\t\t\tl_new = ERR_PTR(-ENOMEM);\n\t\t\tgoto dec_count;\n\t\t}\n\t}\n\n\tmemcpy(l_new->key, key, key_size);\n\tif (percpu) {\n\t\tif (prealloc) {\n\t\t\tpptr = htab_elem_get_ptr(l_new, key_size);\n\t\t} else {\n\t\t\t/* alloc_percpu zero-fills */\n\t\t\tpptr = __alloc_percpu_gfp(size, 8,\n\t\t\t\t\t\t  GFP_ATOMIC | __GFP_NOWARN);\n\t\t\tif (!pptr) {\n\t\t\t\tkfree(l_new);\n\t\t\t\tl_new = ERR_PTR(-ENOMEM);\n\t\t\t\tgoto dec_count;\n\t\t\t}\n\t\t}\n\n\t\tpcpu_copy_value(htab, pptr, value, onallcpus);\n\n\t\tif (!prealloc)\n\t\t\thtab_elem_set_ptr(l_new, key_size, pptr);\n\t} else {\n\t\tmemcpy(l_new->key + round_up(key_size, 8), value, size);\n\t}\n\n\tl_new->hash = hash;\n\treturn l_new;\ndec_count:\n\tatomic_dec(&htab->count);\n\treturn l_new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flags",
          "args": [
            "htab",
            "l_old",
            "map_flags"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "796-808",
          "snippet": "static int check_flags(struct bpf_htab *htab, struct htab_elem *l_old,\n\t\t       u64 map_flags)\n{\n\tif (l_old && map_flags == BPF_NOEXIST)\n\t\t/* elem already exists */\n\t\treturn -EEXIST;\n\n\tif (!l_old && map_flags == BPF_EXIST)\n\t\t/* elem doesn't exist, cannot update it */\n\t\treturn -ENOENT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int check_flags(struct bpf_htab *htab, struct htab_elem *l_old,\n\t\t       u64 map_flags)\n{\n\tif (l_old && map_flags == BPF_NOEXIST)\n\t\t/* elem already exists */\n\t\treturn -EEXIST;\n\n\tif (!l_old && map_flags == BPF_EXIST)\n\t\t/* elem doesn't exist, cannot update it */\n\t\treturn -ENOENT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_elem_raw",
          "args": [
            "head",
            "hash",
            "key",
            "key_size"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_elem_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "424-435",
          "snippet": "static struct htab_elem *lookup_elem_raw(struct hlist_nulls_head *head, u32 hash,\n\t\t\t\t\t void *key, u32 key_size)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct htab_elem *lookup_elem_raw(struct hlist_nulls_head *head, u32 hash,\n\t\t\t\t\t void *key, u32 key_size)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&b->lock",
            "flags"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__select_bucket",
          "args": [
            "htab",
            "hash"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "__select_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "413-416",
          "snippet": "static inline struct bucket *__select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &htab->buckets[hash & (htab->n_buckets - 1)];\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline struct bucket *__select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &htab->buckets[hash & (htab->n_buckets - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_map_hash",
          "args": [
            "key",
            "key_size",
            "htab->hashrnd"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "htab_map_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "408-411",
          "snippet": "static inline u32 htab_map_hash(const void *key, u32 key_len, u32 hashrnd)\n{\n\treturn jhash(key, key_len, hashrnd);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline u32 htab_map_hash(const void *key, u32 key_len, u32 hashrnd)\n{\n\treturn jhash(key, key_len, hashrnd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_read_lock_held()"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_held",
          "args": [],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "273-282",
          "snippet": "int rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "map_flags > BPF_EXIST"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_htab",
            "map"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int htab_map_update_elem(struct bpf_map *map, void *key, void *value,\n\t\t\t\tu64 map_flags)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l_new = NULL, *l_old;\n\tstruct hlist_nulls_head *head;\n\tunsigned long flags;\n\tstruct bucket *b;\n\tu32 key_size, hash;\n\tint ret;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\tb = __select_bucket(htab, hash);\n\thead = &b->head;\n\n\t/* bpf_map_update_elem() can be called in_irq() */\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\tl_old = lookup_elem_raw(head, hash, key, key_size);\n\n\tret = check_flags(htab, l_old, map_flags);\n\tif (ret)\n\t\tgoto err;\n\n\tl_new = alloc_htab_elem(htab, key, value, key_size, hash, false, false,\n\t\t\t\tl_old);\n\tif (IS_ERR(l_new)) {\n\t\t/* all pre-allocated elements are in use or memory exhausted */\n\t\tret = PTR_ERR(l_new);\n\t\tgoto err;\n\t}\n\n\t/* add new element to the head of the list, so that\n\t * concurrent search will find it before old elem\n\t */\n\thlist_nulls_add_head_rcu(&l_new->hash_node, head);\n\tif (l_old) {\n\t\thlist_nulls_del_rcu(&l_old->hash_node);\n\t\tif (!htab_is_prealloc(htab))\n\t\t\tfree_htab_elem(htab, l_old);\n\t}\n\tret = 0;\nerr:\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "check_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "796-808",
    "snippet": "static int check_flags(struct bpf_htab *htab, struct htab_elem *l_old,\n\t\t       u64 map_flags)\n{\n\tif (l_old && map_flags == BPF_NOEXIST)\n\t\t/* elem already exists */\n\t\treturn -EEXIST;\n\n\tif (!l_old && map_flags == BPF_EXIST)\n\t\t/* elem doesn't exist, cannot update it */\n\t\treturn -ENOENT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int check_flags(struct bpf_htab *htab, struct htab_elem *l_old,\n\t\t       u64 map_flags)\n{\n\tif (l_old && map_flags == BPF_NOEXIST)\n\t\t/* elem already exists */\n\t\treturn -EEXIST;\n\n\tif (!l_old && map_flags == BPF_EXIST)\n\t\t/* elem doesn't exist, cannot update it */\n\t\treturn -ENOENT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "alloc_htab_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "721-794",
    "snippet": "static struct htab_elem *alloc_htab_elem(struct bpf_htab *htab, void *key,\n\t\t\t\t\t void *value, u32 key_size, u32 hash,\n\t\t\t\t\t bool percpu, bool onallcpus,\n\t\t\t\t\t struct htab_elem *old_elem)\n{\n\tu32 size = htab_size_value(htab, percpu);\n\tbool prealloc = htab_is_prealloc(htab);\n\tstruct htab_elem *l_new, **pl_new;\n\tvoid __percpu *pptr;\n\n\tif (prealloc) {\n\t\tif (old_elem) {\n\t\t\t/* if we're updating the existing element,\n\t\t\t * use per-cpu extra elems to avoid freelist_pop/push\n\t\t\t */\n\t\t\tpl_new = this_cpu_ptr(htab->extra_elems);\n\t\t\tl_new = *pl_new;\n\t\t\t*pl_new = old_elem;\n\t\t} else {\n\t\t\tstruct pcpu_freelist_node *l;\n\n\t\t\tl = pcpu_freelist_pop(&htab->freelist);\n\t\t\tif (!l)\n\t\t\t\treturn ERR_PTR(-E2BIG);\n\t\t\tl_new = container_of(l, struct htab_elem, fnode);\n\t\t}\n\t} else {\n\t\tif (atomic_inc_return(&htab->count) > htab->map.max_entries)\n\t\t\tif (!old_elem) {\n\t\t\t\t/* when map is full and update() is replacing\n\t\t\t\t * old element, it's ok to allocate, since\n\t\t\t\t * old element will be freed immediately.\n\t\t\t\t * Otherwise return an error\n\t\t\t\t */\n\t\t\t\tl_new = ERR_PTR(-E2BIG);\n\t\t\t\tgoto dec_count;\n\t\t\t}\n\t\tl_new = kmalloc_node(htab->elem_size, GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t\t     htab->map.numa_node);\n\t\tif (!l_new) {\n\t\t\tl_new = ERR_PTR(-ENOMEM);\n\t\t\tgoto dec_count;\n\t\t}\n\t}\n\n\tmemcpy(l_new->key, key, key_size);\n\tif (percpu) {\n\t\tif (prealloc) {\n\t\t\tpptr = htab_elem_get_ptr(l_new, key_size);\n\t\t} else {\n\t\t\t/* alloc_percpu zero-fills */\n\t\t\tpptr = __alloc_percpu_gfp(size, 8,\n\t\t\t\t\t\t  GFP_ATOMIC | __GFP_NOWARN);\n\t\t\tif (!pptr) {\n\t\t\t\tkfree(l_new);\n\t\t\t\tl_new = ERR_PTR(-ENOMEM);\n\t\t\t\tgoto dec_count;\n\t\t\t}\n\t\t}\n\n\t\tpcpu_copy_value(htab, pptr, value, onallcpus);\n\n\t\tif (!prealloc)\n\t\t\thtab_elem_set_ptr(l_new, key_size, pptr);\n\t} else {\n\t\tmemcpy(l_new->key + round_up(key_size, 8), value, size);\n\t}\n\n\tl_new->hash = hash;\n\treturn l_new;\ndec_count:\n\tatomic_dec(&htab->count);\n\treturn l_new;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&htab->count"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "l_new->key + round_up(key_size, 8)",
            "value",
            "size"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "key_size",
            "8"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htab_elem_set_ptr",
          "args": [
            "l_new",
            "key_size",
            "pptr"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "htab_elem_set_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "87-91",
          "snippet": "static inline void htab_elem_set_ptr(struct htab_elem *l, u32 key_size,\n\t\t\t\t     void __percpu *pptr)\n{\n\t*(void __percpu **)(l->key + key_size) = pptr;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline void htab_elem_set_ptr(struct htab_elem *l, u32 key_size,\n\t\t\t\t     void __percpu *pptr)\n{\n\t*(void __percpu **)(l->key + key_size) = pptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_copy_value",
          "args": [
            "htab",
            "pptr",
            "value",
            "onallcpus"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_copy_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "688-704",
          "snippet": "static void pcpu_copy_value(struct bpf_htab *htab, void __percpu *pptr,\n\t\t\t    void *value, bool onallcpus)\n{\n\tif (!onallcpus) {\n\t\t/* copy true value_size bytes */\n\t\tmemcpy(this_cpu_ptr(pptr), value, htab->map.value_size);\n\t} else {\n\t\tu32 size = round_up(htab->map.value_size, 8);\n\t\tint off = 0, cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tbpf_long_memcpy(per_cpu_ptr(pptr, cpu),\n\t\t\t\t\tvalue + off, size);\n\t\t\toff += size;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void pcpu_copy_value(struct bpf_htab *htab, void __percpu *pptr,\n\t\t\t    void *value, bool onallcpus)\n{\n\tif (!onallcpus) {\n\t\t/* copy true value_size bytes */\n\t\tmemcpy(this_cpu_ptr(pptr), value, htab->map.value_size);\n\t} else {\n\t\tu32 size = round_up(htab->map.value_size, 8);\n\t\tint off = 0, cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tbpf_long_memcpy(per_cpu_ptr(pptr, cpu),\n\t\t\t\t\tvalue + off, size);\n\t\t\toff += size;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "l_new"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__alloc_percpu_gfp",
          "args": [
            "size",
            "8",
            "GFP_ATOMIC | __GFP_NOWARN"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htab_elem_get_ptr",
          "args": [
            "l_new",
            "key_size"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "htab_elem_get_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "93-96",
          "snippet": "static inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "htab->elem_size",
            "GFP_ATOMIC | __GFP_NOWARN",
            "htab->map.numa_node"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-E2BIG"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&htab->count"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "l",
            "structhtab_elem",
            "fnode"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-E2BIG"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_freelist_pop",
          "args": [
            "&htab->freelist"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_freelist_pop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/percpu_freelist.c",
          "lines": "77-104",
          "snippet": "struct pcpu_freelist_node *pcpu_freelist_pop(struct pcpu_freelist *s)\n{\n\tstruct pcpu_freelist_head *head;\n\tstruct pcpu_freelist_node *node;\n\tunsigned long flags;\n\tint orig_cpu, cpu;\n\n\tlocal_irq_save(flags);\n\torig_cpu = cpu = raw_smp_processor_id();\n\twhile (1) {\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\traw_spin_lock(&head->lock);\n\t\tnode = head->first;\n\t\tif (node) {\n\t\t\thead->first = node->next;\n\t\t\traw_spin_unlock_irqrestore(&head->lock, flags);\n\t\t\treturn node;\n\t\t}\n\t\traw_spin_unlock(&head->lock);\n\t\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\tcpu = 0;\n\t\tif (cpu == orig_cpu) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nstruct pcpu_freelist_node *pcpu_freelist_pop(struct pcpu_freelist *s)\n{\n\tstruct pcpu_freelist_head *head;\n\tstruct pcpu_freelist_node *node;\n\tunsigned long flags;\n\tint orig_cpu, cpu;\n\n\tlocal_irq_save(flags);\n\torig_cpu = cpu = raw_smp_processor_id();\n\twhile (1) {\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\traw_spin_lock(&head->lock);\n\t\tnode = head->first;\n\t\tif (node) {\n\t\t\thead->first = node->next;\n\t\t\traw_spin_unlock_irqrestore(&head->lock, flags);\n\t\t\treturn node;\n\t\t}\n\t\traw_spin_unlock(&head->lock);\n\t\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\tcpu = 0;\n\t\tif (cpu == orig_cpu) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "htab->extra_elems"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htab_is_prealloc",
          "args": [
            "htab"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "htab_is_prealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "82-85",
          "snippet": "static bool htab_is_prealloc(const struct bpf_htab *htab)\n{\n\treturn !(htab->map.map_flags & BPF_F_NO_PREALLOC);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool htab_is_prealloc(const struct bpf_htab *htab)\n{\n\treturn !(htab->map.map_flags & BPF_F_NO_PREALLOC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_size_value",
          "args": [
            "htab",
            "percpu"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "htab_size_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "712-719",
          "snippet": "static u32 htab_size_value(const struct bpf_htab *htab, bool percpu)\n{\n\tu32 size = htab->map.value_size;\n\n\tif (percpu || fd_htab_map_needs_adjust(htab))\n\t\tsize = round_up(size, 8);\n\treturn size;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic u32 htab_size_value(const struct bpf_htab *htab, bool percpu)\n{\n\tu32 size = htab->map.value_size;\n\n\tif (percpu || fd_htab_map_needs_adjust(htab))\n\t\tsize = round_up(size, 8);\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct htab_elem *alloc_htab_elem(struct bpf_htab *htab, void *key,\n\t\t\t\t\t void *value, u32 key_size, u32 hash,\n\t\t\t\t\t bool percpu, bool onallcpus,\n\t\t\t\t\t struct htab_elem *old_elem)\n{\n\tu32 size = htab_size_value(htab, percpu);\n\tbool prealloc = htab_is_prealloc(htab);\n\tstruct htab_elem *l_new, **pl_new;\n\tvoid __percpu *pptr;\n\n\tif (prealloc) {\n\t\tif (old_elem) {\n\t\t\t/* if we're updating the existing element,\n\t\t\t * use per-cpu extra elems to avoid freelist_pop/push\n\t\t\t */\n\t\t\tpl_new = this_cpu_ptr(htab->extra_elems);\n\t\t\tl_new = *pl_new;\n\t\t\t*pl_new = old_elem;\n\t\t} else {\n\t\t\tstruct pcpu_freelist_node *l;\n\n\t\t\tl = pcpu_freelist_pop(&htab->freelist);\n\t\t\tif (!l)\n\t\t\t\treturn ERR_PTR(-E2BIG);\n\t\t\tl_new = container_of(l, struct htab_elem, fnode);\n\t\t}\n\t} else {\n\t\tif (atomic_inc_return(&htab->count) > htab->map.max_entries)\n\t\t\tif (!old_elem) {\n\t\t\t\t/* when map is full and update() is replacing\n\t\t\t\t * old element, it's ok to allocate, since\n\t\t\t\t * old element will be freed immediately.\n\t\t\t\t * Otherwise return an error\n\t\t\t\t */\n\t\t\t\tl_new = ERR_PTR(-E2BIG);\n\t\t\t\tgoto dec_count;\n\t\t\t}\n\t\tl_new = kmalloc_node(htab->elem_size, GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t\t     htab->map.numa_node);\n\t\tif (!l_new) {\n\t\t\tl_new = ERR_PTR(-ENOMEM);\n\t\t\tgoto dec_count;\n\t\t}\n\t}\n\n\tmemcpy(l_new->key, key, key_size);\n\tif (percpu) {\n\t\tif (prealloc) {\n\t\t\tpptr = htab_elem_get_ptr(l_new, key_size);\n\t\t} else {\n\t\t\t/* alloc_percpu zero-fills */\n\t\t\tpptr = __alloc_percpu_gfp(size, 8,\n\t\t\t\t\t\t  GFP_ATOMIC | __GFP_NOWARN);\n\t\t\tif (!pptr) {\n\t\t\t\tkfree(l_new);\n\t\t\t\tl_new = ERR_PTR(-ENOMEM);\n\t\t\t\tgoto dec_count;\n\t\t\t}\n\t\t}\n\n\t\tpcpu_copy_value(htab, pptr, value, onallcpus);\n\n\t\tif (!prealloc)\n\t\t\thtab_elem_set_ptr(l_new, key_size, pptr);\n\t} else {\n\t\tmemcpy(l_new->key + round_up(key_size, 8), value, size);\n\t}\n\n\tl_new->hash = hash;\n\treturn l_new;\ndec_count:\n\tatomic_dec(&htab->count);\n\treturn l_new;\n}"
  },
  {
    "function_name": "htab_size_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "712-719",
    "snippet": "static u32 htab_size_value(const struct bpf_htab *htab, bool percpu)\n{\n\tu32 size = htab->map.value_size;\n\n\tif (percpu || fd_htab_map_needs_adjust(htab))\n\t\tsize = round_up(size, 8);\n\treturn size;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "size",
            "8"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd_htab_map_needs_adjust",
          "args": [
            "htab"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "fd_htab_map_needs_adjust",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "706-710",
          "snippet": "static bool fd_htab_map_needs_adjust(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_HASH_OF_MAPS &&\n\t       BITS_PER_LONG == 64;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool fd_htab_map_needs_adjust(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_HASH_OF_MAPS &&\n\t       BITS_PER_LONG == 64;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic u32 htab_size_value(const struct bpf_htab *htab, bool percpu)\n{\n\tu32 size = htab->map.value_size;\n\n\tif (percpu || fd_htab_map_needs_adjust(htab))\n\t\tsize = round_up(size, 8);\n\treturn size;\n}"
  },
  {
    "function_name": "fd_htab_map_needs_adjust",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "706-710",
    "snippet": "static bool fd_htab_map_needs_adjust(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_HASH_OF_MAPS &&\n\t       BITS_PER_LONG == 64;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool fd_htab_map_needs_adjust(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_HASH_OF_MAPS &&\n\t       BITS_PER_LONG == 64;\n}"
  },
  {
    "function_name": "pcpu_copy_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "688-704",
    "snippet": "static void pcpu_copy_value(struct bpf_htab *htab, void __percpu *pptr,\n\t\t\t    void *value, bool onallcpus)\n{\n\tif (!onallcpus) {\n\t\t/* copy true value_size bytes */\n\t\tmemcpy(this_cpu_ptr(pptr), value, htab->map.value_size);\n\t} else {\n\t\tu32 size = round_up(htab->map.value_size, 8);\n\t\tint off = 0, cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tbpf_long_memcpy(per_cpu_ptr(pptr, cpu),\n\t\t\t\t\tvalue + off, size);\n\t\t\toff += size;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_long_memcpy",
          "args": [
            "per_cpu_ptr(pptr, cpu)",
            "value + off",
            "size"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pptr",
            "cpu"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "htab->map.value_size",
            "8"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "this_cpu_ptr(pptr)",
            "value",
            "htab->map.value_size"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "pptr"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void pcpu_copy_value(struct bpf_htab *htab, void __percpu *pptr,\n\t\t\t    void *value, bool onallcpus)\n{\n\tif (!onallcpus) {\n\t\t/* copy true value_size bytes */\n\t\tmemcpy(this_cpu_ptr(pptr), value, htab->map.value_size);\n\t} else {\n\t\tu32 size = round_up(htab->map.value_size, 8);\n\t\tint off = 0, cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tbpf_long_memcpy(per_cpu_ptr(pptr, cpu),\n\t\t\t\t\tvalue + off, size);\n\t\t\toff += size;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "free_htab_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "669-686",
    "snippet": "static void free_htab_elem(struct bpf_htab *htab, struct htab_elem *l)\n{\n\tstruct bpf_map *map = &htab->map;\n\n\tif (map->ops->map_fd_put_ptr) {\n\t\tvoid *ptr = fd_htab_map_get_ptr(map, l);\n\n\t\tmap->ops->map_fd_put_ptr(ptr);\n\t}\n\n\tif (htab_is_prealloc(htab)) {\n\t\tpcpu_freelist_push(&htab->freelist, &l->fnode);\n\t} else {\n\t\tatomic_dec(&htab->count);\n\t\tl->htab = htab;\n\t\tcall_rcu(&l->rcu, htab_elem_free_rcu);\n\t}\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&l->rcu",
            "htab_elem_free_rcu"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&htab->count"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_freelist_push",
          "args": [
            "&htab->freelist",
            "&l->fnode"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_freelist_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/percpu_freelist.c",
          "lines": "40-46",
          "snippet": "void pcpu_freelist_push(struct pcpu_freelist *s,\n\t\t\tstruct pcpu_freelist_node *node)\n{\n\tstruct pcpu_freelist_head *head = this_cpu_ptr(s->freelist);\n\n\t__pcpu_freelist_push(head, node);\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nvoid pcpu_freelist_push(struct pcpu_freelist *s,\n\t\t\tstruct pcpu_freelist_node *node)\n{\n\tstruct pcpu_freelist_head *head = this_cpu_ptr(s->freelist);\n\n\t__pcpu_freelist_push(head, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_is_prealloc",
          "args": [
            "htab"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "htab_is_prealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "82-85",
          "snippet": "static bool htab_is_prealloc(const struct bpf_htab *htab)\n{\n\treturn !(htab->map.map_flags & BPF_F_NO_PREALLOC);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool htab_is_prealloc(const struct bpf_htab *htab)\n{\n\treturn !(htab->map.map_flags & BPF_F_NO_PREALLOC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_fd_put_ptr",
          "args": [
            "ptr"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd_htab_map_get_ptr",
          "args": [
            "map",
            "l"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "fd_htab_map_get_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "98-101",
          "snippet": "static void *fd_htab_map_get_ptr(const struct bpf_map *map, struct htab_elem *l)\n{\n\treturn *(void **)(l->key + roundup(map->key_size, 8));\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *fd_htab_map_get_ptr(const struct bpf_map *map, struct htab_elem *l)\n{\n\treturn *(void **)(l->key + roundup(map->key_size, 8));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void free_htab_elem(struct bpf_htab *htab, struct htab_elem *l)\n{\n\tstruct bpf_map *map = &htab->map;\n\n\tif (map->ops->map_fd_put_ptr) {\n\t\tvoid *ptr = fd_htab_map_get_ptr(map, l);\n\n\t\tmap->ops->map_fd_put_ptr(ptr);\n\t}\n\n\tif (htab_is_prealloc(htab)) {\n\t\tpcpu_freelist_push(&htab->freelist, &l->fnode);\n\t} else {\n\t\tatomic_dec(&htab->count);\n\t\tl->htab = htab;\n\t\tcall_rcu(&l->rcu, htab_elem_free_rcu);\n\t}\n}"
  },
  {
    "function_name": "htab_elem_free_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "653-667",
    "snippet": "static void htab_elem_free_rcu(struct rcu_head *head)\n{\n\tstruct htab_elem *l = container_of(head, struct htab_elem, rcu);\n\tstruct bpf_htab *htab = l->htab;\n\n\t/* must increment bpf_prog_active to avoid kprobe+bpf triggering while\n\t * we're calling kfree, otherwise deadlock is possible if kprobes\n\t * are placed somewhere inside of slub\n\t */\n\tpreempt_disable();\n\t__this_cpu_inc(bpf_prog_active);\n\thtab_elem_free(htab, l);\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "bpf_prog_active"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htab_elem_free",
          "args": [
            "htab",
            "l"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "htab_elem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "646-651",
          "snippet": "static void htab_elem_free(struct bpf_htab *htab, struct htab_elem *l)\n{\n\tif (htab->map.map_type == BPF_MAP_TYPE_PERCPU_HASH)\n\t\tfree_percpu(htab_elem_get_ptr(l, htab->map.key_size));\n\tkfree(l);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void htab_elem_free(struct bpf_htab *htab, struct htab_elem *l)\n{\n\tif (htab->map.map_type == BPF_MAP_TYPE_PERCPU_HASH)\n\t\tfree_percpu(htab_elem_get_ptr(l, htab->map.key_size));\n\tkfree(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "bpf_prog_active"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structhtab_elem",
            "rcu"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void htab_elem_free_rcu(struct rcu_head *head)\n{\n\tstruct htab_elem *l = container_of(head, struct htab_elem, rcu);\n\tstruct bpf_htab *htab = l->htab;\n\n\t/* must increment bpf_prog_active to avoid kprobe+bpf triggering while\n\t * we're calling kfree, otherwise deadlock is possible if kprobes\n\t * are placed somewhere inside of slub\n\t */\n\tpreempt_disable();\n\t__this_cpu_inc(bpf_prog_active);\n\thtab_elem_free(htab, l);\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "htab_elem_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "646-651",
    "snippet": "static void htab_elem_free(struct bpf_htab *htab, struct htab_elem *l)\n{\n\tif (htab->map.map_type == BPF_MAP_TYPE_PERCPU_HASH)\n\t\tfree_percpu(htab_elem_get_ptr(l, htab->map.key_size));\n\tkfree(l);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "l"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "htab_elem_get_ptr(l, htab->map.key_size)"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_elem_get_ptr",
          "args": [
            "l",
            "htab->map.key_size"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "htab_elem_get_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "93-96",
          "snippet": "static inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void htab_elem_free(struct bpf_htab *htab, struct htab_elem *l)\n{\n\tif (htab->map.map_type == BPF_MAP_TYPE_PERCPU_HASH)\n\t\tfree_percpu(htab_elem_get_ptr(l, htab->map.key_size));\n\tkfree(l);\n}"
  },
  {
    "function_name": "htab_map_get_next_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "588-644",
    "snippet": "static int htab_map_get_next_key(struct bpf_map *map, void *key, void *next_key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l, *next_l;\n\tu32 hash, key_size;\n\tint i = 0;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\tif (!key)\n\t\tgoto find_first_elem;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\thead = select_bucket(htab, hash);\n\n\t/* lookup the key */\n\tl = lookup_nulls_elem_raw(head, hash, key, key_size, htab->n_buckets);\n\n\tif (!l)\n\t\tgoto find_first_elem;\n\n\t/* key was found, get next key in the same bucket */\n\tnext_l = hlist_nulls_entry_safe(rcu_dereference_raw(hlist_nulls_next_rcu(&l->hash_node)),\n\t\t\t\t  struct htab_elem, hash_node);\n\n\tif (next_l) {\n\t\t/* if next elem in this hash list is non-zero, just return it */\n\t\tmemcpy(next_key, next_l->key, key_size);\n\t\treturn 0;\n\t}\n\n\t/* no more elements in this hash list, go to the next bucket */\n\ti = hash & (htab->n_buckets - 1);\n\ti++;\n\nfind_first_elem:\n\t/* iterate over buckets */\n\tfor (; i < htab->n_buckets; i++) {\n\t\thead = select_bucket(htab, i);\n\n\t\t/* pick first element in the bucket */\n\t\tnext_l = hlist_nulls_entry_safe(rcu_dereference_raw(hlist_nulls_first_rcu(head)),\n\t\t\t\t\t  struct htab_elem, hash_node);\n\t\tif (next_l) {\n\t\t\t/* if it's not empty, just return it */\n\t\t\tmemcpy(next_key, next_l->key, key_size);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* iterated over all buckets and all elements */\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "next_key",
            "next_l->key",
            "key_size"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_nulls_entry_safe",
          "args": [
            "rcu_dereference_raw(hlist_nulls_first_rcu(head))",
            "structhtab_elem",
            "hash_node"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "hlist_nulls_first_rcu(head)"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_nulls_first_rcu",
          "args": [
            "head"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select_bucket",
          "args": [
            "htab",
            "i"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "select_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "418-421",
          "snippet": "static inline struct hlist_nulls_head *select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &__select_bucket(htab, hash)->head;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline struct hlist_nulls_head *select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &__select_bucket(htab, hash)->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_nulls_entry_safe",
          "args": [
            "rcu_dereference_raw(hlist_nulls_next_rcu(&l->hash_node))",
            "structhtab_elem",
            "hash_node"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "hlist_nulls_next_rcu(&l->hash_node)"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_nulls_next_rcu",
          "args": [
            "&l->hash_node"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_nulls_elem_raw",
          "args": [
            "head",
            "hash",
            "key",
            "key_size",
            "htab->n_buckets"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_nulls_elem_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "441-457",
          "snippet": "static struct htab_elem *lookup_nulls_elem_raw(struct hlist_nulls_head *head,\n\t\t\t\t\t       u32 hash, void *key,\n\t\t\t\t\t       u32 key_size, u32 n_buckets)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\nagain:\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\tif (unlikely(get_nulls_value(n) != (hash & (n_buckets - 1))))\n\t\tgoto again;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct htab_elem *lookup_nulls_elem_raw(struct hlist_nulls_head *head,\n\t\t\t\t\t       u32 hash, void *key,\n\t\t\t\t\t       u32 key_size, u32 n_buckets)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\nagain:\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\tif (unlikely(get_nulls_value(n) != (hash & (n_buckets - 1))))\n\t\tgoto again;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_map_hash",
          "args": [
            "key",
            "key_size",
            "htab->hashrnd"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "htab_map_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "408-411",
          "snippet": "static inline u32 htab_map_hash(const void *key, u32 key_len, u32 hashrnd)\n{\n\treturn jhash(key, key_len, hashrnd);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline u32 htab_map_hash(const void *key, u32 key_len, u32 hashrnd)\n{\n\treturn jhash(key, key_len, hashrnd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_read_lock_held()"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_held",
          "args": [],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "273-282",
          "snippet": "int rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_htab",
            "map"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int htab_map_get_next_key(struct bpf_map *map, void *key, void *next_key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l, *next_l;\n\tu32 hash, key_size;\n\tint i = 0;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\tif (!key)\n\t\tgoto find_first_elem;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\thead = select_bucket(htab, hash);\n\n\t/* lookup the key */\n\tl = lookup_nulls_elem_raw(head, hash, key, key_size, htab->n_buckets);\n\n\tif (!l)\n\t\tgoto find_first_elem;\n\n\t/* key was found, get next key in the same bucket */\n\tnext_l = hlist_nulls_entry_safe(rcu_dereference_raw(hlist_nulls_next_rcu(&l->hash_node)),\n\t\t\t\t  struct htab_elem, hash_node);\n\n\tif (next_l) {\n\t\t/* if next elem in this hash list is non-zero, just return it */\n\t\tmemcpy(next_key, next_l->key, key_size);\n\t\treturn 0;\n\t}\n\n\t/* no more elements in this hash list, go to the next bucket */\n\ti = hash & (htab->n_buckets - 1);\n\ti++;\n\nfind_first_elem:\n\t/* iterate over buckets */\n\tfor (; i < htab->n_buckets; i++) {\n\t\thead = select_bucket(htab, i);\n\n\t\t/* pick first element in the bucket */\n\t\tnext_l = hlist_nulls_entry_safe(rcu_dereference_raw(hlist_nulls_first_rcu(head)),\n\t\t\t\t\t  struct htab_elem, hash_node);\n\t\tif (next_l) {\n\t\t\t/* if it's not empty, just return it */\n\t\t\tmemcpy(next_key, next_l->key, key_size);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* iterated over all buckets and all elements */\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "htab_lru_map_delete_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "561-585",
    "snippet": "static bool htab_lru_map_delete_node(void *arg, struct bpf_lru_node *node)\n{\n\tstruct bpf_htab *htab = (struct bpf_htab *)arg;\n\tstruct htab_elem *l = NULL, *tgt_l;\n\tstruct hlist_nulls_head *head;\n\tstruct hlist_nulls_node *n;\n\tunsigned long flags;\n\tstruct bucket *b;\n\n\ttgt_l = container_of(node, struct htab_elem, lru_node);\n\tb = __select_bucket(htab, tgt_l->hash);\n\thead = &b->head;\n\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l == tgt_l) {\n\t\t\thlist_nulls_del_rcu(&l->hash_node);\n\t\t\tbreak;\n\t\t}\n\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\n\treturn l == tgt_l;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool htab_lru_map_delete_node(void *arg, struct bpf_lru_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&b->lock",
            "flags"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_nulls_del_rcu",
          "args": [
            "&l->hash_node"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_nulls_for_each_entry_rcu",
          "args": [
            "l",
            "n",
            "head",
            "hash_node"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&b->lock",
            "flags"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__select_bucket",
          "args": [
            "htab",
            "tgt_l->hash"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "__select_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "413-416",
          "snippet": "static inline struct bucket *__select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &htab->buckets[hash & (htab->n_buckets - 1)];\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline struct bucket *__select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &htab->buckets[hash & (htab->n_buckets - 1)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "node",
            "structhtab_elem",
            "lru_node"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool htab_lru_map_delete_node(void *arg, struct bpf_lru_node *node);\n\nstatic bool htab_lru_map_delete_node(void *arg, struct bpf_lru_node *node)\n{\n\tstruct bpf_htab *htab = (struct bpf_htab *)arg;\n\tstruct htab_elem *l = NULL, *tgt_l;\n\tstruct hlist_nulls_head *head;\n\tstruct hlist_nulls_node *n;\n\tunsigned long flags;\n\tstruct bucket *b;\n\n\ttgt_l = container_of(node, struct htab_elem, lru_node);\n\tb = __select_bucket(htab, tgt_l->hash);\n\thead = &b->head;\n\n\traw_spin_lock_irqsave(&b->lock, flags);\n\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l == tgt_l) {\n\t\t\thlist_nulls_del_rcu(&l->hash_node);\n\t\t\tbreak;\n\t\t}\n\n\traw_spin_unlock_irqrestore(&b->lock, flags);\n\n\treturn l == tgt_l;\n}"
  },
  {
    "function_name": "htab_lru_map_gen_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "533-556",
    "snippet": "static u32 htab_lru_map_gen_lookup(struct bpf_map *map,\n\t\t\t\t   struct bpf_insn *insn_buf)\n{\n\tstruct bpf_insn *insn = insn_buf;\n\tconst int ret = BPF_REG_0;\n\tconst int ref_reg = BPF_REG_1;\n\n\tBUILD_BUG_ON(!__same_type(&__htab_map_lookup_elem,\n\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t*insn++ = BPF_EMIT_CALL(BPF_CAST_CALL(__htab_map_lookup_elem));\n\t*insn++ = BPF_JMP_IMM(BPF_JEQ, ret, 0, 4);\n\t*insn++ = BPF_LDX_MEM(BPF_B, ref_reg, ret,\n\t\t\t      offsetof(struct htab_elem, lru_node) +\n\t\t\t      offsetof(struct bpf_lru_node, ref));\n\t*insn++ = BPF_JMP_IMM(BPF_JNE, ref_reg, 0, 1);\n\t*insn++ = BPF_ST_MEM(BPF_B, ret,\n\t\t\t     offsetof(struct htab_elem, lru_node) +\n\t\t\t     offsetof(struct bpf_lru_node, ref),\n\t\t\t     1);\n\t*insn++ = BPF_ALU64_IMM(BPF_ADD, ret,\n\t\t\t\toffsetof(struct htab_elem, key) +\n\t\t\t\tround_up(map->key_size, 8));\n\treturn insn - insn_buf;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BPF_ALU64_IMM",
          "args": [
            "BPF_ADD",
            "ret",
            "offsetof(struct htab_elem, key) +\n\t\t\t\tround_up(map->key_size, 8)"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "map->key_size",
            "8"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ST_MEM",
          "args": [
            "BPF_B",
            "ret",
            "offsetof(struct htab_elem, lru_node) +\n\t\t\t     offsetof(struct bpf_lru_node, ref)",
            "1"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JMP_IMM",
          "args": [
            "BPF_JNE",
            "ref_reg",
            "0",
            "1"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_LDX_MEM",
          "args": [
            "BPF_B",
            "ref_reg",
            "ret",
            "offsetof(struct htab_elem, lru_node) +\n\t\t\t      offsetof(struct bpf_lru_node, ref)"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JMP_IMM",
          "args": [
            "BPF_JEQ",
            "ret",
            "0",
            "4"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_EMIT_CALL",
          "args": [
            "BPF_CAST_CALL(__htab_map_lookup_elem)"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_CAST_CALL",
          "args": [
            "__htab_map_lookup_elem"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "!__same_type(&__htab_map_lookup_elem,\n\t\t     (void *(*)(struct bpf_map *map, void *key))NULL)"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__same_type",
          "args": [
            "&__htab_map_lookup_elem",
            "(void *(*)(struct bpf_map *map, void *key))NULL"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic u32 htab_lru_map_gen_lookup(struct bpf_map *map,\n\t\t\t\t   struct bpf_insn *insn_buf)\n{\n\tstruct bpf_insn *insn = insn_buf;\n\tconst int ret = BPF_REG_0;\n\tconst int ref_reg = BPF_REG_1;\n\n\tBUILD_BUG_ON(!__same_type(&__htab_map_lookup_elem,\n\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t*insn++ = BPF_EMIT_CALL(BPF_CAST_CALL(__htab_map_lookup_elem));\n\t*insn++ = BPF_JMP_IMM(BPF_JEQ, ret, 0, 4);\n\t*insn++ = BPF_LDX_MEM(BPF_B, ref_reg, ret,\n\t\t\t      offsetof(struct htab_elem, lru_node) +\n\t\t\t      offsetof(struct bpf_lru_node, ref));\n\t*insn++ = BPF_JMP_IMM(BPF_JNE, ref_reg, 0, 1);\n\t*insn++ = BPF_ST_MEM(BPF_B, ret,\n\t\t\t     offsetof(struct htab_elem, lru_node) +\n\t\t\t     offsetof(struct bpf_lru_node, ref),\n\t\t\t     1);\n\t*insn++ = BPF_ALU64_IMM(BPF_ADD, ret,\n\t\t\t\toffsetof(struct htab_elem, key) +\n\t\t\t\tround_up(map->key_size, 8));\n\treturn insn - insn_buf;\n}"
  },
  {
    "function_name": "htab_lru_map_lookup_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "521-531",
    "snippet": "static void *htab_lru_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct htab_elem *l = __htab_map_lookup_elem(map, key);\n\n\tif (l) {\n\t\tbpf_lru_node_set_ref(&l->lru_node);\n\t\treturn l->key + round_up(map->key_size, 8);\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "map->key_size",
            "8"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_lru_node_set_ref",
          "args": [
            "&l->lru_node"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_node_set_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.h",
          "lines": "67-74",
          "snippet": "static inline void bpf_lru_node_set_ref(struct bpf_lru_node *node)\n{\n\t/* ref is an approximation on access frequency.  It does not\n\t * have to be very accurate.  Hence, no protection is used.\n\t */\n\tif (!node->ref)\n\t\tnode->ref = 1;\n}",
          "includes": [
            "#include <linux/spinlock_types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock_types.h>\n#include <linux/list.h>\n\nstatic inline void bpf_lru_node_set_ref(struct bpf_lru_node *node)\n{\n\t/* ref is an approximation on access frequency.  It does not\n\t * have to be very accurate.  Hence, no protection is used.\n\t */\n\tif (!node->ref)\n\t\tnode->ref = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__htab_map_lookup_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "__htab_map_lookup_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "464-483",
          "snippet": "static void *__htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tu32 hash, key_size;\n\n\t/* Must be called with rcu_read_lock. */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\thead = select_bucket(htab, hash);\n\n\tl = lookup_nulls_elem_raw(head, hash, key, key_size, htab->n_buckets);\n\n\treturn l;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *__htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tu32 hash, key_size;\n\n\t/* Must be called with rcu_read_lock. */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\thead = select_bucket(htab, hash);\n\n\tl = lookup_nulls_elem_raw(head, hash, key, key_size, htab->n_buckets);\n\n\treturn l;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *htab_lru_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct htab_elem *l = __htab_map_lookup_elem(map, key);\n\n\tif (l) {\n\t\tbpf_lru_node_set_ref(&l->lru_node);\n\t\treturn l->key + round_up(map->key_size, 8);\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "htab_map_gen_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "506-519",
    "snippet": "static u32 htab_map_gen_lookup(struct bpf_map *map, struct bpf_insn *insn_buf)\n{\n\tstruct bpf_insn *insn = insn_buf;\n\tconst int ret = BPF_REG_0;\n\n\tBUILD_BUG_ON(!__same_type(&__htab_map_lookup_elem,\n\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t*insn++ = BPF_EMIT_CALL(BPF_CAST_CALL(__htab_map_lookup_elem));\n\t*insn++ = BPF_JMP_IMM(BPF_JEQ, ret, 0, 1);\n\t*insn++ = BPF_ALU64_IMM(BPF_ADD, ret,\n\t\t\t\toffsetof(struct htab_elem, key) +\n\t\t\t\tround_up(map->key_size, 8));\n\treturn insn - insn_buf;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BPF_ALU64_IMM",
          "args": [
            "BPF_ADD",
            "ret",
            "offsetof(struct htab_elem, key) +\n\t\t\t\tround_up(map->key_size, 8)"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "map->key_size",
            "8"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JMP_IMM",
          "args": [
            "BPF_JEQ",
            "ret",
            "0",
            "1"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_EMIT_CALL",
          "args": [
            "BPF_CAST_CALL(__htab_map_lookup_elem)"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_CAST_CALL",
          "args": [
            "__htab_map_lookup_elem"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "!__same_type(&__htab_map_lookup_elem,\n\t\t     (void *(*)(struct bpf_map *map, void *key))NULL)"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__same_type",
          "args": [
            "&__htab_map_lookup_elem",
            "(void *(*)(struct bpf_map *map, void *key))NULL"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic u32 htab_map_gen_lookup(struct bpf_map *map, struct bpf_insn *insn_buf)\n{\n\tstruct bpf_insn *insn = insn_buf;\n\tconst int ret = BPF_REG_0;\n\n\tBUILD_BUG_ON(!__same_type(&__htab_map_lookup_elem,\n\t\t     (void *(*)(struct bpf_map *map, void *key))NULL));\n\t*insn++ = BPF_EMIT_CALL(BPF_CAST_CALL(__htab_map_lookup_elem));\n\t*insn++ = BPF_JMP_IMM(BPF_JEQ, ret, 0, 1);\n\t*insn++ = BPF_ALU64_IMM(BPF_ADD, ret,\n\t\t\t\toffsetof(struct htab_elem, key) +\n\t\t\t\tround_up(map->key_size, 8));\n\treturn insn - insn_buf;\n}"
  },
  {
    "function_name": "htab_map_lookup_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "485-493",
    "snippet": "static void *htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct htab_elem *l = __htab_map_lookup_elem(map, key);\n\n\tif (l)\n\t\treturn l->key + round_up(map->key_size, 8);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "map->key_size",
            "8"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__htab_map_lookup_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "__htab_map_lookup_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "464-483",
          "snippet": "static void *__htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tu32 hash, key_size;\n\n\t/* Must be called with rcu_read_lock. */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\thead = select_bucket(htab, hash);\n\n\tl = lookup_nulls_elem_raw(head, hash, key, key_size, htab->n_buckets);\n\n\treturn l;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *__htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tu32 hash, key_size;\n\n\t/* Must be called with rcu_read_lock. */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\thead = select_bucket(htab, hash);\n\n\tl = lookup_nulls_elem_raw(head, hash, key, key_size, htab->n_buckets);\n\n\treturn l;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct htab_elem *l = __htab_map_lookup_elem(map, key);\n\n\tif (l)\n\t\treturn l->key + round_up(map->key_size, 8);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "__htab_map_lookup_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "464-483",
    "snippet": "static void *__htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tu32 hash, key_size;\n\n\t/* Must be called with rcu_read_lock. */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\thead = select_bucket(htab, hash);\n\n\tl = lookup_nulls_elem_raw(head, hash, key, key_size, htab->n_buckets);\n\n\treturn l;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lookup_nulls_elem_raw",
          "args": [
            "head",
            "hash",
            "key",
            "key_size",
            "htab->n_buckets"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_nulls_elem_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "441-457",
          "snippet": "static struct htab_elem *lookup_nulls_elem_raw(struct hlist_nulls_head *head,\n\t\t\t\t\t       u32 hash, void *key,\n\t\t\t\t\t       u32 key_size, u32 n_buckets)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\nagain:\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\tif (unlikely(get_nulls_value(n) != (hash & (n_buckets - 1))))\n\t\tgoto again;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct htab_elem *lookup_nulls_elem_raw(struct hlist_nulls_head *head,\n\t\t\t\t\t       u32 hash, void *key,\n\t\t\t\t\t       u32 key_size, u32 n_buckets)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\nagain:\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\tif (unlikely(get_nulls_value(n) != (hash & (n_buckets - 1))))\n\t\tgoto again;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "select_bucket",
          "args": [
            "htab",
            "hash"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "select_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "418-421",
          "snippet": "static inline struct hlist_nulls_head *select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &__select_bucket(htab, hash)->head;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline struct hlist_nulls_head *select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &__select_bucket(htab, hash)->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_map_hash",
          "args": [
            "key",
            "key_size",
            "htab->hashrnd"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "htab_map_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "408-411",
          "snippet": "static inline u32 htab_map_hash(const void *key, u32 key_len, u32 hashrnd)\n{\n\treturn jhash(key, key_len, hashrnd);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline u32 htab_map_hash(const void *key, u32 key_len, u32 hashrnd)\n{\n\treturn jhash(key, key_len, hashrnd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!rcu_read_lock_held()"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_held",
          "args": [],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "273-282",
          "snippet": "int rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn lock_is_held(&rcu_lock_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_htab",
            "map"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *__htab_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct hlist_nulls_head *head;\n\tstruct htab_elem *l;\n\tu32 hash, key_size;\n\n\t/* Must be called with rcu_read_lock. */\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tkey_size = map->key_size;\n\n\thash = htab_map_hash(key, key_size, htab->hashrnd);\n\n\thead = select_bucket(htab, hash);\n\n\tl = lookup_nulls_elem_raw(head, hash, key, key_size, htab->n_buckets);\n\n\treturn l;\n}"
  },
  {
    "function_name": "lookup_nulls_elem_raw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "441-457",
    "snippet": "static struct htab_elem *lookup_nulls_elem_raw(struct hlist_nulls_head *head,\n\t\t\t\t\t       u32 hash, void *key,\n\t\t\t\t\t       u32 key_size, u32 n_buckets)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\nagain:\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\tif (unlikely(get_nulls_value(n) != (hash & (n_buckets - 1))))\n\t\tgoto again;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "get_nulls_value(n) != (hash & (n_buckets - 1))"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nulls_value",
          "args": [
            "n"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&l->key",
            "key",
            "key_size"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_nulls_for_each_entry_rcu",
          "args": [
            "l",
            "n",
            "head",
            "hash_node"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct htab_elem *lookup_nulls_elem_raw(struct hlist_nulls_head *head,\n\t\t\t\t\t       u32 hash, void *key,\n\t\t\t\t\t       u32 key_size, u32 n_buckets)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\nagain:\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\tif (unlikely(get_nulls_value(n) != (hash & (n_buckets - 1))))\n\t\tgoto again;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "lookup_elem_raw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "424-435",
    "snippet": "static struct htab_elem *lookup_elem_raw(struct hlist_nulls_head *head, u32 hash,\n\t\t\t\t\t void *key, u32 key_size)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&l->key",
            "key",
            "key_size"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_nulls_for_each_entry_rcu",
          "args": [
            "l",
            "n",
            "head",
            "hash_node"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct htab_elem *lookup_elem_raw(struct hlist_nulls_head *head, u32 hash,\n\t\t\t\t\t void *key, u32 key_size)\n{\n\tstruct hlist_nulls_node *n;\n\tstruct htab_elem *l;\n\n\thlist_nulls_for_each_entry_rcu(l, n, head, hash_node)\n\t\tif (l->hash == hash && !memcmp(&l->key, key, key_size))\n\t\t\treturn l;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "select_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "418-421",
    "snippet": "static inline struct hlist_nulls_head *select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &__select_bucket(htab, hash)->head;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__select_bucket",
          "args": [
            "htab",
            "hash"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "__select_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "413-416",
          "snippet": "static inline struct bucket *__select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &htab->buckets[hash & (htab->n_buckets - 1)];\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline struct bucket *__select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &htab->buckets[hash & (htab->n_buckets - 1)];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline struct hlist_nulls_head *select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &__select_bucket(htab, hash)->head;\n}"
  },
  {
    "function_name": "__select_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "413-416",
    "snippet": "static inline struct bucket *__select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &htab->buckets[hash & (htab->n_buckets - 1)];\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline struct bucket *__select_bucket(struct bpf_htab *htab, u32 hash)\n{\n\treturn &htab->buckets[hash & (htab->n_buckets - 1)];\n}"
  },
  {
    "function_name": "htab_map_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "408-411",
    "snippet": "static inline u32 htab_map_hash(const void *key, u32 key_len, u32 hashrnd)\n{\n\treturn jhash(key, key_len, hashrnd);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "key",
            "key_len",
            "hashrnd"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline u32 htab_map_hash(const void *key, u32 key_len, u32 hashrnd)\n{\n\treturn jhash(key, key_len, hashrnd);\n}"
  },
  {
    "function_name": "htab_map_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "298-406",
    "snippet": "static struct bpf_map *htab_map_alloc(union bpf_attr *attr)\n{\n\tbool percpu = (attr->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t\t       attr->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH);\n\tbool lru = (attr->map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t\t    attr->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH);\n\t/* percpu_lru means each cpu has its own LRU list.\n\t * it is different from BPF_MAP_TYPE_PERCPU_HASH where\n\t * the map's value itself is percpu.  percpu_lru has\n\t * nothing to do with the map's value.\n\t */\n\tbool percpu_lru = (attr->map_flags & BPF_F_NO_COMMON_LRU);\n\tbool prealloc = !(attr->map_flags & BPF_F_NO_PREALLOC);\n\tstruct bpf_htab *htab;\n\tint err, i;\n\tu64 cost;\n\n\thtab = kzalloc(sizeof(*htab), GFP_USER);\n\tif (!htab)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbpf_map_init_from_attr(&htab->map, attr);\n\n\tif (percpu_lru) {\n\t\t/* ensure each CPU's lru list has >=1 elements.\n\t\t * since we are at it, make each lru list has the same\n\t\t * number of elements.\n\t\t */\n\t\thtab->map.max_entries = roundup(attr->max_entries,\n\t\t\t\t\t\tnum_possible_cpus());\n\t\tif (htab->map.max_entries < attr->max_entries)\n\t\t\thtab->map.max_entries = rounddown(attr->max_entries,\n\t\t\t\t\t\t\t  num_possible_cpus());\n\t}\n\n\t/* hash table size must be power of 2 */\n\thtab->n_buckets = roundup_pow_of_two(htab->map.max_entries);\n\n\thtab->elem_size = sizeof(struct htab_elem) +\n\t\t\t  round_up(htab->map.key_size, 8);\n\tif (percpu)\n\t\thtab->elem_size += sizeof(void *);\n\telse\n\t\thtab->elem_size += round_up(htab->map.value_size, 8);\n\n\terr = -E2BIG;\n\t/* prevent zero size kmalloc and check for u32 overflow */\n\tif (htab->n_buckets == 0 ||\n\t    htab->n_buckets > U32_MAX / sizeof(struct bucket))\n\t\tgoto free_htab;\n\n\tcost = (u64) htab->n_buckets * sizeof(struct bucket) +\n\t       (u64) htab->elem_size * htab->map.max_entries;\n\n\tif (percpu)\n\t\tcost += (u64) round_up(htab->map.value_size, 8) *\n\t\t\tnum_possible_cpus() * htab->map.max_entries;\n\telse\n\t       cost += (u64) htab->elem_size * num_possible_cpus();\n\n\tif (cost >= U32_MAX - PAGE_SIZE)\n\t\t/* make sure page count doesn't overflow */\n\t\tgoto free_htab;\n\n\thtab->map.pages = round_up(cost, PAGE_SIZE) >> PAGE_SHIFT;\n\n\t/* if map size is larger than memlock limit, reject it early */\n\terr = bpf_map_precharge_memlock(htab->map.pages);\n\tif (err)\n\t\tgoto free_htab;\n\n\terr = -ENOMEM;\n\thtab->buckets = bpf_map_area_alloc(htab->n_buckets *\n\t\t\t\t\t   sizeof(struct bucket),\n\t\t\t\t\t   htab->map.numa_node);\n\tif (!htab->buckets)\n\t\tgoto free_htab;\n\n\thtab->hashrnd = get_random_int();\n\tfor (i = 0; i < htab->n_buckets; i++) {\n\t\tINIT_HLIST_NULLS_HEAD(&htab->buckets[i].head, i);\n\t\traw_spin_lock_init(&htab->buckets[i].lock);\n\t}\n\n\tif (prealloc) {\n\t\terr = prealloc_init(htab);\n\t\tif (err)\n\t\t\tgoto free_buckets;\n\n\t\tif (!percpu && !lru) {\n\t\t\t/* lru itself can remove the least used element, so\n\t\t\t * there is no need for an extra elem during map_update.\n\t\t\t */\n\t\t\terr = alloc_extra_elems(htab);\n\t\t\tif (err)\n\t\t\t\tgoto free_prealloc;\n\t\t}\n\t}\n\n\treturn &htab->map;\n\nfree_prealloc:\n\tprealloc_destroy(htab);\nfree_buckets:\n\tbpf_map_area_free(htab->buckets);\nfree_htab:\n\tkfree(htab);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "htab"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_area_free",
          "args": [
            "htab->buckets"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "156-159",
          "snippet": "void bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prealloc_destroy",
          "args": [
            "htab"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "prealloc_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "200-208",
          "snippet": "static void prealloc_destroy(struct bpf_htab *htab)\n{\n\thtab_free_elems(htab);\n\n\tif (htab_is_lru(htab))\n\t\tbpf_lru_destroy(&htab->lru);\n\telse\n\t\tpcpu_freelist_destroy(&htab->freelist);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void prealloc_destroy(struct bpf_htab *htab)\n{\n\thtab_free_elems(htab);\n\n\tif (htab_is_lru(htab))\n\t\tbpf_lru_destroy(&htab->lru);\n\telse\n\t\tpcpu_freelist_destroy(&htab->freelist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_extra_elems",
          "args": [
            "htab"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_extra_elems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "210-231",
          "snippet": "static int alloc_extra_elems(struct bpf_htab *htab)\n{\n\tstruct htab_elem *__percpu *pptr, *l_new;\n\tstruct pcpu_freelist_node *l;\n\tint cpu;\n\n\tpptr = __alloc_percpu_gfp(sizeof(struct htab_elem *), 8,\n\t\t\t\t  GFP_USER | __GFP_NOWARN);\n\tif (!pptr)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tl = pcpu_freelist_pop(&htab->freelist);\n\t\t/* pop will succeed, since prealloc_init()\n\t\t * preallocated extra num_possible_cpus elements\n\t\t */\n\t\tl_new = container_of(l, struct htab_elem, fnode);\n\t\t*per_cpu_ptr(pptr, cpu) = l_new;\n\t}\n\thtab->extra_elems = pptr;\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int alloc_extra_elems(struct bpf_htab *htab)\n{\n\tstruct htab_elem *__percpu *pptr, *l_new;\n\tstruct pcpu_freelist_node *l;\n\tint cpu;\n\n\tpptr = __alloc_percpu_gfp(sizeof(struct htab_elem *), 8,\n\t\t\t\t  GFP_USER | __GFP_NOWARN);\n\tif (!pptr)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tl = pcpu_freelist_pop(&htab->freelist);\n\t\t/* pop will succeed, since prealloc_init()\n\t\t * preallocated extra num_possible_cpus elements\n\t\t */\n\t\tl_new = container_of(l, struct htab_elem, fnode);\n\t\t*per_cpu_ptr(pptr, cpu) = l_new;\n\t}\n\thtab->extra_elems = pptr;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prealloc_init",
          "args": [
            "htab"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "prealloc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "142-198",
          "snippet": "static int prealloc_init(struct bpf_htab *htab)\n{\n\tu32 num_entries = htab->map.max_entries;\n\tint err = -ENOMEM, i;\n\n\tif (!htab_is_percpu(htab) && !htab_is_lru(htab))\n\t\tnum_entries += num_possible_cpus();\n\n\thtab->elems = bpf_map_area_alloc(htab->elem_size * num_entries,\n\t\t\t\t\t htab->map.numa_node);\n\tif (!htab->elems)\n\t\treturn -ENOMEM;\n\n\tif (!htab_is_percpu(htab))\n\t\tgoto skip_percpu_elems;\n\n\tfor (i = 0; i < num_entries; i++) {\n\t\tu32 size = round_up(htab->map.value_size, 8);\n\t\tvoid __percpu *pptr;\n\n\t\tpptr = __alloc_percpu_gfp(size, 8, GFP_USER | __GFP_NOWARN);\n\t\tif (!pptr)\n\t\t\tgoto free_elems;\n\t\thtab_elem_set_ptr(get_htab_elem(htab, i), htab->map.key_size,\n\t\t\t\t  pptr);\n\t\tcond_resched();\n\t}\n\nskip_percpu_elems:\n\tif (htab_is_lru(htab))\n\t\terr = bpf_lru_init(&htab->lru,\n\t\t\t\t   htab->map.map_flags & BPF_F_NO_COMMON_LRU,\n\t\t\t\t   offsetof(struct htab_elem, hash) -\n\t\t\t\t   offsetof(struct htab_elem, lru_node),\n\t\t\t\t   htab_lru_map_delete_node,\n\t\t\t\t   htab);\n\telse\n\t\terr = pcpu_freelist_init(&htab->freelist);\n\n\tif (err)\n\t\tgoto free_elems;\n\n\tif (htab_is_lru(htab))\n\t\tbpf_lru_populate(&htab->lru, htab->elems,\n\t\t\t\t offsetof(struct htab_elem, lru_node),\n\t\t\t\t htab->elem_size, num_entries);\n\telse\n\t\tpcpu_freelist_populate(&htab->freelist,\n\t\t\t\t       htab->elems + offsetof(struct htab_elem, fnode),\n\t\t\t\t       htab->elem_size, num_entries);\n\n\treturn 0;\n\nfree_elems:\n\thtab_free_elems(htab);\n\treturn err;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int prealloc_init(struct bpf_htab *htab)\n{\n\tu32 num_entries = htab->map.max_entries;\n\tint err = -ENOMEM, i;\n\n\tif (!htab_is_percpu(htab) && !htab_is_lru(htab))\n\t\tnum_entries += num_possible_cpus();\n\n\thtab->elems = bpf_map_area_alloc(htab->elem_size * num_entries,\n\t\t\t\t\t htab->map.numa_node);\n\tif (!htab->elems)\n\t\treturn -ENOMEM;\n\n\tif (!htab_is_percpu(htab))\n\t\tgoto skip_percpu_elems;\n\n\tfor (i = 0; i < num_entries; i++) {\n\t\tu32 size = round_up(htab->map.value_size, 8);\n\t\tvoid __percpu *pptr;\n\n\t\tpptr = __alloc_percpu_gfp(size, 8, GFP_USER | __GFP_NOWARN);\n\t\tif (!pptr)\n\t\t\tgoto free_elems;\n\t\thtab_elem_set_ptr(get_htab_elem(htab, i), htab->map.key_size,\n\t\t\t\t  pptr);\n\t\tcond_resched();\n\t}\n\nskip_percpu_elems:\n\tif (htab_is_lru(htab))\n\t\terr = bpf_lru_init(&htab->lru,\n\t\t\t\t   htab->map.map_flags & BPF_F_NO_COMMON_LRU,\n\t\t\t\t   offsetof(struct htab_elem, hash) -\n\t\t\t\t   offsetof(struct htab_elem, lru_node),\n\t\t\t\t   htab_lru_map_delete_node,\n\t\t\t\t   htab);\n\telse\n\t\terr = pcpu_freelist_init(&htab->freelist);\n\n\tif (err)\n\t\tgoto free_elems;\n\n\tif (htab_is_lru(htab))\n\t\tbpf_lru_populate(&htab->lru, htab->elems,\n\t\t\t\t offsetof(struct htab_elem, lru_node),\n\t\t\t\t htab->elem_size, num_entries);\n\telse\n\t\tpcpu_freelist_populate(&htab->freelist,\n\t\t\t\t       htab->elems + offsetof(struct htab_elem, fnode),\n\t\t\t\t       htab->elem_size, num_entries);\n\n\treturn 0;\n\nfree_elems:\n\thtab_free_elems(htab);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&htab->buckets[i].lock"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NULLS_HEAD",
          "args": [
            "&htab->buckets[i].head",
            "i"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_int",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_area_alloc",
          "args": [
            "htab->n_buckets *\n\t\t\t\t\t   sizeof(struct bucket)",
            "htab->map.numa_node"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "137-154",
          "snippet": "void *bpf_map_area_alloc(size_t size, int numa_node)\n{\n\t/* We definitely need __GFP_NORETRY, so OOM killer doesn't\n\t * trigger under memory pressure as we really just want to\n\t * fail instead.\n\t */\n\tconst gfp_t flags = __GFP_NOWARN | __GFP_NORETRY | __GFP_ZERO;\n\tvoid *area;\n\n\tif (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tarea = kmalloc_node(size, GFP_USER | flags, numa_node);\n\t\tif (area != NULL)\n\t\t\treturn area;\n\t}\n\n\treturn __vmalloc_node_flags_caller(size, numa_node, GFP_KERNEL | flags,\n\t\t\t\t\t   __builtin_return_address(0));\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_area_alloc(size_t size, int numa_node)\n{\n\t/* We definitely need __GFP_NORETRY, so OOM killer doesn't\n\t * trigger under memory pressure as we really just want to\n\t * fail instead.\n\t */\n\tconst gfp_t flags = __GFP_NOWARN | __GFP_NORETRY | __GFP_ZERO;\n\tvoid *area;\n\n\tif (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tarea = kmalloc_node(size, GFP_USER | flags, numa_node);\n\t\tif (area != NULL)\n\t\t\treturn area;\n\t}\n\n\treturn __vmalloc_node_flags_caller(size, numa_node, GFP_KERNEL | flags,\n\t\t\t\t\t   __builtin_return_address(0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_precharge_memlock",
          "args": [
            "htab->map.pages"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_precharge_memlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "171-182",
          "snippet": "int bpf_map_precharge_memlock(u32 pages)\n{\n\tstruct user_struct *user = get_current_user();\n\tunsigned long memlock_limit, cur;\n\n\tmemlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tcur = atomic_long_read(&user->locked_vm);\n\tfree_uid(user);\n\tif (cur + pages > memlock_limit)\n\t\treturn -EPERM;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint bpf_map_precharge_memlock(u32 pages)\n{\n\tstruct user_struct *user = get_current_user();\n\tunsigned long memlock_limit, cur;\n\n\tmemlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tcur = atomic_long_read(&user->locked_vm);\n\tfree_uid(user);\n\tif (cur + pages > memlock_limit)\n\t\treturn -EPERM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "cost",
            "PAGE_SIZE"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "htab->map.value_size",
            "8"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "htab->map.value_size",
            "8"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "htab->map.key_size",
            "8"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "htab->map.max_entries"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rounddown",
          "args": [
            "attr->max_entries",
            "num_possible_cpus()"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "attr->max_entries",
            "num_possible_cpus()"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_init_from_attr",
          "args": [
            "&htab->map",
            "attr"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_init_from_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "161-169",
          "snippet": "void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = attr->map_flags;\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = attr->map_flags;\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*htab)",
            "GFP_USER"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_map *htab_map_alloc(union bpf_attr *attr)\n{\n\tbool percpu = (attr->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t\t       attr->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH);\n\tbool lru = (attr->map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t\t    attr->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH);\n\t/* percpu_lru means each cpu has its own LRU list.\n\t * it is different from BPF_MAP_TYPE_PERCPU_HASH where\n\t * the map's value itself is percpu.  percpu_lru has\n\t * nothing to do with the map's value.\n\t */\n\tbool percpu_lru = (attr->map_flags & BPF_F_NO_COMMON_LRU);\n\tbool prealloc = !(attr->map_flags & BPF_F_NO_PREALLOC);\n\tstruct bpf_htab *htab;\n\tint err, i;\n\tu64 cost;\n\n\thtab = kzalloc(sizeof(*htab), GFP_USER);\n\tif (!htab)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbpf_map_init_from_attr(&htab->map, attr);\n\n\tif (percpu_lru) {\n\t\t/* ensure each CPU's lru list has >=1 elements.\n\t\t * since we are at it, make each lru list has the same\n\t\t * number of elements.\n\t\t */\n\t\thtab->map.max_entries = roundup(attr->max_entries,\n\t\t\t\t\t\tnum_possible_cpus());\n\t\tif (htab->map.max_entries < attr->max_entries)\n\t\t\thtab->map.max_entries = rounddown(attr->max_entries,\n\t\t\t\t\t\t\t  num_possible_cpus());\n\t}\n\n\t/* hash table size must be power of 2 */\n\thtab->n_buckets = roundup_pow_of_two(htab->map.max_entries);\n\n\thtab->elem_size = sizeof(struct htab_elem) +\n\t\t\t  round_up(htab->map.key_size, 8);\n\tif (percpu)\n\t\thtab->elem_size += sizeof(void *);\n\telse\n\t\thtab->elem_size += round_up(htab->map.value_size, 8);\n\n\terr = -E2BIG;\n\t/* prevent zero size kmalloc and check for u32 overflow */\n\tif (htab->n_buckets == 0 ||\n\t    htab->n_buckets > U32_MAX / sizeof(struct bucket))\n\t\tgoto free_htab;\n\n\tcost = (u64) htab->n_buckets * sizeof(struct bucket) +\n\t       (u64) htab->elem_size * htab->map.max_entries;\n\n\tif (percpu)\n\t\tcost += (u64) round_up(htab->map.value_size, 8) *\n\t\t\tnum_possible_cpus() * htab->map.max_entries;\n\telse\n\t       cost += (u64) htab->elem_size * num_possible_cpus();\n\n\tif (cost >= U32_MAX - PAGE_SIZE)\n\t\t/* make sure page count doesn't overflow */\n\t\tgoto free_htab;\n\n\thtab->map.pages = round_up(cost, PAGE_SIZE) >> PAGE_SHIFT;\n\n\t/* if map size is larger than memlock limit, reject it early */\n\terr = bpf_map_precharge_memlock(htab->map.pages);\n\tif (err)\n\t\tgoto free_htab;\n\n\terr = -ENOMEM;\n\thtab->buckets = bpf_map_area_alloc(htab->n_buckets *\n\t\t\t\t\t   sizeof(struct bucket),\n\t\t\t\t\t   htab->map.numa_node);\n\tif (!htab->buckets)\n\t\tgoto free_htab;\n\n\thtab->hashrnd = get_random_int();\n\tfor (i = 0; i < htab->n_buckets; i++) {\n\t\tINIT_HLIST_NULLS_HEAD(&htab->buckets[i].head, i);\n\t\traw_spin_lock_init(&htab->buckets[i].lock);\n\t}\n\n\tif (prealloc) {\n\t\terr = prealloc_init(htab);\n\t\tif (err)\n\t\t\tgoto free_buckets;\n\n\t\tif (!percpu && !lru) {\n\t\t\t/* lru itself can remove the least used element, so\n\t\t\t * there is no need for an extra elem during map_update.\n\t\t\t */\n\t\t\terr = alloc_extra_elems(htab);\n\t\t\tif (err)\n\t\t\t\tgoto free_prealloc;\n\t\t}\n\t}\n\n\treturn &htab->map;\n\nfree_prealloc:\n\tprealloc_destroy(htab);\nfree_buckets:\n\tbpf_map_area_free(htab->buckets);\nfree_htab:\n\tkfree(htab);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "htab_map_alloc_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "234-296",
    "snippet": "static int htab_map_alloc_check(union bpf_attr *attr)\n{\n\tbool percpu = (attr->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t\t       attr->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH);\n\tbool lru = (attr->map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t\t    attr->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH);\n\t/* percpu_lru means each cpu has its own LRU list.\n\t * it is different from BPF_MAP_TYPE_PERCPU_HASH where\n\t * the map's value itself is percpu.  percpu_lru has\n\t * nothing to do with the map's value.\n\t */\n\tbool percpu_lru = (attr->map_flags & BPF_F_NO_COMMON_LRU);\n\tbool prealloc = !(attr->map_flags & BPF_F_NO_PREALLOC);\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\n\tBUILD_BUG_ON(offsetof(struct htab_elem, htab) !=\n\t\t     offsetof(struct htab_elem, hash_node.pprev));\n\tBUILD_BUG_ON(offsetof(struct htab_elem, fnode.next) !=\n\t\t     offsetof(struct htab_elem, hash_node.pprev));\n\n\tif (lru && !capable(CAP_SYS_ADMIN))\n\t\t/* LRU implementation is much complicated than other\n\t\t * maps.  Hence, limit to CAP_SYS_ADMIN for now.\n\t\t */\n\t\treturn -EPERM;\n\n\tif (attr->map_flags & ~HTAB_CREATE_FLAG_MASK)\n\t\t/* reserved bits should not be used */\n\t\treturn -EINVAL;\n\n\tif (!lru && percpu_lru)\n\t\treturn -EINVAL;\n\n\tif (lru && !prealloc)\n\t\treturn -ENOTSUPP;\n\n\tif (numa_node != NUMA_NO_NODE && (percpu || percpu_lru))\n\t\treturn -EINVAL;\n\n\t/* check sanity of attributes.\n\t * value_size == 0 may be allowed in the future to use map as a set\n\t */\n\tif (attr->max_entries == 0 || attr->key_size == 0 ||\n\t    attr->value_size == 0)\n\t\treturn -EINVAL;\n\n\tif (attr->key_size > MAX_BPF_STACK)\n\t\t/* eBPF programs initialize keys on stack, so they cannot be\n\t\t * larger than max stack size\n\t\t */\n\t\treturn -E2BIG;\n\n\tif (attr->value_size >= KMALLOC_MAX_SIZE -\n\t    MAX_BPF_STACK - sizeof(struct htab_elem))\n\t\t/* if value_size is bigger, the user space won't be able to\n\t\t * access the elements via bpf syscall. This check also makes\n\t\t * sure that the elem_size doesn't overflow and it's\n\t\t * kmalloc-able later in htab_map_update_elem()\n\t\t */\n\t\treturn -E2BIG;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define HTAB_CREATE_FLAG_MASK\t\t\t\t\t\t\\\n\t(BPF_F_NO_PREALLOC | BPF_F_NO_COMMON_LRU | BPF_F_NUMA_NODE |\t\\\n\t BPF_F_RDONLY | BPF_F_WRONLY)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct htab_elem, htab) !=\n\t\t     offsetof(struct htab_elem, hash_node.pprev)"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_attr_numa_node",
          "args": [
            "attr"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\n#define HTAB_CREATE_FLAG_MASK\t\t\t\t\t\t\\\n\t(BPF_F_NO_PREALLOC | BPF_F_NO_COMMON_LRU | BPF_F_NUMA_NODE |\t\\\n\t BPF_F_RDONLY | BPF_F_WRONLY)\n\nstatic int htab_map_alloc_check(union bpf_attr *attr)\n{\n\tbool percpu = (attr->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t\t       attr->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH);\n\tbool lru = (attr->map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t\t    attr->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH);\n\t/* percpu_lru means each cpu has its own LRU list.\n\t * it is different from BPF_MAP_TYPE_PERCPU_HASH where\n\t * the map's value itself is percpu.  percpu_lru has\n\t * nothing to do with the map's value.\n\t */\n\tbool percpu_lru = (attr->map_flags & BPF_F_NO_COMMON_LRU);\n\tbool prealloc = !(attr->map_flags & BPF_F_NO_PREALLOC);\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\n\tBUILD_BUG_ON(offsetof(struct htab_elem, htab) !=\n\t\t     offsetof(struct htab_elem, hash_node.pprev));\n\tBUILD_BUG_ON(offsetof(struct htab_elem, fnode.next) !=\n\t\t     offsetof(struct htab_elem, hash_node.pprev));\n\n\tif (lru && !capable(CAP_SYS_ADMIN))\n\t\t/* LRU implementation is much complicated than other\n\t\t * maps.  Hence, limit to CAP_SYS_ADMIN for now.\n\t\t */\n\t\treturn -EPERM;\n\n\tif (attr->map_flags & ~HTAB_CREATE_FLAG_MASK)\n\t\t/* reserved bits should not be used */\n\t\treturn -EINVAL;\n\n\tif (!lru && percpu_lru)\n\t\treturn -EINVAL;\n\n\tif (lru && !prealloc)\n\t\treturn -ENOTSUPP;\n\n\tif (numa_node != NUMA_NO_NODE && (percpu || percpu_lru))\n\t\treturn -EINVAL;\n\n\t/* check sanity of attributes.\n\t * value_size == 0 may be allowed in the future to use map as a set\n\t */\n\tif (attr->max_entries == 0 || attr->key_size == 0 ||\n\t    attr->value_size == 0)\n\t\treturn -EINVAL;\n\n\tif (attr->key_size > MAX_BPF_STACK)\n\t\t/* eBPF programs initialize keys on stack, so they cannot be\n\t\t * larger than max stack size\n\t\t */\n\t\treturn -E2BIG;\n\n\tif (attr->value_size >= KMALLOC_MAX_SIZE -\n\t    MAX_BPF_STACK - sizeof(struct htab_elem))\n\t\t/* if value_size is bigger, the user space won't be able to\n\t\t * access the elements via bpf syscall. This check also makes\n\t\t * sure that the elem_size doesn't overflow and it's\n\t\t * kmalloc-able later in htab_map_update_elem()\n\t\t */\n\t\treturn -E2BIG;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "alloc_extra_elems",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "210-231",
    "snippet": "static int alloc_extra_elems(struct bpf_htab *htab)\n{\n\tstruct htab_elem *__percpu *pptr, *l_new;\n\tstruct pcpu_freelist_node *l;\n\tint cpu;\n\n\tpptr = __alloc_percpu_gfp(sizeof(struct htab_elem *), 8,\n\t\t\t\t  GFP_USER | __GFP_NOWARN);\n\tif (!pptr)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tl = pcpu_freelist_pop(&htab->freelist);\n\t\t/* pop will succeed, since prealloc_init()\n\t\t * preallocated extra num_possible_cpus elements\n\t\t */\n\t\tl_new = container_of(l, struct htab_elem, fnode);\n\t\t*per_cpu_ptr(pptr, cpu) = l_new;\n\t}\n\thtab->extra_elems = pptr;\n\treturn 0;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pptr",
            "cpu"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "l",
            "structhtab_elem",
            "fnode"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcpu_freelist_pop",
          "args": [
            "&htab->freelist"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_freelist_pop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/percpu_freelist.c",
          "lines": "77-104",
          "snippet": "struct pcpu_freelist_node *pcpu_freelist_pop(struct pcpu_freelist *s)\n{\n\tstruct pcpu_freelist_head *head;\n\tstruct pcpu_freelist_node *node;\n\tunsigned long flags;\n\tint orig_cpu, cpu;\n\n\tlocal_irq_save(flags);\n\torig_cpu = cpu = raw_smp_processor_id();\n\twhile (1) {\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\traw_spin_lock(&head->lock);\n\t\tnode = head->first;\n\t\tif (node) {\n\t\t\thead->first = node->next;\n\t\t\traw_spin_unlock_irqrestore(&head->lock, flags);\n\t\t\treturn node;\n\t\t}\n\t\traw_spin_unlock(&head->lock);\n\t\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\tcpu = 0;\n\t\tif (cpu == orig_cpu) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nstruct pcpu_freelist_node *pcpu_freelist_pop(struct pcpu_freelist *s)\n{\n\tstruct pcpu_freelist_head *head;\n\tstruct pcpu_freelist_node *node;\n\tunsigned long flags;\n\tint orig_cpu, cpu;\n\n\tlocal_irq_save(flags);\n\torig_cpu = cpu = raw_smp_processor_id();\n\twhile (1) {\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\traw_spin_lock(&head->lock);\n\t\tnode = head->first;\n\t\tif (node) {\n\t\t\thead->first = node->next;\n\t\t\traw_spin_unlock_irqrestore(&head->lock, flags);\n\t\t\treturn node;\n\t\t}\n\t\traw_spin_unlock(&head->lock);\n\t\tcpu = cpumask_next(cpu, cpu_possible_mask);\n\t\tif (cpu >= nr_cpu_ids)\n\t\t\tcpu = 0;\n\t\tif (cpu == orig_cpu) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__alloc_percpu_gfp",
          "args": [
            "sizeof(struct htab_elem *)",
            "8",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int alloc_extra_elems(struct bpf_htab *htab)\n{\n\tstruct htab_elem *__percpu *pptr, *l_new;\n\tstruct pcpu_freelist_node *l;\n\tint cpu;\n\n\tpptr = __alloc_percpu_gfp(sizeof(struct htab_elem *), 8,\n\t\t\t\t  GFP_USER | __GFP_NOWARN);\n\tif (!pptr)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tl = pcpu_freelist_pop(&htab->freelist);\n\t\t/* pop will succeed, since prealloc_init()\n\t\t * preallocated extra num_possible_cpus elements\n\t\t */\n\t\tl_new = container_of(l, struct htab_elem, fnode);\n\t\t*per_cpu_ptr(pptr, cpu) = l_new;\n\t}\n\thtab->extra_elems = pptr;\n\treturn 0;\n}"
  },
  {
    "function_name": "prealloc_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "200-208",
    "snippet": "static void prealloc_destroy(struct bpf_htab *htab)\n{\n\thtab_free_elems(htab);\n\n\tif (htab_is_lru(htab))\n\t\tbpf_lru_destroy(&htab->lru);\n\telse\n\t\tpcpu_freelist_destroy(&htab->freelist);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcpu_freelist_destroy",
          "args": [
            "&htab->freelist"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_freelist_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/percpu_freelist.c",
          "lines": "26-29",
          "snippet": "void pcpu_freelist_destroy(struct pcpu_freelist *s)\n{\n\tfree_percpu(s->freelist);\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nvoid pcpu_freelist_destroy(struct pcpu_freelist *s)\n{\n\tfree_percpu(s->freelist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_destroy",
          "args": [
            "&htab->lru"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "691-697",
          "snippet": "void bpf_lru_destroy(struct bpf_lru *lru)\n{\n\tif (lru->percpu)\n\t\tfree_percpu(lru->percpu_lru);\n\telse\n\t\tfree_percpu(lru->common_lru.local_list);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nvoid bpf_lru_destroy(struct bpf_lru *lru)\n{\n\tif (lru->percpu)\n\t\tfree_percpu(lru->percpu_lru);\n\telse\n\t\tfree_percpu(lru->common_lru.local_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_is_lru",
          "args": [
            "htab"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "htab_is_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "70-74",
          "snippet": "static bool htab_is_lru(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t\thtab->map.map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool htab_is_lru(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t\thtab->map.map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_free_elems",
          "args": [
            "htab"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "htab_free_elems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "108-125",
          "snippet": "static void htab_free_elems(struct bpf_htab *htab)\n{\n\tint i;\n\n\tif (!htab_is_percpu(htab))\n\t\tgoto free_elems;\n\n\tfor (i = 0; i < htab->map.max_entries; i++) {\n\t\tvoid __percpu *pptr;\n\n\t\tpptr = htab_elem_get_ptr(get_htab_elem(htab, i),\n\t\t\t\t\t htab->map.key_size);\n\t\tfree_percpu(pptr);\n\t\tcond_resched();\n\t}\nfree_elems:\n\tbpf_map_area_free(htab->elems);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void htab_free_elems(struct bpf_htab *htab)\n{\n\tint i;\n\n\tif (!htab_is_percpu(htab))\n\t\tgoto free_elems;\n\n\tfor (i = 0; i < htab->map.max_entries; i++) {\n\t\tvoid __percpu *pptr;\n\n\t\tpptr = htab_elem_get_ptr(get_htab_elem(htab, i),\n\t\t\t\t\t htab->map.key_size);\n\t\tfree_percpu(pptr);\n\t\tcond_resched();\n\t}\nfree_elems:\n\tbpf_map_area_free(htab->elems);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void prealloc_destroy(struct bpf_htab *htab)\n{\n\thtab_free_elems(htab);\n\n\tif (htab_is_lru(htab))\n\t\tbpf_lru_destroy(&htab->lru);\n\telse\n\t\tpcpu_freelist_destroy(&htab->freelist);\n}"
  },
  {
    "function_name": "prealloc_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "142-198",
    "snippet": "static int prealloc_init(struct bpf_htab *htab)\n{\n\tu32 num_entries = htab->map.max_entries;\n\tint err = -ENOMEM, i;\n\n\tif (!htab_is_percpu(htab) && !htab_is_lru(htab))\n\t\tnum_entries += num_possible_cpus();\n\n\thtab->elems = bpf_map_area_alloc(htab->elem_size * num_entries,\n\t\t\t\t\t htab->map.numa_node);\n\tif (!htab->elems)\n\t\treturn -ENOMEM;\n\n\tif (!htab_is_percpu(htab))\n\t\tgoto skip_percpu_elems;\n\n\tfor (i = 0; i < num_entries; i++) {\n\t\tu32 size = round_up(htab->map.value_size, 8);\n\t\tvoid __percpu *pptr;\n\n\t\tpptr = __alloc_percpu_gfp(size, 8, GFP_USER | __GFP_NOWARN);\n\t\tif (!pptr)\n\t\t\tgoto free_elems;\n\t\thtab_elem_set_ptr(get_htab_elem(htab, i), htab->map.key_size,\n\t\t\t\t  pptr);\n\t\tcond_resched();\n\t}\n\nskip_percpu_elems:\n\tif (htab_is_lru(htab))\n\t\terr = bpf_lru_init(&htab->lru,\n\t\t\t\t   htab->map.map_flags & BPF_F_NO_COMMON_LRU,\n\t\t\t\t   offsetof(struct htab_elem, hash) -\n\t\t\t\t   offsetof(struct htab_elem, lru_node),\n\t\t\t\t   htab_lru_map_delete_node,\n\t\t\t\t   htab);\n\telse\n\t\terr = pcpu_freelist_init(&htab->freelist);\n\n\tif (err)\n\t\tgoto free_elems;\n\n\tif (htab_is_lru(htab))\n\t\tbpf_lru_populate(&htab->lru, htab->elems,\n\t\t\t\t offsetof(struct htab_elem, lru_node),\n\t\t\t\t htab->elem_size, num_entries);\n\telse\n\t\tpcpu_freelist_populate(&htab->freelist,\n\t\t\t\t       htab->elems + offsetof(struct htab_elem, fnode),\n\t\t\t\t       htab->elem_size, num_entries);\n\n\treturn 0;\n\nfree_elems:\n\thtab_free_elems(htab);\n\treturn err;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htab_free_elems",
          "args": [
            "htab"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "htab_free_elems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "108-125",
          "snippet": "static void htab_free_elems(struct bpf_htab *htab)\n{\n\tint i;\n\n\tif (!htab_is_percpu(htab))\n\t\tgoto free_elems;\n\n\tfor (i = 0; i < htab->map.max_entries; i++) {\n\t\tvoid __percpu *pptr;\n\n\t\tpptr = htab_elem_get_ptr(get_htab_elem(htab, i),\n\t\t\t\t\t htab->map.key_size);\n\t\tfree_percpu(pptr);\n\t\tcond_resched();\n\t}\nfree_elems:\n\tbpf_map_area_free(htab->elems);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void htab_free_elems(struct bpf_htab *htab)\n{\n\tint i;\n\n\tif (!htab_is_percpu(htab))\n\t\tgoto free_elems;\n\n\tfor (i = 0; i < htab->map.max_entries; i++) {\n\t\tvoid __percpu *pptr;\n\n\t\tpptr = htab_elem_get_ptr(get_htab_elem(htab, i),\n\t\t\t\t\t htab->map.key_size);\n\t\tfree_percpu(pptr);\n\t\tcond_resched();\n\t}\nfree_elems:\n\tbpf_map_area_free(htab->elems);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_freelist_populate",
          "args": [
            "&htab->freelist",
            "htab->elems + offsetof(struct htab_elem, fnode)",
            "htab->elem_size",
            "num_entries"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_freelist_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/percpu_freelist.c",
          "lines": "48-75",
          "snippet": "void pcpu_freelist_populate(struct pcpu_freelist *s, void *buf, u32 elem_size,\n\t\t\t    u32 nr_elems)\n{\n\tstruct pcpu_freelist_head *head;\n\tunsigned long flags;\n\tint i, cpu, pcpu_entries;\n\n\tpcpu_entries = nr_elems / num_possible_cpus() + 1;\n\ti = 0;\n\n\t/* disable irq to workaround lockdep false positive\n\t * in bpf usage pcpu_freelist_populate() will never race\n\t * with pcpu_freelist_push()\n\t */\n\tlocal_irq_save(flags);\n\tfor_each_possible_cpu(cpu) {\nagain:\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\t__pcpu_freelist_push(head, buf);\n\t\ti++;\n\t\tbuf += elem_size;\n\t\tif (i == nr_elems)\n\t\t\tbreak;\n\t\tif (i % pcpu_entries)\n\t\t\tgoto again;\n\t}\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nvoid pcpu_freelist_populate(struct pcpu_freelist *s, void *buf, u32 elem_size,\n\t\t\t    u32 nr_elems)\n{\n\tstruct pcpu_freelist_head *head;\n\tunsigned long flags;\n\tint i, cpu, pcpu_entries;\n\n\tpcpu_entries = nr_elems / num_possible_cpus() + 1;\n\ti = 0;\n\n\t/* disable irq to workaround lockdep false positive\n\t * in bpf usage pcpu_freelist_populate() will never race\n\t * with pcpu_freelist_push()\n\t */\n\tlocal_irq_save(flags);\n\tfor_each_possible_cpu(cpu) {\nagain:\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\t__pcpu_freelist_push(head, buf);\n\t\ti++;\n\t\tbuf += elem_size;\n\t\tif (i == nr_elems)\n\t\t\tbreak;\n\t\tif (i % pcpu_entries)\n\t\t\tgoto again;\n\t}\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_populate",
          "args": [
            "&htab->lru",
            "htab->elems",
            "offsetof(struct htab_elem, lru_node)",
            "htab->elem_size",
            "num_entries"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_populate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "610-619",
          "snippet": "void bpf_lru_populate(struct bpf_lru *lru, void *buf, u32 node_offset,\n\t\t      u32 elem_size, u32 nr_elems)\n{\n\tif (lru->percpu)\n\t\tbpf_percpu_lru_populate(lru, buf, node_offset, elem_size,\n\t\t\t\t\tnr_elems);\n\telse\n\t\tbpf_common_lru_populate(lru, buf, node_offset, elem_size,\n\t\t\t\t\tnr_elems);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nvoid bpf_lru_populate(struct bpf_lru *lru, void *buf, u32 node_offset,\n\t\t      u32 elem_size, u32 nr_elems)\n{\n\tif (lru->percpu)\n\t\tbpf_percpu_lru_populate(lru, buf, node_offset, elem_size,\n\t\t\t\t\tnr_elems);\n\telse\n\t\tbpf_common_lru_populate(lru, buf, node_offset, elem_size,\n\t\t\t\t\tnr_elems);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_is_lru",
          "args": [
            "htab"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "htab_is_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "70-74",
          "snippet": "static bool htab_is_lru(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t\thtab->map.map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool htab_is_lru(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t\thtab->map.map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcpu_freelist_init",
          "args": [
            "&htab->freelist"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "pcpu_freelist_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/percpu_freelist.c",
          "lines": "9-24",
          "snippet": "int pcpu_freelist_init(struct pcpu_freelist *s)\n{\n\tint cpu;\n\n\ts->freelist = alloc_percpu(struct pcpu_freelist_head);\n\tif (!s->freelist)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct pcpu_freelist_head *head = per_cpu_ptr(s->freelist, cpu);\n\n\t\traw_spin_lock_init(&head->lock);\n\t\thead->first = NULL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"percpu_freelist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n\nint pcpu_freelist_init(struct pcpu_freelist *s)\n{\n\tint cpu;\n\n\ts->freelist = alloc_percpu(struct pcpu_freelist_head);\n\tif (!s->freelist)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct pcpu_freelist_head *head = per_cpu_ptr(s->freelist, cpu);\n\n\t\traw_spin_lock_init(&head->lock);\n\t\thead->first = NULL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_lru_init",
          "args": [
            "&htab->lru",
            "htab->map.map_flags & BPF_F_NO_COMMON_LRU",
            "offsetof(struct htab_elem, hash) -\n\t\t\t\t   offsetof(struct htab_elem, lru_node)",
            "htab_lru_map_delete_node",
            "htab"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "648-689",
          "snippet": "int bpf_lru_init(struct bpf_lru *lru, bool percpu, u32 hash_offset,\n\t\t del_from_htab_func del_from_htab, void *del_arg)\n{\n\tint cpu;\n\n\tif (percpu) {\n\t\tlru->percpu_lru = alloc_percpu(struct bpf_lru_list);\n\t\tif (!lru->percpu_lru)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct bpf_lru_list *l;\n\n\t\t\tl = per_cpu_ptr(lru->percpu_lru, cpu);\n\t\t\tbpf_lru_list_init(l);\n\t\t}\n\t\tlru->nr_scans = PERCPU_NR_SCANS;\n\t} else {\n\t\tstruct bpf_common_lru *clru = &lru->common_lru;\n\n\t\tclru->local_list = alloc_percpu(struct bpf_lru_locallist);\n\t\tif (!clru->local_list)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct bpf_lru_locallist *loc_l;\n\n\t\t\tloc_l = per_cpu_ptr(clru->local_list, cpu);\n\t\t\tbpf_lru_locallist_init(loc_l, cpu);\n\t\t}\n\n\t\tbpf_lru_list_init(&clru->lru_list);\n\t\tlru->nr_scans = LOCAL_NR_SCANS;\n\t}\n\n\tlru->percpu = percpu;\n\tlru->del_from_htab = del_from_htab;\n\tlru->del_arg = del_arg;\n\tlru->hash_offset = hash_offset;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [
            "#define PERCPU_NR_SCANS\t\t\tPERCPU_FREE_TARGET",
            "#define LOCAL_NR_SCANS\t\t\tLOCAL_FREE_TARGET"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\n#define PERCPU_NR_SCANS\t\t\tPERCPU_FREE_TARGET\n#define LOCAL_NR_SCANS\t\t\tLOCAL_FREE_TARGET\n\nint bpf_lru_init(struct bpf_lru *lru, bool percpu, u32 hash_offset,\n\t\t del_from_htab_func del_from_htab, void *del_arg)\n{\n\tint cpu;\n\n\tif (percpu) {\n\t\tlru->percpu_lru = alloc_percpu(struct bpf_lru_list);\n\t\tif (!lru->percpu_lru)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct bpf_lru_list *l;\n\n\t\t\tl = per_cpu_ptr(lru->percpu_lru, cpu);\n\t\t\tbpf_lru_list_init(l);\n\t\t}\n\t\tlru->nr_scans = PERCPU_NR_SCANS;\n\t} else {\n\t\tstruct bpf_common_lru *clru = &lru->common_lru;\n\n\t\tclru->local_list = alloc_percpu(struct bpf_lru_locallist);\n\t\tif (!clru->local_list)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct bpf_lru_locallist *loc_l;\n\n\t\t\tloc_l = per_cpu_ptr(clru->local_list, cpu);\n\t\t\tbpf_lru_locallist_init(loc_l, cpu);\n\t\t}\n\n\t\tbpf_lru_list_init(&clru->lru_list);\n\t\tlru->nr_scans = LOCAL_NR_SCANS;\n\t}\n\n\tlru->percpu = percpu;\n\tlru->del_from_htab = del_from_htab;\n\tlru->del_arg = del_arg;\n\tlru->hash_offset = hash_offset;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4957-4965",
          "snippet": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_elem_set_ptr",
          "args": [
            "get_htab_elem(htab, i)",
            "htab->map.key_size",
            "pptr"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "htab_elem_set_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "87-91",
          "snippet": "static inline void htab_elem_set_ptr(struct htab_elem *l, u32 key_size,\n\t\t\t\t     void __percpu *pptr)\n{\n\t*(void __percpu **)(l->key + key_size) = pptr;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline void htab_elem_set_ptr(struct htab_elem *l, u32 key_size,\n\t\t\t\t     void __percpu *pptr)\n{\n\t*(void __percpu **)(l->key + key_size) = pptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_htab_elem",
          "args": [
            "htab",
            "i"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "get_htab_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "103-106",
          "snippet": "static struct htab_elem *get_htab_elem(struct bpf_htab *htab, int i)\n{\n\treturn (struct htab_elem *) (htab->elems + i * htab->elem_size);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct htab_elem *get_htab_elem(struct bpf_htab *htab, int i)\n{\n\treturn (struct htab_elem *) (htab->elems + i * htab->elem_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__alloc_percpu_gfp",
          "args": [
            "size",
            "8",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "htab->map.value_size",
            "8"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htab_is_percpu",
          "args": [
            "htab"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "htab_is_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "76-80",
          "snippet": "static bool htab_is_percpu(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t\thtab->map.map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool htab_is_percpu(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t\thtab->map.map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_area_alloc",
          "args": [
            "htab->elem_size * num_entries",
            "htab->map.numa_node"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "137-154",
          "snippet": "void *bpf_map_area_alloc(size_t size, int numa_node)\n{\n\t/* We definitely need __GFP_NORETRY, so OOM killer doesn't\n\t * trigger under memory pressure as we really just want to\n\t * fail instead.\n\t */\n\tconst gfp_t flags = __GFP_NOWARN | __GFP_NORETRY | __GFP_ZERO;\n\tvoid *area;\n\n\tif (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tarea = kmalloc_node(size, GFP_USER | flags, numa_node);\n\t\tif (area != NULL)\n\t\t\treturn area;\n\t}\n\n\treturn __vmalloc_node_flags_caller(size, numa_node, GFP_KERNEL | flags,\n\t\t\t\t\t   __builtin_return_address(0));\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_area_alloc(size_t size, int numa_node)\n{\n\t/* We definitely need __GFP_NORETRY, so OOM killer doesn't\n\t * trigger under memory pressure as we really just want to\n\t * fail instead.\n\t */\n\tconst gfp_t flags = __GFP_NOWARN | __GFP_NORETRY | __GFP_ZERO;\n\tvoid *area;\n\n\tif (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tarea = kmalloc_node(size, GFP_USER | flags, numa_node);\n\t\tif (area != NULL)\n\t\t\treturn area;\n\t}\n\n\treturn __vmalloc_node_flags_caller(size, numa_node, GFP_KERNEL | flags,\n\t\t\t\t\t   __builtin_return_address(0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int prealloc_init(struct bpf_htab *htab)\n{\n\tu32 num_entries = htab->map.max_entries;\n\tint err = -ENOMEM, i;\n\n\tif (!htab_is_percpu(htab) && !htab_is_lru(htab))\n\t\tnum_entries += num_possible_cpus();\n\n\thtab->elems = bpf_map_area_alloc(htab->elem_size * num_entries,\n\t\t\t\t\t htab->map.numa_node);\n\tif (!htab->elems)\n\t\treturn -ENOMEM;\n\n\tif (!htab_is_percpu(htab))\n\t\tgoto skip_percpu_elems;\n\n\tfor (i = 0; i < num_entries; i++) {\n\t\tu32 size = round_up(htab->map.value_size, 8);\n\t\tvoid __percpu *pptr;\n\n\t\tpptr = __alloc_percpu_gfp(size, 8, GFP_USER | __GFP_NOWARN);\n\t\tif (!pptr)\n\t\t\tgoto free_elems;\n\t\thtab_elem_set_ptr(get_htab_elem(htab, i), htab->map.key_size,\n\t\t\t\t  pptr);\n\t\tcond_resched();\n\t}\n\nskip_percpu_elems:\n\tif (htab_is_lru(htab))\n\t\terr = bpf_lru_init(&htab->lru,\n\t\t\t\t   htab->map.map_flags & BPF_F_NO_COMMON_LRU,\n\t\t\t\t   offsetof(struct htab_elem, hash) -\n\t\t\t\t   offsetof(struct htab_elem, lru_node),\n\t\t\t\t   htab_lru_map_delete_node,\n\t\t\t\t   htab);\n\telse\n\t\terr = pcpu_freelist_init(&htab->freelist);\n\n\tif (err)\n\t\tgoto free_elems;\n\n\tif (htab_is_lru(htab))\n\t\tbpf_lru_populate(&htab->lru, htab->elems,\n\t\t\t\t offsetof(struct htab_elem, lru_node),\n\t\t\t\t htab->elem_size, num_entries);\n\telse\n\t\tpcpu_freelist_populate(&htab->freelist,\n\t\t\t\t       htab->elems + offsetof(struct htab_elem, fnode),\n\t\t\t\t       htab->elem_size, num_entries);\n\n\treturn 0;\n\nfree_elems:\n\thtab_free_elems(htab);\n\treturn err;\n}"
  },
  {
    "function_name": "prealloc_lru_pop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "127-140",
    "snippet": "static struct htab_elem *prealloc_lru_pop(struct bpf_htab *htab, void *key,\n\t\t\t\t\t  u32 hash)\n{\n\tstruct bpf_lru_node *node = bpf_lru_pop_free(&htab->lru, hash);\n\tstruct htab_elem *l;\n\n\tif (node) {\n\t\tl = container_of(node, struct htab_elem, lru_node);\n\t\tmemcpy(l->key, key, htab->map.key_size);\n\t\treturn l;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool htab_lru_map_delete_node(void *arg, struct bpf_lru_node *node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "l->key",
            "key",
            "htab->map.key_size"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "node",
            "structhtab_elem",
            "lru_node"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_lru_pop_free",
          "args": [
            "&htab->lru",
            "hash"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_lru_pop_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/bpf_lru_list.c",
          "lines": "497-503",
          "snippet": "struct bpf_lru_node *bpf_lru_pop_free(struct bpf_lru *lru, u32 hash)\n{\n\tif (lru->percpu)\n\t\treturn bpf_percpu_lru_pop_free(lru, hash);\n\telse\n\t\treturn bpf_common_lru_pop_free(lru, hash);\n}",
          "includes": [
            "#include \"bpf_lru_list.h\"",
            "#include <linux/percpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/cpumask.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_lru_list.h\"\n#include <linux/percpu.h>\n#include <linux/spinlock.h>\n#include <linux/cpumask.h>\n\nstruct bpf_lru_node *bpf_lru_pop_free(struct bpf_lru *lru, u32 hash)\n{\n\tif (lru->percpu)\n\t\treturn bpf_percpu_lru_pop_free(lru, hash);\n\telse\n\t\treturn bpf_common_lru_pop_free(lru, hash);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool htab_lru_map_delete_node(void *arg, struct bpf_lru_node *node);\n\nstatic struct htab_elem *prealloc_lru_pop(struct bpf_htab *htab, void *key,\n\t\t\t\t\t  u32 hash)\n{\n\tstruct bpf_lru_node *node = bpf_lru_pop_free(&htab->lru, hash);\n\tstruct htab_elem *l;\n\n\tif (node) {\n\t\tl = container_of(node, struct htab_elem, lru_node);\n\t\tmemcpy(l->key, key, htab->map.key_size);\n\t\treturn l;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "htab_free_elems",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "108-125",
    "snippet": "static void htab_free_elems(struct bpf_htab *htab)\n{\n\tint i;\n\n\tif (!htab_is_percpu(htab))\n\t\tgoto free_elems;\n\n\tfor (i = 0; i < htab->map.max_entries; i++) {\n\t\tvoid __percpu *pptr;\n\n\t\tpptr = htab_elem_get_ptr(get_htab_elem(htab, i),\n\t\t\t\t\t htab->map.key_size);\n\t\tfree_percpu(pptr);\n\t\tcond_resched();\n\t}\nfree_elems:\n\tbpf_map_area_free(htab->elems);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_area_free",
          "args": [
            "htab->elems"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "156-159",
          "snippet": "void bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4957-4965",
          "snippet": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "pptr"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_elem_get_ptr",
          "args": [
            "get_htab_elem(htab, i)",
            "htab->map.key_size"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "htab_elem_get_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "93-96",
          "snippet": "static inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_htab_elem",
          "args": [
            "htab",
            "i"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "get_htab_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "103-106",
          "snippet": "static struct htab_elem *get_htab_elem(struct bpf_htab *htab, int i)\n{\n\treturn (struct htab_elem *) (htab->elems + i * htab->elem_size);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct htab_elem *get_htab_elem(struct bpf_htab *htab, int i)\n{\n\treturn (struct htab_elem *) (htab->elems + i * htab->elem_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htab_is_percpu",
          "args": [
            "htab"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "htab_is_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "76-80",
          "snippet": "static bool htab_is_percpu(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t\thtab->map.map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool htab_is_percpu(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t\thtab->map.map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void htab_free_elems(struct bpf_htab *htab)\n{\n\tint i;\n\n\tif (!htab_is_percpu(htab))\n\t\tgoto free_elems;\n\n\tfor (i = 0; i < htab->map.max_entries; i++) {\n\t\tvoid __percpu *pptr;\n\n\t\tpptr = htab_elem_get_ptr(get_htab_elem(htab, i),\n\t\t\t\t\t htab->map.key_size);\n\t\tfree_percpu(pptr);\n\t\tcond_resched();\n\t}\nfree_elems:\n\tbpf_map_area_free(htab->elems);\n}"
  },
  {
    "function_name": "get_htab_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "103-106",
    "snippet": "static struct htab_elem *get_htab_elem(struct bpf_htab *htab, int i)\n{\n\treturn (struct htab_elem *) (htab->elems + i * htab->elem_size);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct htab_elem *get_htab_elem(struct bpf_htab *htab, int i)\n{\n\treturn (struct htab_elem *) (htab->elems + i * htab->elem_size);\n}"
  },
  {
    "function_name": "fd_htab_map_get_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "98-101",
    "snippet": "static void *fd_htab_map_get_ptr(const struct bpf_map *map, struct htab_elem *l)\n{\n\treturn *(void **)(l->key + roundup(map->key_size, 8));\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "map->key_size",
            "8"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *fd_htab_map_get_ptr(const struct bpf_map *map, struct htab_elem *l)\n{\n\treturn *(void **)(l->key + roundup(map->key_size, 8));\n}"
  },
  {
    "function_name": "htab_elem_get_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "93-96",
    "snippet": "static inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline void __percpu *htab_elem_get_ptr(struct htab_elem *l, u32 key_size)\n{\n\treturn *(void __percpu **)(l->key + key_size);\n}"
  },
  {
    "function_name": "htab_elem_set_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "87-91",
    "snippet": "static inline void htab_elem_set_ptr(struct htab_elem *l, u32 key_size,\n\t\t\t\t     void __percpu *pptr)\n{\n\t*(void __percpu **)(l->key + key_size) = pptr;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline void htab_elem_set_ptr(struct htab_elem *l, u32 key_size,\n\t\t\t\t     void __percpu *pptr)\n{\n\t*(void __percpu **)(l->key + key_size) = pptr;\n}"
  },
  {
    "function_name": "htab_is_prealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "82-85",
    "snippet": "static bool htab_is_prealloc(const struct bpf_htab *htab)\n{\n\treturn !(htab->map.map_flags & BPF_F_NO_PREALLOC);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool htab_is_prealloc(const struct bpf_htab *htab)\n{\n\treturn !(htab->map.map_flags & BPF_F_NO_PREALLOC);\n}"
  },
  {
    "function_name": "htab_is_percpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "76-80",
    "snippet": "static bool htab_is_percpu(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t\thtab->map.map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool htab_is_percpu(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t\thtab->map.map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH;\n}"
  },
  {
    "function_name": "htab_is_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
    "lines": "70-74",
    "snippet": "static bool htab_is_lru(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t\thtab->map.map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include \"bpf_lru_list.h\"",
      "#include \"percpu_freelist.h\"",
      "#include <uapi/linux/btf.h>",
      "#include <linux/random.h>",
      "#include <linux/rculist_nulls.h>",
      "#include <linux/filter.h>",
      "#include <linux/jhash.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool htab_is_lru(const struct bpf_htab *htab)\n{\n\treturn htab->map.map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t\thtab->map.map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH;\n}"
  }
]