[
  {
    "function_name": "btf_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "2352-2355",
    "snippet": "u32 btf_id(const struct btf *btf)\n{\n\treturn btf->id;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nu32 btf_id(const struct btf *btf)\n{\n\treturn btf->id;\n}"
  },
  {
    "function_name": "btf_get_fd_by_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "2331-2350",
    "snippet": "int btf_get_fd_by_id(u32 id)\n{\n\tstruct btf *btf;\n\tint fd;\n\n\trcu_read_lock();\n\tbtf = idr_find(&btf_idr, id);\n\tif (!btf || !refcount_inc_not_zero(&btf->refcnt))\n\t\tbtf = ERR_PTR(-ENOENT);\n\trcu_read_unlock();\n\n\tif (IS_ERR(btf))\n\t\treturn PTR_ERR(btf);\n\n\tfd = __btf_new_fd(btf);\n\tif (fd < 0)\n\t\tbtf_put(btf);\n\n\treturn fd;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(btf_idr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_put",
          "args": [
            "btf"
          ],
          "line": 2347
        },
        "resolved": true,
        "details": {
          "function_name": "btf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "684-690",
          "snippet": "void btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btf_new_fd",
          "args": [
            "btf"
          ],
          "line": 2345
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_new_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "2242-2245",
          "snippet": "static int __btf_new_fd(struct btf *btf)\n{\n\treturn anon_inode_getfd(\"btf\", &btf_fops, btf, O_RDONLY | O_CLOEXEC);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations btf_fops = {\n\t.release\t= btf_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nconst struct file_operations btf_fops = {\n\t.release\t= btf_release,\n};\n\nstatic int __btf_new_fd(struct btf *btf)\n{\n\treturn anon_inode_getfd(\"btf\", &btf_fops, btf, O_RDONLY | O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "btf"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "btf"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_inc_not_zero",
          "args": [
            "&btf->refcnt"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&btf_idr",
            "id"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic DEFINE_IDR(btf_idr);\n\nint btf_get_fd_by_id(u32 id)\n{\n\tstruct btf *btf;\n\tint fd;\n\n\trcu_read_lock();\n\tbtf = idr_find(&btf_idr, id);\n\tif (!btf || !refcount_inc_not_zero(&btf->refcnt))\n\t\tbtf = ERR_PTR(-ENOENT);\n\trcu_read_unlock();\n\n\tif (IS_ERR(btf))\n\t\treturn PTR_ERR(btf);\n\n\tfd = __btf_new_fd(btf);\n\tif (fd < 0)\n\t\tbtf_put(btf);\n\n\treturn fd;\n}"
  },
  {
    "function_name": "btf_get_info_by_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "2300-2329",
    "snippet": "int btf_get_info_by_fd(const struct btf *btf,\n\t\t       const union bpf_attr *attr,\n\t\t       union bpf_attr __user *uattr)\n{\n\tstruct bpf_btf_info __user *uinfo;\n\tstruct bpf_btf_info info = {};\n\tu32 info_copy, btf_copy;\n\tvoid __user *ubtf;\n\tu32 uinfo_len;\n\n\tuinfo = u64_to_user_ptr(attr->info.info);\n\tuinfo_len = attr->info.info_len;\n\n\tinfo_copy = min_t(u32, uinfo_len, sizeof(info));\n\tif (copy_from_user(&info, uinfo, info_copy))\n\t\treturn -EFAULT;\n\n\tinfo.id = btf->id;\n\tubtf = u64_to_user_ptr(info.btf);\n\tbtf_copy = min_t(u32, btf->data_size, info.btf_size);\n\tif (copy_to_user(ubtf, btf->data, btf_copy))\n\t\treturn -EFAULT;\n\tinfo.btf_size = btf->data_size;\n\n\tif (copy_to_user(uinfo, &info, info_copy) ||\n\t    put_user(info_copy, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "info_copy",
            "&uattr->info.info_len"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uinfo",
            "&info",
            "info_copy"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "btf->data_size",
            "info.btf_size"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "info.btf"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&info",
            "uinfo",
            "info_copy"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "uinfo_len",
            "sizeof(info)"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->info.info"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nint btf_get_info_by_fd(const struct btf *btf,\n\t\t       const union bpf_attr *attr,\n\t\t       union bpf_attr __user *uattr)\n{\n\tstruct bpf_btf_info __user *uinfo;\n\tstruct bpf_btf_info info = {};\n\tu32 info_copy, btf_copy;\n\tvoid __user *ubtf;\n\tu32 uinfo_len;\n\n\tuinfo = u64_to_user_ptr(attr->info.info);\n\tuinfo_len = attr->info.info_len;\n\n\tinfo_copy = min_t(u32, uinfo_len, sizeof(info));\n\tif (copy_from_user(&info, uinfo, info_copy))\n\t\treturn -EFAULT;\n\n\tinfo.id = btf->id;\n\tubtf = u64_to_user_ptr(info.btf);\n\tbtf_copy = min_t(u32, btf->data_size, info.btf_size);\n\tif (copy_to_user(ubtf, btf->data, btf_copy))\n\t\treturn -EFAULT;\n\tinfo.btf_size = btf->data_size;\n\n\tif (copy_to_user(uinfo, &info, info_copy) ||\n\t    put_user(info_copy, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_get_by_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "2278-2298",
    "snippet": "struct btf *btf_get_by_fd(int fd)\n{\n\tstruct btf *btf;\n\tstruct fd f;\n\n\tf = fdget(fd);\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (f.file->f_op != &btf_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tbtf = f.file->private_data;\n\trefcount_inc(&btf->refcnt);\n\tfdput(f);\n\n\treturn btf;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations btf_fops = {\n\t.release\t= btf_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_inc",
          "args": [
            "&btf->refcnt"
          ],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "50-53",
          "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nconst struct file_operations btf_fops = {\n\t.release\t= btf_release,\n};\n\nstruct btf *btf_get_by_fd(int fd)\n{\n\tstruct btf *btf;\n\tstruct fd f;\n\n\tf = fdget(fd);\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (f.file->f_op != &btf_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tbtf = f.file->private_data;\n\trefcount_inc(&btf->refcnt);\n\tfdput(f);\n\n\treturn btf;\n}"
  },
  {
    "function_name": "btf_new_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "2247-2276",
    "snippet": "int btf_new_fd(const union bpf_attr *attr)\n{\n\tstruct btf *btf;\n\tint ret;\n\n\tbtf = btf_parse(u64_to_user_ptr(attr->btf),\n\t\t\tattr->btf_size, attr->btf_log_level,\n\t\t\tu64_to_user_ptr(attr->btf_log_buf),\n\t\t\tattr->btf_log_size);\n\tif (IS_ERR(btf))\n\t\treturn PTR_ERR(btf);\n\n\tret = btf_alloc_id(btf);\n\tif (ret) {\n\t\tbtf_free(btf);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * The BTF ID is published to the userspace.\n\t * All BTF free must go through call_rcu() from\n\t * now on (i.e. free by calling btf_put()).\n\t */\n\n\tret = __btf_new_fd(btf);\n\tif (ret < 0)\n\t\tbtf_put(btf);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_put",
          "args": [
            "btf"
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "btf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "684-690",
          "snippet": "void btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btf_new_fd",
          "args": [
            "btf"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_new_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "2242-2245",
          "snippet": "static int __btf_new_fd(struct btf *btf)\n{\n\treturn anon_inode_getfd(\"btf\", &btf_fops, btf, O_RDONLY | O_CLOEXEC);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations btf_fops = {\n\t.release\t= btf_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nconst struct file_operations btf_fops = {\n\t.release\t= btf_release,\n};\n\nstatic int __btf_new_fd(struct btf *btf)\n{\n\treturn anon_inode_getfd(\"btf\", &btf_fops, btf, O_RDONLY | O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_free",
          "args": [
            "btf"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "btf_free_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "677-682",
          "snippet": "static void btf_free_rcu(struct rcu_head *rcu)\n{\n\tstruct btf *btf = container_of(rcu, struct btf, rcu);\n\n\tbtf_free(btf);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_free_rcu(struct rcu_head *rcu)\n{\n\tstruct btf *btf = container_of(rcu, struct btf, rcu);\n\n\tbtf_free(btf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_alloc_id",
          "args": [
            "btf"
          ],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "btf_alloc_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "632-648",
          "snippet": "static int btf_alloc_id(struct btf *btf)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&btf_idr_lock);\n\tid = idr_alloc_cyclic(&btf_idr, btf, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tbtf->id = id;\n\tspin_unlock_bh(&btf_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(btf_idr);",
            "static DEFINE_SPINLOCK(btf_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic DEFINE_IDR(btf_idr);\nstatic DEFINE_SPINLOCK(btf_idr_lock);\n\nstatic int btf_alloc_id(struct btf *btf)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&btf_idr_lock);\n\tid = idr_alloc_cyclic(&btf_idr, btf, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tbtf->id = id;\n\tspin_unlock_bh(&btf_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "btf"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "btf"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_parse",
          "args": [
            "u64_to_user_ptr(attr->btf)",
            "attr->btf_size",
            "attr->btf_log_level",
            "u64_to_user_ptr(attr->btf_log_buf)",
            "attr->btf_log_size"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "btf_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "2140-2222",
          "snippet": "static struct btf *btf_parse(void __user *btf_data, u32 btf_data_size,\n\t\t\t     u32 log_level, char __user *log_ubuf, u32 log_size)\n{\n\tstruct btf_verifier_env *env = NULL;\n\tstruct bpf_verifier_log *log;\n\tstruct btf *btf = NULL;\n\tu8 *data;\n\tint err;\n\n\tif (btf_data_size > BTF_MAX_SIZE)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL | __GFP_NOWARN);\n\tif (!env)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlog = &env->log;\n\tif (log_level || log_ubuf || log_size) {\n\t\t/* user requested verbose verifier output\n\t\t * and supplied buffer to store the verification trace\n\t\t */\n\t\tlog->level = log_level;\n\t\tlog->ubuf = log_ubuf;\n\t\tlog->len_total = log_size;\n\n\t\t/* log attributes have to be sane */\n\t\tif (log->len_total < 128 || log->len_total > UINT_MAX >> 8 ||\n\t\t    !log->level || !log->ubuf) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tbtf = kzalloc(sizeof(*btf), GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tenv->btf = btf;\n\n\tdata = kvmalloc(btf_data_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!data) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tbtf->data = data;\n\tbtf->data_size = btf_data_size;\n\n\tif (copy_from_user(data, btf_data, btf_data_size)) {\n\t\terr = -EFAULT;\n\t\tgoto errout;\n\t}\n\n\terr = btf_parse_hdr(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf->nohdr_data = btf->data + btf->hdr.hdr_len;\n\n\terr = btf_parse_str_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\terr = btf_parse_type_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\tif (log->level && bpf_verifier_log_full(log)) {\n\t\terr = -ENOSPC;\n\t\tgoto errout;\n\t}\n\n\tbtf_verifier_env_free(env);\n\trefcount_set(&btf->refcnt, 1);\n\treturn btf;\n\nerrout:\n\tbtf_verifier_env_free(env);\n\tif (btf)\n\t\tbtf_free(btf);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define BTF_MAX_SIZE (16 * 1024 * 1024)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\n#define BTF_MAX_SIZE (16 * 1024 * 1024)\n\nstatic struct btf *btf_parse(void __user *btf_data, u32 btf_data_size,\n\t\t\t     u32 log_level, char __user *log_ubuf, u32 log_size)\n{\n\tstruct btf_verifier_env *env = NULL;\n\tstruct bpf_verifier_log *log;\n\tstruct btf *btf = NULL;\n\tu8 *data;\n\tint err;\n\n\tif (btf_data_size > BTF_MAX_SIZE)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL | __GFP_NOWARN);\n\tif (!env)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlog = &env->log;\n\tif (log_level || log_ubuf || log_size) {\n\t\t/* user requested verbose verifier output\n\t\t * and supplied buffer to store the verification trace\n\t\t */\n\t\tlog->level = log_level;\n\t\tlog->ubuf = log_ubuf;\n\t\tlog->len_total = log_size;\n\n\t\t/* log attributes have to be sane */\n\t\tif (log->len_total < 128 || log->len_total > UINT_MAX >> 8 ||\n\t\t    !log->level || !log->ubuf) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tbtf = kzalloc(sizeof(*btf), GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tenv->btf = btf;\n\n\tdata = kvmalloc(btf_data_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!data) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tbtf->data = data;\n\tbtf->data_size = btf_data_size;\n\n\tif (copy_from_user(data, btf_data, btf_data_size)) {\n\t\terr = -EFAULT;\n\t\tgoto errout;\n\t}\n\n\terr = btf_parse_hdr(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf->nohdr_data = btf->data + btf->hdr.hdr_len;\n\n\terr = btf_parse_str_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\terr = btf_parse_type_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\tif (log->level && bpf_verifier_log_full(log)) {\n\t\terr = -ENOSPC;\n\t\tgoto errout;\n\t}\n\n\tbtf_verifier_env_free(env);\n\trefcount_set(&btf->refcnt, 1);\n\treturn btf;\n\nerrout:\n\tbtf_verifier_env_free(env);\n\tif (btf)\n\t\tbtf_free(btf);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->btf_log_buf"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->btf"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nint btf_new_fd(const union bpf_attr *attr)\n{\n\tstruct btf *btf;\n\tint ret;\n\n\tbtf = btf_parse(u64_to_user_ptr(attr->btf),\n\t\t\tattr->btf_size, attr->btf_log_level,\n\t\t\tu64_to_user_ptr(attr->btf_log_buf),\n\t\t\tattr->btf_log_size);\n\tif (IS_ERR(btf))\n\t\treturn PTR_ERR(btf);\n\n\tret = btf_alloc_id(btf);\n\tif (ret) {\n\t\tbtf_free(btf);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * The BTF ID is published to the userspace.\n\t * All BTF free must go through call_rcu() from\n\t * now on (i.e. free by calling btf_put()).\n\t */\n\n\tret = __btf_new_fd(btf);\n\tif (ret < 0)\n\t\tbtf_put(btf);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__btf_new_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "2242-2245",
    "snippet": "static int __btf_new_fd(struct btf *btf)\n{\n\treturn anon_inode_getfd(\"btf\", &btf_fops, btf, O_RDONLY | O_CLOEXEC);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations btf_fops = {\n\t.release\t= btf_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_inode_getfd",
          "args": [
            "\"btf\"",
            "&btf_fops",
            "btf",
            "O_RDONLY | O_CLOEXEC"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nconst struct file_operations btf_fops = {\n\t.release\t= btf_release,\n};\n\nstatic int __btf_new_fd(struct btf *btf)\n{\n\treturn anon_inode_getfd(\"btf\", &btf_fops, btf, O_RDONLY | O_CLOEXEC);\n}"
  },
  {
    "function_name": "btf_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "2232-2236",
    "snippet": "static int btf_release(struct inode *inode, struct file *filp)\n{\n\tbtf_put(filp->private_data);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_put",
          "args": [
            "filp->private_data"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "btf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "684-690",
          "snippet": "void btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_release(struct inode *inode, struct file *filp)\n{\n\tbtf_put(filp->private_data);\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_type_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "2224-2230",
    "snippet": "void btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, type_id);\n\n\tbtf_type_ops(t)->seq_show(btf, t, type_id, obj, 0, m);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "btf",
            "t",
            "type_id",
            "obj",
            "0",
            "m"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "t"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "418-421",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "type_id"
          ],
          "line": 2227
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "439-445",
          "snippet": "static const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, type_id);\n\n\tbtf_type_ops(t)->seq_show(btf, t, type_id, obj, 0, m);\n}"
  },
  {
    "function_name": "btf_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "2140-2222",
    "snippet": "static struct btf *btf_parse(void __user *btf_data, u32 btf_data_size,\n\t\t\t     u32 log_level, char __user *log_ubuf, u32 log_size)\n{\n\tstruct btf_verifier_env *env = NULL;\n\tstruct bpf_verifier_log *log;\n\tstruct btf *btf = NULL;\n\tu8 *data;\n\tint err;\n\n\tif (btf_data_size > BTF_MAX_SIZE)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL | __GFP_NOWARN);\n\tif (!env)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlog = &env->log;\n\tif (log_level || log_ubuf || log_size) {\n\t\t/* user requested verbose verifier output\n\t\t * and supplied buffer to store the verification trace\n\t\t */\n\t\tlog->level = log_level;\n\t\tlog->ubuf = log_ubuf;\n\t\tlog->len_total = log_size;\n\n\t\t/* log attributes have to be sane */\n\t\tif (log->len_total < 128 || log->len_total > UINT_MAX >> 8 ||\n\t\t    !log->level || !log->ubuf) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tbtf = kzalloc(sizeof(*btf), GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tenv->btf = btf;\n\n\tdata = kvmalloc(btf_data_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!data) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tbtf->data = data;\n\tbtf->data_size = btf_data_size;\n\n\tif (copy_from_user(data, btf_data, btf_data_size)) {\n\t\terr = -EFAULT;\n\t\tgoto errout;\n\t}\n\n\terr = btf_parse_hdr(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf->nohdr_data = btf->data + btf->hdr.hdr_len;\n\n\terr = btf_parse_str_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\terr = btf_parse_type_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\tif (log->level && bpf_verifier_log_full(log)) {\n\t\terr = -ENOSPC;\n\t\tgoto errout;\n\t}\n\n\tbtf_verifier_env_free(env);\n\trefcount_set(&btf->refcnt, 1);\n\treturn btf;\n\nerrout:\n\tbtf_verifier_env_free(env);\n\tif (btf)\n\t\tbtf_free(btf);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define BTF_MAX_SIZE (16 * 1024 * 1024)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_free",
          "args": [
            "btf"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "btf_free_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "677-682",
          "snippet": "static void btf_free_rcu(struct rcu_head *rcu)\n{\n\tstruct btf *btf = container_of(rcu, struct btf, rcu);\n\n\tbtf_free(btf);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_free_rcu(struct rcu_head *rcu)\n{\n\tstruct btf *btf = container_of(rcu, struct btf, rcu);\n\n\tbtf_free(btf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_env_free",
          "args": [
            "env"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_env_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "729-733",
          "snippet": "static void btf_verifier_env_free(struct btf_verifier_env *env)\n{\n\tkvfree(env->visit_states);\n\tkfree(env);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_env_free(struct btf_verifier_env *env)\n{\n\tkvfree(env->visit_states);\n\tkfree(env);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&btf->refcnt",
            "1"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_verifier_log_full",
          "args": [
            "log"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_parse_type_sec",
          "args": [
            "env"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "btf_parse_type_sec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "1955-1976",
          "snippet": "static int btf_parse_type_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr = &env->btf->hdr;\n\tint err;\n\n\t/* Type section must align to 4 bytes */\n\tif (hdr->type_off & (sizeof(u32) - 1)) {\n\t\tbtf_verifier_log(env, \"Unaligned type_off\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!hdr->type_len) {\n\t\tbtf_verifier_log(env, \"No type found\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_all_metas(env);\n\tif (err)\n\t\treturn err;\n\n\treturn btf_check_all_types(env);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_parse_type_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr = &env->btf->hdr;\n\tint err;\n\n\t/* Type section must align to 4 bytes */\n\tif (hdr->type_off & (sizeof(u32) - 1)) {\n\t\tbtf_verifier_log(env, \"Unaligned type_off\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!hdr->type_len) {\n\t\tbtf_verifier_log(env, \"No type found\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_all_metas(env);\n\tif (err)\n\t\treturn err;\n\n\treturn btf_check_all_types(env);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_parse_str_sec",
          "args": [
            "env"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "btf_parse_str_sec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "1978-2002",
          "snippet": "static int btf_parse_str_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr;\n\tstruct btf *btf = env->btf;\n\tconst char *start, *end;\n\n\thdr = &btf->hdr;\n\tstart = btf->nohdr_data + hdr->str_off;\n\tend = start + hdr->str_len;\n\n\tif (end != btf->data + btf->data_size) {\n\t\tbtf_verifier_log(env, \"String section is not at the end\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!hdr->str_len || hdr->str_len - 1 > BTF_MAX_NAME_OFFSET ||\n\t    start[0] || end[-1]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf->strings = start;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_parse_str_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr;\n\tstruct btf *btf = env->btf;\n\tconst char *start, *end;\n\n\thdr = &btf->hdr;\n\tstart = btf->nohdr_data + hdr->str_off;\n\tend = start + hdr->str_len;\n\n\tif (end != btf->data + btf->data_size) {\n\t\tbtf_verifier_log(env, \"String section is not at the end\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!hdr->str_len || hdr->str_len - 1 > BTF_MAX_NAME_OFFSET ||\n\t    start[0] || end[-1]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf->strings = start;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_parse_hdr",
          "args": [
            "env"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "btf_parse_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "2070-2138",
          "snippet": "static int btf_parse_hdr(struct btf_verifier_env *env)\n{\n\tu32 hdr_len, hdr_copy, btf_data_size;\n\tconst struct btf_header *hdr;\n\tstruct btf *btf;\n\tint err;\n\n\tbtf = env->btf;\n\tbtf_data_size = btf->data_size;\n\n\tif (btf_data_size <\n\t    offsetof(struct btf_header, hdr_len) + sizeof(hdr->hdr_len)) {\n\t\tbtf_verifier_log(env, \"hdr_len not found\");\n\t\treturn -EINVAL;\n\t}\n\n\thdr = btf->data;\n\thdr_len = hdr->hdr_len;\n\tif (btf_data_size < hdr_len) {\n\t\tbtf_verifier_log(env, \"btf_header not found\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure the unsupported header fields are zero */\n\tif (hdr_len > sizeof(btf->hdr)) {\n\t\tu8 *expected_zero = btf->data + sizeof(btf->hdr);\n\t\tu8 *end = btf->data + hdr_len;\n\n\t\tfor (; expected_zero < end; expected_zero++) {\n\t\t\tif (*expected_zero) {\n\t\t\t\tbtf_verifier_log(env, \"Unsupported btf_header\");\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\t\t}\n\t}\n\n\thdr_copy = min_t(u32, hdr_len, sizeof(btf->hdr));\n\tmemcpy(&btf->hdr, btf->data, hdr_copy);\n\n\thdr = &btf->hdr;\n\n\tbtf_verifier_log_hdr(env, btf_data_size);\n\n\tif (hdr->magic != BTF_MAGIC) {\n\t\tbtf_verifier_log(env, \"Invalid magic\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->version != BTF_VERSION) {\n\t\tbtf_verifier_log(env, \"Unsupported version\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (hdr->flags) {\n\t\tbtf_verifier_log(env, \"Unsupported flags\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (btf_data_size == hdr->hdr_len) {\n\t\tbtf_verifier_log(env, \"No data\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_sec_info(env, btf_data_size);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_parse_hdr(struct btf_verifier_env *env)\n{\n\tu32 hdr_len, hdr_copy, btf_data_size;\n\tconst struct btf_header *hdr;\n\tstruct btf *btf;\n\tint err;\n\n\tbtf = env->btf;\n\tbtf_data_size = btf->data_size;\n\n\tif (btf_data_size <\n\t    offsetof(struct btf_header, hdr_len) + sizeof(hdr->hdr_len)) {\n\t\tbtf_verifier_log(env, \"hdr_len not found\");\n\t\treturn -EINVAL;\n\t}\n\n\thdr = btf->data;\n\thdr_len = hdr->hdr_len;\n\tif (btf_data_size < hdr_len) {\n\t\tbtf_verifier_log(env, \"btf_header not found\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure the unsupported header fields are zero */\n\tif (hdr_len > sizeof(btf->hdr)) {\n\t\tu8 *expected_zero = btf->data + sizeof(btf->hdr);\n\t\tu8 *end = btf->data + hdr_len;\n\n\t\tfor (; expected_zero < end; expected_zero++) {\n\t\t\tif (*expected_zero) {\n\t\t\t\tbtf_verifier_log(env, \"Unsupported btf_header\");\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\t\t}\n\t}\n\n\thdr_copy = min_t(u32, hdr_len, sizeof(btf->hdr));\n\tmemcpy(&btf->hdr, btf->data, hdr_copy);\n\n\thdr = &btf->hdr;\n\n\tbtf_verifier_log_hdr(env, btf_data_size);\n\n\tif (hdr->magic != BTF_MAGIC) {\n\t\tbtf_verifier_log(env, \"Invalid magic\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->version != BTF_VERSION) {\n\t\tbtf_verifier_log(env, \"Unsupported version\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (hdr->flags) {\n\t\tbtf_verifier_log(env, \"Unsupported flags\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (btf_data_size == hdr->hdr_len) {\n\t\tbtf_verifier_log(env, \"No data\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_sec_info(env, btf_data_size);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "data",
            "btf_data",
            "btf_data_size"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "btf_data_size",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*btf)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*env)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-E2BIG"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\n#define BTF_MAX_SIZE (16 * 1024 * 1024)\n\nstatic struct btf *btf_parse(void __user *btf_data, u32 btf_data_size,\n\t\t\t     u32 log_level, char __user *log_ubuf, u32 log_size)\n{\n\tstruct btf_verifier_env *env = NULL;\n\tstruct bpf_verifier_log *log;\n\tstruct btf *btf = NULL;\n\tu8 *data;\n\tint err;\n\n\tif (btf_data_size > BTF_MAX_SIZE)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL | __GFP_NOWARN);\n\tif (!env)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlog = &env->log;\n\tif (log_level || log_ubuf || log_size) {\n\t\t/* user requested verbose verifier output\n\t\t * and supplied buffer to store the verification trace\n\t\t */\n\t\tlog->level = log_level;\n\t\tlog->ubuf = log_ubuf;\n\t\tlog->len_total = log_size;\n\n\t\t/* log attributes have to be sane */\n\t\tif (log->len_total < 128 || log->len_total > UINT_MAX >> 8 ||\n\t\t    !log->level || !log->ubuf) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tbtf = kzalloc(sizeof(*btf), GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tenv->btf = btf;\n\n\tdata = kvmalloc(btf_data_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!data) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tbtf->data = data;\n\tbtf->data_size = btf_data_size;\n\n\tif (copy_from_user(data, btf_data, btf_data_size)) {\n\t\terr = -EFAULT;\n\t\tgoto errout;\n\t}\n\n\terr = btf_parse_hdr(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf->nohdr_data = btf->data + btf->hdr.hdr_len;\n\n\terr = btf_parse_str_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\terr = btf_parse_type_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\tif (log->level && bpf_verifier_log_full(log)) {\n\t\terr = -ENOSPC;\n\t\tgoto errout;\n\t}\n\n\tbtf_verifier_env_free(env);\n\trefcount_set(&btf->refcnt, 1);\n\treturn btf;\n\nerrout:\n\tbtf_verifier_env_free(env);\n\tif (btf)\n\t\tbtf_free(btf);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "btf_parse_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "2070-2138",
    "snippet": "static int btf_parse_hdr(struct btf_verifier_env *env)\n{\n\tu32 hdr_len, hdr_copy, btf_data_size;\n\tconst struct btf_header *hdr;\n\tstruct btf *btf;\n\tint err;\n\n\tbtf = env->btf;\n\tbtf_data_size = btf->data_size;\n\n\tif (btf_data_size <\n\t    offsetof(struct btf_header, hdr_len) + sizeof(hdr->hdr_len)) {\n\t\tbtf_verifier_log(env, \"hdr_len not found\");\n\t\treturn -EINVAL;\n\t}\n\n\thdr = btf->data;\n\thdr_len = hdr->hdr_len;\n\tif (btf_data_size < hdr_len) {\n\t\tbtf_verifier_log(env, \"btf_header not found\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure the unsupported header fields are zero */\n\tif (hdr_len > sizeof(btf->hdr)) {\n\t\tu8 *expected_zero = btf->data + sizeof(btf->hdr);\n\t\tu8 *end = btf->data + hdr_len;\n\n\t\tfor (; expected_zero < end; expected_zero++) {\n\t\t\tif (*expected_zero) {\n\t\t\t\tbtf_verifier_log(env, \"Unsupported btf_header\");\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\t\t}\n\t}\n\n\thdr_copy = min_t(u32, hdr_len, sizeof(btf->hdr));\n\tmemcpy(&btf->hdr, btf->data, hdr_copy);\n\n\thdr = &btf->hdr;\n\n\tbtf_verifier_log_hdr(env, btf_data_size);\n\n\tif (hdr->magic != BTF_MAGIC) {\n\t\tbtf_verifier_log(env, \"Invalid magic\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->version != BTF_VERSION) {\n\t\tbtf_verifier_log(env, \"Unsupported version\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (hdr->flags) {\n\t\tbtf_verifier_log(env, \"Unsupported flags\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (btf_data_size == hdr->hdr_len) {\n\t\tbtf_verifier_log(env, \"No data\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_sec_info(env, btf_data_size);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_check_sec_info",
          "args": [
            "env",
            "btf_data_size"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "btf_check_sec_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "2017-2068",
          "snippet": "static int btf_check_sec_info(struct btf_verifier_env *env,\n\t\t\t      u32 btf_data_size)\n{\n\tstruct btf_sec_info secs[ARRAY_SIZE(btf_sec_info_offset)];\n\tu32 total, expected_total, i;\n\tconst struct btf_header *hdr;\n\tconst struct btf *btf;\n\n\tbtf = env->btf;\n\thdr = &btf->hdr;\n\n\t/* Populate the secs from hdr */\n\tfor (i = 0; i < ARRAY_SIZE(btf_sec_info_offset); i++)\n\t\tsecs[i] = *(struct btf_sec_info *)((void *)hdr +\n\t\t\t\t\t\t   btf_sec_info_offset[i]);\n\n\tsort(secs, ARRAY_SIZE(btf_sec_info_offset),\n\t     sizeof(struct btf_sec_info), btf_sec_info_cmp, NULL);\n\n\t/* Check for gaps and overlap among sections */\n\ttotal = 0;\n\texpected_total = btf_data_size - hdr->hdr_len;\n\tfor (i = 0; i < ARRAY_SIZE(btf_sec_info_offset); i++) {\n\t\tif (expected_total < secs[i].off) {\n\t\t\tbtf_verifier_log(env, \"Invalid section offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total < secs[i].off) {\n\t\t\t/* gap */\n\t\t\tbtf_verifier_log(env, \"Unsupported section found\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total > secs[i].off) {\n\t\t\tbtf_verifier_log(env, \"Section overlap found\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (expected_total - total < secs[i].len) {\n\t\t\tbtf_verifier_log(env,\n\t\t\t\t\t \"Total section length too long\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttotal += secs[i].len;\n\t}\n\n\t/* There is data other than hdr and known sections */\n\tif (expected_total != total) {\n\t\tbtf_verifier_log(env, \"Unsupported section found\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t btf_sec_info_offset[] = {\n\toffsetof(struct btf_header, type_off),\n\toffsetof(struct btf_header, str_off),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const size_t btf_sec_info_offset[] = {\n\toffsetof(struct btf_header, type_off),\n\toffsetof(struct btf_header, str_off),\n};\n\nstatic int btf_check_sec_info(struct btf_verifier_env *env,\n\t\t\t      u32 btf_data_size)\n{\n\tstruct btf_sec_info secs[ARRAY_SIZE(btf_sec_info_offset)];\n\tu32 total, expected_total, i;\n\tconst struct btf_header *hdr;\n\tconst struct btf *btf;\n\n\tbtf = env->btf;\n\thdr = &btf->hdr;\n\n\t/* Populate the secs from hdr */\n\tfor (i = 0; i < ARRAY_SIZE(btf_sec_info_offset); i++)\n\t\tsecs[i] = *(struct btf_sec_info *)((void *)hdr +\n\t\t\t\t\t\t   btf_sec_info_offset[i]);\n\n\tsort(secs, ARRAY_SIZE(btf_sec_info_offset),\n\t     sizeof(struct btf_sec_info), btf_sec_info_cmp, NULL);\n\n\t/* Check for gaps and overlap among sections */\n\ttotal = 0;\n\texpected_total = btf_data_size - hdr->hdr_len;\n\tfor (i = 0; i < ARRAY_SIZE(btf_sec_info_offset); i++) {\n\t\tif (expected_total < secs[i].off) {\n\t\t\tbtf_verifier_log(env, \"Invalid section offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total < secs[i].off) {\n\t\t\t/* gap */\n\t\t\tbtf_verifier_log(env, \"Unsupported section found\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total > secs[i].off) {\n\t\t\tbtf_verifier_log(env, \"Section overlap found\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (expected_total - total < secs[i].len) {\n\t\t\tbtf_verifier_log(env,\n\t\t\t\t\t \"Total section length too long\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttotal += secs[i].len;\n\t}\n\n\t/* There is data other than hdr and known sections */\n\tif (expected_total != total) {\n\t\tbtf_verifier_log(env, \"Unsupported section found\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"No data\""
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "566-586",
          "snippet": "static void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&btf->hdr",
            "btf->data",
            "hdr_copy"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "hdr_len",
            "sizeof(btf->hdr)"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_parse_hdr(struct btf_verifier_env *env)\n{\n\tu32 hdr_len, hdr_copy, btf_data_size;\n\tconst struct btf_header *hdr;\n\tstruct btf *btf;\n\tint err;\n\n\tbtf = env->btf;\n\tbtf_data_size = btf->data_size;\n\n\tif (btf_data_size <\n\t    offsetof(struct btf_header, hdr_len) + sizeof(hdr->hdr_len)) {\n\t\tbtf_verifier_log(env, \"hdr_len not found\");\n\t\treturn -EINVAL;\n\t}\n\n\thdr = btf->data;\n\thdr_len = hdr->hdr_len;\n\tif (btf_data_size < hdr_len) {\n\t\tbtf_verifier_log(env, \"btf_header not found\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure the unsupported header fields are zero */\n\tif (hdr_len > sizeof(btf->hdr)) {\n\t\tu8 *expected_zero = btf->data + sizeof(btf->hdr);\n\t\tu8 *end = btf->data + hdr_len;\n\n\t\tfor (; expected_zero < end; expected_zero++) {\n\t\t\tif (*expected_zero) {\n\t\t\t\tbtf_verifier_log(env, \"Unsupported btf_header\");\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\t\t}\n\t}\n\n\thdr_copy = min_t(u32, hdr_len, sizeof(btf->hdr));\n\tmemcpy(&btf->hdr, btf->data, hdr_copy);\n\n\thdr = &btf->hdr;\n\n\tbtf_verifier_log_hdr(env, btf_data_size);\n\n\tif (hdr->magic != BTF_MAGIC) {\n\t\tbtf_verifier_log(env, \"Invalid magic\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->version != BTF_VERSION) {\n\t\tbtf_verifier_log(env, \"Unsupported version\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (hdr->flags) {\n\t\tbtf_verifier_log(env, \"Unsupported flags\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (btf_data_size == hdr->hdr_len) {\n\t\tbtf_verifier_log(env, \"No data\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_sec_info(env, btf_data_size);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_check_sec_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "2017-2068",
    "snippet": "static int btf_check_sec_info(struct btf_verifier_env *env,\n\t\t\t      u32 btf_data_size)\n{\n\tstruct btf_sec_info secs[ARRAY_SIZE(btf_sec_info_offset)];\n\tu32 total, expected_total, i;\n\tconst struct btf_header *hdr;\n\tconst struct btf *btf;\n\n\tbtf = env->btf;\n\thdr = &btf->hdr;\n\n\t/* Populate the secs from hdr */\n\tfor (i = 0; i < ARRAY_SIZE(btf_sec_info_offset); i++)\n\t\tsecs[i] = *(struct btf_sec_info *)((void *)hdr +\n\t\t\t\t\t\t   btf_sec_info_offset[i]);\n\n\tsort(secs, ARRAY_SIZE(btf_sec_info_offset),\n\t     sizeof(struct btf_sec_info), btf_sec_info_cmp, NULL);\n\n\t/* Check for gaps and overlap among sections */\n\ttotal = 0;\n\texpected_total = btf_data_size - hdr->hdr_len;\n\tfor (i = 0; i < ARRAY_SIZE(btf_sec_info_offset); i++) {\n\t\tif (expected_total < secs[i].off) {\n\t\t\tbtf_verifier_log(env, \"Invalid section offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total < secs[i].off) {\n\t\t\t/* gap */\n\t\t\tbtf_verifier_log(env, \"Unsupported section found\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total > secs[i].off) {\n\t\t\tbtf_verifier_log(env, \"Section overlap found\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (expected_total - total < secs[i].len) {\n\t\t\tbtf_verifier_log(env,\n\t\t\t\t\t \"Total section length too long\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttotal += secs[i].len;\n\t}\n\n\t/* There is data other than hdr and known sections */\n\tif (expected_total != total) {\n\t\tbtf_verifier_log(env, \"Unsupported section found\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const size_t btf_sec_info_offset[] = {\n\toffsetof(struct btf_header, type_off),\n\toffsetof(struct btf_header, str_off),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"Unsupported section found\""
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "566-586",
          "snippet": "static void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "btf_sec_info_offset"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "secs",
            "ARRAY_SIZE(btf_sec_info_offset)",
            "sizeof(struct btf_sec_info)",
            "btf_sec_info_cmp",
            "NULL"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "986-1033",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t  const struct tracing_map_sort_entry **);\n\tint (*secondary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t    const struct tracing_map_sort_entry **);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t  const struct tracing_map_sort_entry **);\n\tint (*secondary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t    const struct tracing_map_sort_entry **);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "btf_sec_info_offset"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "btf_sec_info_offset"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "btf_sec_info_offset"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const size_t btf_sec_info_offset[] = {\n\toffsetof(struct btf_header, type_off),\n\toffsetof(struct btf_header, str_off),\n};\n\nstatic int btf_check_sec_info(struct btf_verifier_env *env,\n\t\t\t      u32 btf_data_size)\n{\n\tstruct btf_sec_info secs[ARRAY_SIZE(btf_sec_info_offset)];\n\tu32 total, expected_total, i;\n\tconst struct btf_header *hdr;\n\tconst struct btf *btf;\n\n\tbtf = env->btf;\n\thdr = &btf->hdr;\n\n\t/* Populate the secs from hdr */\n\tfor (i = 0; i < ARRAY_SIZE(btf_sec_info_offset); i++)\n\t\tsecs[i] = *(struct btf_sec_info *)((void *)hdr +\n\t\t\t\t\t\t   btf_sec_info_offset[i]);\n\n\tsort(secs, ARRAY_SIZE(btf_sec_info_offset),\n\t     sizeof(struct btf_sec_info), btf_sec_info_cmp, NULL);\n\n\t/* Check for gaps and overlap among sections */\n\ttotal = 0;\n\texpected_total = btf_data_size - hdr->hdr_len;\n\tfor (i = 0; i < ARRAY_SIZE(btf_sec_info_offset); i++) {\n\t\tif (expected_total < secs[i].off) {\n\t\t\tbtf_verifier_log(env, \"Invalid section offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total < secs[i].off) {\n\t\t\t/* gap */\n\t\t\tbtf_verifier_log(env, \"Unsupported section found\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total > secs[i].off) {\n\t\t\tbtf_verifier_log(env, \"Section overlap found\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (expected_total - total < secs[i].len) {\n\t\t\tbtf_verifier_log(env,\n\t\t\t\t\t \"Total section length too long\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttotal += secs[i].len;\n\t}\n\n\t/* There is data other than hdr and known sections */\n\tif (expected_total != total) {\n\t\tbtf_verifier_log(env, \"Unsupported section found\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_sec_info_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "2009-2015",
    "snippet": "static int btf_sec_info_cmp(const void *a, const void *b)\n{\n\tconst struct btf_sec_info *x = a;\n\tconst struct btf_sec_info *y = b;\n\n\treturn (int)(x->off - y->off) ? : (int)(x->len - y->len);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_sec_info_cmp(const void *a, const void *b)\n{\n\tconst struct btf_sec_info *x = a;\n\tconst struct btf_sec_info *y = b;\n\n\treturn (int)(x->off - y->off) ? : (int)(x->len - y->len);\n}"
  },
  {
    "function_name": "btf_parse_str_sec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1978-2002",
    "snippet": "static int btf_parse_str_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr;\n\tstruct btf *btf = env->btf;\n\tconst char *start, *end;\n\n\thdr = &btf->hdr;\n\tstart = btf->nohdr_data + hdr->str_off;\n\tend = start + hdr->str_len;\n\n\tif (end != btf->data + btf->data_size) {\n\t\tbtf_verifier_log(env, \"String section is not at the end\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!hdr->str_len || hdr->str_len - 1 > BTF_MAX_NAME_OFFSET ||\n\t    start[0] || end[-1]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf->strings = start;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"Invalid string section\""
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "566-586",
          "snippet": "static void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_parse_str_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr;\n\tstruct btf *btf = env->btf;\n\tconst char *start, *end;\n\n\thdr = &btf->hdr;\n\tstart = btf->nohdr_data + hdr->str_off;\n\tend = start + hdr->str_len;\n\n\tif (end != btf->data + btf->data_size) {\n\t\tbtf_verifier_log(env, \"String section is not at the end\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!hdr->str_len || hdr->str_len - 1 > BTF_MAX_NAME_OFFSET ||\n\t    start[0] || end[-1]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf->strings = start;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_parse_type_sec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1955-1976",
    "snippet": "static int btf_parse_type_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr = &env->btf->hdr;\n\tint err;\n\n\t/* Type section must align to 4 bytes */\n\tif (hdr->type_off & (sizeof(u32) - 1)) {\n\t\tbtf_verifier_log(env, \"Unaligned type_off\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!hdr->type_len) {\n\t\tbtf_verifier_log(env, \"No type found\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_all_metas(env);\n\tif (err)\n\t\treturn err;\n\n\treturn btf_check_all_types(env);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_check_all_types",
          "args": [
            "env"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "btf_check_all_types",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "1923-1953",
          "snippet": "static int btf_check_all_types(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tu32 type_id;\n\tint err;\n\n\terr = env_resolve_init(env);\n\tif (err)\n\t\treturn err;\n\n\tenv->phase++;\n\tfor (type_id = 1; type_id <= btf->nr_types; type_id++) {\n\t\tconst struct btf_type *t = btf_type_by_id(btf, type_id);\n\n\t\tenv->log_type_id = type_id;\n\t\tif (btf_type_needs_resolve(t) &&\n\t\t    !env_type_is_resolved(env, type_id)) {\n\t\t\terr = btf_resolve(env, t, type_id);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (btf_type_needs_resolve(t) &&\n\t\t    !btf_resolve_valid(env, t, type_id)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid resolve state\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_check_all_types(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tu32 type_id;\n\tint err;\n\n\terr = env_resolve_init(env);\n\tif (err)\n\t\treturn err;\n\n\tenv->phase++;\n\tfor (type_id = 1; type_id <= btf->nr_types; type_id++) {\n\t\tconst struct btf_type *t = btf_type_by_id(btf, type_id);\n\n\t\tenv->log_type_id = type_id;\n\t\tif (btf_type_needs_resolve(t) &&\n\t\t    !env_type_is_resolved(env, type_id)) {\n\t\t\terr = btf_resolve(env, t, type_id);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (btf_type_needs_resolve(t) &&\n\t\t    !btf_resolve_valid(env, t, type_id)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid resolve state\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_check_all_metas",
          "args": [
            "env"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "btf_check_all_metas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "1839-1864",
          "snippet": "static int btf_check_all_metas(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tstruct btf_header *hdr;\n\tvoid *cur, *end;\n\n\thdr = &btf->hdr;\n\tcur = btf->nohdr_data + hdr->type_off;\n\tend = cur + hdr->type_len;\n\n\tenv->log_type_id = 1;\n\twhile (cur < end) {\n\t\tstruct btf_type *t = cur;\n\t\ts32 meta_size;\n\n\t\tmeta_size = btf_check_meta(env, t, end - cur);\n\t\tif (meta_size < 0)\n\t\t\treturn meta_size;\n\n\t\tbtf_add_type(env, t);\n\t\tcur += meta_size;\n\t\tenv->log_type_id++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_check_all_metas(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tstruct btf_header *hdr;\n\tvoid *cur, *end;\n\n\thdr = &btf->hdr;\n\tcur = btf->nohdr_data + hdr->type_off;\n\tend = cur + hdr->type_len;\n\n\tenv->log_type_id = 1;\n\twhile (cur < end) {\n\t\tstruct btf_type *t = cur;\n\t\ts32 meta_size;\n\n\t\tmeta_size = btf_check_meta(env, t, end - cur);\n\t\tif (meta_size < 0)\n\t\t\treturn meta_size;\n\n\t\tbtf_add_type(env, t);\n\t\tcur += meta_size;\n\t\tenv->log_type_id++;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"No type found\""
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "566-586",
          "snippet": "static void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_parse_type_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr = &env->btf->hdr;\n\tint err;\n\n\t/* Type section must align to 4 bytes */\n\tif (hdr->type_off & (sizeof(u32) - 1)) {\n\t\tbtf_verifier_log(env, \"Unaligned type_off\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!hdr->type_len) {\n\t\tbtf_verifier_log(env, \"No type found\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_all_metas(env);\n\tif (err)\n\t\treturn err;\n\n\treturn btf_check_all_types(env);\n}"
  },
  {
    "function_name": "btf_check_all_types",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1923-1953",
    "snippet": "static int btf_check_all_types(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tu32 type_id;\n\tint err;\n\n\terr = env_resolve_init(env);\n\tif (err)\n\t\treturn err;\n\n\tenv->phase++;\n\tfor (type_id = 1; type_id <= btf->nr_types; type_id++) {\n\t\tconst struct btf_type *t = btf_type_by_id(btf, type_id);\n\n\t\tenv->log_type_id = type_id;\n\t\tif (btf_type_needs_resolve(t) &&\n\t\t    !env_type_is_resolved(env, type_id)) {\n\t\t\terr = btf_resolve(env, t, type_id);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (btf_type_needs_resolve(t) &&\n\t\t    !btf_resolve_valid(env, t, type_id)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid resolve state\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid resolve state\""
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_resolve_valid",
          "args": [
            "env",
            "t",
            "type_id"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "btf_resolve_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "1890-1921",
          "snippet": "static bool btf_resolve_valid(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 type_id)\n{\n\tstruct btf *btf = env->btf;\n\n\tif (!env_type_is_resolved(env, type_id))\n\t\treturn false;\n\n\tif (btf_type_is_struct(t))\n\t\treturn !btf->resolved_ids[type_id] &&\n\t\t\t!btf->resolved_sizes[type_id];\n\n\tif (btf_type_is_modifier(t) || btf_type_is_ptr(t)) {\n\t\tt = btf_type_id_resolve(btf, &type_id);\n\t\treturn t && !btf_type_is_modifier(t);\n\t}\n\n\tif (btf_type_is_array(t)) {\n\t\tconst struct btf_array *array = btf_type_array(t);\n\t\tconst struct btf_type *elem_type;\n\t\tu32 elem_type_id = array->type;\n\t\tu32 elem_size;\n\n\t\telem_type = btf_type_id_size(btf, &elem_type_id, &elem_size);\n\t\treturn elem_type && !btf_type_is_modifier(elem_type) &&\n\t\t\t(array->nelems * elem_size ==\n\t\t\t btf->resolved_sizes[type_id]);\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_resolve_valid(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 type_id)\n{\n\tstruct btf *btf = env->btf;\n\n\tif (!env_type_is_resolved(env, type_id))\n\t\treturn false;\n\n\tif (btf_type_is_struct(t))\n\t\treturn !btf->resolved_ids[type_id] &&\n\t\t\t!btf->resolved_sizes[type_id];\n\n\tif (btf_type_is_modifier(t) || btf_type_is_ptr(t)) {\n\t\tt = btf_type_id_resolve(btf, &type_id);\n\t\treturn t && !btf_type_is_modifier(t);\n\t}\n\n\tif (btf_type_is_array(t)) {\n\t\tconst struct btf_array *array = btf_type_array(t);\n\t\tconst struct btf_type *elem_type;\n\t\tu32 elem_type_id = array->type;\n\t\tu32 elem_size;\n\n\t\telem_type = btf_type_id_size(btf, &elem_type_id, &elem_size);\n\t\treturn elem_type && !btf_type_is_modifier(elem_type) &&\n\t\t\t(array->nelems * elem_size ==\n\t\t\t btf->resolved_sizes[type_id]);\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_needs_resolve",
          "args": [
            "t"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_needs_resolve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "357-363",
          "snippet": "static bool btf_type_needs_resolve(const struct btf_type *t)\n{\n\treturn btf_type_is_modifier(t) ||\n\t\tbtf_type_is_ptr(t) ||\n\t\tbtf_type_is_struct(t) ||\n\t\tbtf_type_is_array(t);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_needs_resolve(const struct btf_type *t)\n{\n\treturn btf_type_is_modifier(t) ||\n\t\tbtf_type_is_ptr(t) ||\n\t\tbtf_type_is_struct(t) ||\n\t\tbtf_type_is_array(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolved",
          "args": [
            "env",
            "type_id"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "756-760",
          "snippet": "static bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\treturn env->visit_states[type_id] == RESOLVED;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\treturn env->visit_states[type_id] == RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "type_id"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "439-445",
          "snippet": "static const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_resolve_init",
          "args": [
            "env"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "env_resolve_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "692-727",
          "snippet": "static int env_resolve_init(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tu32 nr_types = btf->nr_types;\n\tu32 *resolved_sizes = NULL;\n\tu32 *resolved_ids = NULL;\n\tu8 *visit_states = NULL;\n\n\t/* +1 for btf_void */\n\tresolved_sizes = kvcalloc(nr_types + 1, sizeof(*resolved_sizes),\n\t\t\t\t  GFP_KERNEL | __GFP_NOWARN);\n\tif (!resolved_sizes)\n\t\tgoto nomem;\n\n\tresolved_ids = kvcalloc(nr_types + 1, sizeof(*resolved_ids),\n\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!resolved_ids)\n\t\tgoto nomem;\n\n\tvisit_states = kvcalloc(nr_types + 1, sizeof(*visit_states),\n\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!visit_states)\n\t\tgoto nomem;\n\n\tbtf->resolved_sizes = resolved_sizes;\n\tbtf->resolved_ids = resolved_ids;\n\tenv->visit_states = visit_states;\n\n\treturn 0;\n\nnomem:\n\tkvfree(resolved_sizes);\n\tkvfree(resolved_ids);\n\tkvfree(visit_states);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct btf_type btf_void;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic struct btf_type btf_void;\n\nstatic int env_resolve_init(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tu32 nr_types = btf->nr_types;\n\tu32 *resolved_sizes = NULL;\n\tu32 *resolved_ids = NULL;\n\tu8 *visit_states = NULL;\n\n\t/* +1 for btf_void */\n\tresolved_sizes = kvcalloc(nr_types + 1, sizeof(*resolved_sizes),\n\t\t\t\t  GFP_KERNEL | __GFP_NOWARN);\n\tif (!resolved_sizes)\n\t\tgoto nomem;\n\n\tresolved_ids = kvcalloc(nr_types + 1, sizeof(*resolved_ids),\n\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!resolved_ids)\n\t\tgoto nomem;\n\n\tvisit_states = kvcalloc(nr_types + 1, sizeof(*visit_states),\n\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!visit_states)\n\t\tgoto nomem;\n\n\tbtf->resolved_sizes = resolved_sizes;\n\tbtf->resolved_ids = resolved_ids;\n\tenv->visit_states = visit_states;\n\n\treturn 0;\n\nnomem:\n\tkvfree(resolved_sizes);\n\tkvfree(resolved_ids);\n\tkvfree(visit_states);\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_check_all_types(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tu32 type_id;\n\tint err;\n\n\terr = env_resolve_init(env);\n\tif (err)\n\t\treturn err;\n\n\tenv->phase++;\n\tfor (type_id = 1; type_id <= btf->nr_types; type_id++) {\n\t\tconst struct btf_type *t = btf_type_by_id(btf, type_id);\n\n\t\tenv->log_type_id = type_id;\n\t\tif (btf_type_needs_resolve(t) &&\n\t\t    !env_type_is_resolved(env, type_id)) {\n\t\t\terr = btf_resolve(env, t, type_id);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (btf_type_needs_resolve(t) &&\n\t\t    !btf_resolve_valid(env, t, type_id)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid resolve state\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_resolve_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1890-1921",
    "snippet": "static bool btf_resolve_valid(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 type_id)\n{\n\tstruct btf *btf = env->btf;\n\n\tif (!env_type_is_resolved(env, type_id))\n\t\treturn false;\n\n\tif (btf_type_is_struct(t))\n\t\treturn !btf->resolved_ids[type_id] &&\n\t\t\t!btf->resolved_sizes[type_id];\n\n\tif (btf_type_is_modifier(t) || btf_type_is_ptr(t)) {\n\t\tt = btf_type_id_resolve(btf, &type_id);\n\t\treturn t && !btf_type_is_modifier(t);\n\t}\n\n\tif (btf_type_is_array(t)) {\n\t\tconst struct btf_array *array = btf_type_array(t);\n\t\tconst struct btf_type *elem_type;\n\t\tu32 elem_type_id = array->type;\n\t\tu32 elem_size;\n\n\t\telem_type = btf_type_id_size(btf, &elem_type_id, &elem_size);\n\t\treturn elem_type && !btf_type_is_modifier(elem_type) &&\n\t\t\t(array->nelems * elem_size ==\n\t\t\t btf->resolved_sizes[type_id]);\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_is_modifier",
          "args": [
            "elem_type"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_modifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "284-305",
          "snippet": "static bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&elem_type_id",
            "&elem_size"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "821-854",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_is_void_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t\tsize_type_id = btf->resolved_ids[size_type_id];\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_is_void(size_type))\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_is_void_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t\tsize_type_id = btf->resolved_ids[size_type_id];\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_is_void(size_type))\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_array",
          "args": [
            "t"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "403-406",
          "snippet": "static const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_array",
          "args": [
            "t"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "330-333",
          "snippet": "static bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_resolve",
          "args": [
            "btf",
            "&type_id"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_resolve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "814-819",
          "snippet": "static const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf->resolved_ids[*type_id];\n\treturn btf_type_by_id(btf, *type_id);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf->resolved_ids[*type_id];\n\treturn btf_type_by_id(btf, *type_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "t"
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "335-338",
          "snippet": "static bool btf_type_is_ptr(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_PTR;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_ptr(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_PTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_struct",
          "args": [
            "t"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "323-328",
          "snippet": "static bool btf_type_is_struct(const struct btf_type *t)\n{\n\tu8 kind = BTF_INFO_KIND(t->info);\n\n\treturn kind == BTF_KIND_STRUCT || kind == BTF_KIND_UNION;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_struct(const struct btf_type *t)\n{\n\tu8 kind = BTF_INFO_KIND(t->info);\n\n\treturn kind == BTF_KIND_STRUCT || kind == BTF_KIND_UNION;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolved",
          "args": [
            "env",
            "type_id"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "756-760",
          "snippet": "static bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\treturn env->visit_states[type_id] == RESOLVED;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\treturn env->visit_states[type_id] == RESOLVED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_resolve_valid(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 type_id)\n{\n\tstruct btf *btf = env->btf;\n\n\tif (!env_type_is_resolved(env, type_id))\n\t\treturn false;\n\n\tif (btf_type_is_struct(t))\n\t\treturn !btf->resolved_ids[type_id] &&\n\t\t\t!btf->resolved_sizes[type_id];\n\n\tif (btf_type_is_modifier(t) || btf_type_is_ptr(t)) {\n\t\tt = btf_type_id_resolve(btf, &type_id);\n\t\treturn t && !btf_type_is_modifier(t);\n\t}\n\n\tif (btf_type_is_array(t)) {\n\t\tconst struct btf_array *array = btf_type_array(t);\n\t\tconst struct btf_type *elem_type;\n\t\tu32 elem_type_id = array->type;\n\t\tu32 elem_size;\n\n\t\telem_type = btf_type_id_size(btf, &elem_type_id, &elem_size);\n\t\treturn elem_type && !btf_type_is_modifier(elem_type) &&\n\t\t\t(array->nelems * elem_size ==\n\t\t\t btf->resolved_sizes[type_id]);\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "btf_resolve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1866-1888",
    "snippet": "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id)\n{\n\tconst struct resolve_vertex *v;\n\tint err = 0;\n\n\tenv->resolve_mode = RESOLVE_TBD;\n\tenv_stack_push(env, t, type_id);\n\twhile (!err && (v = env_stack_peak(env))) {\n\t\tenv->log_type_id = v->type_id;\n\t\terr = btf_type_ops(v->t)->resolve(env, v);\n\t}\n\n\tenv->log_type_id = type_id;\n\tif (err == -E2BIG)\n\t\tbtf_verifier_log_type(env, t,\n\t\t\t\t      \"Exceeded max resolving depth:%u\",\n\t\t\t\t      MAX_RESOLVE_DEPTH);\n\telse if (err == -EEXIST)\n\t\tbtf_verifier_log_type(env, t, \"Loop detected\");\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define MAX_RESOLVE_DEPTH 32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Loop detected\""
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Exceeded max resolving depth:%u\"",
            "MAX_RESOLVE_DEPTH"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_verifier_log_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "493-523",
          "snippet": "static void __btf_verifier_log_type(struct btf_verifier_env *env,\n\t\t\t\t\t\t   const struct btf_type *t,\n\t\t\t\t\t\t   bool log_details,\n\t\t\t\t\t\t   const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tu8 kind = BTF_INFO_KIND(t->info);\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t__btf_verifier_log(log, \"[%u] %s %s%s\",\n\t\t\t   env->log_type_id,\n\t\t\t   btf_kind_str[kind],\n\t\t\t   btf_name_by_offset(btf, t->name_off),\n\t\t\t   log_details ? \" \" : \"\");\n\n\tif (log_details)\n\t\tbtf_type_ops(t)->log_details(env, t);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n};\n\nstatic void __btf_verifier_log_type(struct btf_verifier_env *env,\n\t\t\t\t\t\t   const struct btf_type *t,\n\t\t\t\t\t\t   bool log_details,\n\t\t\t\t\t\t   const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tu8 kind = BTF_INFO_KIND(t->info);\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t__btf_verifier_log(log, \"[%u] %s %s%s\",\n\t\t\t   env->log_type_id,\n\t\t\t   btf_kind_str[kind],\n\t\t\t   btf_name_by_offset(btf, t->name_off),\n\t\t\t   log_details ? \" \" : \"\");\n\n\tif (log_details)\n\t\tbtf_type_ops(t)->log_details(env, t);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "env",
            "v"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "v->t"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "418-421",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_stack_peak",
          "args": [
            "env"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_peak",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "808-811",
          "snippet": "static const struct resolve_vertex *env_stack_peak(struct btf_verifier_env *env)\n{\n\treturn env->top_stack ? &env->stack[env->top_stack - 1] : NULL;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct resolve_vertex *env_stack_peak(struct btf_verifier_env *env)\n{\n\treturn env->top_stack ? &env->stack[env->top_stack - 1] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_stack_push",
          "args": [
            "env",
            "t",
            "type_id"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "762-788",
          "snippet": "static int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (env->visit_states[type_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MAX_RESOLVE_DEPTH 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (env->visit_states[type_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id)\n{\n\tconst struct resolve_vertex *v;\n\tint err = 0;\n\n\tenv->resolve_mode = RESOLVE_TBD;\n\tenv_stack_push(env, t, type_id);\n\twhile (!err && (v = env_stack_peak(env))) {\n\t\tenv->log_type_id = v->type_id;\n\t\terr = btf_type_ops(v->t)->resolve(env, v);\n\t}\n\n\tenv->log_type_id = type_id;\n\tif (err == -E2BIG)\n\t\tbtf_verifier_log_type(env, t,\n\t\t\t\t      \"Exceeded max resolving depth:%u\",\n\t\t\t\t      MAX_RESOLVE_DEPTH);\n\telse if (err == -EEXIST)\n\t\tbtf_verifier_log_type(env, t, \"Loop detected\");\n\n\treturn err;\n}"
  },
  {
    "function_name": "btf_check_all_metas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1839-1864",
    "snippet": "static int btf_check_all_metas(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tstruct btf_header *hdr;\n\tvoid *cur, *end;\n\n\thdr = &btf->hdr;\n\tcur = btf->nohdr_data + hdr->type_off;\n\tend = cur + hdr->type_len;\n\n\tenv->log_type_id = 1;\n\twhile (cur < end) {\n\t\tstruct btf_type *t = cur;\n\t\ts32 meta_size;\n\n\t\tmeta_size = btf_check_meta(env, t, end - cur);\n\t\tif (meta_size < 0)\n\t\t\treturn meta_size;\n\n\t\tbtf_add_type(env, t);\n\t\tcur += meta_size;\n\t\tenv->log_type_id++;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_add_type",
          "args": [
            "env",
            "t"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "btf_add_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "588-630",
          "snippet": "static int btf_add_type(struct btf_verifier_env *env, struct btf_type *t)\n{\n\tstruct btf *btf = env->btf;\n\n\t/* < 2 because +1 for btf_void which is always in btf->types[0].\n\t * btf_void is not accounted in btf->nr_types because btf_void\n\t * does not come from the BTF file.\n\t */\n\tif (btf->types_size - btf->nr_types < 2) {\n\t\t/* Expand 'types' array */\n\n\t\tstruct btf_type **new_types;\n\t\tu32 expand_by, new_size;\n\n\t\tif (btf->types_size == BTF_MAX_TYPE) {\n\t\t\tbtf_verifier_log(env, \"Exceeded max num of types\");\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\texpand_by = max_t(u32, btf->types_size >> 2, 16);\n\t\tnew_size = min_t(u32, BTF_MAX_TYPE,\n\t\t\t\t btf->types_size + expand_by);\n\n\t\tnew_types = kvcalloc(new_size, sizeof(*new_types),\n\t\t\t\t     GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!new_types)\n\t\t\treturn -ENOMEM;\n\n\t\tif (btf->nr_types == 0)\n\t\t\tnew_types[0] = &btf_void;\n\t\telse\n\t\t\tmemcpy(new_types, btf->types,\n\t\t\t       sizeof(*btf->types) * (btf->nr_types + 1));\n\n\t\tkvfree(btf->types);\n\t\tbtf->types = new_types;\n\t\tbtf->types_size = new_size;\n\t}\n\n\tbtf->types[++(btf->nr_types)] = t;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct btf_type btf_void;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic struct btf_type btf_void;\n\nstatic int btf_add_type(struct btf_verifier_env *env, struct btf_type *t)\n{\n\tstruct btf *btf = env->btf;\n\n\t/* < 2 because +1 for btf_void which is always in btf->types[0].\n\t * btf_void is not accounted in btf->nr_types because btf_void\n\t * does not come from the BTF file.\n\t */\n\tif (btf->types_size - btf->nr_types < 2) {\n\t\t/* Expand 'types' array */\n\n\t\tstruct btf_type **new_types;\n\t\tu32 expand_by, new_size;\n\n\t\tif (btf->types_size == BTF_MAX_TYPE) {\n\t\t\tbtf_verifier_log(env, \"Exceeded max num of types\");\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\texpand_by = max_t(u32, btf->types_size >> 2, 16);\n\t\tnew_size = min_t(u32, BTF_MAX_TYPE,\n\t\t\t\t btf->types_size + expand_by);\n\n\t\tnew_types = kvcalloc(new_size, sizeof(*new_types),\n\t\t\t\t     GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!new_types)\n\t\t\treturn -ENOMEM;\n\n\t\tif (btf->nr_types == 0)\n\t\t\tnew_types[0] = &btf_void;\n\t\telse\n\t\t\tmemcpy(new_types, btf->types,\n\t\t\t       sizeof(*btf->types) * (btf->nr_types + 1));\n\n\t\tkvfree(btf->types);\n\t\tbtf->types = new_types;\n\t\tbtf->types_size = new_size;\n\t}\n\n\tbtf->types[++(btf->nr_types)] = t;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_check_meta",
          "args": [
            "env",
            "t",
            "end - cur"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "btf_check_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "1797-1837",
          "snippet": "static s32 btf_check_meta(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t,\n\t\t\t  u32 meta_left)\n{\n\tu32 saved_meta_left = meta_left;\n\ts32 var_meta_size;\n\n\tif (meta_left < sizeof(*t)) {\n\t\tbtf_verifier_log(env, \"[%u] meta_left:%u meta_needed:%zu\",\n\t\t\t\t env->log_type_id, meta_left, sizeof(*t));\n\t\treturn -EINVAL;\n\t}\n\tmeta_left -= sizeof(*t);\n\n\tif (t->info & ~BTF_INFO_MASK) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid btf_info:%x\",\n\t\t\t\t env->log_type_id, t->info);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BTF_INFO_KIND(t->info) > BTF_KIND_MAX ||\n\t    BTF_INFO_KIND(t->info) == BTF_KIND_UNKN) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid kind:%u\",\n\t\t\t\t env->log_type_id, BTF_INFO_KIND(t->info));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!btf_name_offset_valid(env->btf, t->name_off)) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid name_offset:%u\",\n\t\t\t\t env->log_type_id, t->name_off);\n\t\treturn -EINVAL;\n\t}\n\n\tvar_meta_size = btf_type_ops(t)->check_meta(env, t, meta_left);\n\tif (var_meta_size < 0)\n\t\treturn var_meta_size;\n\n\tmeta_left -= var_meta_size;\n\n\treturn saved_meta_left - meta_left;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define BTF_INFO_MASK 0x0f00ffff"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\n#define BTF_INFO_MASK 0x0f00ffff\n\nstatic s32 btf_check_meta(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t,\n\t\t\t  u32 meta_left)\n{\n\tu32 saved_meta_left = meta_left;\n\ts32 var_meta_size;\n\n\tif (meta_left < sizeof(*t)) {\n\t\tbtf_verifier_log(env, \"[%u] meta_left:%u meta_needed:%zu\",\n\t\t\t\t env->log_type_id, meta_left, sizeof(*t));\n\t\treturn -EINVAL;\n\t}\n\tmeta_left -= sizeof(*t);\n\n\tif (t->info & ~BTF_INFO_MASK) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid btf_info:%x\",\n\t\t\t\t env->log_type_id, t->info);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BTF_INFO_KIND(t->info) > BTF_KIND_MAX ||\n\t    BTF_INFO_KIND(t->info) == BTF_KIND_UNKN) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid kind:%u\",\n\t\t\t\t env->log_type_id, BTF_INFO_KIND(t->info));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!btf_name_offset_valid(env->btf, t->name_off)) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid name_offset:%u\",\n\t\t\t\t env->log_type_id, t->name_off);\n\t\treturn -EINVAL;\n\t}\n\n\tvar_meta_size = btf_type_ops(t)->check_meta(env, t, meta_left);\n\tif (var_meta_size < 0)\n\t\treturn var_meta_size;\n\n\tmeta_left -= var_meta_size;\n\n\treturn saved_meta_left - meta_left;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_check_all_metas(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tstruct btf_header *hdr;\n\tvoid *cur, *end;\n\n\thdr = &btf->hdr;\n\tcur = btf->nohdr_data + hdr->type_off;\n\tend = cur + hdr->type_len;\n\n\tenv->log_type_id = 1;\n\twhile (cur < end) {\n\t\tstruct btf_type *t = cur;\n\t\ts32 meta_size;\n\n\t\tmeta_size = btf_check_meta(env, t, end - cur);\n\t\tif (meta_size < 0)\n\t\t\treturn meta_size;\n\n\t\tbtf_add_type(env, t);\n\t\tcur += meta_size;\n\t\tenv->log_type_id++;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_check_meta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1797-1837",
    "snippet": "static s32 btf_check_meta(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t,\n\t\t\t  u32 meta_left)\n{\n\tu32 saved_meta_left = meta_left;\n\ts32 var_meta_size;\n\n\tif (meta_left < sizeof(*t)) {\n\t\tbtf_verifier_log(env, \"[%u] meta_left:%u meta_needed:%zu\",\n\t\t\t\t env->log_type_id, meta_left, sizeof(*t));\n\t\treturn -EINVAL;\n\t}\n\tmeta_left -= sizeof(*t);\n\n\tif (t->info & ~BTF_INFO_MASK) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid btf_info:%x\",\n\t\t\t\t env->log_type_id, t->info);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BTF_INFO_KIND(t->info) > BTF_KIND_MAX ||\n\t    BTF_INFO_KIND(t->info) == BTF_KIND_UNKN) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid kind:%u\",\n\t\t\t\t env->log_type_id, BTF_INFO_KIND(t->info));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!btf_name_offset_valid(env->btf, t->name_off)) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid name_offset:%u\",\n\t\t\t\t env->log_type_id, t->name_off);\n\t\treturn -EINVAL;\n\t}\n\n\tvar_meta_size = btf_type_ops(t)->check_meta(env, t, meta_left);\n\tif (var_meta_size < 0)\n\t\treturn var_meta_size;\n\n\tmeta_left -= var_meta_size;\n\n\treturn saved_meta_left - meta_left;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define BTF_INFO_MASK 0x0f00ffff"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "env",
            "t",
            "meta_left"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "t"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "418-421",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"[%u] Invalid name_offset:%u\"",
            "env->log_type_id",
            "t->name_off"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "479-491",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_name_offset_valid",
          "args": [
            "env->btf",
            "t->name_off"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_offset_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "423-427",
          "snippet": "static bool btf_name_offset_valid(const struct btf *btf, u32 offset)\n{\n\treturn BTF_STR_OFFSET_VALID(offset) &&\n\t\toffset < btf->hdr.str_len;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_name_offset_valid(const struct btf *btf, u32 offset)\n{\n\treturn BTF_STR_OFFSET_VALID(offset) &&\n\t\toffset < btf->hdr.str_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\n#define BTF_INFO_MASK 0x0f00ffff\n\nstatic s32 btf_check_meta(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t,\n\t\t\t  u32 meta_left)\n{\n\tu32 saved_meta_left = meta_left;\n\ts32 var_meta_size;\n\n\tif (meta_left < sizeof(*t)) {\n\t\tbtf_verifier_log(env, \"[%u] meta_left:%u meta_needed:%zu\",\n\t\t\t\t env->log_type_id, meta_left, sizeof(*t));\n\t\treturn -EINVAL;\n\t}\n\tmeta_left -= sizeof(*t);\n\n\tif (t->info & ~BTF_INFO_MASK) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid btf_info:%x\",\n\t\t\t\t env->log_type_id, t->info);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BTF_INFO_KIND(t->info) > BTF_KIND_MAX ||\n\t    BTF_INFO_KIND(t->info) == BTF_KIND_UNKN) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid kind:%u\",\n\t\t\t\t env->log_type_id, BTF_INFO_KIND(t->info));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!btf_name_offset_valid(env->btf, t->name_off)) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid name_offset:%u\",\n\t\t\t\t env->log_type_id, t->name_off);\n\t\treturn -EINVAL;\n\t}\n\n\tvar_meta_size = btf_type_ops(t)->check_meta(env, t, meta_left);\n\tif (var_meta_size < 0)\n\t\treturn var_meta_size;\n\n\tmeta_left -= var_meta_size;\n\n\treturn saved_meta_left - meta_left;\n}"
  },
  {
    "function_name": "btf_enum_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1756-1773",
    "snippet": "static void btf_enum_seq_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t      u32 type_id, void *data, u8 bits_offset,\n\t\t\t      struct seq_file *m)\n{\n\tconst struct btf_enum *enums = btf_type_enum(t);\n\tu32 i, nr_enums = btf_type_vlen(t);\n\tint v = *(int *)data;\n\n\tfor (i = 0; i < nr_enums; i++) {\n\t\tif (v == enums[i].val) {\n\t\t\tseq_printf(m, \"%s\",\n\t\t\t\t   btf_name_by_offset(btf, enums[i].name_off));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tseq_printf(m, \"%d\", v);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%d\"",
            "v"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_name_by_offset",
          "args": [
            "btf",
            "enums[i].name_off"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_by_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "429-437",
          "snippet": "static const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tif (!offset)\n\t\treturn \"(anon)\";\n\telse if (offset < btf->hdr.str_len)\n\t\treturn &btf->strings[offset];\n\telse\n\t\treturn \"(invalid-name-offset)\";\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tif (!offset)\n\t\treturn \"(anon)\";\n\telse if (offset < btf->hdr.str_len)\n\t\treturn &btf->strings[offset];\n\telse\n\t\treturn \"(invalid-name-offset)\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_vlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "393-396",
          "snippet": "static u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_enum",
          "args": [
            "t"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_enum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "413-416",
          "snippet": "static const struct btf_enum *btf_type_enum(const struct btf_type *t)\n{\n\treturn (const struct btf_enum *)(t + 1);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_enum *btf_type_enum(const struct btf_type *t)\n{\n\treturn (const struct btf_enum *)(t + 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_enum_seq_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t      u32 type_id, void *data, u8 bits_offset,\n\t\t\t      struct seq_file *m)\n{\n\tconst struct btf_enum *enums = btf_type_enum(t);\n\tu32 i, nr_enums = btf_type_vlen(t);\n\tint v = *(int *)data;\n\n\tfor (i = 0; i < nr_enums; i++) {\n\t\tif (v == enums[i].val) {\n\t\t\tseq_printf(m, \"%s\",\n\t\t\t\t   btf_name_by_offset(btf, enums[i].name_off));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tseq_printf(m, \"%d\", v);\n}"
  },
  {
    "function_name": "btf_enum_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1750-1754",
    "snippet": "static void btf_enum_log(struct btf_verifier_env *env,\n\t\t\t const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"size=%u vlen=%u\", t->size, btf_type_vlen(t));\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"size=%u vlen=%u\"",
            "t->size",
            "btf_type_vlen(t)"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "479-491",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_vlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "393-396",
          "snippet": "static u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_enum_log(struct btf_verifier_env *env,\n\t\t\t const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"size=%u vlen=%u\", t->size, btf_type_vlen(t));\n}"
  },
  {
    "function_name": "btf_enum_check_meta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1708-1748",
    "snippet": "static s32 btf_enum_check_meta(struct btf_verifier_env *env,\n\t\t\t       const struct btf_type *t,\n\t\t\t       u32 meta_left)\n{\n\tconst struct btf_enum *enums = btf_type_enum(t);\n\tstruct btf *btf = env->btf;\n\tu16 i, nr_enums;\n\tu32 meta_needed;\n\n\tnr_enums = btf_type_vlen(t);\n\tmeta_needed = nr_enums * sizeof(*enums);\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->size != sizeof(int)) {\n\t\tbtf_verifier_log_type(env, t, \"Expected size:%zu\",\n\t\t\t\t      sizeof(int));\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\tfor (i = 0; i < nr_enums; i++) {\n\t\tif (!btf_name_offset_valid(btf, enums[i].name_off)) {\n\t\t\tbtf_verifier_log(env, \"\\tInvalid name_offset:%u\",\n\t\t\t\t\t enums[i].name_off);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbtf_verifier_log(env, \"\\t%s val=%d\\n\",\n\t\t\t\t btf_name_by_offset(btf, enums[i].name_off),\n\t\t\t\t enums[i].val);\n\t}\n\n\treturn meta_needed;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"\\t%s val=%d\\n\"",
            "btf_name_by_offset(btf, enums[i].name_off)",
            "enums[i].val"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "479-491",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_name_by_offset",
          "args": [
            "btf",
            "enums[i].name_off"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_by_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "429-437",
          "snippet": "static const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tif (!offset)\n\t\treturn \"(anon)\";\n\telse if (offset < btf->hdr.str_len)\n\t\treturn &btf->strings[offset];\n\telse\n\t\treturn \"(invalid-name-offset)\";\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tif (!offset)\n\t\treturn \"(anon)\";\n\telse if (offset < btf->hdr.str_len)\n\t\treturn &btf->strings[offset];\n\telse\n\t\treturn \"(invalid-name-offset)\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_name_offset_valid",
          "args": [
            "btf",
            "enums[i].name_off"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_offset_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "423-427",
          "snippet": "static bool btf_name_offset_valid(const struct btf *btf, u32 offset)\n{\n\treturn BTF_STR_OFFSET_VALID(offset) &&\n\t\toffset < btf->hdr.str_len;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_name_offset_valid(const struct btf *btf, u32 offset)\n{\n\treturn BTF_STR_OFFSET_VALID(offset) &&\n\t\toffset < btf->hdr.str_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "NULL"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Expected size:%zu\"",
            "sizeof(int)"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_verifier_log_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "493-523",
          "snippet": "static void __btf_verifier_log_type(struct btf_verifier_env *env,\n\t\t\t\t\t\t   const struct btf_type *t,\n\t\t\t\t\t\t   bool log_details,\n\t\t\t\t\t\t   const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tu8 kind = BTF_INFO_KIND(t->info);\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t__btf_verifier_log(log, \"[%u] %s %s%s\",\n\t\t\t   env->log_type_id,\n\t\t\t   btf_kind_str[kind],\n\t\t\t   btf_name_by_offset(btf, t->name_off),\n\t\t\t   log_details ? \" \" : \"\");\n\n\tif (log_details)\n\t\tbtf_type_ops(t)->log_details(env, t);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n};\n\nstatic void __btf_verifier_log_type(struct btf_verifier_env *env,\n\t\t\t\t\t\t   const struct btf_type *t,\n\t\t\t\t\t\t   bool log_details,\n\t\t\t\t\t\t   const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tu8 kind = BTF_INFO_KIND(t->info);\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t__btf_verifier_log(log, \"[%u] %s %s%s\",\n\t\t\t   env->log_type_id,\n\t\t\t   btf_kind_str[kind],\n\t\t\t   btf_name_by_offset(btf, t->name_off),\n\t\t\t   log_details ? \" \" : \"\");\n\n\tif (log_details)\n\t\tbtf_type_ops(t)->log_details(env, t);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_basic",
          "args": [
            "env",
            "t",
            "\"meta_left:%u meta_needed:%u\"",
            "meta_left",
            "meta_needed"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_vlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "393-396",
          "snippet": "static u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_enum",
          "args": [
            "t"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_enum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "413-416",
          "snippet": "static const struct btf_enum *btf_type_enum(const struct btf_type *t)\n{\n\treturn (const struct btf_enum *)(t + 1);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_enum *btf_type_enum(const struct btf_type *t)\n{\n\treturn (const struct btf_enum *)(t + 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic s32 btf_enum_check_meta(struct btf_verifier_env *env,\n\t\t\t       const struct btf_type *t,\n\t\t\t       u32 meta_left)\n{\n\tconst struct btf_enum *enums = btf_type_enum(t);\n\tstruct btf *btf = env->btf;\n\tu16 i, nr_enums;\n\tu32 meta_needed;\n\n\tnr_enums = btf_type_vlen(t);\n\tmeta_needed = nr_enums * sizeof(*enums);\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->size != sizeof(int)) {\n\t\tbtf_verifier_log_type(env, t, \"Expected size:%zu\",\n\t\t\t\t      sizeof(int));\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\tfor (i = 0; i < nr_enums; i++) {\n\t\tif (!btf_name_offset_valid(btf, enums[i].name_off)) {\n\t\t\tbtf_verifier_log(env, \"\\tInvalid name_offset:%u\",\n\t\t\t\t\t enums[i].name_off);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbtf_verifier_log(env, \"\\t%s val=%d\\n\",\n\t\t\t\t btf_name_by_offset(btf, enums[i].name_off),\n\t\t\t\t enums[i].val);\n\t}\n\n\treturn meta_needed;\n}"
  },
  {
    "function_name": "btf_enum_check_member",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1683-1706",
    "snippet": "static int btf_enum_check_member(struct btf_verifier_env *env,\n\t\t\t\t const struct btf_type *struct_type,\n\t\t\t\t const struct btf_member *member,\n\t\t\t\t const struct btf_type *member_type)\n{\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size, bytes_offset;\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct_size = struct_type->size;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tif (struct_size - bytes_offset < sizeof(int)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "struct_type",
            "member",
            "\"Member exceeds struct_size\""
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "531-564",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t   btf_name_by_offset(btf, member->name_off),\n\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t   btf_name_by_offset(btf, member->name_off),\n\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDDOWN_BYTES",
          "args": [
            "struct_bits_off"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "struct_bits_off"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_enum_check_member(struct btf_verifier_env *env,\n\t\t\t\t const struct btf_type *struct_type,\n\t\t\t\t const struct btf_member *member,\n\t\t\t\t const struct btf_type *member_type)\n{\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size, bytes_offset;\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct_size = struct_type->size;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tif (struct_size - bytes_offset < sizeof(int)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_struct_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1648-1673",
    "snippet": "static void btf_struct_seq_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t\tu32 type_id, void *data, u8 bits_offset,\n\t\t\t\tstruct seq_file *m)\n{\n\tconst char *seq = BTF_INFO_KIND(t->info) == BTF_KIND_UNION ? \"|\" : \",\";\n\tconst struct btf_member *member;\n\tu32 i;\n\n\tseq_puts(m, \"{\");\n\tfor_each_member(i, t, member) {\n\t\tconst struct btf_type *member_type = btf_type_by_id(btf,\n\t\t\t\t\t\t\t\tmember->type);\n\t\tu32 member_offset = member->offset;\n\t\tu32 bytes_offset = BITS_ROUNDDOWN_BYTES(member_offset);\n\t\tu8 bits8_offset = BITS_PER_BYTE_MASKED(member_offset);\n\t\tconst struct btf_kind_operations *ops;\n\n\t\tif (i)\n\t\t\tseq_puts(m, seq);\n\n\t\tops = btf_type_ops(member_type);\n\t\tops->seq_show(btf, member_type, member->type,\n\t\t\t      data + bytes_offset, bits8_offset, m);\n\t}\n\tseq_puts(m, \"}\");\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"}\""
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->seq_show",
          "args": [
            "btf",
            "member_type",
            "member->type",
            "data + bytes_offset",
            "bits8_offset",
            "m"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "member_type"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "418-421",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "member_offset"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDDOWN_BYTES",
          "args": [
            "member_offset"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "member->type"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "439-445",
          "snippet": "static const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_member",
          "args": [
            "i",
            "t",
            "member"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_struct_seq_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t\tu32 type_id, void *data, u8 bits_offset,\n\t\t\t\tstruct seq_file *m)\n{\n\tconst char *seq = BTF_INFO_KIND(t->info) == BTF_KIND_UNION ? \"|\" : \",\";\n\tconst struct btf_member *member;\n\tu32 i;\n\n\tseq_puts(m, \"{\");\n\tfor_each_member(i, t, member) {\n\t\tconst struct btf_type *member_type = btf_type_by_id(btf,\n\t\t\t\t\t\t\t\tmember->type);\n\t\tu32 member_offset = member->offset;\n\t\tu32 bytes_offset = BITS_ROUNDDOWN_BYTES(member_offset);\n\t\tu8 bits8_offset = BITS_PER_BYTE_MASKED(member_offset);\n\t\tconst struct btf_kind_operations *ops;\n\n\t\tif (i)\n\t\t\tseq_puts(m, seq);\n\n\t\tops = btf_type_ops(member_type);\n\t\tops->seq_show(btf, member_type, member->type,\n\t\t\t      data + bytes_offset, bits8_offset, m);\n\t}\n\tseq_puts(m, \"}\");\n}"
  },
  {
    "function_name": "btf_struct_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1642-1646",
    "snippet": "static void btf_struct_log(struct btf_verifier_env *env,\n\t\t\t   const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"size=%u vlen=%u\", t->size, btf_type_vlen(t));\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"size=%u vlen=%u\"",
            "t->size",
            "btf_type_vlen(t)"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "479-491",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_vlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "393-396",
          "snippet": "static u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_struct_log(struct btf_verifier_env *env,\n\t\t\t   const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"size=%u vlen=%u\", t->size, btf_type_vlen(t));\n}"
  },
  {
    "function_name": "btf_struct_resolve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1582-1640",
    "snippet": "static int btf_struct_resolve(struct btf_verifier_env *env,\n\t\t\t      const struct resolve_vertex *v)\n{\n\tconst struct btf_member *member;\n\tint err;\n\tu16 i;\n\n\t/* Before continue resolving the next_member,\n\t * ensure the last member is indeed resolved to a\n\t * type with size info.\n\t */\n\tif (v->next_member) {\n\t\tconst struct btf_type *last_member_type;\n\t\tconst struct btf_member *last_member;\n\t\tu16 last_member_type_id;\n\n\t\tlast_member = btf_type_member(v->t) + v->next_member - 1;\n\t\tlast_member_type_id = last_member->type;\n\t\tif (WARN_ON_ONCE(!env_type_is_resolved(env,\n\t\t\t\t\t\t       last_member_type_id)))\n\t\t\treturn -EINVAL;\n\n\t\tlast_member_type = btf_type_by_id(env->btf,\n\t\t\t\t\t\t  last_member_type_id);\n\t\terr = btf_type_ops(last_member_type)->check_member(env, v->t,\n\t\t\t\t\t\t\tlast_member,\n\t\t\t\t\t\t\tlast_member_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor_each_member_from(i, v->next_member, v->t, member) {\n\t\tu32 member_type_id = member->type;\n\t\tconst struct btf_type *member_type = btf_type_by_id(env->btf,\n\t\t\t\t\t\t\t\tmember_type_id);\n\n\t\tif (btf_type_is_void_or_null(member_type)) {\n\t\t\tbtf_verifier_log_member(env, v->t, member,\n\t\t\t\t\t\t\"Invalid member\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!env_type_is_resolve_sink(env, member_type) &&\n\t\t    !env_type_is_resolved(env, member_type_id)) {\n\t\t\tenv_stack_set_next_member(env, i + 1);\n\t\t\treturn env_stack_push(env, member_type, member_type_id);\n\t\t}\n\n\t\terr = btf_type_ops(member_type)->check_member(env, v->t,\n\t\t\t\t\t\t\t      member,\n\t\t\t\t\t\t\t      member_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tenv_stack_pop_resolved(env, 0, 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_stack_pop_resolved",
          "args": [
            "env",
            "0",
            "0"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_pop_resolved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "796-806",
          "snippet": "static void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "env",
            "v->t",
            "member",
            "member_type"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "member_type"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "418-421",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_stack_push",
          "args": [
            "env",
            "member_type",
            "member_type_id"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "762-788",
          "snippet": "static int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (env->visit_states[type_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MAX_RESOLVE_DEPTH 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (env->visit_states[type_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_stack_set_next_member",
          "args": [
            "env",
            "i + 1"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_set_next_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "790-794",
          "snippet": "static void env_stack_set_next_member(struct btf_verifier_env *env,\n\t\t\t\t      u16 next_member)\n{\n\tenv->stack[env->top_stack - 1].next_member = next_member;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void env_stack_set_next_member(struct btf_verifier_env *env,\n\t\t\t\t      u16 next_member)\n{\n\tenv->stack[env->top_stack - 1].next_member = next_member;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolved",
          "args": [
            "env",
            "member_type_id"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "756-760",
          "snippet": "static bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\treturn env->visit_states[type_id] == RESOLVED;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\treturn env->visit_states[type_id] == RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolve_sink",
          "args": [
            "env",
            "member_type"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolve_sink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "735-754",
          "snippet": "static bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct or array is a sink for ptr */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void or ptr is a sink for struct and array */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct or array is a sink for ptr */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void or ptr is a sink for struct and array */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "v->t",
            "member",
            "\"Invalid member\""
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "531-564",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t   btf_name_by_offset(btf, member->name_off),\n\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t   btf_name_by_offset(btf, member->name_off),\n\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_void_or_null",
          "args": [
            "member_type"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_void_or_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "315-318",
          "snippet": "static bool btf_type_is_void_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_is_void(t);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_void_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_is_void(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "env->btf",
            "member_type_id"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "439-445",
          "snippet": "static const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_member_from",
          "args": [
            "i",
            "v->next_member",
            "v->t",
            "member"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "env",
            "v->t",
            "last_member",
            "last_member_type"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!env_type_is_resolved(env,\n\t\t\t\t\t\t       last_member_type_id)"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_member",
          "args": [
            "v->t"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "408-411",
          "snippet": "static const struct btf_member *btf_type_member(const struct btf_type *t)\n{\n\treturn (const struct btf_member *)(t + 1);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_member *btf_type_member(const struct btf_type *t)\n{\n\treturn (const struct btf_member *)(t + 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_struct_resolve(struct btf_verifier_env *env,\n\t\t\t      const struct resolve_vertex *v)\n{\n\tconst struct btf_member *member;\n\tint err;\n\tu16 i;\n\n\t/* Before continue resolving the next_member,\n\t * ensure the last member is indeed resolved to a\n\t * type with size info.\n\t */\n\tif (v->next_member) {\n\t\tconst struct btf_type *last_member_type;\n\t\tconst struct btf_member *last_member;\n\t\tu16 last_member_type_id;\n\n\t\tlast_member = btf_type_member(v->t) + v->next_member - 1;\n\t\tlast_member_type_id = last_member->type;\n\t\tif (WARN_ON_ONCE(!env_type_is_resolved(env,\n\t\t\t\t\t\t       last_member_type_id)))\n\t\t\treturn -EINVAL;\n\n\t\tlast_member_type = btf_type_by_id(env->btf,\n\t\t\t\t\t\t  last_member_type_id);\n\t\terr = btf_type_ops(last_member_type)->check_member(env, v->t,\n\t\t\t\t\t\t\tlast_member,\n\t\t\t\t\t\t\tlast_member_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor_each_member_from(i, v->next_member, v->t, member) {\n\t\tu32 member_type_id = member->type;\n\t\tconst struct btf_type *member_type = btf_type_by_id(env->btf,\n\t\t\t\t\t\t\t\tmember_type_id);\n\n\t\tif (btf_type_is_void_or_null(member_type)) {\n\t\t\tbtf_verifier_log_member(env, v->t, member,\n\t\t\t\t\t\t\"Invalid member\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!env_type_is_resolve_sink(env, member_type) &&\n\t\t    !env_type_is_resolved(env, member_type_id)) {\n\t\t\tenv_stack_set_next_member(env, i + 1);\n\t\t\treturn env_stack_push(env, member_type, member_type_id);\n\t\t}\n\n\t\terr = btf_type_ops(member_type)->check_member(env, v->t,\n\t\t\t\t\t\t\t      member,\n\t\t\t\t\t\t\t      member_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tenv_stack_pop_resolved(env, 0, 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_struct_check_meta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1516-1580",
    "snippet": "static s32 btf_struct_check_meta(struct btf_verifier_env *env,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 meta_left)\n{\n\tbool is_union = BTF_INFO_KIND(t->info) == BTF_KIND_UNION;\n\tconst struct btf_member *member;\n\tu32 meta_needed, last_offset;\n\tstruct btf *btf = env->btf;\n\tu32 struct_size = t->size;\n\tu16 i;\n\n\tmeta_needed = btf_type_vlen(t) * sizeof(*member);\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\tlast_offset = 0;\n\tfor_each_member(i, t, member) {\n\t\tif (!btf_name_offset_valid(btf, member->name_off)) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid member name_offset:%u\",\n\t\t\t\t\t\tmember->name_off);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* A member cannot be in type void */\n\t\tif (!member->type || !BTF_TYPE_ID_VALID(member->type)) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid type_id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (is_union && member->offset) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid member bits_offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/*\n\t\t * \">\" instead of \">=\" because the last member could be\n\t\t * \"char a[0];\"\n\t\t */\n\t\tif (last_offset > member->offset) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid member bits_offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (BITS_ROUNDUP_BYTES(member->offset) > struct_size) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Memmber bits_offset exceeds its struct size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbtf_verifier_log_member(env, t, member, NULL);\n\t\tlast_offset = member->offset;\n\t}\n\n\treturn meta_needed;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "t",
            "member",
            "NULL"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "531-564",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t   btf_name_by_offset(btf, member->name_off),\n\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t   btf_name_by_offset(btf, member->name_off),\n\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDUP_BYTES",
          "args": [
            "member->offset"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_TYPE_ID_VALID",
          "args": [
            "member->type"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_name_offset_valid",
          "args": [
            "btf",
            "member->name_off"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_offset_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "423-427",
          "snippet": "static bool btf_name_offset_valid(const struct btf *btf, u32 offset)\n{\n\treturn BTF_STR_OFFSET_VALID(offset) &&\n\t\toffset < btf->hdr.str_len;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_name_offset_valid(const struct btf *btf, u32 offset)\n{\n\treturn BTF_STR_OFFSET_VALID(offset) &&\n\t\toffset < btf->hdr.str_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_member",
          "args": [
            "i",
            "t",
            "member"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "NULL"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_basic",
          "args": [
            "env",
            "t",
            "\"meta_left:%u meta_needed:%u\"",
            "meta_left",
            "meta_needed"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_vlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "393-396",
          "snippet": "static u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic s32 btf_struct_check_meta(struct btf_verifier_env *env,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 meta_left)\n{\n\tbool is_union = BTF_INFO_KIND(t->info) == BTF_KIND_UNION;\n\tconst struct btf_member *member;\n\tu32 meta_needed, last_offset;\n\tstruct btf *btf = env->btf;\n\tu32 struct_size = t->size;\n\tu16 i;\n\n\tmeta_needed = btf_type_vlen(t) * sizeof(*member);\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\tlast_offset = 0;\n\tfor_each_member(i, t, member) {\n\t\tif (!btf_name_offset_valid(btf, member->name_off)) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid member name_offset:%u\",\n\t\t\t\t\t\tmember->name_off);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* A member cannot be in type void */\n\t\tif (!member->type || !BTF_TYPE_ID_VALID(member->type)) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid type_id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (is_union && member->offset) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid member bits_offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/*\n\t\t * \">\" instead of \">=\" because the last member could be\n\t\t * \"char a[0];\"\n\t\t */\n\t\tif (last_offset > member->offset) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid member bits_offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (BITS_ROUNDUP_BYTES(member->offset) > struct_size) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Memmber bits_offset exceeds its struct size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbtf_verifier_log_member(env, t, member, NULL);\n\t\tlast_offset = member->offset;\n\t}\n\n\treturn meta_needed;\n}"
  },
  {
    "function_name": "btf_struct_check_member",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1491-1514",
    "snippet": "static int btf_struct_check_member(struct btf_verifier_env *env,\n\t\t\t\t   const struct btf_type *struct_type,\n\t\t\t\t   const struct btf_member *member,\n\t\t\t\t   const struct btf_type *member_type)\n{\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size, bytes_offset;\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct_size = struct_type->size;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tif (struct_size - bytes_offset < member_type->size) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "struct_type",
            "member",
            "\"Member exceeds struct_size\""
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "531-564",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t   btf_name_by_offset(btf, member->name_off),\n\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t   btf_name_by_offset(btf, member->name_off),\n\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDDOWN_BYTES",
          "args": [
            "struct_bits_off"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "struct_bits_off"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_struct_check_member(struct btf_verifier_env *env,\n\t\t\t\t   const struct btf_type *struct_type,\n\t\t\t\t   const struct btf_member *member,\n\t\t\t\t   const struct btf_type *member_type)\n{\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size, bytes_offset;\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct_size = struct_type->size;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tif (struct_size - bytes_offset < member_type->size) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_array_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1459-1481",
    "snippet": "static void btf_array_seq_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t       u32 type_id, void *data, u8 bits_offset,\n\t\t\t       struct seq_file *m)\n{\n\tconst struct btf_array *array = btf_type_array(t);\n\tconst struct btf_kind_operations *elem_ops;\n\tconst struct btf_type *elem_type;\n\tu32 i, elem_size, elem_type_id;\n\n\telem_type_id = array->type;\n\telem_type = btf_type_id_size(btf, &elem_type_id, &elem_size);\n\telem_ops = btf_type_ops(elem_type);\n\tseq_puts(m, \"[\");\n\tfor (i = 0; i < array->nelems; i++) {\n\t\tif (i)\n\t\t\tseq_puts(m, \",\");\n\n\t\telem_ops->seq_show(btf, elem_type, elem_type_id, data,\n\t\t\t\t   bits_offset, m);\n\t\tdata += elem_size;\n\t}\n\tseq_puts(m, \"]\");\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"]\""
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elem_ops->seq_show",
          "args": [
            "btf",
            "elem_type",
            "elem_type_id",
            "data",
            "bits_offset",
            "m"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "elem_type"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "418-421",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&elem_type_id",
            "&elem_size"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "821-854",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_is_void_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t\tsize_type_id = btf->resolved_ids[size_type_id];\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_is_void(size_type))\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_is_void_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t\tsize_type_id = btf->resolved_ids[size_type_id];\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_is_void(size_type))\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_array",
          "args": [
            "t"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "403-406",
          "snippet": "static const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_array_seq_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t       u32 type_id, void *data, u8 bits_offset,\n\t\t\t       struct seq_file *m)\n{\n\tconst struct btf_array *array = btf_type_array(t);\n\tconst struct btf_kind_operations *elem_ops;\n\tconst struct btf_type *elem_type;\n\tu32 i, elem_size, elem_type_id;\n\n\telem_type_id = array->type;\n\telem_type = btf_type_id_size(btf, &elem_type_id, &elem_size);\n\telem_ops = btf_type_ops(elem_type);\n\tseq_puts(m, \"[\");\n\tfor (i = 0; i < array->nelems; i++) {\n\t\tif (i)\n\t\t\tseq_puts(m, \",\");\n\n\t\telem_ops->seq_show(btf, elem_type, elem_type_id, data,\n\t\t\t\t   bits_offset, m);\n\t\tdata += elem_size;\n\t}\n\tseq_puts(m, \"]\");\n}"
  },
  {
    "function_name": "btf_array_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1450-1457",
    "snippet": "static void btf_array_log(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t)\n{\n\tconst struct btf_array *array = btf_type_array(t);\n\n\tbtf_verifier_log(env, \"type_id=%u index_type_id=%u nr_elems=%u\",\n\t\t\t array->type, array->index_type, array->nelems);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"type_id=%u index_type_id=%u nr_elems=%u\"",
            "array->type",
            "array->index_type",
            "array->nelems"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "479-491",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_array",
          "args": [
            "t"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "403-406",
          "snippet": "static const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_array_log(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t)\n{\n\tconst struct btf_array *array = btf_type_array(t);\n\n\tbtf_verifier_log(env, \"type_id=%u index_type_id=%u nr_elems=%u\",\n\t\t\t array->type, array->index_type, array->nelems);\n}"
  },
  {
    "function_name": "btf_array_resolve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1387-1448",
    "snippet": "static int btf_array_resolve(struct btf_verifier_env *env,\n\t\t\t     const struct resolve_vertex *v)\n{\n\tconst struct btf_array *array = btf_type_array(v->t);\n\tconst struct btf_type *elem_type, *index_type;\n\tu32 elem_type_id, index_type_id;\n\tstruct btf *btf = env->btf;\n\tu32 elem_size;\n\n\t/* Check array->index_type */\n\tindex_type_id = array->index_type;\n\tindex_type = btf_type_by_id(btf, index_type_id);\n\tif (btf_type_is_void_or_null(index_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid index\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, index_type) &&\n\t    !env_type_is_resolved(env, index_type_id))\n\t\treturn env_stack_push(env, index_type, index_type_id);\n\n\tindex_type = btf_type_id_size(btf, &index_type_id, NULL);\n\tif (!index_type || !btf_type_is_int(index_type) ||\n\t    !btf_type_int_is_regular(index_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid index\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check array->type */\n\telem_type_id = array->type;\n\telem_type = btf_type_by_id(btf, elem_type_id);\n\tif (btf_type_is_void_or_null(elem_type)) {\n\t\tbtf_verifier_log_type(env, v->t,\n\t\t\t\t      \"Invalid elem\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, elem_type) &&\n\t    !env_type_is_resolved(env, elem_type_id))\n\t\treturn env_stack_push(env, elem_type, elem_type_id);\n\n\telem_type = btf_type_id_size(btf, &elem_type_id, &elem_size);\n\tif (!elem_type) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid elem\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_is_int(elem_type) && !btf_type_int_is_regular(elem_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid array of int\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (array->nelems && elem_size > U32_MAX / array->nelems) {\n\t\tbtf_verifier_log_type(env, v->t,\n\t\t\t\t      \"Array size overflows U32_MAX\");\n\t\treturn -EINVAL;\n\t}\n\n\tenv_stack_pop_resolved(env, elem_type_id, elem_size * array->nelems);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_stack_pop_resolved",
          "args": [
            "env",
            "elem_type_id",
            "elem_size * array->nelems"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_pop_resolved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "796-806",
          "snippet": "static void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Array size overflows U32_MAX\""
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid array of int\""
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_int_is_regular",
          "args": [
            "elem_type"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_int_is_regular",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "451-467",
          "snippet": "static bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_int",
          "args": [
            "elem_type"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "340-343",
          "snippet": "static bool btf_type_is_int(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_INT;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_int(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_INT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid elem\""
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&elem_type_id",
            "&elem_size"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "821-854",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_is_void_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t\tsize_type_id = btf->resolved_ids[size_type_id];\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_is_void(size_type))\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_is_void_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t\tsize_type_id = btf->resolved_ids[size_type_id];\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_is_void(size_type))\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_stack_push",
          "args": [
            "env",
            "elem_type",
            "elem_type_id"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "762-788",
          "snippet": "static int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (env->visit_states[type_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MAX_RESOLVE_DEPTH 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (env->visit_states[type_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolved",
          "args": [
            "env",
            "elem_type_id"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "756-760",
          "snippet": "static bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\treturn env->visit_states[type_id] == RESOLVED;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\treturn env->visit_states[type_id] == RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolve_sink",
          "args": [
            "env",
            "elem_type"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolve_sink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "735-754",
          "snippet": "static bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct or array is a sink for ptr */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void or ptr is a sink for struct and array */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct or array is a sink for ptr */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void or ptr is a sink for struct and array */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid elem\""
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_void_or_null",
          "args": [
            "elem_type"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_void_or_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "315-318",
          "snippet": "static bool btf_type_is_void_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_is_void(t);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_void_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_is_void(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "elem_type_id"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "439-445",
          "snippet": "static const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid index\""
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid index\""
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_array",
          "args": [
            "v->t"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "403-406",
          "snippet": "static const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_array_resolve(struct btf_verifier_env *env,\n\t\t\t     const struct resolve_vertex *v)\n{\n\tconst struct btf_array *array = btf_type_array(v->t);\n\tconst struct btf_type *elem_type, *index_type;\n\tu32 elem_type_id, index_type_id;\n\tstruct btf *btf = env->btf;\n\tu32 elem_size;\n\n\t/* Check array->index_type */\n\tindex_type_id = array->index_type;\n\tindex_type = btf_type_by_id(btf, index_type_id);\n\tif (btf_type_is_void_or_null(index_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid index\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, index_type) &&\n\t    !env_type_is_resolved(env, index_type_id))\n\t\treturn env_stack_push(env, index_type, index_type_id);\n\n\tindex_type = btf_type_id_size(btf, &index_type_id, NULL);\n\tif (!index_type || !btf_type_is_int(index_type) ||\n\t    !btf_type_int_is_regular(index_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid index\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check array->type */\n\telem_type_id = array->type;\n\telem_type = btf_type_by_id(btf, elem_type_id);\n\tif (btf_type_is_void_or_null(elem_type)) {\n\t\tbtf_verifier_log_type(env, v->t,\n\t\t\t\t      \"Invalid elem\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, elem_type) &&\n\t    !env_type_is_resolved(env, elem_type_id))\n\t\treturn env_stack_push(env, elem_type, elem_type_id);\n\n\telem_type = btf_type_id_size(btf, &elem_type_id, &elem_size);\n\tif (!elem_type) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid elem\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_is_int(elem_type) && !btf_type_int_is_regular(elem_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid array of int\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (array->nelems && elem_size > U32_MAX / array->nelems) {\n\t\tbtf_verifier_log_type(env, v->t,\n\t\t\t\t      \"Array size overflows U32_MAX\");\n\t\treturn -EINVAL;\n\t}\n\n\tenv_stack_pop_resolved(env, elem_type_id, elem_size * array->nelems);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_array_check_meta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1345-1385",
    "snippet": "static s32 btf_array_check_meta(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *t,\n\t\t\t\tu32 meta_left)\n{\n\tconst struct btf_array *array = btf_type_array(t);\n\tu32 meta_needed = sizeof(*array);\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->size) {\n\t\tbtf_verifier_log_type(env, t, \"size != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Array elem type and index type cannot be in type void,\n\t * so !array->type and !array->index_type are not allowed.\n\t */\n\tif (!array->type || !BTF_TYPE_ID_VALID(array->type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid elem\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!array->index_type || !BTF_TYPE_ID_VALID(array->index_type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid index\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn meta_needed;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "NULL"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid index\""
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_TYPE_ID_VALID",
          "args": [
            "array->index_type"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid elem\""
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_TYPE_ID_VALID",
          "args": [
            "array->type"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"size != 0\""
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"vlen != 0\""
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_vlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "393-396",
          "snippet": "static u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_basic",
          "args": [
            "env",
            "t",
            "\"meta_left:%u meta_needed:%u\"",
            "meta_left",
            "meta_needed"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_array",
          "args": [
            "t"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "403-406",
          "snippet": "static const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic s32 btf_array_check_meta(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *t,\n\t\t\t\tu32 meta_left)\n{\n\tconst struct btf_array *array = btf_type_array(t);\n\tu32 meta_needed = sizeof(*array);\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->size) {\n\t\tbtf_verifier_log_type(env, t, \"size != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Array elem type and index type cannot be in type void,\n\t * so !array->type and !array->index_type are not allowed.\n\t */\n\tif (!array->type || !BTF_TYPE_ID_VALID(array->type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid elem\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!array->index_type || !BTF_TYPE_ID_VALID(array->index_type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid index\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn meta_needed;\n}"
  },
  {
    "function_name": "btf_array_check_member",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1316-1343",
    "snippet": "static int btf_array_check_member(struct btf_verifier_env *env,\n\t\t\t\t  const struct btf_type *struct_type,\n\t\t\t\t  const struct btf_member *member,\n\t\t\t\t  const struct btf_type *member_type)\n{\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size, bytes_offset;\n\tu32 array_type_id, array_size;\n\tstruct btf *btf = env->btf;\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tarray_type_id = member->type;\n\tbtf_type_id_size(btf, &array_type_id, &array_size);\n\tstruct_size = struct_type->size;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tif (struct_size - bytes_offset < array_size) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "struct_type",
            "member",
            "\"Member exceeds struct_size\""
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "531-564",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t   btf_name_by_offset(btf, member->name_off),\n\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t   btf_name_by_offset(btf, member->name_off),\n\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDDOWN_BYTES",
          "args": [
            "struct_bits_off"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&array_type_id",
            "&array_size"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "821-854",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_is_void_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t\tsize_type_id = btf->resolved_ids[size_type_id];\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_is_void(size_type))\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_is_void_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t\tsize_type_id = btf->resolved_ids[size_type_id];\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_is_void(size_type))\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "struct_bits_off"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_array_check_member(struct btf_verifier_env *env,\n\t\t\t\t  const struct btf_type *struct_type,\n\t\t\t\t  const struct btf_member *member,\n\t\t\t\t  const struct btf_type *member_type)\n{\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size, bytes_offset;\n\tu32 array_type_id, array_size;\n\tstruct btf *btf = env->btf;\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tarray_type_id = member->type;\n\tbtf_type_id_size(btf, &array_type_id, &array_size);\n\tstruct_size = struct_type->size;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tif (struct_size - bytes_offset < array_size) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_fwd_check_meta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1289-1306",
    "snippet": "static s32 btf_fwd_check_meta(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 meta_left)\n{\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->type) {\n\t\tbtf_verifier_log_type(env, t, \"type != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "NULL"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"type != 0\""
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"vlen != 0\""
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_vlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "393-396",
          "snippet": "static u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic s32 btf_fwd_check_meta(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 meta_left)\n{\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->type) {\n\t\tbtf_verifier_log_type(env, t, \"type != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_ref_type_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1267-1271",
    "snippet": "static void btf_ref_type_log(struct btf_verifier_env *env,\n\t\t\t     const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"type_id=%u\", t->type);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"type_id=%u\"",
            "t->type"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "479-491",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_ref_type_log(struct btf_verifier_env *env,\n\t\t\t     const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"type_id=%u\", t->type);\n}"
  },
  {
    "function_name": "btf_ptr_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1259-1265",
    "snippet": "static void btf_ptr_seq_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t     u32 type_id, void *data, u8 bits_offset,\n\t\t\t     struct seq_file *m)\n{\n\t/* It is a hashed value */\n\tseq_printf(m, \"%p\", *(void **)data);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%p\"",
            "*(void **)data"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_ptr_seq_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t     u32 type_id, void *data, u8 bits_offset,\n\t\t\t     struct seq_file *m)\n{\n\t/* It is a hashed value */\n\tseq_printf(m, \"%p\", *(void **)data);\n}"
  },
  {
    "function_name": "btf_modifier_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1249-1257",
    "snippet": "static void btf_modifier_seq_show(const struct btf *btf,\n\t\t\t\t  const struct btf_type *t,\n\t\t\t\t  u32 type_id, void *data,\n\t\t\t\t  u8 bits_offset, struct seq_file *m)\n{\n\tt = btf_type_id_resolve(btf, &type_id);\n\n\tbtf_type_ops(t)->seq_show(btf, t, type_id, data, bits_offset, m);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "btf",
            "t",
            "type_id",
            "data",
            "bits_offset",
            "m"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "t"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "418-421",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_resolve",
          "args": [
            "btf",
            "&type_id"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_resolve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "814-819",
          "snippet": "static const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf->resolved_ids[*type_id];\n\treturn btf_type_by_id(btf, *type_id);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf->resolved_ids[*type_id];\n\treturn btf_type_by_id(btf, *type_id);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_modifier_seq_show(const struct btf *btf,\n\t\t\t\t  const struct btf_type *t,\n\t\t\t\t  u32 type_id, void *data,\n\t\t\t\t  u8 bits_offset, struct seq_file *m)\n{\n\tt = btf_type_id_resolve(btf, &type_id);\n\n\tbtf_type_ops(t)->seq_show(btf, t, type_id, data, bits_offset, m);\n}"
  },
  {
    "function_name": "btf_ptr_resolve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1192-1247",
    "snippet": "static int btf_ptr_resolve(struct btf_verifier_env *env,\n\t\t\t   const struct resolve_vertex *v)\n{\n\tconst struct btf_type *next_type;\n\tconst struct btf_type *t = v->t;\n\tu32 next_type_id = t->type;\n\tstruct btf *btf = env->btf;\n\tu32 next_type_size = 0;\n\n\tnext_type = btf_type_by_id(btf, next_type_id);\n\tif (!next_type) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* \"void *\" */\n\tif (btf_type_is_void(next_type))\n\t\tgoto resolved;\n\n\tif (!env_type_is_resolve_sink(env, next_type) &&\n\t    !env_type_is_resolved(env, next_type_id))\n\t\treturn env_stack_push(env, next_type, next_type_id);\n\n\t/* If the modifier was RESOLVED during RESOLVE_STRUCT_OR_ARRAY,\n\t * the modifier may have stopped resolving when it was resolved\n\t * to a ptr (last-resolved-ptr).\n\t *\n\t * We now need to continue from the last-resolved-ptr to\n\t * ensure the last-resolved-ptr will not referring back to\n\t * the currenct ptr (t).\n\t */\n\tif (btf_type_is_modifier(next_type)) {\n\t\tconst struct btf_type *resolved_type;\n\t\tu32 resolved_type_id;\n\n\t\tresolved_type_id = next_type_id;\n\t\tresolved_type = btf_type_id_resolve(btf, &resolved_type_id);\n\n\t\tif (btf_type_is_ptr(resolved_type) &&\n\t\t    !env_type_is_resolve_sink(env, resolved_type) &&\n\t\t    !env_type_is_resolved(env, resolved_type_id))\n\t\t\treturn env_stack_push(env, resolved_type,\n\t\t\t\t\t      resolved_type_id);\n\t}\n\n\tif (!btf_type_id_size(btf, &next_type_id, &next_type_size) &&\n\t    !btf_type_is_void(btf_type_id_resolve(btf, &next_type_id))) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\nresolved:\n\tenv_stack_pop_resolved(env, next_type_id, 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_stack_pop_resolved",
          "args": [
            "env",
            "next_type_id",
            "0"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_pop_resolved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "796-806",
          "snippet": "static void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid type_id\""
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_void",
          "args": [
            "btf_type_id_resolve(btf, &next_type_id)"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_void_or_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "315-318",
          "snippet": "static bool btf_type_is_void_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_is_void(t);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_void_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_is_void(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_resolve",
          "args": [
            "btf",
            "&next_type_id"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_resolve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "814-819",
          "snippet": "static const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf->resolved_ids[*type_id];\n\treturn btf_type_by_id(btf, *type_id);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf->resolved_ids[*type_id];\n\treturn btf_type_by_id(btf, *type_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&next_type_id",
            "&next_type_size"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "821-854",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_is_void_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t\tsize_type_id = btf->resolved_ids[size_type_id];\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_is_void(size_type))\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_is_void_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t\tsize_type_id = btf->resolved_ids[size_type_id];\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_is_void(size_type))\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_stack_push",
          "args": [
            "env",
            "resolved_type",
            "resolved_type_id"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "762-788",
          "snippet": "static int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (env->visit_states[type_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MAX_RESOLVE_DEPTH 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (env->visit_states[type_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolved",
          "args": [
            "env",
            "resolved_type_id"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "756-760",
          "snippet": "static bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\treturn env->visit_states[type_id] == RESOLVED;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\treturn env->visit_states[type_id] == RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolve_sink",
          "args": [
            "env",
            "resolved_type"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolve_sink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "735-754",
          "snippet": "static bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct or array is a sink for ptr */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void or ptr is a sink for struct and array */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct or array is a sink for ptr */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void or ptr is a sink for struct and array */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "resolved_type"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "335-338",
          "snippet": "static bool btf_type_is_ptr(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_PTR;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_ptr(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_PTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_modifier",
          "args": [
            "next_type"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_modifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "284-305",
          "snippet": "static bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid type_id\""
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "next_type_id"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "439-445",
          "snippet": "static const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_ptr_resolve(struct btf_verifier_env *env,\n\t\t\t   const struct resolve_vertex *v)\n{\n\tconst struct btf_type *next_type;\n\tconst struct btf_type *t = v->t;\n\tu32 next_type_id = t->type;\n\tstruct btf *btf = env->btf;\n\tu32 next_type_size = 0;\n\n\tnext_type = btf_type_by_id(btf, next_type_id);\n\tif (!next_type) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* \"void *\" */\n\tif (btf_type_is_void(next_type))\n\t\tgoto resolved;\n\n\tif (!env_type_is_resolve_sink(env, next_type) &&\n\t    !env_type_is_resolved(env, next_type_id))\n\t\treturn env_stack_push(env, next_type, next_type_id);\n\n\t/* If the modifier was RESOLVED during RESOLVE_STRUCT_OR_ARRAY,\n\t * the modifier may have stopped resolving when it was resolved\n\t * to a ptr (last-resolved-ptr).\n\t *\n\t * We now need to continue from the last-resolved-ptr to\n\t * ensure the last-resolved-ptr will not referring back to\n\t * the currenct ptr (t).\n\t */\n\tif (btf_type_is_modifier(next_type)) {\n\t\tconst struct btf_type *resolved_type;\n\t\tu32 resolved_type_id;\n\n\t\tresolved_type_id = next_type_id;\n\t\tresolved_type = btf_type_id_resolve(btf, &resolved_type_id);\n\n\t\tif (btf_type_is_ptr(resolved_type) &&\n\t\t    !env_type_is_resolve_sink(env, resolved_type) &&\n\t\t    !env_type_is_resolved(env, resolved_type_id))\n\t\t\treturn env_stack_push(env, resolved_type,\n\t\t\t\t\t      resolved_type_id);\n\t}\n\n\tif (!btf_type_id_size(btf, &next_type_id, &next_type_size) &&\n\t    !btf_type_is_void(btf_type_id_resolve(btf, &next_type_id))) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\nresolved:\n\tenv_stack_pop_resolved(env, next_type_id, 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_modifier_resolve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1151-1190",
    "snippet": "static int btf_modifier_resolve(struct btf_verifier_env *env,\n\t\t\t\tconst struct resolve_vertex *v)\n{\n\tconst struct btf_type *t = v->t;\n\tconst struct btf_type *next_type;\n\tu32 next_type_id = t->type;\n\tstruct btf *btf = env->btf;\n\tu32 next_type_size = 0;\n\n\tnext_type = btf_type_by_id(btf, next_type_id);\n\tif (!next_type) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* \"typedef void new_void\", \"const void\"...etc */\n\tif (btf_type_is_void(next_type))\n\t\tgoto resolved;\n\n\tif (!env_type_is_resolve_sink(env, next_type) &&\n\t    !env_type_is_resolved(env, next_type_id))\n\t\treturn env_stack_push(env, next_type, next_type_id);\n\n\t/* Figure out the resolved next_type_id with size.\n\t * They will be stored in the current modifier's\n\t * resolved_ids and resolved_sizes such that it can\n\t * save us a few type-following when we use it later (e.g. in\n\t * pretty print).\n\t */\n\tif (!btf_type_id_size(btf, &next_type_id, &next_type_size) &&\n\t    !btf_type_is_void(btf_type_id_resolve(btf, &next_type_id))) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\nresolved:\n\tenv_stack_pop_resolved(env, next_type_id, next_type_size);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_stack_pop_resolved",
          "args": [
            "env",
            "next_type_id",
            "next_type_size"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_pop_resolved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "796-806",
          "snippet": "static void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid type_id\""
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_void",
          "args": [
            "btf_type_id_resolve(btf, &next_type_id)"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_void_or_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "315-318",
          "snippet": "static bool btf_type_is_void_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_is_void(t);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_void_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_is_void(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_resolve",
          "args": [
            "btf",
            "&next_type_id"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_resolve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "814-819",
          "snippet": "static const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf->resolved_ids[*type_id];\n\treturn btf_type_by_id(btf, *type_id);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf->resolved_ids[*type_id];\n\treturn btf_type_by_id(btf, *type_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&next_type_id",
            "&next_type_size"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "821-854",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_is_void_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t\tsize_type_id = btf->resolved_ids[size_type_id];\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_is_void(size_type))\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_is_void_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t\tsize_type_id = btf->resolved_ids[size_type_id];\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_is_void(size_type))\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_stack_push",
          "args": [
            "env",
            "next_type",
            "next_type_id"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "env_stack_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "762-788",
          "snippet": "static int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (env->visit_states[type_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define MAX_RESOLVE_DEPTH 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (env->visit_states[type_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolved",
          "args": [
            "env",
            "next_type_id"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "756-760",
          "snippet": "static bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\treturn env->visit_states[type_id] == RESOLVED;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\treturn env->visit_states[type_id] == RESOLVED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_type_is_resolve_sink",
          "args": [
            "env",
            "next_type"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "env_type_is_resolve_sink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "735-754",
          "snippet": "static bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct or array is a sink for ptr */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void or ptr is a sink for struct and array */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct or array is a sink for ptr */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void or ptr is a sink for struct and array */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "v->t",
            "\"Invalid type_id\""
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "next_type_id"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "439-445",
          "snippet": "static const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_modifier_resolve(struct btf_verifier_env *env,\n\t\t\t\tconst struct resolve_vertex *v)\n{\n\tconst struct btf_type *t = v->t;\n\tconst struct btf_type *next_type;\n\tu32 next_type_id = t->type;\n\tstruct btf *btf = env->btf;\n\tu32 next_type_size = 0;\n\n\tnext_type = btf_type_by_id(btf, next_type_id);\n\tif (!next_type) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* \"typedef void new_void\", \"const void\"...etc */\n\tif (btf_type_is_void(next_type))\n\t\tgoto resolved;\n\n\tif (!env_type_is_resolve_sink(env, next_type) &&\n\t    !env_type_is_resolved(env, next_type_id))\n\t\treturn env_stack_push(env, next_type, next_type_id);\n\n\t/* Figure out the resolved next_type_id with size.\n\t * They will be stored in the current modifier's\n\t * resolved_ids and resolved_sizes such that it can\n\t * save us a few type-following when we use it later (e.g. in\n\t * pretty print).\n\t */\n\tif (!btf_type_id_size(btf, &next_type_id, &next_type_size) &&\n\t    !btf_type_is_void(btf_type_id_resolve(btf, &next_type_id))) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\nresolved:\n\tenv_stack_pop_resolved(env, next_type_id, next_type_size);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_ref_type_check_meta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1132-1149",
    "snippet": "static int btf_ref_type_check_meta(struct btf_verifier_env *env,\n\t\t\t\t   const struct btf_type *t,\n\t\t\t\t   u32 meta_left)\n{\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!BTF_TYPE_ID_VALID(t->type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "NULL"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Invalid type_id\""
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_TYPE_ID_VALID",
          "args": [
            "t->type"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"vlen != 0\""
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_vlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "393-396",
          "snippet": "static u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_ref_type_check_meta(struct btf_verifier_env *env,\n\t\t\t\t   const struct btf_type *t,\n\t\t\t\t   u32 meta_left)\n{\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!BTF_TYPE_ID_VALID(t->type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_ptr_check_member",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1106-1130",
    "snippet": "static int btf_ptr_check_member(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *struct_type,\n\t\t\t\tconst struct btf_member *member,\n\t\t\t\tconst struct btf_type *member_type)\n{\n\tu32 struct_size, struct_bits_off, bytes_offset;\n\n\tstruct_size = struct_type->size;\n\tstruct_bits_off = member->offset;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (struct_size - bytes_offset < sizeof(void *)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "struct_type",
            "member",
            "\"Member exceeds struct_size\""
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "531-564",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t   btf_name_by_offset(btf, member->name_off),\n\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t   btf_name_by_offset(btf, member->name_off),\n\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "struct_bits_off"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDDOWN_BYTES",
          "args": [
            "struct_bits_off"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_ptr_check_member(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *struct_type,\n\t\t\t\tconst struct btf_member *member,\n\t\t\t\tconst struct btf_type *member_type)\n{\n\tu32 struct_size, struct_bits_off, bytes_offset;\n\n\tstruct_size = struct_type->size;\n\tstruct_bits_off = member->offset;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (struct_size - bytes_offset < sizeof(void *)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_modifier_check_member",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1081-1104",
    "snippet": "static int btf_modifier_check_member(struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *struct_type,\n\t\t\t\t     const struct btf_member *member,\n\t\t\t\t     const struct btf_type *member_type)\n{\n\tconst struct btf_type *resolved_type;\n\tu32 resolved_type_id = member->type;\n\tstruct btf_member resolved_member;\n\tstruct btf *btf = env->btf;\n\n\tresolved_type = btf_type_id_size(btf, &resolved_type_id, NULL);\n\tif (!resolved_type) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member\");\n\t\treturn -EINVAL;\n\t}\n\n\tresolved_member = *member;\n\tresolved_member.type = resolved_type_id;\n\n\treturn btf_type_ops(resolved_type)->check_member(env, struct_type,\n\t\t\t\t\t\t\t &resolved_member,\n\t\t\t\t\t\t\t resolved_type);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "env",
            "struct_type",
            "&resolved_member",
            "resolved_type"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "resolved_type"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "418-421",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "struct_type",
            "member",
            "\"Invalid member\""
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "531-564",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t   btf_name_by_offset(btf, member->name_off),\n\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t   btf_name_by_offset(btf, member->name_off),\n\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&resolved_type_id",
            "NULL"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "821-854",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_is_void_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t\tsize_type_id = btf->resolved_ids[size_type_id];\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_is_void(size_type))\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_is_void_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t\tsize_type_id = btf->resolved_ids[size_type_id];\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_is_void(size_type))\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_modifier_check_member(struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *struct_type,\n\t\t\t\t     const struct btf_member *member,\n\t\t\t\t     const struct btf_type *member_type)\n{\n\tconst struct btf_type *resolved_type;\n\tu32 resolved_type_id = member->type;\n\tstruct btf_member resolved_member;\n\tstruct btf *btf = env->btf;\n\n\tresolved_type = btf_type_id_size(btf, &resolved_type_id, NULL);\n\tif (!resolved_type) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member\");\n\t\treturn -EINVAL;\n\t}\n\n\tresolved_member = *member;\n\tresolved_member.type = resolved_type_id;\n\n\treturn btf_type_ops(resolved_type)->check_member(env, struct_type,\n\t\t\t\t\t\t\t &resolved_member,\n\t\t\t\t\t\t\t resolved_type);\n}"
  },
  {
    "function_name": "btf_int_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "1028-1071",
    "snippet": "static void btf_int_seq_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t     u32 type_id, void *data, u8 bits_offset,\n\t\t\t     struct seq_file *m)\n{\n\tu32 int_data = btf_type_int(t);\n\tu8 encoding = BTF_INT_ENCODING(int_data);\n\tbool sign = encoding & BTF_INT_SIGNED;\n\tu8 nr_bits = BTF_INT_BITS(int_data);\n\n\tif (bits_offset || BTF_INT_OFFSET(int_data) ||\n\t    BITS_PER_BYTE_MASKED(nr_bits)) {\n\t\tbtf_int_bits_seq_show(btf, t, data, bits_offset, m);\n\t\treturn;\n\t}\n\n\tswitch (nr_bits) {\n\tcase 64:\n\t\tif (sign)\n\t\t\tseq_printf(m, \"%lld\", *(s64 *)data);\n\t\telse\n\t\t\tseq_printf(m, \"%llu\", *(u64 *)data);\n\t\tbreak;\n\tcase 32:\n\t\tif (sign)\n\t\t\tseq_printf(m, \"%d\", *(s32 *)data);\n\t\telse\n\t\t\tseq_printf(m, \"%u\", *(u32 *)data);\n\t\tbreak;\n\tcase 16:\n\t\tif (sign)\n\t\t\tseq_printf(m, \"%d\", *(s16 *)data);\n\t\telse\n\t\t\tseq_printf(m, \"%u\", *(u16 *)data);\n\t\tbreak;\n\tcase 8:\n\t\tif (sign)\n\t\t\tseq_printf(m, \"%d\", *(s8 *)data);\n\t\telse\n\t\t\tseq_printf(m, \"%u\", *(u8 *)data);\n\t\tbreak;\n\tdefault:\n\t\tbtf_int_bits_seq_show(btf, t, data, bits_offset, m);\n\t}\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_int_bits_seq_show",
          "args": [
            "btf",
            "t",
            "data",
            "bits_offset",
            "m"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "btf_int_bits_seq_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "989-1026",
          "snippet": "static void btf_int_bits_seq_show(const struct btf *btf,\n\t\t\t\t  const struct btf_type *t,\n\t\t\t\t  void *data, u8 bits_offset,\n\t\t\t\t  struct seq_file *m)\n{\n\tu16 left_shift_bits, right_shift_bits;\n\tu32 int_data = btf_type_int(t);\n\tu8 nr_bits = BTF_INT_BITS(int_data);\n\tu8 total_bits_offset;\n\tu8 nr_copy_bytes;\n\tu8 nr_copy_bits;\n\tu64 print_num;\n\n\t/*\n\t * bits_offset is at most 7.\n\t * BTF_INT_OFFSET() cannot exceed 64 bits.\n\t */\n\ttotal_bits_offset = bits_offset + BTF_INT_OFFSET(int_data);\n\tdata += BITS_ROUNDDOWN_BYTES(total_bits_offset);\n\tbits_offset = BITS_PER_BYTE_MASKED(total_bits_offset);\n\tnr_copy_bits = nr_bits + bits_offset;\n\tnr_copy_bytes = BITS_ROUNDUP_BYTES(nr_copy_bits);\n\n\tprint_num = 0;\n\tmemcpy(&print_num, data, nr_copy_bytes);\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tleft_shift_bits = bits_offset;\n#else\n\tleft_shift_bits = BITS_PER_U64 - nr_copy_bits;\n#endif\n\tright_shift_bits = BITS_PER_U64 - nr_bits;\n\n\tprint_num <<= left_shift_bits;\n\tprint_num >>= right_shift_bits;\n\n\tseq_printf(m, \"0x%llx\", print_num);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [
            "#define BITS_PER_U64 (sizeof(u64) * BITS_PER_BYTE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\n#define BITS_PER_U64 (sizeof(u64) * BITS_PER_BYTE)\n\nstatic void btf_int_bits_seq_show(const struct btf *btf,\n\t\t\t\t  const struct btf_type *t,\n\t\t\t\t  void *data, u8 bits_offset,\n\t\t\t\t  struct seq_file *m)\n{\n\tu16 left_shift_bits, right_shift_bits;\n\tu32 int_data = btf_type_int(t);\n\tu8 nr_bits = BTF_INT_BITS(int_data);\n\tu8 total_bits_offset;\n\tu8 nr_copy_bytes;\n\tu8 nr_copy_bits;\n\tu64 print_num;\n\n\t/*\n\t * bits_offset is at most 7.\n\t * BTF_INT_OFFSET() cannot exceed 64 bits.\n\t */\n\ttotal_bits_offset = bits_offset + BTF_INT_OFFSET(int_data);\n\tdata += BITS_ROUNDDOWN_BYTES(total_bits_offset);\n\tbits_offset = BITS_PER_BYTE_MASKED(total_bits_offset);\n\tnr_copy_bits = nr_bits + bits_offset;\n\tnr_copy_bytes = BITS_ROUNDUP_BYTES(nr_copy_bits);\n\n\tprint_num = 0;\n\tmemcpy(&print_num, data, nr_copy_bytes);\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tleft_shift_bits = bits_offset;\n#else\n\tleft_shift_bits = BITS_PER_U64 - nr_copy_bits;\n#endif\n\tright_shift_bits = BITS_PER_U64 - nr_bits;\n\n\tprint_num <<= left_shift_bits;\n\tprint_num >>= right_shift_bits;\n\n\tseq_printf(m, \"0x%llx\", print_num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%u\"",
            "*(u8 *)data"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "nr_bits"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_OFFSET",
          "args": [
            "int_data"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_BITS",
          "args": [
            "int_data"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_ENCODING",
          "args": [
            "int_data"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_int",
          "args": [
            "t"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_int_is_regular",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "451-467",
          "snippet": "static bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_int_seq_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t     u32 type_id, void *data, u8 bits_offset,\n\t\t\t     struct seq_file *m)\n{\n\tu32 int_data = btf_type_int(t);\n\tu8 encoding = BTF_INT_ENCODING(int_data);\n\tbool sign = encoding & BTF_INT_SIGNED;\n\tu8 nr_bits = BTF_INT_BITS(int_data);\n\n\tif (bits_offset || BTF_INT_OFFSET(int_data) ||\n\t    BITS_PER_BYTE_MASKED(nr_bits)) {\n\t\tbtf_int_bits_seq_show(btf, t, data, bits_offset, m);\n\t\treturn;\n\t}\n\n\tswitch (nr_bits) {\n\tcase 64:\n\t\tif (sign)\n\t\t\tseq_printf(m, \"%lld\", *(s64 *)data);\n\t\telse\n\t\t\tseq_printf(m, \"%llu\", *(u64 *)data);\n\t\tbreak;\n\tcase 32:\n\t\tif (sign)\n\t\t\tseq_printf(m, \"%d\", *(s32 *)data);\n\t\telse\n\t\t\tseq_printf(m, \"%u\", *(u32 *)data);\n\t\tbreak;\n\tcase 16:\n\t\tif (sign)\n\t\t\tseq_printf(m, \"%d\", *(s16 *)data);\n\t\telse\n\t\t\tseq_printf(m, \"%u\", *(u16 *)data);\n\t\tbreak;\n\tcase 8:\n\t\tif (sign)\n\t\t\tseq_printf(m, \"%d\", *(s8 *)data);\n\t\telse\n\t\t\tseq_printf(m, \"%u\", *(u8 *)data);\n\t\tbreak;\n\tdefault:\n\t\tbtf_int_bits_seq_show(btf, t, data, bits_offset, m);\n\t}\n}"
  },
  {
    "function_name": "btf_int_bits_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "989-1026",
    "snippet": "static void btf_int_bits_seq_show(const struct btf *btf,\n\t\t\t\t  const struct btf_type *t,\n\t\t\t\t  void *data, u8 bits_offset,\n\t\t\t\t  struct seq_file *m)\n{\n\tu16 left_shift_bits, right_shift_bits;\n\tu32 int_data = btf_type_int(t);\n\tu8 nr_bits = BTF_INT_BITS(int_data);\n\tu8 total_bits_offset;\n\tu8 nr_copy_bytes;\n\tu8 nr_copy_bits;\n\tu64 print_num;\n\n\t/*\n\t * bits_offset is at most 7.\n\t * BTF_INT_OFFSET() cannot exceed 64 bits.\n\t */\n\ttotal_bits_offset = bits_offset + BTF_INT_OFFSET(int_data);\n\tdata += BITS_ROUNDDOWN_BYTES(total_bits_offset);\n\tbits_offset = BITS_PER_BYTE_MASKED(total_bits_offset);\n\tnr_copy_bits = nr_bits + bits_offset;\n\tnr_copy_bytes = BITS_ROUNDUP_BYTES(nr_copy_bits);\n\n\tprint_num = 0;\n\tmemcpy(&print_num, data, nr_copy_bytes);\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tleft_shift_bits = bits_offset;\n#else\n\tleft_shift_bits = BITS_PER_U64 - nr_copy_bits;\n#endif\n\tright_shift_bits = BITS_PER_U64 - nr_bits;\n\n\tprint_num <<= left_shift_bits;\n\tprint_num >>= right_shift_bits;\n\n\tseq_printf(m, \"0x%llx\", print_num);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define BITS_PER_U64 (sizeof(u64) * BITS_PER_BYTE)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"0x%llx\"",
            "print_num"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&print_num",
            "data",
            "nr_copy_bytes"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDUP_BYTES",
          "args": [
            "nr_copy_bits"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "total_bits_offset"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDDOWN_BYTES",
          "args": [
            "total_bits_offset"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_OFFSET",
          "args": [
            "int_data"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_BITS",
          "args": [
            "int_data"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_int",
          "args": [
            "t"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_int_is_regular",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "451-467",
          "snippet": "static bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\n#define BITS_PER_U64 (sizeof(u64) * BITS_PER_BYTE)\n\nstatic void btf_int_bits_seq_show(const struct btf *btf,\n\t\t\t\t  const struct btf_type *t,\n\t\t\t\t  void *data, u8 bits_offset,\n\t\t\t\t  struct seq_file *m)\n{\n\tu16 left_shift_bits, right_shift_bits;\n\tu32 int_data = btf_type_int(t);\n\tu8 nr_bits = BTF_INT_BITS(int_data);\n\tu8 total_bits_offset;\n\tu8 nr_copy_bytes;\n\tu8 nr_copy_bits;\n\tu64 print_num;\n\n\t/*\n\t * bits_offset is at most 7.\n\t * BTF_INT_OFFSET() cannot exceed 64 bits.\n\t */\n\ttotal_bits_offset = bits_offset + BTF_INT_OFFSET(int_data);\n\tdata += BITS_ROUNDDOWN_BYTES(total_bits_offset);\n\tbits_offset = BITS_PER_BYTE_MASKED(total_bits_offset);\n\tnr_copy_bits = nr_bits + bits_offset;\n\tnr_copy_bytes = BITS_ROUNDUP_BYTES(nr_copy_bits);\n\n\tprint_num = 0;\n\tmemcpy(&print_num, data, nr_copy_bytes);\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tleft_shift_bits = bits_offset;\n#else\n\tleft_shift_bits = BITS_PER_U64 - nr_copy_bits;\n#endif\n\tright_shift_bits = BITS_PER_U64 - nr_bits;\n\n\tprint_num <<= left_shift_bits;\n\tprint_num >>= right_shift_bits;\n\n\tseq_printf(m, \"0x%llx\", print_num);\n}"
  },
  {
    "function_name": "btf_int_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "977-987",
    "snippet": "static void btf_int_log(struct btf_verifier_env *env,\n\t\t\tconst struct btf_type *t)\n{\n\tint int_data = btf_type_int(t);\n\n\tbtf_verifier_log(env,\n\t\t\t \"size=%u bits_offset=%u nr_bits=%u encoding=%s\",\n\t\t\t t->size, BTF_INT_OFFSET(int_data),\n\t\t\t BTF_INT_BITS(int_data),\n\t\t\t btf_int_encoding_str(BTF_INT_ENCODING(int_data)));\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"size=%u bits_offset=%u nr_bits=%u encoding=%s\"",
            "t->size",
            "BTF_INT_OFFSET(int_data)",
            "BTF_INT_BITS(int_data)",
            "btf_int_encoding_str(BTF_INT_ENCODING(int_data))"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "479-491",
          "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_int_encoding_str",
          "args": [
            "BTF_INT_ENCODING(int_data)"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "btf_int_encoding_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "379-391",
          "snippet": "static const char *btf_int_encoding_str(u8 encoding)\n{\n\tif (encoding == 0)\n\t\treturn \"(none)\";\n\telse if (encoding == BTF_INT_SIGNED)\n\t\treturn \"SIGNED\";\n\telse if (encoding == BTF_INT_CHAR)\n\t\treturn \"CHAR\";\n\telse if (encoding == BTF_INT_BOOL)\n\t\treturn \"BOOL\";\n\telse\n\t\treturn \"UNKN\";\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_int_encoding_str(u8 encoding)\n{\n\tif (encoding == 0)\n\t\treturn \"(none)\";\n\telse if (encoding == BTF_INT_SIGNED)\n\t\treturn \"SIGNED\";\n\telse if (encoding == BTF_INT_CHAR)\n\t\treturn \"CHAR\";\n\telse if (encoding == BTF_INT_BOOL)\n\t\treturn \"BOOL\";\n\telse\n\t\treturn \"UNKN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INT_ENCODING",
          "args": [
            "int_data"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_BITS",
          "args": [
            "int_data"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_OFFSET",
          "args": [
            "int_data"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_int",
          "args": [
            "t"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_int_is_regular",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "451-467",
          "snippet": "static bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_int_log(struct btf_verifier_env *env,\n\t\t\tconst struct btf_type *t)\n{\n\tint int_data = btf_type_int(t);\n\n\tbtf_verifier_log(env,\n\t\t\t \"size=%u bits_offset=%u nr_bits=%u encoding=%s\",\n\t\t\t t->size, BTF_INT_OFFSET(int_data),\n\t\t\t BTF_INT_BITS(int_data),\n\t\t\t btf_int_encoding_str(BTF_INT_ENCODING(int_data)));\n}"
  },
  {
    "function_name": "btf_int_check_meta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "918-975",
    "snippet": "static s32 btf_int_check_meta(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 meta_left)\n{\n\tu32 int_data, nr_bits, meta_needed = sizeof(int_data);\n\tu16 encoding;\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tint_data = btf_type_int(t);\n\tif (int_data & ~BTF_INT_MASK) {\n\t\tbtf_verifier_log_basic(env, t, \"Invalid int_data:%x\",\n\t\t\t\t       int_data);\n\t\treturn -EINVAL;\n\t}\n\n\tnr_bits = BTF_INT_BITS(int_data) + BTF_INT_OFFSET(int_data);\n\n\tif (nr_bits > BITS_PER_U64) {\n\t\tbtf_verifier_log_type(env, t, \"nr_bits exceeds %zu\",\n\t\t\t\t      BITS_PER_U64);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BITS_ROUNDUP_BYTES(nr_bits) > t->size) {\n\t\tbtf_verifier_log_type(env, t, \"nr_bits exceeds type_size\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Only one of the encoding bits is allowed and it\n\t * should be sufficient for the pretty print purpose (i.e. decoding).\n\t * Multiple bits can be allowed later if it is found\n\t * to be insufficient.\n\t */\n\tencoding = BTF_INT_ENCODING(int_data);\n\tif (encoding &&\n\t    encoding != BTF_INT_SIGNED &&\n\t    encoding != BTF_INT_CHAR &&\n\t    encoding != BTF_INT_BOOL) {\n\t\tbtf_verifier_log_type(env, t, \"Unsupported encoding\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn meta_needed;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define BTF_INT_MASK 0x0fffffff",
      "#define BITS_PER_U64 (sizeof(u64) * BITS_PER_BYTE)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "NULL"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"Unsupported encoding\""
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_ENCODING",
          "args": [
            "int_data"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"nr_bits exceeds type_size\""
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDUP_BYTES",
          "args": [
            "nr_bits"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"nr_bits exceeds %zu\"",
            "BITS_PER_U64"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_verifier_log_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "493-523",
          "snippet": "static void __btf_verifier_log_type(struct btf_verifier_env *env,\n\t\t\t\t\t\t   const struct btf_type *t,\n\t\t\t\t\t\t   bool log_details,\n\t\t\t\t\t\t   const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tu8 kind = BTF_INFO_KIND(t->info);\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t__btf_verifier_log(log, \"[%u] %s %s%s\",\n\t\t\t   env->log_type_id,\n\t\t\t   btf_kind_str[kind],\n\t\t\t   btf_name_by_offset(btf, t->name_off),\n\t\t\t   log_details ? \" \" : \"\");\n\n\tif (log_details)\n\t\tbtf_type_ops(t)->log_details(env, t);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n};\n\nstatic void __btf_verifier_log_type(struct btf_verifier_env *env,\n\t\t\t\t\t\t   const struct btf_type *t,\n\t\t\t\t\t\t   bool log_details,\n\t\t\t\t\t\t   const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tu8 kind = BTF_INFO_KIND(t->info);\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t__btf_verifier_log(log, \"[%u] %s %s%s\",\n\t\t\t   env->log_type_id,\n\t\t\t   btf_kind_str[kind],\n\t\t\t   btf_name_by_offset(btf, t->name_off),\n\t\t\t   log_details ? \" \" : \"\");\n\n\tif (log_details)\n\t\tbtf_type_ops(t)->log_details(env, t);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INT_OFFSET",
          "args": [
            "int_data"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_BITS",
          "args": [
            "int_data"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_basic",
          "args": [
            "env",
            "t",
            "\"Invalid int_data:%x\"",
            "int_data"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_int",
          "args": [
            "t"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_int_is_regular",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "451-467",
          "snippet": "static bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "t",
            "\"vlen != 0\""
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_vlen",
          "args": [
            "t"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_vlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "393-396",
          "snippet": "static u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_basic",
          "args": [
            "env",
            "t",
            "\"meta_left:%u meta_needed:%u\"",
            "meta_left",
            "meta_needed"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\n#define BTF_INT_MASK 0x0fffffff\n#define BITS_PER_U64 (sizeof(u64) * BITS_PER_BYTE)\n\nstatic s32 btf_int_check_meta(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 meta_left)\n{\n\tu32 int_data, nr_bits, meta_needed = sizeof(int_data);\n\tu16 encoding;\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tint_data = btf_type_int(t);\n\tif (int_data & ~BTF_INT_MASK) {\n\t\tbtf_verifier_log_basic(env, t, \"Invalid int_data:%x\",\n\t\t\t\t       int_data);\n\t\treturn -EINVAL;\n\t}\n\n\tnr_bits = BTF_INT_BITS(int_data) + BTF_INT_OFFSET(int_data);\n\n\tif (nr_bits > BITS_PER_U64) {\n\t\tbtf_verifier_log_type(env, t, \"nr_bits exceeds %zu\",\n\t\t\t\t      BITS_PER_U64);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BITS_ROUNDUP_BYTES(nr_bits) > t->size) {\n\t\tbtf_verifier_log_type(env, t, \"nr_bits exceeds type_size\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Only one of the encoding bits is allowed and it\n\t * should be sufficient for the pretty print purpose (i.e. decoding).\n\t * Multiple bits can be allowed later if it is found\n\t * to be insufficient.\n\t */\n\tencoding = BTF_INT_ENCODING(int_data);\n\tif (encoding &&\n\t    encoding != BTF_INT_SIGNED &&\n\t    encoding != BTF_INT_CHAR &&\n\t    encoding != BTF_INT_BOOL) {\n\t\tbtf_verifier_log_type(env, t, \"Unsupported encoding\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn meta_needed;\n}"
  },
  {
    "function_name": "btf_int_check_member",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "880-916",
    "snippet": "static int btf_int_check_member(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *struct_type,\n\t\t\t\tconst struct btf_member *member,\n\t\t\t\tconst struct btf_type *member_type)\n{\n\tu32 int_data = btf_type_int(member_type);\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size = struct_type->size;\n\tu32 nr_copy_bits;\n\tu32 bytes_offset;\n\n\tif (U32_MAX - struct_bits_off < BTF_INT_OFFSET(int_data)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"bits_offset exceeds U32_MAX\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct_bits_off += BTF_INT_OFFSET(int_data);\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tnr_copy_bits = BTF_INT_BITS(int_data) +\n\t\tBITS_PER_BYTE_MASKED(struct_bits_off);\n\n\tif (nr_copy_bits > BITS_PER_U64) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"nr_copy_bits exceeds 64\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (struct_size < bytes_offset ||\n\t    struct_size - bytes_offset < BITS_ROUNDUP_BYTES(nr_copy_bits)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define BITS_PER_U64 (sizeof(u64) * BITS_PER_BYTE)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_member",
          "args": [
            "env",
            "struct_type",
            "member",
            "\"Member exceeds struct_size\""
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "531-564",
          "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t   btf_name_by_offset(btf, member->name_off),\n\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t   btf_name_by_offset(btf, member->name_off),\n\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDUP_BYTES",
          "args": [
            "nr_copy_bits"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "struct_bits_off"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_BITS",
          "args": [
            "int_data"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDDOWN_BYTES",
          "args": [
            "struct_bits_off"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_OFFSET",
          "args": [
            "int_data"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_OFFSET",
          "args": [
            "int_data"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_int",
          "args": [
            "member_type"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_int_is_regular",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "451-467",
          "snippet": "static bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\n#define BITS_PER_U64 (sizeof(u64) * BITS_PER_BYTE)\n\nstatic int btf_int_check_member(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *struct_type,\n\t\t\t\tconst struct btf_member *member,\n\t\t\t\tconst struct btf_type *member_type)\n{\n\tu32 int_data = btf_type_int(member_type);\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size = struct_type->size;\n\tu32 nr_copy_bits;\n\tu32 bytes_offset;\n\n\tif (U32_MAX - struct_bits_off < BTF_INT_OFFSET(int_data)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"bits_offset exceeds U32_MAX\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct_bits_off += BTF_INT_OFFSET(int_data);\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tnr_copy_bits = BTF_INT_BITS(int_data) +\n\t\tBITS_PER_BYTE_MASKED(struct_bits_off);\n\n\tif (nr_copy_bits > BITS_PER_U64) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"nr_copy_bits exceeds 64\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (struct_size < bytes_offset ||\n\t    struct_size - bytes_offset < BITS_ROUNDUP_BYTES(nr_copy_bits)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_df_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "873-878",
    "snippet": "static void btf_df_seq_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t    u32 type_id, void *data, u8 bits_offsets,\n\t\t\t    struct seq_file *m)\n{\n\tseq_printf(m, \"<unsupported kind:%u>\", BTF_INFO_KIND(t->info));\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"<unsupported kind:%u>\"",
            "BTF_INFO_KIND(t->info)"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_df_seq_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t    u32 type_id, void *data, u8 bits_offsets,\n\t\t\t    struct seq_file *m)\n{\n\tseq_printf(m, \"<unsupported kind:%u>\", BTF_INFO_KIND(t->info));\n}"
  },
  {
    "function_name": "btf_df_resolve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "866-871",
    "snippet": "static int btf_df_resolve(struct btf_verifier_env *env,\n\t\t\t  const struct resolve_vertex *v)\n{\n\tbtf_verifier_log_basic(env, v->t, \"Unsupported resolve\");\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_basic",
          "args": [
            "env",
            "v->t",
            "\"Unsupported resolve\""
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_df_resolve(struct btf_verifier_env *env,\n\t\t\t  const struct resolve_vertex *v)\n{\n\tbtf_verifier_log_basic(env, v->t, \"Unsupported resolve\");\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "btf_df_check_member",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "856-864",
    "snippet": "static int btf_df_check_member(struct btf_verifier_env *env,\n\t\t\t       const struct btf_type *struct_type,\n\t\t\t       const struct btf_member *member,\n\t\t\t       const struct btf_type *member_type)\n{\n\tbtf_verifier_log_basic(env, struct_type,\n\t\t\t       \"Unsupported check_member\");\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_verifier_log_basic",
          "args": [
            "env",
            "struct_type",
            "\"Unsupported check_member\""
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_df_check_member(struct btf_verifier_env *env,\n\t\t\t       const struct btf_type *struct_type,\n\t\t\t       const struct btf_member *member,\n\t\t\t       const struct btf_type *member_type)\n{\n\tbtf_verifier_log_basic(env, struct_type,\n\t\t\t       \"Unsupported check_member\");\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "btf_type_id_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "821-854",
    "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_is_void_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t\tsize_type_id = btf->resolved_ids[size_type_id];\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_is_void(size_type))\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_is_void",
          "args": [
            "size_type"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_void_or_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "315-318",
          "snippet": "static bool btf_type_is_void_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_is_void(t);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_void_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_is_void(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "size_type_id"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "439-445",
          "snippet": "static const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!btf_type_is_modifier(size_type)"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_modifier",
          "args": [
            "size_type"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_modifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "284-305",
          "snippet": "static bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "size_type"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "335-338",
          "snippet": "static bool btf_type_is_ptr(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_PTR;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_ptr(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_PTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_array",
          "args": [
            "size_type"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "330-333",
          "snippet": "static bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_has_size",
          "args": [
            "size_type"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_has_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "366-377",
          "snippet": "static bool btf_type_has_size(const struct btf_type *t)\n{\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\tcase BTF_KIND_ENUM:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_has_size(const struct btf_type *t)\n{\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\tcase BTF_KIND_ENUM:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_is_void_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t\tsize_type_id = btf->resolved_ids[size_type_id];\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_is_void(size_type))\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
  },
  {
    "function_name": "btf_type_id_resolve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "814-819",
    "snippet": "static const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf->resolved_ids[*type_id];\n\treturn btf_type_by_id(btf, *type_id);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_by_id",
          "args": [
            "btf",
            "*type_id"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "439-445",
          "snippet": "static const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf->resolved_ids[*type_id];\n\treturn btf_type_by_id(btf, *type_id);\n}"
  },
  {
    "function_name": "env_stack_peak",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "808-811",
    "snippet": "static const struct resolve_vertex *env_stack_peak(struct btf_verifier_env *env)\n{\n\treturn env->top_stack ? &env->stack[env->top_stack - 1] : NULL;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct resolve_vertex *env_stack_peak(struct btf_verifier_env *env)\n{\n\treturn env->top_stack ? &env->stack[env->top_stack - 1] : NULL;\n}"
  },
  {
    "function_name": "env_stack_pop_resolved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "796-806",
    "snippet": "static void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}"
  },
  {
    "function_name": "env_stack_set_next_member",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "790-794",
    "snippet": "static void env_stack_set_next_member(struct btf_verifier_env *env,\n\t\t\t\t      u16 next_member)\n{\n\tenv->stack[env->top_stack - 1].next_member = next_member;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void env_stack_set_next_member(struct btf_verifier_env *env,\n\t\t\t\t      u16 next_member)\n{\n\tenv->stack[env->top_stack - 1].next_member = next_member;\n}"
  },
  {
    "function_name": "env_stack_push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "762-788",
    "snippet": "static int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (env->visit_states[type_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [
      "#define MAX_RESOLVE_DEPTH 32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_is_array",
          "args": [
            "t"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "330-333",
          "snippet": "static bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_struct",
          "args": [
            "t"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "323-328",
          "snippet": "static bool btf_type_is_struct(const struct btf_type *t)\n{\n\tu8 kind = BTF_INFO_KIND(t->info);\n\n\treturn kind == BTF_KIND_STRUCT || kind == BTF_KIND_UNION;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_struct(const struct btf_type *t)\n{\n\tu8 kind = BTF_INFO_KIND(t->info);\n\n\treturn kind == BTF_KIND_STRUCT || kind == BTF_KIND_UNION;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "t"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "335-338",
          "snippet": "static bool btf_type_is_ptr(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_PTR;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_ptr(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_PTR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\n#define MAX_RESOLVE_DEPTH 32\n\nstatic int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (env->visit_states[type_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "env_type_is_resolved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "756-760",
    "snippet": "static bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\treturn env->visit_states[type_id] == RESOLVED;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\treturn env->visit_states[type_id] == RESOLVED;\n}"
  },
  {
    "function_name": "env_type_is_resolve_sink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "735-754",
    "snippet": "static bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct or array is a sink for ptr */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void or ptr is a sink for struct and array */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_struct",
          "args": [
            "next_type"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "323-328",
          "snippet": "static bool btf_type_is_struct(const struct btf_type *t)\n{\n\tu8 kind = BTF_INFO_KIND(t->info);\n\n\treturn kind == BTF_KIND_STRUCT || kind == BTF_KIND_UNION;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_struct(const struct btf_type *t)\n{\n\tu8 kind = BTF_INFO_KIND(t->info);\n\n\treturn kind == BTF_KIND_STRUCT || kind == BTF_KIND_UNION;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_array",
          "args": [
            "next_type"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "330-333",
          "snippet": "static bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_modifier",
          "args": [
            "next_type"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_modifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "284-305",
          "snippet": "static bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "next_type"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "335-338",
          "snippet": "static bool btf_type_is_ptr(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_PTR;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_ptr(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_PTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_needs_resolve",
          "args": [
            "next_type"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_needs_resolve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "357-363",
          "snippet": "static bool btf_type_needs_resolve(const struct btf_type *t)\n{\n\treturn btf_type_is_modifier(t) ||\n\t\tbtf_type_is_ptr(t) ||\n\t\tbtf_type_is_struct(t) ||\n\t\tbtf_type_is_array(t);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_needs_resolve(const struct btf_type *t)\n{\n\treturn btf_type_is_modifier(t) ||\n\t\tbtf_type_is_ptr(t) ||\n\t\tbtf_type_is_struct(t) ||\n\t\tbtf_type_is_array(t);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct or array is a sink for ptr */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void or ptr is a sink for struct and array */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "btf_verifier_env_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "729-733",
    "snippet": "static void btf_verifier_env_free(struct btf_verifier_env *env)\n{\n\tkvfree(env->visit_states);\n\tkfree(env);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "env"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "env->visit_states"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_env_free(struct btf_verifier_env *env)\n{\n\tkvfree(env->visit_states);\n\tkfree(env);\n}"
  },
  {
    "function_name": "env_resolve_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "692-727",
    "snippet": "static int env_resolve_init(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tu32 nr_types = btf->nr_types;\n\tu32 *resolved_sizes = NULL;\n\tu32 *resolved_ids = NULL;\n\tu8 *visit_states = NULL;\n\n\t/* +1 for btf_void */\n\tresolved_sizes = kvcalloc(nr_types + 1, sizeof(*resolved_sizes),\n\t\t\t\t  GFP_KERNEL | __GFP_NOWARN);\n\tif (!resolved_sizes)\n\t\tgoto nomem;\n\n\tresolved_ids = kvcalloc(nr_types + 1, sizeof(*resolved_ids),\n\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!resolved_ids)\n\t\tgoto nomem;\n\n\tvisit_states = kvcalloc(nr_types + 1, sizeof(*visit_states),\n\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!visit_states)\n\t\tgoto nomem;\n\n\tbtf->resolved_sizes = resolved_sizes;\n\tbtf->resolved_ids = resolved_ids;\n\tenv->visit_states = visit_states;\n\n\treturn 0;\n\nnomem:\n\tkvfree(resolved_sizes);\n\tkvfree(resolved_ids);\n\tkvfree(visit_states);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct btf_type btf_void;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "visit_states"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "resolved_ids"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "resolved_sizes"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvcalloc",
          "args": [
            "nr_types + 1",
            "sizeof(*visit_states)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvcalloc",
          "args": [
            "nr_types + 1",
            "sizeof(*resolved_ids)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvcalloc",
          "args": [
            "nr_types + 1",
            "sizeof(*resolved_sizes)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic struct btf_type btf_void;\n\nstatic int env_resolve_init(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tu32 nr_types = btf->nr_types;\n\tu32 *resolved_sizes = NULL;\n\tu32 *resolved_ids = NULL;\n\tu8 *visit_states = NULL;\n\n\t/* +1 for btf_void */\n\tresolved_sizes = kvcalloc(nr_types + 1, sizeof(*resolved_sizes),\n\t\t\t\t  GFP_KERNEL | __GFP_NOWARN);\n\tif (!resolved_sizes)\n\t\tgoto nomem;\n\n\tresolved_ids = kvcalloc(nr_types + 1, sizeof(*resolved_ids),\n\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!resolved_ids)\n\t\tgoto nomem;\n\n\tvisit_states = kvcalloc(nr_types + 1, sizeof(*visit_states),\n\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!visit_states)\n\t\tgoto nomem;\n\n\tbtf->resolved_sizes = resolved_sizes;\n\tbtf->resolved_ids = resolved_ids;\n\tenv->visit_states = visit_states;\n\n\treturn 0;\n\nnomem:\n\tkvfree(resolved_sizes);\n\tkvfree(resolved_ids);\n\tkvfree(visit_states);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "btf_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "684-690",
    "snippet": "void btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&btf->rcu",
            "btf_free_rcu"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_free_id",
          "args": [
            "btf"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "btf_free_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "650-666",
          "snippet": "static void btf_free_id(struct btf *btf)\n{\n\tunsigned long flags;\n\n\t/*\n\t * In map-in-map, calling map_delete_elem() on outer\n\t * map will call bpf_map_put on the inner map.\n\t * It will then eventually call btf_free_id()\n\t * on the inner map.  Some of the map_delete_elem()\n\t * implementation may have irq disabled, so\n\t * we need to use the _irqsave() version instead\n\t * of the _bh() version.\n\t */\n\tspin_lock_irqsave(&btf_idr_lock, flags);\n\tidr_remove(&btf_idr, btf->id);\n\tspin_unlock_irqrestore(&btf_idr_lock, flags);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(btf_idr);",
            "static DEFINE_SPINLOCK(btf_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic DEFINE_IDR(btf_idr);\nstatic DEFINE_SPINLOCK(btf_idr_lock);\n\nstatic void btf_free_id(struct btf *btf)\n{\n\tunsigned long flags;\n\n\t/*\n\t * In map-in-map, calling map_delete_elem() on outer\n\t * map will call bpf_map_put on the inner map.\n\t * It will then eventually call btf_free_id()\n\t * on the inner map.  Some of the map_delete_elem()\n\t * implementation may have irq disabled, so\n\t * we need to use the _irqsave() version instead\n\t * of the _bh() version.\n\t */\n\tspin_lock_irqsave(&btf_idr_lock, flags);\n\tidr_remove(&btf_idr, btf->id);\n\tspin_unlock_irqrestore(&btf_idr_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&btf->refcnt"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}"
  },
  {
    "function_name": "btf_free_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "677-682",
    "snippet": "static void btf_free_rcu(struct rcu_head *rcu)\n{\n\tstruct btf *btf = container_of(rcu, struct btf, rcu);\n\n\tbtf_free(btf);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_free",
          "args": [
            "btf"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "btf_free_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "677-682",
          "snippet": "static void btf_free_rcu(struct rcu_head *rcu)\n{\n\tstruct btf *btf = container_of(rcu, struct btf, rcu);\n\n\tbtf_free(btf);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structbtf",
            "rcu"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_free_rcu(struct rcu_head *rcu)\n{\n\tstruct btf *btf = container_of(rcu, struct btf, rcu);\n\n\tbtf_free(btf);\n}"
  },
  {
    "function_name": "btf_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "668-675",
    "snippet": "static void btf_free(struct btf *btf)\n{\n\tkvfree(btf->types);\n\tkvfree(btf->resolved_sizes);\n\tkvfree(btf->resolved_ids);\n\tkvfree(btf->data);\n\tkfree(btf);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "btf"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "btf->data"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "btf->resolved_ids"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "btf->resolved_sizes"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "btf->types"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_free(struct btf *btf)\n{\n\tkvfree(btf->types);\n\tkvfree(btf->resolved_sizes);\n\tkvfree(btf->resolved_ids);\n\tkvfree(btf->data);\n\tkfree(btf);\n}"
  },
  {
    "function_name": "btf_free_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "650-666",
    "snippet": "static void btf_free_id(struct btf *btf)\n{\n\tunsigned long flags;\n\n\t/*\n\t * In map-in-map, calling map_delete_elem() on outer\n\t * map will call bpf_map_put on the inner map.\n\t * It will then eventually call btf_free_id()\n\t * on the inner map.  Some of the map_delete_elem()\n\t * implementation may have irq disabled, so\n\t * we need to use the _irqsave() version instead\n\t * of the _bh() version.\n\t */\n\tspin_lock_irqsave(&btf_idr_lock, flags);\n\tidr_remove(&btf_idr, btf->id);\n\tspin_unlock_irqrestore(&btf_idr_lock, flags);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(btf_idr);",
      "static DEFINE_SPINLOCK(btf_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&btf_idr_lock",
            "flags"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&btf_idr",
            "btf->id"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "324-329",
          "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&btf_idr_lock",
            "flags"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic DEFINE_IDR(btf_idr);\nstatic DEFINE_SPINLOCK(btf_idr_lock);\n\nstatic void btf_free_id(struct btf *btf)\n{\n\tunsigned long flags;\n\n\t/*\n\t * In map-in-map, calling map_delete_elem() on outer\n\t * map will call bpf_map_put on the inner map.\n\t * It will then eventually call btf_free_id()\n\t * on the inner map.  Some of the map_delete_elem()\n\t * implementation may have irq disabled, so\n\t * we need to use the _irqsave() version instead\n\t * of the _bh() version.\n\t */\n\tspin_lock_irqsave(&btf_idr_lock, flags);\n\tidr_remove(&btf_idr, btf->id);\n\tspin_unlock_irqrestore(&btf_idr_lock, flags);\n}"
  },
  {
    "function_name": "btf_alloc_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "632-648",
    "snippet": "static int btf_alloc_id(struct btf *btf)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&btf_idr_lock);\n\tid = idr_alloc_cyclic(&btf_idr, btf, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tbtf->id = id;\n\tspin_unlock_bh(&btf_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(btf_idr);",
      "static DEFINE_SPINLOCK(btf_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!id"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_preload_end",
          "args": [],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&btf_idr_lock"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_alloc_cyclic",
          "args": [
            "&btf_idr",
            "btf",
            "1",
            "INT_MAX",
            "GFP_ATOMIC"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&btf_idr_lock"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_preload",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic DEFINE_IDR(btf_idr);\nstatic DEFINE_SPINLOCK(btf_idr_lock);\n\nstatic int btf_alloc_id(struct btf *btf)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&btf_idr_lock);\n\tid = idr_alloc_cyclic(&btf_idr, btf, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tbtf->id = id;\n\tspin_unlock_bh(&btf_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}"
  },
  {
    "function_name": "btf_add_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "588-630",
    "snippet": "static int btf_add_type(struct btf_verifier_env *env, struct btf_type *t)\n{\n\tstruct btf *btf = env->btf;\n\n\t/* < 2 because +1 for btf_void which is always in btf->types[0].\n\t * btf_void is not accounted in btf->nr_types because btf_void\n\t * does not come from the BTF file.\n\t */\n\tif (btf->types_size - btf->nr_types < 2) {\n\t\t/* Expand 'types' array */\n\n\t\tstruct btf_type **new_types;\n\t\tu32 expand_by, new_size;\n\n\t\tif (btf->types_size == BTF_MAX_TYPE) {\n\t\t\tbtf_verifier_log(env, \"Exceeded max num of types\");\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\texpand_by = max_t(u32, btf->types_size >> 2, 16);\n\t\tnew_size = min_t(u32, BTF_MAX_TYPE,\n\t\t\t\t btf->types_size + expand_by);\n\n\t\tnew_types = kvcalloc(new_size, sizeof(*new_types),\n\t\t\t\t     GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!new_types)\n\t\t\treturn -ENOMEM;\n\n\t\tif (btf->nr_types == 0)\n\t\t\tnew_types[0] = &btf_void;\n\t\telse\n\t\t\tmemcpy(new_types, btf->types,\n\t\t\t       sizeof(*btf->types) * (btf->nr_types + 1));\n\n\t\tkvfree(btf->types);\n\t\tbtf->types = new_types;\n\t\tbtf->types_size = new_size;\n\t}\n\n\tbtf->types[++(btf->nr_types)] = t;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct btf_type btf_void;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "btf->types"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_types",
            "btf->types",
            "sizeof(*btf->types) * (btf->nr_types + 1)"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvcalloc",
          "args": [
            "new_size",
            "sizeof(*new_types)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "BTF_MAX_TYPE",
            "btf->types_size + expand_by"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u32",
            "btf->types_size >> 2",
            "16"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "update_max_tr_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1397-1431",
          "snippet": "void\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->trace_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->trace_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log",
          "args": [
            "env",
            "\"Exceeded max num of types\""
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "btf_verifier_log_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "566-586",
          "snippet": "static void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic struct btf_type btf_void;\n\nstatic int btf_add_type(struct btf_verifier_env *env, struct btf_type *t)\n{\n\tstruct btf *btf = env->btf;\n\n\t/* < 2 because +1 for btf_void which is always in btf->types[0].\n\t * btf_void is not accounted in btf->nr_types because btf_void\n\t * does not come from the BTF file.\n\t */\n\tif (btf->types_size - btf->nr_types < 2) {\n\t\t/* Expand 'types' array */\n\n\t\tstruct btf_type **new_types;\n\t\tu32 expand_by, new_size;\n\n\t\tif (btf->types_size == BTF_MAX_TYPE) {\n\t\t\tbtf_verifier_log(env, \"Exceeded max num of types\");\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\texpand_by = max_t(u32, btf->types_size >> 2, 16);\n\t\tnew_size = min_t(u32, BTF_MAX_TYPE,\n\t\t\t\t btf->types_size + expand_by);\n\n\t\tnew_types = kvcalloc(new_size, sizeof(*new_types),\n\t\t\t\t     GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!new_types)\n\t\t\treturn -ENOMEM;\n\n\t\tif (btf->nr_types == 0)\n\t\t\tnew_types[0] = &btf_void;\n\t\telse\n\t\t\tmemcpy(new_types, btf->types,\n\t\t\t       sizeof(*btf->types) * (btf->nr_types + 1));\n\n\t\tkvfree(btf->types);\n\t\tbtf->types = new_types;\n\t\tbtf->types_size = new_size;\n\t}\n\n\tbtf->types[++(btf->nr_types)] = t;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btf_verifier_log_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "566-586",
    "snippet": "static void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btf_verifier_log",
          "args": [
            "log",
            "\"btf_total_size: %u\\n\"",
            "btf_data_size"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_verifier_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "469-477",
          "snippet": "static void __btf_verifier_log(struct bpf_verifier_log *log,\n\t\t\t\t\t      const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void __btf_verifier_log(struct bpf_verifier_log *log,\n\t\t\t\t\t      const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_verifier_log_needed",
          "args": [
            "log"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}"
  },
  {
    "function_name": "btf_verifier_log_member",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "531-564",
    "snippet": "static void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t   btf_name_by_offset(btf, member->name_off),\n\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btf_verifier_log",
          "args": [
            "log",
            "\"\\n\""
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_verifier_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "469-477",
          "snippet": "static void __btf_verifier_log(struct bpf_verifier_log *log,\n\t\t\t\t\t      const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void __btf_verifier_log(struct bpf_verifier_log *log,\n\t\t\t\t\t      const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_verifier_vlog",
          "args": [
            "log",
            "fmt",
            "args"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_verifier_vlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/verifier.c",
          "lines": "216-233",
          "snippet": "void bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tunsigned int n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tWARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,\n\t\t  \"verifier log line truncated - local buffer too short\\n\");\n\n\tn = min(log->len_total - log->len_used - 1, n);\n\tlog->kbuf[n] = '\\0';\n\n\tif (!copy_to_user(log->ubuf + log->len_used, log->kbuf, n + 1))\n\t\tlog->len_used += n;\n\telse\n\t\tlog->ubuf = NULL;\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tunsigned int n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tWARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,\n\t\t  \"verifier log line truncated - local buffer too short\\n\");\n\n\tn = min(log->len_total - log->len_used - 1, n);\n\tlog->kbuf[n] = '\\0';\n\n\tif (!copy_to_user(log->ubuf + log->len_used, log->kbuf, n + 1))\n\t\tlog->len_used += n;\n\telse\n\t\tlog->ubuf = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_name_by_offset",
          "args": [
            "btf",
            "member->name_off"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_by_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "429-437",
          "snippet": "static const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tif (!offset)\n\t\treturn \"(anon)\";\n\telse if (offset < btf->hdr.str_len)\n\t\treturn &btf->strings[offset];\n\telse\n\t\treturn \"(invalid-name-offset)\";\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tif (!offset)\n\t\treturn \"(anon)\";\n\telse if (offset < btf->hdr.str_len)\n\t\treturn &btf->strings[offset];\n\telse\n\t\treturn \"(invalid-name-offset)\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_verifier_log_type",
          "args": [
            "env",
            "struct_type",
            "NULL"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_verifier_log_needed",
          "args": [
            "log"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t   btf_name_by_offset(btf, member->name_off),\n\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
  },
  {
    "function_name": "__btf_verifier_log_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "493-523",
    "snippet": "static void __btf_verifier_log_type(struct btf_verifier_env *env,\n\t\t\t\t\t\t   const struct btf_type *t,\n\t\t\t\t\t\t   bool log_details,\n\t\t\t\t\t\t   const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tu8 kind = BTF_INFO_KIND(t->info);\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t__btf_verifier_log(log, \"[%u] %s %s%s\",\n\t\t\t   env->log_type_id,\n\t\t\t   btf_kind_str[kind],\n\t\t\t   btf_name_by_offset(btf, t->name_off),\n\t\t\t   log_details ? \" \" : \"\");\n\n\tif (log_details)\n\t\tbtf_type_ops(t)->log_details(env, t);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btf_verifier_log",
          "args": [
            "log",
            "\"\\n\""
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "__btf_verifier_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "469-477",
          "snippet": "static void __btf_verifier_log(struct bpf_verifier_log *log,\n\t\t\t\t\t      const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void __btf_verifier_log(struct bpf_verifier_log *log,\n\t\t\t\t\t      const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_verifier_vlog",
          "args": [
            "log",
            "fmt",
            "args"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_verifier_vlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/verifier.c",
          "lines": "216-233",
          "snippet": "void bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tunsigned int n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tWARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,\n\t\t  \"verifier log line truncated - local buffer too short\\n\");\n\n\tn = min(log->len_total - log->len_used - 1, n);\n\tlog->kbuf[n] = '\\0';\n\n\tif (!copy_to_user(log->ubuf + log->len_used, log->kbuf, n + 1))\n\t\tlog->len_used += n;\n\telse\n\t\tlog->ubuf = NULL;\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tunsigned int n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tWARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,\n\t\t  \"verifier log line truncated - local buffer too short\\n\");\n\n\tn = min(log->len_total - log->len_used - 1, n);\n\tlog->kbuf[n] = '\\0';\n\n\tif (!copy_to_user(log->ubuf + log->len_used, log->kbuf, n + 1))\n\t\tlog->len_used += n;\n\telse\n\t\tlog->ubuf = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "env",
            "t"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_ops",
          "args": [
            "t"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "418-421",
          "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
            "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_name_by_offset",
          "args": [
            "btf",
            "t->name_off"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "btf_name_by_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "429-437",
          "snippet": "static const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tif (!offset)\n\t\treturn \"(anon)\";\n\telse if (offset < btf->hdr.str_len)\n\t\treturn &btf->strings[offset];\n\telse\n\t\treturn \"(invalid-name-offset)\";\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tif (!offset)\n\t\treturn \"(anon)\";\n\telse if (offset < btf->hdr.str_len)\n\t\treturn &btf->strings[offset];\n\telse\n\t\treturn \"(invalid-name-offset)\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_verifier_log_needed",
          "args": [
            "log"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n};\n\nstatic void __btf_verifier_log_type(struct btf_verifier_env *env,\n\t\t\t\t\t\t   const struct btf_type *t,\n\t\t\t\t\t\t   bool log_details,\n\t\t\t\t\t\t   const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tu8 kind = BTF_INFO_KIND(t->info);\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t__btf_verifier_log(log, \"[%u] %s %s%s\",\n\t\t\t   env->log_type_id,\n\t\t\t   btf_kind_str[kind],\n\t\t\t   btf_name_by_offset(btf, t->name_off),\n\t\t\t   log_details ? \" \" : \"\");\n\n\tif (log_details)\n\t\tbtf_type_ops(t)->log_details(env, t);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}"
  },
  {
    "function_name": "btf_verifier_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "479-491",
    "snippet": "static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_verifier_vlog",
          "args": [
            "log",
            "fmt",
            "args"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_verifier_vlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/verifier.c",
          "lines": "216-233",
          "snippet": "void bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tunsigned int n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tWARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,\n\t\t  \"verifier log line truncated - local buffer too short\\n\");\n\n\tn = min(log->len_total - log->len_used - 1, n);\n\tlog->kbuf[n] = '\\0';\n\n\tif (!copy_to_user(log->ubuf + log->len_used, log->kbuf, n + 1))\n\t\tlog->len_used += n;\n\telse\n\t\tlog->ubuf = NULL;\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tunsigned int n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tWARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,\n\t\t  \"verifier log line truncated - local buffer too short\\n\");\n\n\tn = min(log->len_total - log->len_used - 1, n);\n\tlog->kbuf[n] = '\\0';\n\n\tif (!copy_to_user(log->ubuf + log->len_used, log->kbuf, n + 1))\n\t\tlog->len_used += n;\n\telse\n\t\tlog->ubuf = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_verifier_log_needed",
          "args": [
            "log"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
  },
  {
    "function_name": "__btf_verifier_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "469-477",
    "snippet": "static void __btf_verifier_log(struct bpf_verifier_log *log,\n\t\t\t\t\t      const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_verifier_vlog",
          "args": [
            "log",
            "fmt",
            "args"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_verifier_vlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/verifier.c",
          "lines": "216-233",
          "snippet": "void bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tunsigned int n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tWARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,\n\t\t  \"verifier log line truncated - local buffer too short\\n\");\n\n\tn = min(log->len_total - log->len_used - 1, n);\n\tlog->kbuf[n] = '\\0';\n\n\tif (!copy_to_user(log->ubuf + log->len_used, log->kbuf, n + 1))\n\t\tlog->len_used += n;\n\telse\n\t\tlog->ubuf = NULL;\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid bpf_verifier_vlog(struct bpf_verifier_log *log, const char *fmt,\n\t\t       va_list args)\n{\n\tunsigned int n;\n\n\tn = vscnprintf(log->kbuf, BPF_VERIFIER_TMP_LOG_SIZE, fmt, args);\n\n\tWARN_ONCE(n >= BPF_VERIFIER_TMP_LOG_SIZE - 1,\n\t\t  \"verifier log line truncated - local buffer too short\\n\");\n\n\tn = min(log->len_total - log->len_used - 1, n);\n\tlog->kbuf[n] = '\\0';\n\n\tif (!copy_to_user(log->ubuf + log->len_used, log->kbuf, n + 1))\n\t\tlog->len_used += n;\n\telse\n\t\tlog->ubuf = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic void __btf_verifier_log(struct bpf_verifier_log *log,\n\t\t\t\t\t      const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}"
  },
  {
    "function_name": "btf_type_int_is_regular",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "451-467",
    "snippet": "static bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INT_OFFSET",
          "args": [
            "int_data"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_PER_BYTE_MASKED",
          "args": [
            "nr_bits"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_ROUNDUP_BYTES",
          "args": [
            "nr_bits"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_BITS",
          "args": [
            "int_data"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_int",
          "args": [
            "t"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_int_is_regular",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "451-467",
          "snippet": "static bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "btf_type_by_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "439-445",
    "snippet": "static const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\tif (type_id > btf->nr_types)\n\t\treturn NULL;\n\n\treturn btf->types[type_id];\n}"
  },
  {
    "function_name": "btf_name_by_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "429-437",
    "snippet": "static const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tif (!offset)\n\t\treturn \"(anon)\";\n\telse if (offset < btf->hdr.str_len)\n\t\treturn &btf->strings[offset];\n\telse\n\t\treturn \"(invalid-name-offset)\";\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tif (!offset)\n\t\treturn \"(anon)\";\n\telse if (offset < btf->hdr.str_len)\n\t\treturn &btf->strings[offset];\n\telse\n\t\treturn \"(invalid-name-offset)\";\n}"
  },
  {
    "function_name": "btf_name_offset_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "423-427",
    "snippet": "static bool btf_name_offset_valid(const struct btf *btf, u32 offset)\n{\n\treturn BTF_STR_OFFSET_VALID(offset) &&\n\t\toffset < btf->hdr.str_len;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_STR_OFFSET_VALID",
          "args": [
            "offset"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_name_offset_valid(const struct btf *btf, u32 offset)\n{\n\treturn BTF_STR_OFFSET_VALID(offset) &&\n\t\toffset < btf->hdr.str_len;\n}"
  },
  {
    "function_name": "btf_type_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "418-421",
    "snippet": "static const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];",
      "static const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n};\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}"
  },
  {
    "function_name": "btf_type_enum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "413-416",
    "snippet": "static const struct btf_enum *btf_type_enum(const struct btf_type *t)\n{\n\treturn (const struct btf_enum *)(t + 1);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_enum *btf_type_enum(const struct btf_type *t)\n{\n\treturn (const struct btf_enum *)(t + 1);\n}"
  },
  {
    "function_name": "btf_type_member",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "408-411",
    "snippet": "static const struct btf_member *btf_type_member(const struct btf_type *t)\n{\n\treturn (const struct btf_member *)(t + 1);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_member *btf_type_member(const struct btf_type *t)\n{\n\treturn (const struct btf_member *)(t + 1);\n}"
  },
  {
    "function_name": "btf_type_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "403-406",
    "snippet": "static const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}"
  },
  {
    "function_name": "btf_type_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "398-401",
    "snippet": "static u32 btf_type_int(const struct btf_type *t)\n{\n\treturn *(u32 *)(t + 1);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic u32 btf_type_int(const struct btf_type *t)\n{\n\treturn *(u32 *)(t + 1);\n}"
  },
  {
    "function_name": "btf_type_vlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "393-396",
    "snippet": "static u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_VLEN",
          "args": [
            "t->info"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic u16 btf_type_vlen(const struct btf_type *t)\n{\n\treturn BTF_INFO_VLEN(t->info);\n}"
  },
  {
    "function_name": "btf_int_encoding_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "379-391",
    "snippet": "static const char *btf_int_encoding_str(u8 encoding)\n{\n\tif (encoding == 0)\n\t\treturn \"(none)\";\n\telse if (encoding == BTF_INT_SIGNED)\n\t\treturn \"SIGNED\";\n\telse if (encoding == BTF_INT_CHAR)\n\t\treturn \"CHAR\";\n\telse if (encoding == BTF_INT_BOOL)\n\t\treturn \"BOOL\";\n\telse\n\t\treturn \"UNKN\";\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic const char *btf_int_encoding_str(u8 encoding)\n{\n\tif (encoding == 0)\n\t\treturn \"(none)\";\n\telse if (encoding == BTF_INT_SIGNED)\n\t\treturn \"SIGNED\";\n\telse if (encoding == BTF_INT_CHAR)\n\t\treturn \"CHAR\";\n\telse if (encoding == BTF_INT_BOOL)\n\t\treturn \"BOOL\";\n\telse\n\t\treturn \"UNKN\";\n}"
  },
  {
    "function_name": "btf_type_has_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "366-377",
    "snippet": "static bool btf_type_has_size(const struct btf_type *t)\n{\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\tcase BTF_KIND_ENUM:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_has_size(const struct btf_type *t)\n{\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\tcase BTF_KIND_ENUM:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "btf_type_needs_resolve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "357-363",
    "snippet": "static bool btf_type_needs_resolve(const struct btf_type *t)\n{\n\treturn btf_type_is_modifier(t) ||\n\t\tbtf_type_is_ptr(t) ||\n\t\tbtf_type_is_struct(t) ||\n\t\tbtf_type_is_array(t);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_is_array",
          "args": [
            "t"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "330-333",
          "snippet": "static bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_struct",
          "args": [
            "t"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "323-328",
          "snippet": "static bool btf_type_is_struct(const struct btf_type *t)\n{\n\tu8 kind = BTF_INFO_KIND(t->info);\n\n\treturn kind == BTF_KIND_STRUCT || kind == BTF_KIND_UNION;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_struct(const struct btf_type *t)\n{\n\tu8 kind = BTF_INFO_KIND(t->info);\n\n\treturn kind == BTF_KIND_STRUCT || kind == BTF_KIND_UNION;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_ptr",
          "args": [
            "t"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "335-338",
          "snippet": "static bool btf_type_is_ptr(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_PTR;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_ptr(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_PTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_is_modifier",
          "args": [
            "t"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_modifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "284-305",
          "snippet": "static bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_needs_resolve(const struct btf_type *t)\n{\n\treturn btf_type_is_modifier(t) ||\n\t\tbtf_type_is_ptr(t) ||\n\t\tbtf_type_is_struct(t) ||\n\t\tbtf_type_is_array(t);\n}"
  },
  {
    "function_name": "btf_type_is_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "340-343",
    "snippet": "static bool btf_type_is_int(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_INT;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_int(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_INT;\n}"
  },
  {
    "function_name": "btf_type_is_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "335-338",
    "snippet": "static bool btf_type_is_ptr(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_PTR;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_ptr(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_PTR;\n}"
  },
  {
    "function_name": "btf_type_is_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "330-333",
    "snippet": "static bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}"
  },
  {
    "function_name": "btf_type_is_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "323-328",
    "snippet": "static bool btf_type_is_struct(const struct btf_type *t)\n{\n\tu8 kind = BTF_INFO_KIND(t->info);\n\n\treturn kind == BTF_KIND_STRUCT || kind == BTF_KIND_UNION;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_struct(const struct btf_type *t)\n{\n\tu8 kind = BTF_INFO_KIND(t->info);\n\n\treturn kind == BTF_KIND_STRUCT || kind == BTF_KIND_UNION;\n}"
  },
  {
    "function_name": "btf_type_is_void_or_null",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "315-318",
    "snippet": "static bool btf_type_is_void_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_is_void(t);\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_type_is_void",
          "args": [
            "t"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_void_or_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "315-318",
          "snippet": "static bool btf_type_is_void_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_is_void(t);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_void_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_is_void(t);\n}"
  },
  {
    "function_name": "btf_type_is_void",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "307-313",
    "snippet": "static bool btf_type_is_void(const struct btf_type *t)\n{\n\t/* void => no type and size info.\n\t * Hence, FWD is also treated as void.\n\t */\n\treturn t == &btf_void || BTF_INFO_KIND(t->info) == BTF_KIND_FWD;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct btf_type btf_void;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic struct btf_type btf_void;\n\nstatic bool btf_type_is_void(const struct btf_type *t)\n{\n\t/* void => no type and size info.\n\t * Hence, FWD is also treated as void.\n\t */\n\treturn t == &btf_void || BTF_INFO_KIND(t->info) == BTF_KIND_FWD;\n}"
  },
  {
    "function_name": "btf_type_is_modifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
    "lines": "284-305",
    "snippet": "static bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/btf.h>",
      "#include <linux/bpf_verifier.h>",
      "#include <linux/sort.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/file.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/compiler.h>",
      "#include <linux/seq_file.h>",
      "#include <uapi/linux/types.h>",
      "#include <uapi/linux/btf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "t->info"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  }
]