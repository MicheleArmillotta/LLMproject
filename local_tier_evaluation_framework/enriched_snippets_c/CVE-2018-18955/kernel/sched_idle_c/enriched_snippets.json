[
  {
    "function_name": "update_curr_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "435-437",
    "snippet": "static void update_curr_idle(struct rq *rq)\n{\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void update_curr_idle(struct rq *rq)\n{\n}"
  },
  {
    "function_name": "get_rr_interval_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "430-433",
    "snippet": "static unsigned int get_rr_interval_idle(struct rq *rq, struct task_struct *task)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic unsigned int get_rr_interval_idle(struct rq *rq, struct task_struct *task)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "prio_changed_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "424-428",
    "snippet": "static void\nprio_changed_idle(struct rq *rq, struct task_struct *p, int oldprio)\n{\n\tBUG();\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void\nprio_changed_idle(struct rq *rq, struct task_struct *p, int oldprio)\n{\n\tBUG();\n}"
  },
  {
    "function_name": "switched_to_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "419-422",
    "snippet": "static void switched_to_idle(struct rq *rq, struct task_struct *p)\n{\n\tBUG();\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void switched_to_idle(struct rq *rq, struct task_struct *p)\n{\n\tBUG();\n}"
  },
  {
    "function_name": "set_curr_task_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "415-417",
    "snippet": "static void set_curr_task_idle(struct rq *rq)\n{\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void set_curr_task_idle(struct rq *rq)\n{\n}"
  },
  {
    "function_name": "task_tick_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "411-413",
    "snippet": "static void task_tick_idle(struct rq *rq, struct task_struct *curr, int queued)\n{\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void task_tick_idle(struct rq *rq, struct task_struct *curr, int queued)\n{\n}"
  },
  {
    "function_name": "put_prev_task_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "399-401",
    "snippet": "static void put_prev_task_idle(struct rq *rq, struct task_struct *prev)\n{\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void put_prev_task_idle(struct rq *rq, struct task_struct *prev)\n{\n}"
  },
  {
    "function_name": "dequeue_task_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "390-397",
    "snippet": "static void\ndequeue_task_idle(struct rq *rq, struct task_struct *p, int flags)\n{\n\traw_spin_unlock_irq(&rq->lock);\n\tprintk(KERN_ERR \"bad: scheduling from the idle thread!\\n\");\n\tdump_stack();\n\traw_spin_lock_irq(&rq->lock);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&rq->lock"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"bad: scheduling from the idle thread!\\n\""
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "540-547",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&rq->lock"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void\ndequeue_task_idle(struct rq *rq, struct task_struct *p, int flags)\n{\n\traw_spin_unlock_irq(&rq->lock);\n\tprintk(KERN_ERR \"bad: scheduling from the idle thread!\\n\");\n\tdump_stack();\n\traw_spin_lock_irq(&rq->lock);\n}"
  },
  {
    "function_name": "pick_next_task_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "376-384",
    "snippet": "static struct task_struct *\npick_next_task_idle(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tput_prev_task(rq, prev);\n\tupdate_idle_core(rq);\n\tschedstat_inc(rq->sched_goidle);\n\n\treturn rq->idle;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedstat_inc",
          "args": [
            "rq->sched_goidle"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_idle_core",
          "args": [
            "rq"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "update_idle_core",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "951-951",
          "snippet": "static inline void update_idle_core(struct rq *rq) { }",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void update_idle_core(struct rq *rq) { }"
        }
      },
      {
        "call_info": {
          "callee": "put_prev_task",
          "args": [
            "rq",
            "prev"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "put_prev_task_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
          "lines": "399-401",
          "snippet": "static void put_prev_task_idle(struct rq *rq, struct task_struct *prev)\n{\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void put_prev_task_idle(struct rq *rq, struct task_struct *prev)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic struct task_struct *\npick_next_task_idle(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tput_prev_task(rq, prev);\n\tupdate_idle_core(rq);\n\tschedstat_inc(rq->sched_goidle);\n\n\treturn rq->idle;\n}"
  },
  {
    "function_name": "check_preempt_curr_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "371-374",
    "snippet": "static void check_preempt_curr_idle(struct rq *rq, struct task_struct *p, int flags)\n{\n\tresched_curr(rq);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "rq"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "452-474",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void check_preempt_curr_idle(struct rq *rq, struct task_struct *p, int flags)\n{\n\tresched_curr(rq);\n}"
  },
  {
    "function_name": "select_task_rq_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "361-365",
    "snippet": "static int\nselect_task_rq_idle(struct task_struct *p, int cpu, int sd_flag, int flags)\n{\n\treturn task_cpu(p); /* IDLE tasks as never migrated */\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic int\nselect_task_rq_idle(struct task_struct *p, int cpu, int sd_flag, int flags)\n{\n\treturn task_cpu(p); /* IDLE tasks as never migrated */\n}"
  },
  {
    "function_name": "cpu_startup_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "348-354",
    "snippet": "void cpu_startup_entry(enum cpuhp_state state)\n{\n\tarch_cpu_idle_prepare();\n\tcpuhp_online_idle(state);\n\twhile (1)\n\t\tdo_idle();\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_idle",
          "args": [],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "do_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
          "lines": "224-290",
          "snippet": "static void do_idle(void)\n{\n\tint cpu = smp_processor_id();\n\t/*\n\t * If the arch has a polling bit, we maintain an invariant:\n\t *\n\t * Our polling bit is clear if we're not scheduled (i.e. if rq->curr !=\n\t * rq->idle). This means that, if rq->idle has the polling bit set,\n\t * then setting need_resched is guaranteed to cause the CPU to\n\t * reschedule.\n\t */\n\n\t__current_set_polling();\n\ttick_nohz_idle_enter();\n\n\twhile (!need_resched()) {\n\t\tcheck_pgt_cache();\n\t\trmb();\n\n\t\tif (cpu_is_offline(cpu)) {\n\t\t\ttick_nohz_idle_stop_tick_protected();\n\t\t\tcpuhp_report_idle_dead();\n\t\t\tarch_cpu_idle_dead();\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\tarch_cpu_idle_enter();\n\n\t\t/*\n\t\t * In poll mode we reenable interrupts and spin. Also if we\n\t\t * detected in the wakeup from idle path that the tick\n\t\t * broadcast device expired for us, we don't want to go deep\n\t\t * idle as we know that the IPI is going to arrive right away.\n\t\t */\n\t\tif (cpu_idle_force_poll || tick_check_broadcast_expired()) {\n\t\t\ttick_nohz_idle_restart_tick();\n\t\t\tcpu_idle_poll();\n\t\t} else {\n\t\t\tcpuidle_idle_call();\n\t\t}\n\t\tarch_cpu_idle_exit();\n\t}\n\n\t/*\n\t * Since we fell out of the loop above, we know TIF_NEED_RESCHED must\n\t * be set, propagate it into PREEMPT_NEED_RESCHED.\n\t *\n\t * This is required because for polling idle loops we will not have had\n\t * an IPI to fold the state for us.\n\t */\n\tpreempt_set_need_resched();\n\ttick_nohz_idle_exit();\n\t__current_clr_polling();\n\n\t/*\n\t * We promise to call sched_ttwu_pending() and reschedule if\n\t * need_resched() is set while polling is set. That means that clearing\n\t * polling needs to be visible before doing these things.\n\t */\n\tsmp_mb__after_atomic();\n\n\tsched_ttwu_pending();\n\tschedule_idle();\n\n\tif (unlikely(klp_patch_pending(current)))\n\t\tklp_update_patch_state(current);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void do_idle(void)\n{\n\tint cpu = smp_processor_id();\n\t/*\n\t * If the arch has a polling bit, we maintain an invariant:\n\t *\n\t * Our polling bit is clear if we're not scheduled (i.e. if rq->curr !=\n\t * rq->idle). This means that, if rq->idle has the polling bit set,\n\t * then setting need_resched is guaranteed to cause the CPU to\n\t * reschedule.\n\t */\n\n\t__current_set_polling();\n\ttick_nohz_idle_enter();\n\n\twhile (!need_resched()) {\n\t\tcheck_pgt_cache();\n\t\trmb();\n\n\t\tif (cpu_is_offline(cpu)) {\n\t\t\ttick_nohz_idle_stop_tick_protected();\n\t\t\tcpuhp_report_idle_dead();\n\t\t\tarch_cpu_idle_dead();\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\tarch_cpu_idle_enter();\n\n\t\t/*\n\t\t * In poll mode we reenable interrupts and spin. Also if we\n\t\t * detected in the wakeup from idle path that the tick\n\t\t * broadcast device expired for us, we don't want to go deep\n\t\t * idle as we know that the IPI is going to arrive right away.\n\t\t */\n\t\tif (cpu_idle_force_poll || tick_check_broadcast_expired()) {\n\t\t\ttick_nohz_idle_restart_tick();\n\t\t\tcpu_idle_poll();\n\t\t} else {\n\t\t\tcpuidle_idle_call();\n\t\t}\n\t\tarch_cpu_idle_exit();\n\t}\n\n\t/*\n\t * Since we fell out of the loop above, we know TIF_NEED_RESCHED must\n\t * be set, propagate it into PREEMPT_NEED_RESCHED.\n\t *\n\t * This is required because for polling idle loops we will not have had\n\t * an IPI to fold the state for us.\n\t */\n\tpreempt_set_need_resched();\n\ttick_nohz_idle_exit();\n\t__current_clr_polling();\n\n\t/*\n\t * We promise to call sched_ttwu_pending() and reschedule if\n\t * need_resched() is set while polling is set. That means that clearing\n\t * polling needs to be visible before doing these things.\n\t */\n\tsmp_mb__after_atomic();\n\n\tsched_ttwu_pending();\n\tschedule_idle();\n\n\tif (unlikely(klp_patch_pending(current)))\n\t\tklp_update_patch_state(current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_online_idle",
          "args": [
            "state"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_online_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "1074-1084",
          "snippet": "void cpuhp_online_idle(enum cpuhp_state state)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\t/* Happens for the boot cpu */\n\tif (state != CPUHP_AP_ONLINE_IDLE)\n\t\treturn;\n\n\tst->state = CPUHP_AP_ONLINE_IDLE;\n\tcomplete_ap_thread(st, true);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nvoid cpuhp_online_idle(enum cpuhp_state state)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\t/* Happens for the boot cpu */\n\tif (state != CPUHP_AP_ONLINE_IDLE)\n\t\treturn;\n\n\tst->state = CPUHP_AP_ONLINE_IDLE;\n\tcomplete_ap_thread(st, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_cpu_idle_prepare",
          "args": [],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "arch_cpu_idle_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
          "lines": "72-72",
          "snippet": "void __weak arch_cpu_idle_prepare(void) { }",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle_prepare(void) { }"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid cpu_startup_entry(enum cpuhp_state state)\n{\n\tarch_cpu_idle_prepare();\n\tcpuhp_online_idle(state);\n\twhile (1)\n\t\tdo_idle();\n}"
  },
  {
    "function_name": "play_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "313-345",
    "snippet": "void play_idle(unsigned long duration_ms)\n{\n\tstruct idle_timer it;\n\n\t/*\n\t * Only FIFO tasks can disable the tick since they don't need the forced\n\t * preemption.\n\t */\n\tWARN_ON_ONCE(current->policy != SCHED_FIFO);\n\tWARN_ON_ONCE(current->nr_cpus_allowed != 1);\n\tWARN_ON_ONCE(!(current->flags & PF_KTHREAD));\n\tWARN_ON_ONCE(!(current->flags & PF_NO_SETAFFINITY));\n\tWARN_ON_ONCE(!duration_ms);\n\n\trcu_sleep_check();\n\tpreempt_disable();\n\tcurrent->flags |= PF_IDLE;\n\tcpuidle_use_deepest_state(true);\n\n\tit.done = 0;\n\thrtimer_init_on_stack(&it.timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tit.timer.function = idle_inject_timer_fn;\n\thrtimer_start(&it.timer, ms_to_ktime(duration_ms), HRTIMER_MODE_REL_PINNED);\n\n\twhile (!READ_ONCE(it.done))\n\t\tdo_idle();\n\n\tcpuidle_use_deepest_state(false);\n\tcurrent->flags &= ~PF_IDLE;\n\n\tpreempt_fold_need_resched();\n\tpreempt_enable();\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_fold_need_resched",
          "args": [],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuidle_use_deepest_state",
          "args": [
            "false"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_idle",
          "args": [],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "do_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
          "lines": "224-290",
          "snippet": "static void do_idle(void)\n{\n\tint cpu = smp_processor_id();\n\t/*\n\t * If the arch has a polling bit, we maintain an invariant:\n\t *\n\t * Our polling bit is clear if we're not scheduled (i.e. if rq->curr !=\n\t * rq->idle). This means that, if rq->idle has the polling bit set,\n\t * then setting need_resched is guaranteed to cause the CPU to\n\t * reschedule.\n\t */\n\n\t__current_set_polling();\n\ttick_nohz_idle_enter();\n\n\twhile (!need_resched()) {\n\t\tcheck_pgt_cache();\n\t\trmb();\n\n\t\tif (cpu_is_offline(cpu)) {\n\t\t\ttick_nohz_idle_stop_tick_protected();\n\t\t\tcpuhp_report_idle_dead();\n\t\t\tarch_cpu_idle_dead();\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\tarch_cpu_idle_enter();\n\n\t\t/*\n\t\t * In poll mode we reenable interrupts and spin. Also if we\n\t\t * detected in the wakeup from idle path that the tick\n\t\t * broadcast device expired for us, we don't want to go deep\n\t\t * idle as we know that the IPI is going to arrive right away.\n\t\t */\n\t\tif (cpu_idle_force_poll || tick_check_broadcast_expired()) {\n\t\t\ttick_nohz_idle_restart_tick();\n\t\t\tcpu_idle_poll();\n\t\t} else {\n\t\t\tcpuidle_idle_call();\n\t\t}\n\t\tarch_cpu_idle_exit();\n\t}\n\n\t/*\n\t * Since we fell out of the loop above, we know TIF_NEED_RESCHED must\n\t * be set, propagate it into PREEMPT_NEED_RESCHED.\n\t *\n\t * This is required because for polling idle loops we will not have had\n\t * an IPI to fold the state for us.\n\t */\n\tpreempt_set_need_resched();\n\ttick_nohz_idle_exit();\n\t__current_clr_polling();\n\n\t/*\n\t * We promise to call sched_ttwu_pending() and reschedule if\n\t * need_resched() is set while polling is set. That means that clearing\n\t * polling needs to be visible before doing these things.\n\t */\n\tsmp_mb__after_atomic();\n\n\tsched_ttwu_pending();\n\tschedule_idle();\n\n\tif (unlikely(klp_patch_pending(current)))\n\t\tklp_update_patch_state(current);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void do_idle(void)\n{\n\tint cpu = smp_processor_id();\n\t/*\n\t * If the arch has a polling bit, we maintain an invariant:\n\t *\n\t * Our polling bit is clear if we're not scheduled (i.e. if rq->curr !=\n\t * rq->idle). This means that, if rq->idle has the polling bit set,\n\t * then setting need_resched is guaranteed to cause the CPU to\n\t * reschedule.\n\t */\n\n\t__current_set_polling();\n\ttick_nohz_idle_enter();\n\n\twhile (!need_resched()) {\n\t\tcheck_pgt_cache();\n\t\trmb();\n\n\t\tif (cpu_is_offline(cpu)) {\n\t\t\ttick_nohz_idle_stop_tick_protected();\n\t\t\tcpuhp_report_idle_dead();\n\t\t\tarch_cpu_idle_dead();\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\tarch_cpu_idle_enter();\n\n\t\t/*\n\t\t * In poll mode we reenable interrupts and spin. Also if we\n\t\t * detected in the wakeup from idle path that the tick\n\t\t * broadcast device expired for us, we don't want to go deep\n\t\t * idle as we know that the IPI is going to arrive right away.\n\t\t */\n\t\tif (cpu_idle_force_poll || tick_check_broadcast_expired()) {\n\t\t\ttick_nohz_idle_restart_tick();\n\t\t\tcpu_idle_poll();\n\t\t} else {\n\t\t\tcpuidle_idle_call();\n\t\t}\n\t\tarch_cpu_idle_exit();\n\t}\n\n\t/*\n\t * Since we fell out of the loop above, we know TIF_NEED_RESCHED must\n\t * be set, propagate it into PREEMPT_NEED_RESCHED.\n\t *\n\t * This is required because for polling idle loops we will not have had\n\t * an IPI to fold the state for us.\n\t */\n\tpreempt_set_need_resched();\n\ttick_nohz_idle_exit();\n\t__current_clr_polling();\n\n\t/*\n\t * We promise to call sched_ttwu_pending() and reschedule if\n\t * need_resched() is set while polling is set. That means that clearing\n\t * polling needs to be visible before doing these things.\n\t */\n\tsmp_mb__after_atomic();\n\n\tsched_ttwu_pending();\n\tschedule_idle();\n\n\tif (unlikely(klp_patch_pending(current)))\n\t\tklp_update_patch_state(current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "it.done"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&it.timer",
            "ms_to_ktime(duration_ms)",
            "HRTIMER_MODE_REL_PINNED"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ms_to_ktime",
          "args": [
            "duration_ms"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init_on_stack",
          "args": [
            "&it.timer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_REL"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "432-437",
          "snippet": "void hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidle_use_deepest_state",
          "args": [
            "true"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_sleep_check",
          "args": [],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!duration_ms"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(current->flags & PF_NO_SETAFFINITY)"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(current->flags & PF_KTHREAD)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "current->nr_cpus_allowed != 1"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "current->policy != SCHED_FIFO"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid play_idle(unsigned long duration_ms)\n{\n\tstruct idle_timer it;\n\n\t/*\n\t * Only FIFO tasks can disable the tick since they don't need the forced\n\t * preemption.\n\t */\n\tWARN_ON_ONCE(current->policy != SCHED_FIFO);\n\tWARN_ON_ONCE(current->nr_cpus_allowed != 1);\n\tWARN_ON_ONCE(!(current->flags & PF_KTHREAD));\n\tWARN_ON_ONCE(!(current->flags & PF_NO_SETAFFINITY));\n\tWARN_ON_ONCE(!duration_ms);\n\n\trcu_sleep_check();\n\tpreempt_disable();\n\tcurrent->flags |= PF_IDLE;\n\tcpuidle_use_deepest_state(true);\n\n\tit.done = 0;\n\thrtimer_init_on_stack(&it.timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tit.timer.function = idle_inject_timer_fn;\n\thrtimer_start(&it.timer, ms_to_ktime(duration_ms), HRTIMER_MODE_REL_PINNED);\n\n\twhile (!READ_ONCE(it.done))\n\t\tdo_idle();\n\n\tcpuidle_use_deepest_state(false);\n\tcurrent->flags &= ~PF_IDLE;\n\n\tpreempt_fold_need_resched();\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "idle_inject_timer_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "303-311",
    "snippet": "static enum hrtimer_restart idle_inject_timer_fn(struct hrtimer *timer)\n{\n\tstruct idle_timer *it = container_of(timer, struct idle_timer, timer);\n\n\tWRITE_ONCE(it->done, 1);\n\tset_tsk_need_resched(current);\n\n\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_tsk_need_resched",
          "args": [
            "current"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "it->done",
            "1"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structidle_timer",
            "timer"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic enum hrtimer_restart idle_inject_timer_fn(struct hrtimer *timer)\n{\n\tstruct idle_timer *it = container_of(timer, struct idle_timer, timer);\n\n\tWRITE_ONCE(it->done, 1);\n\tset_tsk_need_resched(current);\n\n\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "cpu_in_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "292-296",
    "snippet": "bool cpu_in_idle(unsigned long pc)\n{\n\treturn pc >= (unsigned long)__cpuidle_text_start &&\n\t\tpc < (unsigned long)__cpuidle_text_end;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern char __cpuidle_text_start[], __cpuidle_text_end[];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nextern char __cpuidle_text_start[], __cpuidle_text_end[];\n\nbool cpu_in_idle(unsigned long pc)\n{\n\treturn pc >= (unsigned long)__cpuidle_text_start &&\n\t\tpc < (unsigned long)__cpuidle_text_end;\n}"
  },
  {
    "function_name": "do_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "224-290",
    "snippet": "static void do_idle(void)\n{\n\tint cpu = smp_processor_id();\n\t/*\n\t * If the arch has a polling bit, we maintain an invariant:\n\t *\n\t * Our polling bit is clear if we're not scheduled (i.e. if rq->curr !=\n\t * rq->idle). This means that, if rq->idle has the polling bit set,\n\t * then setting need_resched is guaranteed to cause the CPU to\n\t * reschedule.\n\t */\n\n\t__current_set_polling();\n\ttick_nohz_idle_enter();\n\n\twhile (!need_resched()) {\n\t\tcheck_pgt_cache();\n\t\trmb();\n\n\t\tif (cpu_is_offline(cpu)) {\n\t\t\ttick_nohz_idle_stop_tick_protected();\n\t\t\tcpuhp_report_idle_dead();\n\t\t\tarch_cpu_idle_dead();\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\tarch_cpu_idle_enter();\n\n\t\t/*\n\t\t * In poll mode we reenable interrupts and spin. Also if we\n\t\t * detected in the wakeup from idle path that the tick\n\t\t * broadcast device expired for us, we don't want to go deep\n\t\t * idle as we know that the IPI is going to arrive right away.\n\t\t */\n\t\tif (cpu_idle_force_poll || tick_check_broadcast_expired()) {\n\t\t\ttick_nohz_idle_restart_tick();\n\t\t\tcpu_idle_poll();\n\t\t} else {\n\t\t\tcpuidle_idle_call();\n\t\t}\n\t\tarch_cpu_idle_exit();\n\t}\n\n\t/*\n\t * Since we fell out of the loop above, we know TIF_NEED_RESCHED must\n\t * be set, propagate it into PREEMPT_NEED_RESCHED.\n\t *\n\t * This is required because for polling idle loops we will not have had\n\t * an IPI to fold the state for us.\n\t */\n\tpreempt_set_need_resched();\n\ttick_nohz_idle_exit();\n\t__current_clr_polling();\n\n\t/*\n\t * We promise to call sched_ttwu_pending() and reschedule if\n\t * need_resched() is set while polling is set. That means that clearing\n\t * polling needs to be visible before doing these things.\n\t */\n\tsmp_mb__after_atomic();\n\n\tsched_ttwu_pending();\n\tschedule_idle();\n\n\tif (unlikely(klp_patch_pending(current)))\n\t\tklp_update_patch_state(current);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_update_patch_state",
          "args": [
            "current"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "klp_update_patch_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "175-199",
          "snippet": "void klp_update_patch_state(struct task_struct *task)\n{\n\t/*\n\t * A variant of synchronize_sched() is used to allow patching functions\n\t * where RCU is not watching, see klp_synchronize_transition().\n\t */\n\tpreempt_disable_notrace();\n\n\t/*\n\t * This test_and_clear_tsk_thread_flag() call also serves as a read\n\t * barrier (smp_rmb) for two cases:\n\t *\n\t * 1) Enforce the order of the TIF_PATCH_PENDING read and the\n\t *    klp_target_state read.  The corresponding write barrier is in\n\t *    klp_init_transition().\n\t *\n\t * 2) Enforce the order of the TIF_PATCH_PENDING read and a future read\n\t *    of func->transition, if klp_ftrace_handler() is called later on\n\t *    the same CPU.  See __klp_disable_patch().\n\t */\n\tif (test_and_clear_tsk_thread_flag(task, TIF_PATCH_PENDING))\n\t\ttask->patch_state = READ_ONCE(klp_target_state);\n\n\tpreempt_enable_notrace();\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_update_patch_state(struct task_struct *task)\n{\n\t/*\n\t * A variant of synchronize_sched() is used to allow patching functions\n\t * where RCU is not watching, see klp_synchronize_transition().\n\t */\n\tpreempt_disable_notrace();\n\n\t/*\n\t * This test_and_clear_tsk_thread_flag() call also serves as a read\n\t * barrier (smp_rmb) for two cases:\n\t *\n\t * 1) Enforce the order of the TIF_PATCH_PENDING read and the\n\t *    klp_target_state read.  The corresponding write barrier is in\n\t *    klp_init_transition().\n\t *\n\t * 2) Enforce the order of the TIF_PATCH_PENDING read and a future read\n\t *    of func->transition, if klp_ftrace_handler() is called later on\n\t *    the same CPU.  See __klp_disable_patch().\n\t */\n\tif (test_and_clear_tsk_thread_flag(task, TIF_PATCH_PENDING))\n\t\ttask->patch_state = READ_ONCE(klp_target_state);\n\n\tpreempt_enable_notrace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "klp_patch_pending(current)"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_patch_pending",
          "args": [
            "current"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_idle",
          "args": [],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3532-3545",
          "snippet": "void __sched schedule_idle(void)\n{\n\t/*\n\t * As this skips calling sched_submit_work(), which the idle task does\n\t * regardless because that function is a nop when the task is in a\n\t * TASK_RUNNING state, make sure this isn't used someplace that the\n\t * current task can be in any other state. Note, idle is always in the\n\t * TASK_RUNNING state.\n\t */\n\tWARN_ON_ONCE(current->state);\n\tdo {\n\t\t__schedule(false);\n\t} while (need_resched());\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_idle(void)\n{\n\t/*\n\t * As this skips calling sched_submit_work(), which the idle task does\n\t * regardless because that function is a nop when the task is in a\n\t * TASK_RUNNING state, make sure this isn't used someplace that the\n\t * current task can be in any other state. Note, idle is always in the\n\t * TASK_RUNNING state.\n\t */\n\tWARN_ON_ONCE(current->state);\n\tdo {\n\t\t__schedule(false);\n\t} while (need_resched());\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_ttwu_pending",
          "args": [],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "sched_ttwu_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1731-1748",
          "snippet": "void sched_ttwu_pending(void)\n{\n\tstruct rq *rq = this_rq();\n\tstruct llist_node *llist = llist_del_all(&rq->wake_list);\n\tstruct task_struct *p, *t;\n\tstruct rq_flags rf;\n\n\tif (!llist)\n\t\treturn;\n\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\n\tllist_for_each_entry_safe(p, t, llist, wake_entry)\n\t\tttwu_do_activate(rq, p, p->sched_remote_wakeup ? WF_MIGRATED : 0, &rf);\n\n\trq_unlock_irqrestore(rq, &rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid sched_ttwu_pending(void)\n{\n\tstruct rq *rq = this_rq();\n\tstruct llist_node *llist = llist_del_all(&rq->wake_list);\n\tstruct task_struct *p, *t;\n\tstruct rq_flags rf;\n\n\tif (!llist)\n\t\treturn;\n\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\n\tllist_for_each_entry_safe(p, t, llist, wake_entry)\n\t\tttwu_do_activate(rq, p, p->sched_remote_wakeup ? WF_MIGRATED : 0, &rf);\n\n\trq_unlock_irqrestore(rq, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__current_clr_polling",
          "args": [],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_idle_exit",
          "args": [],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_idle_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "1134-1159",
          "snippet": "void tick_nohz_idle_exit(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tbool idle_active, tick_stopped;\n\tktime_t now;\n\n\tlocal_irq_disable();\n\n\tWARN_ON_ONCE(!ts->inidle);\n\tWARN_ON_ONCE(ts->timer_expires_base);\n\n\tts->inidle = 0;\n\tidle_active = ts->idle_active;\n\ttick_stopped = ts->tick_stopped;\n\n\tif (idle_active || tick_stopped)\n\t\tnow = ktime_get();\n\n\tif (idle_active)\n\t\ttick_nohz_stop_idle(ts, now);\n\n\tif (tick_stopped)\n\t\t__tick_nohz_idle_restart_tick(ts, now);\n\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_exit(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tbool idle_active, tick_stopped;\n\tktime_t now;\n\n\tlocal_irq_disable();\n\n\tWARN_ON_ONCE(!ts->inidle);\n\tWARN_ON_ONCE(ts->timer_expires_base);\n\n\tts->inidle = 0;\n\tidle_active = ts->idle_active;\n\ttick_stopped = ts->tick_stopped;\n\n\tif (idle_active || tick_stopped)\n\t\tnow = ktime_get();\n\n\tif (idle_active)\n\t\ttick_nohz_stop_idle(ts, now);\n\n\tif (tick_stopped)\n\t\t__tick_nohz_idle_restart_tick(ts, now);\n\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_set_need_resched",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_cpu_idle_exit",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "arch_cpu_idle_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
          "lines": "74-74",
          "snippet": "void __weak arch_cpu_idle_exit(void) { }",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle_exit(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpuidle_idle_call",
          "args": [],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "cpuidle_idle_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
          "lines": "128-217",
          "snippet": "static void cpuidle_idle_call(void)\n{\n\tstruct cpuidle_device *dev = cpuidle_get_device();\n\tstruct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev);\n\tint next_state, entered_state;\n\n\t/*\n\t * Check if the idle task must be rescheduled. If it is the\n\t * case, exit the function after re-enabling the local irq.\n\t */\n\tif (need_resched()) {\n\t\tlocal_irq_enable();\n\t\treturn;\n\t}\n\n\t/*\n\t * The RCU framework needs to be told that we are entering an idle\n\t * section, so no more rcu read side critical sections and one more\n\t * step to the grace period\n\t */\n\n\tif (cpuidle_not_available(drv, dev)) {\n\t\ttick_nohz_idle_stop_tick();\n\t\trcu_idle_enter();\n\n\t\tdefault_idle_call();\n\t\tgoto exit_idle;\n\t}\n\n\t/*\n\t * Suspend-to-idle (\"s2idle\") is a system state in which all user space\n\t * has been frozen, all I/O devices have been suspended and the only\n\t * activity happens here and in iterrupts (if any).  In that case bypass\n\t * the cpuidle governor and go stratight for the deepest idle state\n\t * available.  Possibly also suspend the local tick and the entire\n\t * timekeeping to prevent timer interrupts from kicking us out of idle\n\t * until a proper wakeup interrupt happens.\n\t */\n\n\tif (idle_should_enter_s2idle() || dev->use_deepest_state) {\n\t\tif (idle_should_enter_s2idle()) {\n\t\t\trcu_idle_enter();\n\n\t\t\tentered_state = cpuidle_enter_s2idle(drv, dev);\n\t\t\tif (entered_state > 0) {\n\t\t\t\tlocal_irq_enable();\n\t\t\t\tgoto exit_idle;\n\t\t\t}\n\n\t\t\trcu_idle_exit();\n\t\t}\n\n\t\ttick_nohz_idle_stop_tick();\n\t\trcu_idle_enter();\n\n\t\tnext_state = cpuidle_find_deepest_state(drv, dev);\n\t\tcall_cpuidle(drv, dev, next_state);\n\t} else {\n\t\tbool stop_tick = true;\n\n\t\t/*\n\t\t * Ask the cpuidle framework to choose a convenient idle state.\n\t\t */\n\t\tnext_state = cpuidle_select(drv, dev, &stop_tick);\n\n\t\tif (stop_tick || tick_nohz_tick_stopped())\n\t\t\ttick_nohz_idle_stop_tick();\n\t\telse\n\t\t\ttick_nohz_idle_retain_tick();\n\n\t\trcu_idle_enter();\n\n\t\tentered_state = call_cpuidle(drv, dev, next_state);\n\t\t/*\n\t\t * Give the governor an opportunity to reflect on the outcome\n\t\t */\n\t\tcpuidle_reflect(dev, entered_state);\n\t}\n\nexit_idle:\n\t__current_set_polling();\n\n\t/*\n\t * It is up to the idle functions to reenable local interrupts\n\t */\n\tif (WARN_ON_ONCE(irqs_disabled()))\n\t\tlocal_irq_enable();\n\n\trcu_idle_exit();\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void cpuidle_idle_call(void)\n{\n\tstruct cpuidle_device *dev = cpuidle_get_device();\n\tstruct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev);\n\tint next_state, entered_state;\n\n\t/*\n\t * Check if the idle task must be rescheduled. If it is the\n\t * case, exit the function after re-enabling the local irq.\n\t */\n\tif (need_resched()) {\n\t\tlocal_irq_enable();\n\t\treturn;\n\t}\n\n\t/*\n\t * The RCU framework needs to be told that we are entering an idle\n\t * section, so no more rcu read side critical sections and one more\n\t * step to the grace period\n\t */\n\n\tif (cpuidle_not_available(drv, dev)) {\n\t\ttick_nohz_idle_stop_tick();\n\t\trcu_idle_enter();\n\n\t\tdefault_idle_call();\n\t\tgoto exit_idle;\n\t}\n\n\t/*\n\t * Suspend-to-idle (\"s2idle\") is a system state in which all user space\n\t * has been frozen, all I/O devices have been suspended and the only\n\t * activity happens here and in iterrupts (if any).  In that case bypass\n\t * the cpuidle governor and go stratight for the deepest idle state\n\t * available.  Possibly also suspend the local tick and the entire\n\t * timekeeping to prevent timer interrupts from kicking us out of idle\n\t * until a proper wakeup interrupt happens.\n\t */\n\n\tif (idle_should_enter_s2idle() || dev->use_deepest_state) {\n\t\tif (idle_should_enter_s2idle()) {\n\t\t\trcu_idle_enter();\n\n\t\t\tentered_state = cpuidle_enter_s2idle(drv, dev);\n\t\t\tif (entered_state > 0) {\n\t\t\t\tlocal_irq_enable();\n\t\t\t\tgoto exit_idle;\n\t\t\t}\n\n\t\t\trcu_idle_exit();\n\t\t}\n\n\t\ttick_nohz_idle_stop_tick();\n\t\trcu_idle_enter();\n\n\t\tnext_state = cpuidle_find_deepest_state(drv, dev);\n\t\tcall_cpuidle(drv, dev, next_state);\n\t} else {\n\t\tbool stop_tick = true;\n\n\t\t/*\n\t\t * Ask the cpuidle framework to choose a convenient idle state.\n\t\t */\n\t\tnext_state = cpuidle_select(drv, dev, &stop_tick);\n\n\t\tif (stop_tick || tick_nohz_tick_stopped())\n\t\t\ttick_nohz_idle_stop_tick();\n\t\telse\n\t\t\ttick_nohz_idle_retain_tick();\n\n\t\trcu_idle_enter();\n\n\t\tentered_state = call_cpuidle(drv, dev, next_state);\n\t\t/*\n\t\t * Give the governor an opportunity to reflect on the outcome\n\t\t */\n\t\tcpuidle_reflect(dev, entered_state);\n\t}\n\nexit_idle:\n\t__current_set_polling();\n\n\t/*\n\t * It is up to the idle functions to reenable local interrupts\n\t */\n\tif (WARN_ON_ONCE(irqs_disabled()))\n\t\tlocal_irq_enable();\n\n\trcu_idle_exit();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_idle_poll",
          "args": [],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_idle_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
          "lines": "54-69",
          "snippet": "__cpuidle cpu_idle_poll(void)\n{\n\trcu_idle_enter();\n\ttrace_cpu_idle_rcuidle(0, smp_processor_id());\n\tlocal_irq_enable();\n\tstop_critical_timings();\n\n\twhile (!tif_need_resched() &&\n\t\t(cpu_idle_force_poll || tick_check_broadcast_expired()))\n\t\tcpu_relax();\n\tstart_critical_timings();\n\ttrace_cpu_idle_rcuidle(PWR_EVENT_EXIT, smp_processor_id());\n\trcu_idle_exit();\n\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\n__cpuidle cpu_idle_poll(void)\n{\n\trcu_idle_enter();\n\ttrace_cpu_idle_rcuidle(0, smp_processor_id());\n\tlocal_irq_enable();\n\tstop_critical_timings();\n\n\twhile (!tif_need_resched() &&\n\t\t(cpu_idle_force_poll || tick_check_broadcast_expired()))\n\t\tcpu_relax();\n\tstart_critical_timings();\n\ttrace_cpu_idle_rcuidle(PWR_EVENT_EXIT, smp_processor_id());\n\trcu_idle_exit();\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_idle_restart_tick",
          "args": [],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_idle_restart_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "1119-1125",
          "snippet": "void tick_nohz_idle_restart_tick(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->tick_stopped)\n\t\t__tick_nohz_idle_restart_tick(ts, ktime_get());\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_restart_tick(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\tif (ts->tick_stopped)\n\t\t__tick_nohz_idle_restart_tick(ts, ktime_get());\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_check_broadcast_expired",
          "args": [],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_broadcast_expired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "539-542",
          "snippet": "int tick_check_broadcast_expired(void)\n{\n\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_force_mask);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_check_broadcast_expired(void)\n{\n\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_force_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_cpu_idle_enter",
          "args": [],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "arch_cpu_idle_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
          "lines": "73-73",
          "snippet": "void __weak arch_cpu_idle_enter(void) { }",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle_enter(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_cpu_idle_dead",
          "args": [],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "arch_cpu_idle_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
          "lines": "75-75",
          "snippet": "void __weak arch_cpu_idle_dead(void) { }",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle_dead(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "cpuhp_report_idle_dead",
          "args": [],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_report_idle_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "917-930",
          "snippet": "void cpuhp_report_idle_dead(void)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\tBUG_ON(st->state != CPUHP_AP_OFFLINE);\n\trcu_report_dead(smp_processor_id());\n\tst->state = CPUHP_AP_IDLE_DEAD;\n\t/*\n\t * We cannot call complete after rcu_report_dead() so we delegate it\n\t * to an online cpu.\n\t */\n\tsmp_call_function_single(cpumask_first(cpu_online_mask),\n\t\t\t\t cpuhp_complete_idle_dead, st, 0);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nvoid cpuhp_report_idle_dead(void)\n{\n\tstruct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);\n\n\tBUG_ON(st->state != CPUHP_AP_OFFLINE);\n\trcu_report_dead(smp_processor_id());\n\tst->state = CPUHP_AP_IDLE_DEAD;\n\t/*\n\t * We cannot call complete after rcu_report_dead() so we delegate it\n\t * to an online cpu.\n\t */\n\tsmp_call_function_single(cpumask_first(cpu_online_mask),\n\t\t\t\t cpuhp_complete_idle_dead, st, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_idle_stop_tick_protected",
          "args": [],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_is_offline",
          "args": [
            "cpu"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmb",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_pgt_cache",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_idle_enter",
          "args": [],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_idle_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "978-994",
          "snippet": "void tick_nohz_idle_enter(void)\n{\n\tstruct tick_sched *ts;\n\n\tlockdep_assert_irqs_enabled();\n\n\tlocal_irq_disable();\n\n\tts = this_cpu_ptr(&tick_cpu_sched);\n\n\tWARN_ON_ONCE(ts->timer_expires_base);\n\n\tts->inidle = 1;\n\ttick_nohz_start_idle(ts);\n\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_enter(void)\n{\n\tstruct tick_sched *ts;\n\n\tlockdep_assert_irqs_enabled();\n\n\tlocal_irq_disable();\n\n\tts = this_cpu_ptr(&tick_cpu_sched);\n\n\tWARN_ON_ONCE(ts->timer_expires_base);\n\n\tts->inidle = 1;\n\ttick_nohz_start_idle(ts);\n\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__current_set_polling",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void do_idle(void)\n{\n\tint cpu = smp_processor_id();\n\t/*\n\t * If the arch has a polling bit, we maintain an invariant:\n\t *\n\t * Our polling bit is clear if we're not scheduled (i.e. if rq->curr !=\n\t * rq->idle). This means that, if rq->idle has the polling bit set,\n\t * then setting need_resched is guaranteed to cause the CPU to\n\t * reschedule.\n\t */\n\n\t__current_set_polling();\n\ttick_nohz_idle_enter();\n\n\twhile (!need_resched()) {\n\t\tcheck_pgt_cache();\n\t\trmb();\n\n\t\tif (cpu_is_offline(cpu)) {\n\t\t\ttick_nohz_idle_stop_tick_protected();\n\t\t\tcpuhp_report_idle_dead();\n\t\t\tarch_cpu_idle_dead();\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\tarch_cpu_idle_enter();\n\n\t\t/*\n\t\t * In poll mode we reenable interrupts and spin. Also if we\n\t\t * detected in the wakeup from idle path that the tick\n\t\t * broadcast device expired for us, we don't want to go deep\n\t\t * idle as we know that the IPI is going to arrive right away.\n\t\t */\n\t\tif (cpu_idle_force_poll || tick_check_broadcast_expired()) {\n\t\t\ttick_nohz_idle_restart_tick();\n\t\t\tcpu_idle_poll();\n\t\t} else {\n\t\t\tcpuidle_idle_call();\n\t\t}\n\t\tarch_cpu_idle_exit();\n\t}\n\n\t/*\n\t * Since we fell out of the loop above, we know TIF_NEED_RESCHED must\n\t * be set, propagate it into PREEMPT_NEED_RESCHED.\n\t *\n\t * This is required because for polling idle loops we will not have had\n\t * an IPI to fold the state for us.\n\t */\n\tpreempt_set_need_resched();\n\ttick_nohz_idle_exit();\n\t__current_clr_polling();\n\n\t/*\n\t * We promise to call sched_ttwu_pending() and reschedule if\n\t * need_resched() is set while polling is set. That means that clearing\n\t * polling needs to be visible before doing these things.\n\t */\n\tsmp_mb__after_atomic();\n\n\tsched_ttwu_pending();\n\tschedule_idle();\n\n\tif (unlikely(klp_patch_pending(current)))\n\t\tklp_update_patch_state(current);\n}"
  },
  {
    "function_name": "cpuidle_idle_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "128-217",
    "snippet": "static void cpuidle_idle_call(void)\n{\n\tstruct cpuidle_device *dev = cpuidle_get_device();\n\tstruct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev);\n\tint next_state, entered_state;\n\n\t/*\n\t * Check if the idle task must be rescheduled. If it is the\n\t * case, exit the function after re-enabling the local irq.\n\t */\n\tif (need_resched()) {\n\t\tlocal_irq_enable();\n\t\treturn;\n\t}\n\n\t/*\n\t * The RCU framework needs to be told that we are entering an idle\n\t * section, so no more rcu read side critical sections and one more\n\t * step to the grace period\n\t */\n\n\tif (cpuidle_not_available(drv, dev)) {\n\t\ttick_nohz_idle_stop_tick();\n\t\trcu_idle_enter();\n\n\t\tdefault_idle_call();\n\t\tgoto exit_idle;\n\t}\n\n\t/*\n\t * Suspend-to-idle (\"s2idle\") is a system state in which all user space\n\t * has been frozen, all I/O devices have been suspended and the only\n\t * activity happens here and in iterrupts (if any).  In that case bypass\n\t * the cpuidle governor and go stratight for the deepest idle state\n\t * available.  Possibly also suspend the local tick and the entire\n\t * timekeeping to prevent timer interrupts from kicking us out of idle\n\t * until a proper wakeup interrupt happens.\n\t */\n\n\tif (idle_should_enter_s2idle() || dev->use_deepest_state) {\n\t\tif (idle_should_enter_s2idle()) {\n\t\t\trcu_idle_enter();\n\n\t\t\tentered_state = cpuidle_enter_s2idle(drv, dev);\n\t\t\tif (entered_state > 0) {\n\t\t\t\tlocal_irq_enable();\n\t\t\t\tgoto exit_idle;\n\t\t\t}\n\n\t\t\trcu_idle_exit();\n\t\t}\n\n\t\ttick_nohz_idle_stop_tick();\n\t\trcu_idle_enter();\n\n\t\tnext_state = cpuidle_find_deepest_state(drv, dev);\n\t\tcall_cpuidle(drv, dev, next_state);\n\t} else {\n\t\tbool stop_tick = true;\n\n\t\t/*\n\t\t * Ask the cpuidle framework to choose a convenient idle state.\n\t\t */\n\t\tnext_state = cpuidle_select(drv, dev, &stop_tick);\n\n\t\tif (stop_tick || tick_nohz_tick_stopped())\n\t\t\ttick_nohz_idle_stop_tick();\n\t\telse\n\t\t\ttick_nohz_idle_retain_tick();\n\n\t\trcu_idle_enter();\n\n\t\tentered_state = call_cpuidle(drv, dev, next_state);\n\t\t/*\n\t\t * Give the governor an opportunity to reflect on the outcome\n\t\t */\n\t\tcpuidle_reflect(dev, entered_state);\n\t}\n\nexit_idle:\n\t__current_set_polling();\n\n\t/*\n\t * It is up to the idle functions to reenable local interrupts\n\t */\n\tif (WARN_ON_ONCE(irqs_disabled()))\n\t\tlocal_irq_enable();\n\n\trcu_idle_exit();\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_idle_exit",
          "args": [],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_idle_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "768-775",
          "snippet": "void rcu_idle_exit(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_eqs_exit(false);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nvoid rcu_idle_exit(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_eqs_exit(false);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "irqs_disabled()"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__current_set_polling",
          "args": [],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuidle_reflect",
          "args": [
            "dev",
            "entered_state"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_cpuidle",
          "args": [
            "drv",
            "dev",
            "next_state"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "call_cpuidle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
          "lines": "98-117",
          "snippet": "static int call_cpuidle(struct cpuidle_driver *drv, struct cpuidle_device *dev,\n\t\t      int next_state)\n{\n\t/*\n\t * The idle task must be scheduled, it is pointless to go to idle, just\n\t * update no idle residency and return.\n\t */\n\tif (current_clr_polling_and_test()) {\n\t\tdev->last_residency = 0;\n\t\tlocal_irq_enable();\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * Enter the idle state previously returned by the governor decision.\n\t * This function will block until an interrupt occurs and will take\n\t * care of re-enabling the local interrupts\n\t */\n\treturn cpuidle_enter(drv, dev, next_state);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic int call_cpuidle(struct cpuidle_driver *drv, struct cpuidle_device *dev,\n\t\t      int next_state)\n{\n\t/*\n\t * The idle task must be scheduled, it is pointless to go to idle, just\n\t * update no idle residency and return.\n\t */\n\tif (current_clr_polling_and_test()) {\n\t\tdev->last_residency = 0;\n\t\tlocal_irq_enable();\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * Enter the idle state previously returned by the governor decision.\n\t * This function will block until an interrupt occurs and will take\n\t * care of re-enabling the local interrupts\n\t */\n\treturn cpuidle_enter(drv, dev, next_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_idle_enter",
          "args": [],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_idle_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "606-610",
          "snippet": "void rcu_idle_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_eqs_enter(false);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_idle_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_eqs_enter(false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_idle_retain_tick",
          "args": [],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_idle_retain_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "963-971",
          "snippet": "void tick_nohz_idle_retain_tick(void)\n{\n\ttick_nohz_retain_tick(this_cpu_ptr(&tick_cpu_sched));\n\t/*\n\t * Undo the effect of get_next_timer_interrupt() called from\n\t * tick_nohz_next_event().\n\t */\n\ttimer_clear_idle();\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_retain_tick(void)\n{\n\ttick_nohz_retain_tick(this_cpu_ptr(&tick_cpu_sched));\n\t/*\n\t * Undo the effect of get_next_timer_interrupt() called from\n\t * tick_nohz_next_event().\n\t */\n\ttimer_clear_idle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_idle_stop_tick",
          "args": [],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_idle_stop_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "958-961",
          "snippet": "void tick_nohz_idle_stop_tick(void)\n{\n\t__tick_nohz_idle_stop_tick(this_cpu_ptr(&tick_cpu_sched));\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_nohz_idle_stop_tick(void)\n{\n\t__tick_nohz_idle_stop_tick(this_cpu_ptr(&tick_cpu_sched));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_nohz_tick_stopped",
          "args": [],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_tick_stopped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "468-473",
          "snippet": "bool tick_nohz_tick_stopped(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\treturn ts->tick_stopped;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nbool tick_nohz_tick_stopped(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\n\treturn ts->tick_stopped;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidle_select",
          "args": [
            "drv",
            "dev",
            "&stop_tick"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuidle_find_deepest_state",
          "args": [
            "drv",
            "dev"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuidle_enter_s2idle",
          "args": [
            "drv",
            "dev"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_should_enter_s2idle",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_should_enter_s2idle",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "default_idle_call",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "default_idle_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
          "lines": "87-96",
          "snippet": "void __cpuidle default_idle_call(void)\n{\n\tif (current_clr_polling_and_test()) {\n\t\tlocal_irq_enable();\n\t} else {\n\t\tstop_critical_timings();\n\t\tarch_cpu_idle();\n\t\tstart_critical_timings();\n\t}\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __cpuidle default_idle_call(void)\n{\n\tif (current_clr_polling_and_test()) {\n\t\tlocal_irq_enable();\n\t} else {\n\t\tstop_critical_timings();\n\t\tarch_cpu_idle();\n\t\tstart_critical_timings();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuidle_not_available",
          "args": [
            "drv",
            "dev"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuidle_get_cpu_driver",
          "args": [
            "dev"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuidle_get_device",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void cpuidle_idle_call(void)\n{\n\tstruct cpuidle_device *dev = cpuidle_get_device();\n\tstruct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev);\n\tint next_state, entered_state;\n\n\t/*\n\t * Check if the idle task must be rescheduled. If it is the\n\t * case, exit the function after re-enabling the local irq.\n\t */\n\tif (need_resched()) {\n\t\tlocal_irq_enable();\n\t\treturn;\n\t}\n\n\t/*\n\t * The RCU framework needs to be told that we are entering an idle\n\t * section, so no more rcu read side critical sections and one more\n\t * step to the grace period\n\t */\n\n\tif (cpuidle_not_available(drv, dev)) {\n\t\ttick_nohz_idle_stop_tick();\n\t\trcu_idle_enter();\n\n\t\tdefault_idle_call();\n\t\tgoto exit_idle;\n\t}\n\n\t/*\n\t * Suspend-to-idle (\"s2idle\") is a system state in which all user space\n\t * has been frozen, all I/O devices have been suspended and the only\n\t * activity happens here and in iterrupts (if any).  In that case bypass\n\t * the cpuidle governor and go stratight for the deepest idle state\n\t * available.  Possibly also suspend the local tick and the entire\n\t * timekeeping to prevent timer interrupts from kicking us out of idle\n\t * until a proper wakeup interrupt happens.\n\t */\n\n\tif (idle_should_enter_s2idle() || dev->use_deepest_state) {\n\t\tif (idle_should_enter_s2idle()) {\n\t\t\trcu_idle_enter();\n\n\t\t\tentered_state = cpuidle_enter_s2idle(drv, dev);\n\t\t\tif (entered_state > 0) {\n\t\t\t\tlocal_irq_enable();\n\t\t\t\tgoto exit_idle;\n\t\t\t}\n\n\t\t\trcu_idle_exit();\n\t\t}\n\n\t\ttick_nohz_idle_stop_tick();\n\t\trcu_idle_enter();\n\n\t\tnext_state = cpuidle_find_deepest_state(drv, dev);\n\t\tcall_cpuidle(drv, dev, next_state);\n\t} else {\n\t\tbool stop_tick = true;\n\n\t\t/*\n\t\t * Ask the cpuidle framework to choose a convenient idle state.\n\t\t */\n\t\tnext_state = cpuidle_select(drv, dev, &stop_tick);\n\n\t\tif (stop_tick || tick_nohz_tick_stopped())\n\t\t\ttick_nohz_idle_stop_tick();\n\t\telse\n\t\t\ttick_nohz_idle_retain_tick();\n\n\t\trcu_idle_enter();\n\n\t\tentered_state = call_cpuidle(drv, dev, next_state);\n\t\t/*\n\t\t * Give the governor an opportunity to reflect on the outcome\n\t\t */\n\t\tcpuidle_reflect(dev, entered_state);\n\t}\n\nexit_idle:\n\t__current_set_polling();\n\n\t/*\n\t * It is up to the idle functions to reenable local interrupts\n\t */\n\tif (WARN_ON_ONCE(irqs_disabled()))\n\t\tlocal_irq_enable();\n\n\trcu_idle_exit();\n}"
  },
  {
    "function_name": "call_cpuidle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "98-117",
    "snippet": "static int call_cpuidle(struct cpuidle_driver *drv, struct cpuidle_device *dev,\n\t\t      int next_state)\n{\n\t/*\n\t * The idle task must be scheduled, it is pointless to go to idle, just\n\t * update no idle residency and return.\n\t */\n\tif (current_clr_polling_and_test()) {\n\t\tdev->last_residency = 0;\n\t\tlocal_irq_enable();\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * Enter the idle state previously returned by the governor decision.\n\t * This function will block until an interrupt occurs and will take\n\t * care of re-enabling the local interrupts\n\t */\n\treturn cpuidle_enter(drv, dev, next_state);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuidle_enter",
          "args": [
            "drv",
            "dev",
            "next_state"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_clr_polling_and_test",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic int call_cpuidle(struct cpuidle_driver *drv, struct cpuidle_device *dev,\n\t\t      int next_state)\n{\n\t/*\n\t * The idle task must be scheduled, it is pointless to go to idle, just\n\t * update no idle residency and return.\n\t */\n\tif (current_clr_polling_and_test()) {\n\t\tdev->last_residency = 0;\n\t\tlocal_irq_enable();\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * Enter the idle state previously returned by the governor decision.\n\t * This function will block until an interrupt occurs and will take\n\t * care of re-enabling the local interrupts\n\t */\n\treturn cpuidle_enter(drv, dev, next_state);\n}"
  },
  {
    "function_name": "default_idle_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "87-96",
    "snippet": "void __cpuidle default_idle_call(void)\n{\n\tif (current_clr_polling_and_test()) {\n\t\tlocal_irq_enable();\n\t} else {\n\t\tstop_critical_timings();\n\t\tarch_cpu_idle();\n\t\tstart_critical_timings();\n\t}\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_critical_timings",
          "args": [],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "start_critical_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_irqsoff.c",
          "lines": "439-445",
          "snippet": "void start_critical_timings(void)\n{\n\tint pc = preempt_count();\n\n\tif (preempt_trace(pc) || irq_trace())\n\t\tstart_critical_timing(CALLER_ADDR0, CALLER_ADDR1, pc);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid start_critical_timings(void)\n{\n\tint pc = preempt_count();\n\n\tif (preempt_trace(pc) || irq_trace())\n\t\tstart_critical_timing(CALLER_ADDR0, CALLER_ADDR1, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_cpu_idle",
          "args": [],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "arch_cpu_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
          "lines": "76-80",
          "snippet": "void __weak arch_cpu_idle(void)\n{\n\tcpu_idle_force_poll = 1;\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle(void)\n{\n\tcpu_idle_force_poll = 1;\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_critical_timings",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "stop_critical_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_irqsoff.c",
          "lines": "448-454",
          "snippet": "void stop_critical_timings(void)\n{\n\tint pc = preempt_count();\n\n\tif (preempt_trace(pc) || irq_trace())\n\t\tstop_critical_timing(CALLER_ADDR0, CALLER_ADDR1, pc);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid stop_critical_timings(void)\n{\n\tint pc = preempt_count();\n\n\tif (preempt_trace(pc) || irq_trace())\n\t\tstop_critical_timing(CALLER_ADDR0, CALLER_ADDR1, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_clr_polling_and_test",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __cpuidle default_idle_call(void)\n{\n\tif (current_clr_polling_and_test()) {\n\t\tlocal_irq_enable();\n\t} else {\n\t\tstop_critical_timings();\n\t\tarch_cpu_idle();\n\t\tstart_critical_timings();\n\t}\n}"
  },
  {
    "function_name": "arch_cpu_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "76-80",
    "snippet": "void __weak arch_cpu_idle(void)\n{\n\tcpu_idle_force_poll = 1;\n\tlocal_irq_enable();\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle(void)\n{\n\tcpu_idle_force_poll = 1;\n\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "arch_cpu_idle_dead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "75-75",
    "snippet": "void __weak arch_cpu_idle_dead(void) { }",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle_dead(void) { }"
  },
  {
    "function_name": "arch_cpu_idle_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "74-74",
    "snippet": "void __weak arch_cpu_idle_exit(void) { }",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle_exit(void) { }"
  },
  {
    "function_name": "arch_cpu_idle_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "73-73",
    "snippet": "void __weak arch_cpu_idle_enter(void) { }",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle_enter(void) { }"
  },
  {
    "function_name": "arch_cpu_idle_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "72-72",
    "snippet": "void __weak arch_cpu_idle_prepare(void) { }",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid __weak arch_cpu_idle_prepare(void) { }"
  },
  {
    "function_name": "cpu_idle_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "54-69",
    "snippet": "__cpuidle cpu_idle_poll(void)\n{\n\trcu_idle_enter();\n\ttrace_cpu_idle_rcuidle(0, smp_processor_id());\n\tlocal_irq_enable();\n\tstop_critical_timings();\n\n\twhile (!tif_need_resched() &&\n\t\t(cpu_idle_force_poll || tick_check_broadcast_expired()))\n\t\tcpu_relax();\n\tstart_critical_timings();\n\ttrace_cpu_idle_rcuidle(PWR_EVENT_EXIT, smp_processor_id());\n\trcu_idle_exit();\n\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_idle_exit",
          "args": [],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_idle_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "768-775",
          "snippet": "void rcu_idle_exit(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_eqs_exit(false);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void rcu_report_qs_rnp(unsigned long mask, struct rcu_node *rnp,\n\t\t\t      unsigned long gps, unsigned long flags);\n\nvoid rcu_idle_exit(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcu_eqs_exit(false);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_cpu_idle_rcuidle",
          "args": [
            "PWR_EVENT_EXIT",
            "smp_processor_id()"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_critical_timings",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "start_critical_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_irqsoff.c",
          "lines": "439-445",
          "snippet": "void start_critical_timings(void)\n{\n\tint pc = preempt_count();\n\n\tif (preempt_trace(pc) || irq_trace())\n\t\tstart_critical_timing(CALLER_ADDR0, CALLER_ADDR1, pc);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid start_critical_timings(void)\n{\n\tint pc = preempt_count();\n\n\tif (preempt_trace(pc) || irq_trace())\n\t\tstart_critical_timing(CALLER_ADDR0, CALLER_ADDR1, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_check_broadcast_expired",
          "args": [],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_broadcast_expired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "539-542",
          "snippet": "int tick_check_broadcast_expired(void)\n{\n\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_force_mask);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_check_broadcast_expired(void)\n{\n\treturn cpumask_test_cpu(smp_processor_id(), tick_broadcast_force_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tif_need_resched",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop_critical_timings",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "stop_critical_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_irqsoff.c",
          "lines": "448-454",
          "snippet": "void stop_critical_timings(void)\n{\n\tint pc = preempt_count();\n\n\tif (preempt_trace(pc) || irq_trace())\n\t\tstop_critical_timing(CALLER_ADDR0, CALLER_ADDR1, pc);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid stop_critical_timings(void)\n{\n\tint pc = preempt_count();\n\n\tif (preempt_trace(pc) || irq_trace())\n\t\tstop_critical_timing(CALLER_ADDR0, CALLER_ADDR1, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_cpu_idle_rcuidle",
          "args": [
            "0",
            "smp_processor_id()"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_idle_enter",
          "args": [],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_idle_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "606-610",
          "snippet": "void rcu_idle_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_eqs_enter(false);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_idle_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\trcu_eqs_enter(false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\n__cpuidle cpu_idle_poll(void)\n{\n\trcu_idle_enter();\n\ttrace_cpu_idle_rcuidle(0, smp_processor_id());\n\tlocal_irq_enable();\n\tstop_critical_timings();\n\n\twhile (!tif_need_resched() &&\n\t\t(cpu_idle_force_poll || tick_check_broadcast_expired()))\n\t\tcpu_relax();\n\tstart_critical_timings();\n\ttrace_cpu_idle_rcuidle(PWR_EVENT_EXIT, smp_processor_id());\n\trcu_idle_exit();\n\n\treturn 1;\n}"
  },
  {
    "function_name": "cpu_idle_nopoll_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "45-50",
    "snippet": "static int __init cpu_idle_nopoll_setup(char *__unused)\n{\n\tcpu_idle_force_poll = 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic int __init cpu_idle_nopoll_setup(char *__unused)\n{\n\tcpu_idle_force_poll = 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "cpu_idle_poll_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "37-42",
    "snippet": "static int __init cpu_idle_poll_setup(char *__unused)\n{\n\tcpu_idle_force_poll = 1;\n\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic int __init cpu_idle_poll_setup(char *__unused)\n{\n\tcpu_idle_force_poll = 1;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "cpu_idle_poll_ctrl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "26-34",
    "snippet": "void cpu_idle_poll_ctrl(bool enable)\n{\n\tif (enable) {\n\t\tcpu_idle_force_poll++;\n\t} else {\n\t\tcpu_idle_force_poll--;\n\t\tWARN_ON_ONCE(cpu_idle_force_poll < 0);\n\t}\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpu_idle_force_poll < 0"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid cpu_idle_poll_ctrl(bool enable)\n{\n\tif (enable) {\n\t\tcpu_idle_force_poll++;\n\t} else {\n\t\tcpu_idle_force_poll--;\n\t\tWARN_ON_ONCE(cpu_idle_force_poll < 0);\n\t}\n}"
  },
  {
    "function_name": "sched_idle_set_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/idle.c",
    "lines": "19-22",
    "snippet": "void sched_idle_set_state(struct cpuidle_state *idle_state)\n{\n\tidle_set_state(this_rq(), idle_state);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "idle_set_state",
          "args": [
            "this_rq()",
            "idle_state"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "idle_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1719-1722",
          "snippet": "static inline void idle_set_state(struct rq *rq,\n\t\t\t\t  struct cpuidle_state *idle_state)\n{\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void idle_set_state(struct rq *rq,\n\t\t\t\t  struct cpuidle_state *idle_state)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_rq",
          "args": [],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nvoid sched_idle_set_state(struct cpuidle_state *idle_state)\n{\n\tidle_set_state(this_rq(), idle_state);\n}"
  }
]