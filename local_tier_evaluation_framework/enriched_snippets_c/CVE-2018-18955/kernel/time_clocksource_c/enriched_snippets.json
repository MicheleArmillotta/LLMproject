[
  {
    "function_name": "boot_override_clock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "1238-1246",
    "snippet": "static int __init boot_override_clock(char* str)\n{\n\tif (!strcmp(str, \"pmtmr\")) {\n\t\tpr_warn(\"clock=pmtmr is deprecated - use clocksource=acpi_pm\\n\");\n\t\treturn boot_override_clocksource(\"acpi_pm\");\n\t}\n\tpr_warn(\"clock= boot option is deprecated - use clocksource=xyz\\n\");\n\treturn boot_override_clocksource(str);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "boot_override_clocksource",
          "args": [
            "str"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "boot_override_clocksource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "1220-1227",
          "snippet": "static int __init boot_override_clocksource(char* str)\n{\n\tmutex_lock(&clocksource_mutex);\n\tif (str)\n\t\tstrlcpy(override_name, str, sizeof(override_name));\n\tmutex_unlock(&clocksource_mutex);\n\treturn 1;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(clocksource_mutex);",
            "static char override_name[CS_NAME_LEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(clocksource_mutex);\nstatic char override_name[CS_NAME_LEN];\n\nstatic int __init boot_override_clocksource(char* str)\n{\n\tmutex_lock(&clocksource_mutex);\n\tif (str)\n\t\tstrlcpy(override_name, str, sizeof(override_name));\n\tmutex_unlock(&clocksource_mutex);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"clock= boot option is deprecated - use clocksource=xyz\\n\""
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"clock=pmtmr is deprecated - use clocksource=acpi_pm\\n\""
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"pmtmr\""
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic int __init boot_override_clock(char* str)\n{\n\tif (!strcmp(str, \"pmtmr\")) {\n\t\tpr_warn(\"clock=pmtmr is deprecated - use clocksource=acpi_pm\\n\");\n\t\treturn boot_override_clocksource(\"acpi_pm\");\n\t}\n\tpr_warn(\"clock= boot option is deprecated - use clocksource=xyz\\n\");\n\treturn boot_override_clocksource(str);\n}"
  },
  {
    "function_name": "boot_override_clocksource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "1220-1227",
    "snippet": "static int __init boot_override_clocksource(char* str)\n{\n\tmutex_lock(&clocksource_mutex);\n\tif (str)\n\t\tstrlcpy(override_name, str, sizeof(override_name));\n\tmutex_unlock(&clocksource_mutex);\n\treturn 1;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(clocksource_mutex);",
      "static char override_name[CS_NAME_LEN];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "override_name",
            "str",
            "sizeof(override_name)"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(clocksource_mutex);\nstatic char override_name[CS_NAME_LEN];\n\nstatic int __init boot_override_clocksource(char* str)\n{\n\tmutex_lock(&clocksource_mutex);\n\tif (str)\n\t\tstrlcpy(override_name, str, sizeof(override_name));\n\tmutex_unlock(&clocksource_mutex);\n\treturn 1;\n}"
  },
  {
    "function_name": "init_clocksource_sysfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "1200-1208",
    "snippet": "static int __init init_clocksource_sysfs(void)\n{\n\tint error = subsys_system_register(&clocksource_subsys, NULL);\n\n\tif (!error)\n\t\terror = device_register(&device_clocksource);\n\n\treturn error;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_register",
          "args": [
            "&device_clocksource"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "subsys_system_register",
          "args": [
            "&clocksource_subsys",
            "NULL"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic int __init init_clocksource_sysfs(void)\n{\n\tint error = subsys_system_register(&clocksource_subsys, NULL);\n\n\tif (!error)\n\t\terror = device_register(&device_clocksource);\n\n\treturn error;\n}"
  },
  {
    "function_name": "available_clocksource_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "1153-1178",
    "snippet": "static ssize_t available_clocksource_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct clocksource *src;\n\tssize_t count = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tlist_for_each_entry(src, &clocksource_list, list) {\n\t\t/*\n\t\t * Don't show non-HRES clocksource if the tick code is\n\t\t * in one shot mode (highres=on or nohz=on)\n\t\t */\n\t\tif (!tick_oneshot_mode_active() ||\n\t\t    (src->flags & CLOCK_SOURCE_VALID_FOR_HRES))\n\t\t\tcount += snprintf(buf + count,\n\t\t\t\t  max((ssize_t)PAGE_SIZE - count, (ssize_t)0),\n\t\t\t\t  \"%s \", src->name);\n\t}\n\tmutex_unlock(&clocksource_mutex);\n\n\tcount += snprintf(buf + count,\n\t\t\t  max((ssize_t)PAGE_SIZE - count, (ssize_t)0), \"\\n\");\n\n\treturn count;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clocksource_list);",
      "static DEFINE_MUTEX(clocksource_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + count",
            "max((ssize_t)PAGE_SIZE - count, (ssize_t)0)",
            "\"\\n\""
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "(ssize_t)PAGE_SIZE - count",
            "(ssize_t)0"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4232-4251",
          "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + count",
            "max((ssize_t)PAGE_SIZE - count, (ssize_t)0)",
            "\"%s \"",
            "src->name"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_oneshot_mode_active",
          "args": [],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "tick_oneshot_mode_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-oneshot.c",
          "lines": "110-120",
          "snippet": "int tick_oneshot_mode_active(void)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = __this_cpu_read(tick_cpu_device.mode) == TICKDEV_MODE_ONESHOT;\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_oneshot_mode_active(void)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = __this_cpu_read(tick_cpu_device.mode) == TICKDEV_MODE_ONESHOT;\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "src",
            "&clocksource_list",
            "list"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\nstatic DEFINE_MUTEX(clocksource_mutex);\n\nstatic ssize_t available_clocksource_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct clocksource *src;\n\tssize_t count = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tlist_for_each_entry(src, &clocksource_list, list) {\n\t\t/*\n\t\t * Don't show non-HRES clocksource if the tick code is\n\t\t * in one shot mode (highres=on or nohz=on)\n\t\t */\n\t\tif (!tick_oneshot_mode_active() ||\n\t\t    (src->flags & CLOCK_SOURCE_VALID_FOR_HRES))\n\t\t\tcount += snprintf(buf + count,\n\t\t\t\t  max((ssize_t)PAGE_SIZE - count, (ssize_t)0),\n\t\t\t\t  \"%s \", src->name);\n\t}\n\tmutex_unlock(&clocksource_mutex);\n\n\tcount += snprintf(buf + count,\n\t\t\t  max((ssize_t)PAGE_SIZE - count, (ssize_t)0), \"\\n\");\n\n\treturn count;\n}"
  },
  {
    "function_name": "unbind_clocksource_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "1119-1142",
    "snippet": "static ssize_t unbind_clocksource_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct clocksource *cs;\n\tchar name[CS_NAME_LEN];\n\tssize_t ret;\n\n\tret = sysfs_get_uname(buf, name, count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = -ENODEV;\n\tmutex_lock(&clocksource_mutex);\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (strcmp(cs->name, name))\n\t\t\tcontinue;\n\t\tret = clocksource_unbind(cs);\n\t\tbreak;\n\t}\n\tmutex_unlock(&clocksource_mutex);\n\n\treturn ret ? ret : count;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clocksource_list);",
      "static DEFINE_MUTEX(clocksource_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_unbind",
          "args": [
            "cs"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_unbind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "992-1025",
          "snippet": "static int clocksource_unbind(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tif (clocksource_is_watchdog(cs)) {\n\t\t/* Select and try to install a replacement watchdog. */\n\t\tclocksource_select_watchdog(true);\n\t\tif (clocksource_is_watchdog(cs))\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (cs == curr_clocksource) {\n\t\t/* Select and try to install a replacement clock source */\n\t\tclocksource_select_fallback();\n\t\tif (curr_clocksource == cs)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (clocksource_is_suspend(cs)) {\n\t\t/*\n\t\t * Select and try to install a replacement suspend clocksource.\n\t\t * If no replacement suspend clocksource, we will just let the\n\t\t * clocksource go and have no suspend clocksource.\n\t\t */\n\t\tclocksource_suspend_select(true);\n\t}\n\n\tclocksource_watchdog_lock(&flags);\n\tclocksource_dequeue_watchdog(cs);\n\tlist_del_init(&cs->list);\n\tclocksource_watchdog_unlock(&flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *curr_clocksource;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\n\nstatic int clocksource_unbind(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tif (clocksource_is_watchdog(cs)) {\n\t\t/* Select and try to install a replacement watchdog. */\n\t\tclocksource_select_watchdog(true);\n\t\tif (clocksource_is_watchdog(cs))\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (cs == curr_clocksource) {\n\t\t/* Select and try to install a replacement clock source */\n\t\tclocksource_select_fallback();\n\t\tif (curr_clocksource == cs)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (clocksource_is_suspend(cs)) {\n\t\t/*\n\t\t * Select and try to install a replacement suspend clocksource.\n\t\t * If no replacement suspend clocksource, we will just let the\n\t\t * clocksource go and have no suspend clocksource.\n\t\t */\n\t\tclocksource_suspend_select(true);\n\t}\n\n\tclocksource_watchdog_lock(&flags);\n\tclocksource_dequeue_watchdog(cs);\n\tlist_del_init(&cs->list);\n\tclocksource_watchdog_unlock(&flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cs->name",
            "name"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cs",
            "&clocksource_list",
            "list"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_get_uname",
          "args": [
            "buf",
            "name",
            "count"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_get_uname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "1065-1080",
          "snippet": "ssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt)\n{\n\tsize_t ret = cnt;\n\n\t/* strings from sysfs write are not 0 terminated! */\n\tif (!cnt || cnt >= CS_NAME_LEN)\n\t\treturn -EINVAL;\n\n\t/* strip of \\n: */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\tif (cnt > 0)\n\t\tmemcpy(dst, buf, cnt);\n\tdst[cnt] = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt)\n{\n\tsize_t ret = cnt;\n\n\t/* strings from sysfs write are not 0 terminated! */\n\tif (!cnt || cnt >= CS_NAME_LEN)\n\t\treturn -EINVAL;\n\n\t/* strip of \\n: */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\tif (cnt > 0)\n\t\tmemcpy(dst, buf, cnt);\n\tdst[cnt] = 0;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\nstatic DEFINE_MUTEX(clocksource_mutex);\n\nstatic ssize_t unbind_clocksource_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct clocksource *cs;\n\tchar name[CS_NAME_LEN];\n\tssize_t ret;\n\n\tret = sysfs_get_uname(buf, name, count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = -ENODEV;\n\tmutex_lock(&clocksource_mutex);\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (strcmp(cs->name, name))\n\t\t\tcontinue;\n\t\tret = clocksource_unbind(cs);\n\t\tbreak;\n\t}\n\tmutex_unlock(&clocksource_mutex);\n\n\treturn ret ? ret : count;\n}"
  },
  {
    "function_name": "current_clocksource_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "1092-1107",
    "snippet": "static ssize_t current_clocksource_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tssize_t ret;\n\n\tmutex_lock(&clocksource_mutex);\n\n\tret = sysfs_get_uname(buf, override_name, count);\n\tif (ret >= 0)\n\t\tclocksource_select();\n\n\tmutex_unlock(&clocksource_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(clocksource_mutex);",
      "static char override_name[CS_NAME_LEN];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_select",
          "args": [],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_select_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "814-814",
          "snippet": "static inline void clocksource_select_fallback(void) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_select_fallback(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_get_uname",
          "args": [
            "buf",
            "override_name",
            "count"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_get_uname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "1065-1080",
          "snippet": "ssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt)\n{\n\tsize_t ret = cnt;\n\n\t/* strings from sysfs write are not 0 terminated! */\n\tif (!cnt || cnt >= CS_NAME_LEN)\n\t\treturn -EINVAL;\n\n\t/* strip of \\n: */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\tif (cnt > 0)\n\t\tmemcpy(dst, buf, cnt);\n\tdst[cnt] = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt)\n{\n\tsize_t ret = cnt;\n\n\t/* strings from sysfs write are not 0 terminated! */\n\tif (!cnt || cnt >= CS_NAME_LEN)\n\t\treturn -EINVAL;\n\n\t/* strip of \\n: */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\tif (cnt > 0)\n\t\tmemcpy(dst, buf, cnt);\n\tdst[cnt] = 0;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(clocksource_mutex);\nstatic char override_name[CS_NAME_LEN];\n\nstatic ssize_t current_clocksource_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tssize_t ret;\n\n\tmutex_lock(&clocksource_mutex);\n\n\tret = sysfs_get_uname(buf, override_name, count);\n\tif (ret >= 0)\n\t\tclocksource_select();\n\n\tmutex_unlock(&clocksource_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "sysfs_get_uname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "1065-1080",
    "snippet": "ssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt)\n{\n\tsize_t ret = cnt;\n\n\t/* strings from sysfs write are not 0 terminated! */\n\tif (!cnt || cnt >= CS_NAME_LEN)\n\t\treturn -EINVAL;\n\n\t/* strip of \\n: */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\tif (cnt > 0)\n\t\tmemcpy(dst, buf, cnt);\n\tdst[cnt] = 0;\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "buf",
            "cnt"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt)\n{\n\tsize_t ret = cnt;\n\n\t/* strings from sysfs write are not 0 terminated! */\n\tif (!cnt || cnt >= CS_NAME_LEN)\n\t\treturn -EINVAL;\n\n\t/* strip of \\n: */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\tif (cnt > 0)\n\t\tmemcpy(dst, buf, cnt);\n\tdst[cnt] = 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "current_clocksource_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "1052-1063",
    "snippet": "static ssize_t current_clocksource_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tssize_t count = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tcount = snprintf(buf, PAGE_SIZE, \"%s\\n\", curr_clocksource->name);\n\tmutex_unlock(&clocksource_mutex);\n\n\treturn count;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *curr_clocksource;",
      "static DEFINE_MUTEX(clocksource_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%s\\n\"",
            "curr_clocksource->name"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\nstatic DEFINE_MUTEX(clocksource_mutex);\n\nstatic ssize_t current_clocksource_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tssize_t count = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tcount = snprintf(buf, PAGE_SIZE, \"%s\\n\", curr_clocksource->name);\n\tmutex_unlock(&clocksource_mutex);\n\n\treturn count;\n}"
  },
  {
    "function_name": "clocksource_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "1031-1040",
    "snippet": "int clocksource_unregister(struct clocksource *cs)\n{\n\tint ret = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tif (!list_empty(&cs->list))\n\t\tret = clocksource_unbind(cs);\n\tmutex_unlock(&clocksource_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(clocksource_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_unbind",
          "args": [
            "cs"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_unbind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "992-1025",
          "snippet": "static int clocksource_unbind(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tif (clocksource_is_watchdog(cs)) {\n\t\t/* Select and try to install a replacement watchdog. */\n\t\tclocksource_select_watchdog(true);\n\t\tif (clocksource_is_watchdog(cs))\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (cs == curr_clocksource) {\n\t\t/* Select and try to install a replacement clock source */\n\t\tclocksource_select_fallback();\n\t\tif (curr_clocksource == cs)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (clocksource_is_suspend(cs)) {\n\t\t/*\n\t\t * Select and try to install a replacement suspend clocksource.\n\t\t * If no replacement suspend clocksource, we will just let the\n\t\t * clocksource go and have no suspend clocksource.\n\t\t */\n\t\tclocksource_suspend_select(true);\n\t}\n\n\tclocksource_watchdog_lock(&flags);\n\tclocksource_dequeue_watchdog(cs);\n\tlist_del_init(&cs->list);\n\tclocksource_watchdog_unlock(&flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *curr_clocksource;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\n\nstatic int clocksource_unbind(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tif (clocksource_is_watchdog(cs)) {\n\t\t/* Select and try to install a replacement watchdog. */\n\t\tclocksource_select_watchdog(true);\n\t\tif (clocksource_is_watchdog(cs))\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (cs == curr_clocksource) {\n\t\t/* Select and try to install a replacement clock source */\n\t\tclocksource_select_fallback();\n\t\tif (curr_clocksource == cs)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (clocksource_is_suspend(cs)) {\n\t\t/*\n\t\t * Select and try to install a replacement suspend clocksource.\n\t\t * If no replacement suspend clocksource, we will just let the\n\t\t * clocksource go and have no suspend clocksource.\n\t\t */\n\t\tclocksource_suspend_select(true);\n\t}\n\n\tclocksource_watchdog_lock(&flags);\n\tclocksource_dequeue_watchdog(cs);\n\tlist_del_init(&cs->list);\n\tclocksource_watchdog_unlock(&flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cs->list"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(clocksource_mutex);\n\nint clocksource_unregister(struct clocksource *cs)\n{\n\tint ret = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tif (!list_empty(&cs->list))\n\t\tret = clocksource_unbind(cs);\n\tmutex_unlock(&clocksource_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "clocksource_unbind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "992-1025",
    "snippet": "static int clocksource_unbind(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tif (clocksource_is_watchdog(cs)) {\n\t\t/* Select and try to install a replacement watchdog. */\n\t\tclocksource_select_watchdog(true);\n\t\tif (clocksource_is_watchdog(cs))\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (cs == curr_clocksource) {\n\t\t/* Select and try to install a replacement clock source */\n\t\tclocksource_select_fallback();\n\t\tif (curr_clocksource == cs)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (clocksource_is_suspend(cs)) {\n\t\t/*\n\t\t * Select and try to install a replacement suspend clocksource.\n\t\t * If no replacement suspend clocksource, we will just let the\n\t\t * clocksource go and have no suspend clocksource.\n\t\t */\n\t\tclocksource_suspend_select(true);\n\t}\n\n\tclocksource_watchdog_lock(&flags);\n\tclocksource_dequeue_watchdog(cs);\n\tlist_del_init(&cs->list);\n\tclocksource_watchdog_unlock(&flags);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *curr_clocksource;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clocksource_watchdog_unlock",
          "args": [
            "&flags"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_watchdog_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "470-470",
          "snippet": "static inline void clocksource_watchdog_unlock(unsigned long *flags) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_watchdog_unlock(unsigned long *flags) { }"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cs->list"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_dequeue_watchdog",
          "args": [
            "cs"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_dequeue_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "463-463",
          "snippet": "static inline void clocksource_dequeue_watchdog(struct clocksource *cs) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_dequeue_watchdog(struct clocksource *cs) { }"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_watchdog_lock",
          "args": [
            "&flags"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_watchdog_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "469-469",
          "snippet": "static inline void clocksource_watchdog_lock(unsigned long *flags) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_watchdog_lock(unsigned long *flags) { }"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_suspend_select",
          "args": [
            "true"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_suspend_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "506-521",
          "snippet": "static void clocksource_suspend_select(bool fallback)\n{\n\tstruct clocksource *cs, *old_suspend;\n\n\told_suspend = suspend_clocksource;\n\tif (fallback)\n\t\tsuspend_clocksource = NULL;\n\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\t/* Skip current if we were requested for a fallback. */\n\t\tif (fallback && cs == old_suspend)\n\t\t\tcontinue;\n\n\t\t__clocksource_suspend_select(cs);\n\t}\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;",
            "static LIST_HEAD(clocksource_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic LIST_HEAD(clocksource_list);\n\nstatic void clocksource_suspend_select(bool fallback)\n{\n\tstruct clocksource *cs, *old_suspend;\n\n\told_suspend = suspend_clocksource;\n\tif (fallback)\n\t\tsuspend_clocksource = NULL;\n\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\t/* Skip current if we were requested for a fallback. */\n\t\tif (fallback && cs == old_suspend)\n\t\t\tcontinue;\n\n\t\t__clocksource_suspend_select(cs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_is_suspend",
          "args": [
            "cs"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_is_suspend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "474-477",
          "snippet": "static bool clocksource_is_suspend(struct clocksource *cs)\n{\n\treturn cs == suspend_clocksource;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\n\nstatic bool clocksource_is_suspend(struct clocksource *cs)\n{\n\treturn cs == suspend_clocksource;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_select_fallback",
          "args": [],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_select_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "814-814",
          "snippet": "static inline void clocksource_select_fallback(void) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_select_fallback(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_is_watchdog",
          "args": [
            "cs"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_is_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "466-466",
          "snippet": "static bool clocksource_is_watchdog(struct clocksource *cs) { return false; }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic bool clocksource_is_watchdog(struct clocksource *cs) { return false; }"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_select_watchdog",
          "args": [
            "true"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_select_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "462-462",
          "snippet": "static void clocksource_select_watchdog(bool fallback) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_select_watchdog(bool fallback) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\n\nstatic int clocksource_unbind(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tif (clocksource_is_watchdog(cs)) {\n\t\t/* Select and try to install a replacement watchdog. */\n\t\tclocksource_select_watchdog(true);\n\t\tif (clocksource_is_watchdog(cs))\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (cs == curr_clocksource) {\n\t\t/* Select and try to install a replacement clock source */\n\t\tclocksource_select_fallback();\n\t\tif (curr_clocksource == cs)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (clocksource_is_suspend(cs)) {\n\t\t/*\n\t\t * Select and try to install a replacement suspend clocksource.\n\t\t * If no replacement suspend clocksource, we will just let the\n\t\t * clocksource go and have no suspend clocksource.\n\t\t */\n\t\tclocksource_suspend_select(true);\n\t}\n\n\tclocksource_watchdog_lock(&flags);\n\tclocksource_dequeue_watchdog(cs);\n\tlist_del_init(&cs->list);\n\tclocksource_watchdog_unlock(&flags);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "clocksource_change_rating",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "973-986",
    "snippet": "void clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tunsigned long flags;\n\n\tmutex_lock(&clocksource_mutex);\n\tclocksource_watchdog_lock(&flags);\n\t__clocksource_change_rating(cs, rating);\n\tclocksource_watchdog_unlock(&flags);\n\n\tclocksource_select();\n\tclocksource_select_watchdog(false);\n\tclocksource_suspend_select(false);\n\tmutex_unlock(&clocksource_mutex);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(clocksource_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_suspend_select",
          "args": [
            "false"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_suspend_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "506-521",
          "snippet": "static void clocksource_suspend_select(bool fallback)\n{\n\tstruct clocksource *cs, *old_suspend;\n\n\told_suspend = suspend_clocksource;\n\tif (fallback)\n\t\tsuspend_clocksource = NULL;\n\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\t/* Skip current if we were requested for a fallback. */\n\t\tif (fallback && cs == old_suspend)\n\t\t\tcontinue;\n\n\t\t__clocksource_suspend_select(cs);\n\t}\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;",
            "static LIST_HEAD(clocksource_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic LIST_HEAD(clocksource_list);\n\nstatic void clocksource_suspend_select(bool fallback)\n{\n\tstruct clocksource *cs, *old_suspend;\n\n\told_suspend = suspend_clocksource;\n\tif (fallback)\n\t\tsuspend_clocksource = NULL;\n\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\t/* Skip current if we were requested for a fallback. */\n\t\tif (fallback && cs == old_suspend)\n\t\t\tcontinue;\n\n\t\t__clocksource_suspend_select(cs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_select_watchdog",
          "args": [
            "false"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_select_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "462-462",
          "snippet": "static void clocksource_select_watchdog(bool fallback) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_select_watchdog(bool fallback) { }"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_select",
          "args": [],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_select_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "814-814",
          "snippet": "static inline void clocksource_select_fallback(void) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_select_fallback(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_watchdog_unlock",
          "args": [
            "&flags"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_watchdog_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "470-470",
          "snippet": "static inline void clocksource_watchdog_unlock(unsigned long *flags) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_watchdog_unlock(unsigned long *flags) { }"
        }
      },
      {
        "call_info": {
          "callee": "__clocksource_change_rating",
          "args": [
            "cs",
            "rating"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_change_rating",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "961-966",
          "snippet": "static void __clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tlist_del(&cs->list);\n\tcs->rating = rating;\n\tclocksource_enqueue(cs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void __clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tlist_del(&cs->list);\n\tcs->rating = rating;\n\tclocksource_enqueue(cs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_watchdog_lock",
          "args": [
            "&flags"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_watchdog_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "469-469",
          "snippet": "static inline void clocksource_watchdog_lock(unsigned long *flags) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_watchdog_lock(unsigned long *flags) { }"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(clocksource_mutex);\n\nvoid clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tunsigned long flags;\n\n\tmutex_lock(&clocksource_mutex);\n\tclocksource_watchdog_lock(&flags);\n\t__clocksource_change_rating(cs, rating);\n\tclocksource_watchdog_unlock(&flags);\n\n\tclocksource_select();\n\tclocksource_select_watchdog(false);\n\tclocksource_suspend_select(false);\n\tmutex_unlock(&clocksource_mutex);\n}"
  },
  {
    "function_name": "__clocksource_change_rating",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "961-966",
    "snippet": "static void __clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tlist_del(&cs->list);\n\tcs->rating = rating;\n\tclocksource_enqueue(cs);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clocksource_enqueue",
          "args": [
            "cs"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_enqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "843-855",
          "snippet": "static void clocksource_enqueue(struct clocksource *cs)\n{\n\tstruct list_head *entry = &clocksource_list;\n\tstruct clocksource *tmp;\n\n\tlist_for_each_entry(tmp, &clocksource_list, list) {\n\t\t/* Keep track of the place, where to insert */\n\t\tif (tmp->rating < cs->rating)\n\t\t\tbreak;\n\t\tentry = &tmp->list;\n\t}\n\tlist_add(&cs->list, entry);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clocksource_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\n\nstatic void clocksource_enqueue(struct clocksource *cs)\n{\n\tstruct list_head *entry = &clocksource_list;\n\tstruct clocksource *tmp;\n\n\tlist_for_each_entry(tmp, &clocksource_list, list) {\n\t\t/* Keep track of the place, where to insert */\n\t\tif (tmp->rating < cs->rating)\n\t\t\tbreak;\n\t\tentry = &tmp->list;\n\t}\n\tlist_add(&cs->list, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cs->list"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void __clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tlist_del(&cs->list);\n\tcs->rating = rating;\n\tclocksource_enqueue(cs);\n}"
  },
  {
    "function_name": "__clocksource_register_scale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "936-958",
    "snippet": "int __clocksource_register_scale(struct clocksource *cs, u32 scale, u32 freq)\n{\n\tunsigned long flags;\n\n\tclocksource_arch_init(cs);\n\n\t/* Initialize mult/shift and max_idle_ns */\n\t__clocksource_update_freq_scale(cs, scale, freq);\n\n\t/* Add clocksource to the clocksource list */\n\tmutex_lock(&clocksource_mutex);\n\n\tclocksource_watchdog_lock(&flags);\n\tclocksource_enqueue(cs);\n\tclocksource_enqueue_watchdog(cs);\n\tclocksource_watchdog_unlock(&flags);\n\n\tclocksource_select();\n\tclocksource_select_watchdog(false);\n\t__clocksource_suspend_select(cs);\n\tmutex_unlock(&clocksource_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(clocksource_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clocksource_suspend_select",
          "args": [
            "cs"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_suspend_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "479-500",
          "snippet": "static void __clocksource_suspend_select(struct clocksource *cs)\n{\n\t/*\n\t * Skip the clocksource which will be stopped in suspend state.\n\t */\n\tif (!(cs->flags & CLOCK_SOURCE_SUSPEND_NONSTOP))\n\t\treturn;\n\n\t/*\n\t * The nonstop clocksource can be selected as the suspend clocksource to\n\t * calculate the suspend time, so it should not supply suspend/resume\n\t * interfaces to suspend the nonstop clocksource when system suspends.\n\t */\n\tif (cs->suspend || cs->resume) {\n\t\tpr_warn(\"Nonstop clocksource %s should not supply suspend/resume interfaces\\n\",\n\t\t\tcs->name);\n\t}\n\n\t/* Pick the best rating. */\n\tif (!suspend_clocksource || cs->rating > suspend_clocksource->rating)\n\t\tsuspend_clocksource = cs;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\n\nstatic void __clocksource_suspend_select(struct clocksource *cs)\n{\n\t/*\n\t * Skip the clocksource which will be stopped in suspend state.\n\t */\n\tif (!(cs->flags & CLOCK_SOURCE_SUSPEND_NONSTOP))\n\t\treturn;\n\n\t/*\n\t * The nonstop clocksource can be selected as the suspend clocksource to\n\t * calculate the suspend time, so it should not supply suspend/resume\n\t * interfaces to suspend the nonstop clocksource when system suspends.\n\t */\n\tif (cs->suspend || cs->resume) {\n\t\tpr_warn(\"Nonstop clocksource %s should not supply suspend/resume interfaces\\n\",\n\t\t\tcs->name);\n\t}\n\n\t/* Pick the best rating. */\n\tif (!suspend_clocksource || cs->rating > suspend_clocksource->rating)\n\t\tsuspend_clocksource = cs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_select_watchdog",
          "args": [
            "false"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_select_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "462-462",
          "snippet": "static void clocksource_select_watchdog(bool fallback) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_select_watchdog(bool fallback) { }"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_select",
          "args": [],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_select_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "814-814",
          "snippet": "static inline void clocksource_select_fallback(void) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_select_fallback(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_watchdog_unlock",
          "args": [
            "&flags"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_watchdog_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "470-470",
          "snippet": "static inline void clocksource_watchdog_unlock(unsigned long *flags) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_watchdog_unlock(unsigned long *flags) { }"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_enqueue_watchdog",
          "args": [
            "cs"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_enqueue_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "456-460",
          "snippet": "static void clocksource_enqueue_watchdog(struct clocksource *cs)\n{\n\tif (cs->flags & CLOCK_SOURCE_IS_CONTINUOUS)\n\t\tcs->flags |= CLOCK_SOURCE_VALID_FOR_HRES;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_enqueue_watchdog(struct clocksource *cs)\n{\n\tif (cs->flags & CLOCK_SOURCE_IS_CONTINUOUS)\n\t\tcs->flags |= CLOCK_SOURCE_VALID_FOR_HRES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_enqueue",
          "args": [
            "cs"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_enqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "843-855",
          "snippet": "static void clocksource_enqueue(struct clocksource *cs)\n{\n\tstruct list_head *entry = &clocksource_list;\n\tstruct clocksource *tmp;\n\n\tlist_for_each_entry(tmp, &clocksource_list, list) {\n\t\t/* Keep track of the place, where to insert */\n\t\tif (tmp->rating < cs->rating)\n\t\t\tbreak;\n\t\tentry = &tmp->list;\n\t}\n\tlist_add(&cs->list, entry);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clocksource_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\n\nstatic void clocksource_enqueue(struct clocksource *cs)\n{\n\tstruct list_head *entry = &clocksource_list;\n\tstruct clocksource *tmp;\n\n\tlist_for_each_entry(tmp, &clocksource_list, list) {\n\t\t/* Keep track of the place, where to insert */\n\t\tif (tmp->rating < cs->rating)\n\t\t\tbreak;\n\t\tentry = &tmp->list;\n\t}\n\tlist_add(&cs->list, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_watchdog_lock",
          "args": [
            "&flags"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_watchdog_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "469-469",
          "snippet": "static inline void clocksource_watchdog_lock(unsigned long *flags) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_watchdog_lock(unsigned long *flags) { }"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clocksource_update_freq_scale",
          "args": [
            "cs",
            "scale",
            "freq"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_update_freq_scale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "869-922",
          "snippet": "void __clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq)\n{\n\tu64 sec;\n\n\t/*\n\t * Default clocksources are *special* and self-define their mult/shift.\n\t * But, you're not special, so you should specify a freq value.\n\t */\n\tif (freq) {\n\t\t/*\n\t\t * Calc the maximum number of seconds which we can run before\n\t\t * wrapping around. For clocksources which have a mask > 32-bit\n\t\t * we need to limit the max sleep time to have a good\n\t\t * conversion precision. 10 minutes is still a reasonable\n\t\t * amount. That results in a shift value of 24 for a\n\t\t * clocksource with mask >= 40-bit and f >= 4GHz. That maps to\n\t\t * ~ 0.06ppm granularity for NTP.\n\t\t */\n\t\tsec = cs->mask;\n\t\tdo_div(sec, freq);\n\t\tdo_div(sec, scale);\n\t\tif (!sec)\n\t\t\tsec = 1;\n\t\telse if (sec > 600 && cs->mask > UINT_MAX)\n\t\t\tsec = 600;\n\n\t\tclocks_calc_mult_shift(&cs->mult, &cs->shift, freq,\n\t\t\t\t       NSEC_PER_SEC / scale, sec * scale);\n\t}\n\t/*\n\t * Ensure clocksources that have large 'mult' values don't overflow\n\t * when adjusted.\n\t */\n\tcs->maxadj = clocksource_max_adjustment(cs);\n\twhile (freq && ((cs->mult + cs->maxadj < cs->mult)\n\t\t|| (cs->mult - cs->maxadj > cs->mult))) {\n\t\tcs->mult >>= 1;\n\t\tcs->shift--;\n\t\tcs->maxadj = clocksource_max_adjustment(cs);\n\t}\n\n\t/*\n\t * Only warn for *special* clocksources that self-define\n\t * their mult/shift values and don't specify a freq.\n\t */\n\tWARN_ONCE(cs->mult + cs->maxadj < cs->mult,\n\t\t\"timekeeping: Clocksource %s might overflow on 11%% adjustment\\n\",\n\t\tcs->name);\n\n\tclocksource_update_max_deferment(cs);\n\n\tpr_info(\"%s: mask: 0x%llx max_cycles: 0x%llx, max_idle_ns: %lld ns\\n\",\n\t\tcs->name, cs->mask, cs->max_cycles, cs->max_idle_ns);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nvoid __clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq)\n{\n\tu64 sec;\n\n\t/*\n\t * Default clocksources are *special* and self-define their mult/shift.\n\t * But, you're not special, so you should specify a freq value.\n\t */\n\tif (freq) {\n\t\t/*\n\t\t * Calc the maximum number of seconds which we can run before\n\t\t * wrapping around. For clocksources which have a mask > 32-bit\n\t\t * we need to limit the max sleep time to have a good\n\t\t * conversion precision. 10 minutes is still a reasonable\n\t\t * amount. That results in a shift value of 24 for a\n\t\t * clocksource with mask >= 40-bit and f >= 4GHz. That maps to\n\t\t * ~ 0.06ppm granularity for NTP.\n\t\t */\n\t\tsec = cs->mask;\n\t\tdo_div(sec, freq);\n\t\tdo_div(sec, scale);\n\t\tif (!sec)\n\t\t\tsec = 1;\n\t\telse if (sec > 600 && cs->mask > UINT_MAX)\n\t\t\tsec = 600;\n\n\t\tclocks_calc_mult_shift(&cs->mult, &cs->shift, freq,\n\t\t\t\t       NSEC_PER_SEC / scale, sec * scale);\n\t}\n\t/*\n\t * Ensure clocksources that have large 'mult' values don't overflow\n\t * when adjusted.\n\t */\n\tcs->maxadj = clocksource_max_adjustment(cs);\n\twhile (freq && ((cs->mult + cs->maxadj < cs->mult)\n\t\t|| (cs->mult - cs->maxadj > cs->mult))) {\n\t\tcs->mult >>= 1;\n\t\tcs->shift--;\n\t\tcs->maxadj = clocksource_max_adjustment(cs);\n\t}\n\n\t/*\n\t * Only warn for *special* clocksources that self-define\n\t * their mult/shift values and don't specify a freq.\n\t */\n\tWARN_ONCE(cs->mult + cs->maxadj < cs->mult,\n\t\t\"timekeeping: Clocksource %s might overflow on 11%% adjustment\\n\",\n\t\tcs->name);\n\n\tclocksource_update_max_deferment(cs);\n\n\tpr_info(\"%s: mask: 0x%llx max_cycles: 0x%llx, max_idle_ns: %lld ns\\n\",\n\t\tcs->name, cs->mask, cs->max_cycles, cs->max_idle_ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_arch_init",
          "args": [
            "cs"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(clocksource_mutex);\n\nint __clocksource_register_scale(struct clocksource *cs, u32 scale, u32 freq)\n{\n\tunsigned long flags;\n\n\tclocksource_arch_init(cs);\n\n\t/* Initialize mult/shift and max_idle_ns */\n\t__clocksource_update_freq_scale(cs, scale, freq);\n\n\t/* Add clocksource to the clocksource list */\n\tmutex_lock(&clocksource_mutex);\n\n\tclocksource_watchdog_lock(&flags);\n\tclocksource_enqueue(cs);\n\tclocksource_enqueue_watchdog(cs);\n\tclocksource_watchdog_unlock(&flags);\n\n\tclocksource_select();\n\tclocksource_select_watchdog(false);\n\t__clocksource_suspend_select(cs);\n\tmutex_unlock(&clocksource_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "__clocksource_update_freq_scale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "869-922",
    "snippet": "void __clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq)\n{\n\tu64 sec;\n\n\t/*\n\t * Default clocksources are *special* and self-define their mult/shift.\n\t * But, you're not special, so you should specify a freq value.\n\t */\n\tif (freq) {\n\t\t/*\n\t\t * Calc the maximum number of seconds which we can run before\n\t\t * wrapping around. For clocksources which have a mask > 32-bit\n\t\t * we need to limit the max sleep time to have a good\n\t\t * conversion precision. 10 minutes is still a reasonable\n\t\t * amount. That results in a shift value of 24 for a\n\t\t * clocksource with mask >= 40-bit and f >= 4GHz. That maps to\n\t\t * ~ 0.06ppm granularity for NTP.\n\t\t */\n\t\tsec = cs->mask;\n\t\tdo_div(sec, freq);\n\t\tdo_div(sec, scale);\n\t\tif (!sec)\n\t\t\tsec = 1;\n\t\telse if (sec > 600 && cs->mask > UINT_MAX)\n\t\t\tsec = 600;\n\n\t\tclocks_calc_mult_shift(&cs->mult, &cs->shift, freq,\n\t\t\t\t       NSEC_PER_SEC / scale, sec * scale);\n\t}\n\t/*\n\t * Ensure clocksources that have large 'mult' values don't overflow\n\t * when adjusted.\n\t */\n\tcs->maxadj = clocksource_max_adjustment(cs);\n\twhile (freq && ((cs->mult + cs->maxadj < cs->mult)\n\t\t|| (cs->mult - cs->maxadj > cs->mult))) {\n\t\tcs->mult >>= 1;\n\t\tcs->shift--;\n\t\tcs->maxadj = clocksource_max_adjustment(cs);\n\t}\n\n\t/*\n\t * Only warn for *special* clocksources that self-define\n\t * their mult/shift values and don't specify a freq.\n\t */\n\tWARN_ONCE(cs->mult + cs->maxadj < cs->mult,\n\t\t\"timekeeping: Clocksource %s might overflow on 11%% adjustment\\n\",\n\t\tcs->name);\n\n\tclocksource_update_max_deferment(cs);\n\n\tpr_info(\"%s: mask: 0x%llx max_cycles: 0x%llx, max_idle_ns: %lld ns\\n\",\n\t\tcs->name, cs->mask, cs->max_cycles, cs->max_idle_ns);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: mask: 0x%llx max_cycles: 0x%llx, max_idle_ns: %lld ns\\n\"",
            "cs->name",
            "cs->mask",
            "cs->max_cycles",
            "cs->max_idle_ns"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_update_max_deferment",
          "args": [
            "cs"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_update_max_deferment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "712-717",
          "snippet": "static inline void clocksource_update_max_deferment(struct clocksource *cs)\n{\n\tcs->max_idle_ns = clocks_calc_max_nsecs(cs->mult, cs->shift,\n\t\t\t\t\t\tcs->maxadj, cs->mask,\n\t\t\t\t\t\t&cs->max_cycles);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_update_max_deferment(struct clocksource *cs)\n{\n\tcs->max_idle_ns = clocks_calc_max_nsecs(cs->mult, cs->shift,\n\t\t\t\t\t\tcs->maxadj, cs->mask,\n\t\t\t\t\t\t&cs->max_cycles);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "cs->mult + cs->maxadj < cs->mult",
            "\"timekeeping: Clocksource %s might overflow on 11%% adjustment\\n\"",
            "cs->name"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_max_adjustment",
          "args": [
            "cs"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_max_adjustment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "651-660",
          "snippet": "static u32 clocksource_max_adjustment(struct clocksource *cs)\n{\n\tu64 ret;\n\t/*\n\t * We won't try to correct for more than 11% adjustments (110,000 ppm),\n\t */\n\tret = (u64)cs->mult * 11;\n\tdo_div(ret,100);\n\treturn (u32)ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic u32 clocksource_max_adjustment(struct clocksource *cs)\n{\n\tu64 ret;\n\t/*\n\t * We won't try to correct for more than 11% adjustments (110,000 ppm),\n\t */\n\tret = (u64)cs->mult * 11;\n\tdo_div(ret,100);\n\treturn (u32)ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocks_calc_mult_shift",
          "args": [
            "&cs->mult",
            "&cs->shift",
            "freq",
            "NSEC_PER_SEC / scale",
            "sec * scale"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "clocks_calc_mult_shift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "62-91",
          "snippet": "void\nclocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 maxsec)\n{\n\tu64 tmp;\n\tu32 sft, sftacc= 32;\n\n\t/*\n\t * Calculate the shift factor which is limiting the conversion\n\t * range:\n\t */\n\ttmp = ((u64)maxsec * from) >> 32;\n\twhile (tmp) {\n\t\ttmp >>=1;\n\t\tsftacc--;\n\t}\n\n\t/*\n\t * Find the conversion shift/mult pair which has the best\n\t * accuracy and fits the maxsec conversion range:\n\t */\n\tfor (sft = 32; sft > 0; sft--) {\n\t\ttmp = (u64) to << sft;\n\t\ttmp += from / 2;\n\t\tdo_div(tmp, from);\n\t\tif ((tmp >> sftacc) == 0)\n\t\t\tbreak;\n\t}\n\t*mult = tmp;\n\t*shift = sft;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nvoid\nclocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 maxsec)\n{\n\tu64 tmp;\n\tu32 sft, sftacc= 32;\n\n\t/*\n\t * Calculate the shift factor which is limiting the conversion\n\t * range:\n\t */\n\ttmp = ((u64)maxsec * from) >> 32;\n\twhile (tmp) {\n\t\ttmp >>=1;\n\t\tsftacc--;\n\t}\n\n\t/*\n\t * Find the conversion shift/mult pair which has the best\n\t * accuracy and fits the maxsec conversion range:\n\t */\n\tfor (sft = 32; sft > 0; sft--) {\n\t\ttmp = (u64) to << sft;\n\t\ttmp += from / 2;\n\t\tdo_div(tmp, from);\n\t\tif ((tmp >> sftacc) == 0)\n\t\t\tbreak;\n\t}\n\t*mult = tmp;\n\t*shift = sft;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "sec",
            "scale"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "sec",
            "freq"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nvoid __clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq)\n{\n\tu64 sec;\n\n\t/*\n\t * Default clocksources are *special* and self-define their mult/shift.\n\t * But, you're not special, so you should specify a freq value.\n\t */\n\tif (freq) {\n\t\t/*\n\t\t * Calc the maximum number of seconds which we can run before\n\t\t * wrapping around. For clocksources which have a mask > 32-bit\n\t\t * we need to limit the max sleep time to have a good\n\t\t * conversion precision. 10 minutes is still a reasonable\n\t\t * amount. That results in a shift value of 24 for a\n\t\t * clocksource with mask >= 40-bit and f >= 4GHz. That maps to\n\t\t * ~ 0.06ppm granularity for NTP.\n\t\t */\n\t\tsec = cs->mask;\n\t\tdo_div(sec, freq);\n\t\tdo_div(sec, scale);\n\t\tif (!sec)\n\t\t\tsec = 1;\n\t\telse if (sec > 600 && cs->mask > UINT_MAX)\n\t\t\tsec = 600;\n\n\t\tclocks_calc_mult_shift(&cs->mult, &cs->shift, freq,\n\t\t\t\t       NSEC_PER_SEC / scale, sec * scale);\n\t}\n\t/*\n\t * Ensure clocksources that have large 'mult' values don't overflow\n\t * when adjusted.\n\t */\n\tcs->maxadj = clocksource_max_adjustment(cs);\n\twhile (freq && ((cs->mult + cs->maxadj < cs->mult)\n\t\t|| (cs->mult - cs->maxadj > cs->mult))) {\n\t\tcs->mult >>= 1;\n\t\tcs->shift--;\n\t\tcs->maxadj = clocksource_max_adjustment(cs);\n\t}\n\n\t/*\n\t * Only warn for *special* clocksources that self-define\n\t * their mult/shift values and don't specify a freq.\n\t */\n\tWARN_ONCE(cs->mult + cs->maxadj < cs->mult,\n\t\t\"timekeeping: Clocksource %s might overflow on 11%% adjustment\\n\",\n\t\tcs->name);\n\n\tclocksource_update_max_deferment(cs);\n\n\tpr_info(\"%s: mask: 0x%llx max_cycles: 0x%llx, max_idle_ns: %lld ns\\n\",\n\t\tcs->name, cs->mask, cs->max_cycles, cs->max_idle_ns);\n}"
  },
  {
    "function_name": "clocksource_enqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "843-855",
    "snippet": "static void clocksource_enqueue(struct clocksource *cs)\n{\n\tstruct list_head *entry = &clocksource_list;\n\tstruct clocksource *tmp;\n\n\tlist_for_each_entry(tmp, &clocksource_list, list) {\n\t\t/* Keep track of the place, where to insert */\n\t\tif (tmp->rating < cs->rating)\n\t\t\tbreak;\n\t\tentry = &tmp->list;\n\t}\n\tlist_add(&cs->list, entry);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clocksource_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cs->list",
            "entry"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp",
            "&clocksource_list",
            "list"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\n\nstatic void clocksource_enqueue(struct clocksource *cs)\n{\n\tstruct list_head *entry = &clocksource_list;\n\tstruct clocksource *tmp;\n\n\tlist_for_each_entry(tmp, &clocksource_list, list) {\n\t\t/* Keep track of the place, where to insert */\n\t\tif (tmp->rating < cs->rating)\n\t\t\tbreak;\n\t\tentry = &tmp->list;\n\t}\n\tlist_add(&cs->list, entry);\n}"
  },
  {
    "function_name": "clocksource_done_booting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "825-837",
    "snippet": "static int __init clocksource_done_booting(void)\n{\n\tmutex_lock(&clocksource_mutex);\n\tcurr_clocksource = clocksource_default_clock();\n\tfinished_booting = 1;\n\t/*\n\t * Run the watchdog first to eliminate unstable clock sources\n\t */\n\t__clocksource_watchdog_kthread();\n\tclocksource_select();\n\tmutex_unlock(&clocksource_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *curr_clocksource;",
      "static DEFINE_MUTEX(clocksource_mutex);",
      "static int finished_booting;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_select",
          "args": [],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_select_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "814-814",
          "snippet": "static inline void clocksource_select_fallback(void) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_select_fallback(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "__clocksource_watchdog_kthread",
          "args": [],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_watchdog_kthread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "465-465",
          "snippet": "static inline int __clocksource_watchdog_kthread(void) { return 0; }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline int __clocksource_watchdog_kthread(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_default_clock",
          "args": [],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_default_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/jiffies.c",
          "lines": "103-106",
          "snippet": "__weak clocksource_default_clock(void)\n{\n\treturn &clocksource_jiffies;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource clocksource_jiffies = {\n\t.name\t\t= \"jiffies\",\n\t.rating\t\t= 1, /* lowest valid rating*/\n\t.read\t\t= jiffies_read,\n\t.mask\t\t= CLOCKSOURCE_MASK(32),\n\t.mult\t\t= TICK_NSEC << JIFFIES_SHIFT, /* details above */\n\t.shift\t\t= JIFFIES_SHIFT,\n\t.max_cycles\t= 10,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n\nstatic struct clocksource clocksource_jiffies = {\n\t.name\t\t= \"jiffies\",\n\t.rating\t\t= 1, /* lowest valid rating*/\n\t.read\t\t= jiffies_read,\n\t.mask\t\t= CLOCKSOURCE_MASK(32),\n\t.mult\t\t= TICK_NSEC << JIFFIES_SHIFT, /* details above */\n\t.shift\t\t= JIFFIES_SHIFT,\n\t.max_cycles\t= 10,\n};\n\n__weak clocksource_default_clock(void)\n{\n\treturn &clocksource_jiffies;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\nstatic DEFINE_MUTEX(clocksource_mutex);\nstatic int finished_booting;\n\nstatic int __init clocksource_done_booting(void)\n{\n\tmutex_lock(&clocksource_mutex);\n\tcurr_clocksource = clocksource_default_clock();\n\tfinished_booting = 1;\n\t/*\n\t * Run the watchdog first to eliminate unstable clock sources\n\t */\n\t__clocksource_watchdog_kthread();\n\tclocksource_select();\n\tmutex_unlock(&clocksource_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "clocksource_select_fallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "814-814",
    "snippet": "static inline void clocksource_select_fallback(void) { }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_select_fallback(void) { }"
  },
  {
    "function_name": "clocksource_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "813-813",
    "snippet": "static inline void clocksource_select(void) { }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_select(void) { }"
  },
  {
    "function_name": "clocksource_select_fallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "807-810",
    "snippet": "static void clocksource_select_fallback(void)\n{\n\t__clocksource_select(true);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clocksource_select",
          "args": [
            "true"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "743-792",
          "snippet": "static void __clocksource_select(bool skipcur)\n{\n\tbool oneshot = tick_oneshot_mode_active();\n\tstruct clocksource *best, *cs;\n\n\t/* Find the best suitable clocksource */\n\tbest = clocksource_find_best(oneshot, skipcur);\n\tif (!best)\n\t\treturn;\n\n\tif (!strlen(override_name))\n\t\tgoto found;\n\n\t/* Check for the override clocksource. */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (strcmp(cs->name, override_name) != 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check to make sure we don't switch to a non-highres\n\t\t * capable clocksource if the tick code is in oneshot\n\t\t * mode (highres or nohz)\n\t\t */\n\t\tif (!(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES) && oneshot) {\n\t\t\t/* Override clocksource cannot be used. */\n\t\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\t\tpr_warn(\"Override clocksource %s is unstable and not HRT compatible - cannot switch while in HRT/NOHZ mode\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t\toverride_name[0] = 0;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * The override cannot be currently verified.\n\t\t\t\t * Deferring to let the watchdog check.\n\t\t\t\t */\n\t\t\t\tpr_info(\"Override clocksource %s is not currently HRT compatible - deferring\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t}\n\t\t} else\n\t\t\t/* Override clocksource can be used. */\n\t\t\tbest = cs;\n\t\tbreak;\n\t}\n\nfound:\n\tif (curr_clocksource != best && !timekeeping_notify(best)) {\n\t\tpr_info(\"Switched to clocksource %s\\n\", best->name);\n\t\tcurr_clocksource = best;\n\t}\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *curr_clocksource;",
            "static LIST_HEAD(clocksource_list);",
            "static char override_name[CS_NAME_LEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\nstatic LIST_HEAD(clocksource_list);\nstatic char override_name[CS_NAME_LEN];\n\nstatic void __clocksource_select(bool skipcur)\n{\n\tbool oneshot = tick_oneshot_mode_active();\n\tstruct clocksource *best, *cs;\n\n\t/* Find the best suitable clocksource */\n\tbest = clocksource_find_best(oneshot, skipcur);\n\tif (!best)\n\t\treturn;\n\n\tif (!strlen(override_name))\n\t\tgoto found;\n\n\t/* Check for the override clocksource. */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (strcmp(cs->name, override_name) != 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check to make sure we don't switch to a non-highres\n\t\t * capable clocksource if the tick code is in oneshot\n\t\t * mode (highres or nohz)\n\t\t */\n\t\tif (!(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES) && oneshot) {\n\t\t\t/* Override clocksource cannot be used. */\n\t\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\t\tpr_warn(\"Override clocksource %s is unstable and not HRT compatible - cannot switch while in HRT/NOHZ mode\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t\toverride_name[0] = 0;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * The override cannot be currently verified.\n\t\t\t\t * Deferring to let the watchdog check.\n\t\t\t\t */\n\t\t\t\tpr_info(\"Override clocksource %s is not currently HRT compatible - deferring\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t}\n\t\t} else\n\t\t\t/* Override clocksource can be used. */\n\t\t\tbest = cs;\n\t\tbreak;\n\t}\n\nfound:\n\tif (curr_clocksource != best && !timekeeping_notify(best)) {\n\t\tpr_info(\"Switched to clocksource %s\\n\", best->name);\n\t\tcurr_clocksource = best;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_select_fallback(void)\n{\n\t__clocksource_select(true);\n}"
  },
  {
    "function_name": "clocksource_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "802-805",
    "snippet": "static void clocksource_select(void)\n{\n\t__clocksource_select(false);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clocksource_select",
          "args": [
            "false"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "743-792",
          "snippet": "static void __clocksource_select(bool skipcur)\n{\n\tbool oneshot = tick_oneshot_mode_active();\n\tstruct clocksource *best, *cs;\n\n\t/* Find the best suitable clocksource */\n\tbest = clocksource_find_best(oneshot, skipcur);\n\tif (!best)\n\t\treturn;\n\n\tif (!strlen(override_name))\n\t\tgoto found;\n\n\t/* Check for the override clocksource. */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (strcmp(cs->name, override_name) != 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check to make sure we don't switch to a non-highres\n\t\t * capable clocksource if the tick code is in oneshot\n\t\t * mode (highres or nohz)\n\t\t */\n\t\tif (!(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES) && oneshot) {\n\t\t\t/* Override clocksource cannot be used. */\n\t\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\t\tpr_warn(\"Override clocksource %s is unstable and not HRT compatible - cannot switch while in HRT/NOHZ mode\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t\toverride_name[0] = 0;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * The override cannot be currently verified.\n\t\t\t\t * Deferring to let the watchdog check.\n\t\t\t\t */\n\t\t\t\tpr_info(\"Override clocksource %s is not currently HRT compatible - deferring\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t}\n\t\t} else\n\t\t\t/* Override clocksource can be used. */\n\t\t\tbest = cs;\n\t\tbreak;\n\t}\n\nfound:\n\tif (curr_clocksource != best && !timekeeping_notify(best)) {\n\t\tpr_info(\"Switched to clocksource %s\\n\", best->name);\n\t\tcurr_clocksource = best;\n\t}\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *curr_clocksource;",
            "static LIST_HEAD(clocksource_list);",
            "static char override_name[CS_NAME_LEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\nstatic LIST_HEAD(clocksource_list);\nstatic char override_name[CS_NAME_LEN];\n\nstatic void __clocksource_select(bool skipcur)\n{\n\tbool oneshot = tick_oneshot_mode_active();\n\tstruct clocksource *best, *cs;\n\n\t/* Find the best suitable clocksource */\n\tbest = clocksource_find_best(oneshot, skipcur);\n\tif (!best)\n\t\treturn;\n\n\tif (!strlen(override_name))\n\t\tgoto found;\n\n\t/* Check for the override clocksource. */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (strcmp(cs->name, override_name) != 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check to make sure we don't switch to a non-highres\n\t\t * capable clocksource if the tick code is in oneshot\n\t\t * mode (highres or nohz)\n\t\t */\n\t\tif (!(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES) && oneshot) {\n\t\t\t/* Override clocksource cannot be used. */\n\t\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\t\tpr_warn(\"Override clocksource %s is unstable and not HRT compatible - cannot switch while in HRT/NOHZ mode\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t\toverride_name[0] = 0;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * The override cannot be currently verified.\n\t\t\t\t * Deferring to let the watchdog check.\n\t\t\t\t */\n\t\t\t\tpr_info(\"Override clocksource %s is not currently HRT compatible - deferring\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t}\n\t\t} else\n\t\t\t/* Override clocksource can be used. */\n\t\t\tbest = cs;\n\t\tbreak;\n\t}\n\nfound:\n\tif (curr_clocksource != best && !timekeeping_notify(best)) {\n\t\tpr_info(\"Switched to clocksource %s\\n\", best->name);\n\t\tcurr_clocksource = best;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_select(void)\n{\n\t__clocksource_select(false);\n}"
  },
  {
    "function_name": "__clocksource_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "743-792",
    "snippet": "static void __clocksource_select(bool skipcur)\n{\n\tbool oneshot = tick_oneshot_mode_active();\n\tstruct clocksource *best, *cs;\n\n\t/* Find the best suitable clocksource */\n\tbest = clocksource_find_best(oneshot, skipcur);\n\tif (!best)\n\t\treturn;\n\n\tif (!strlen(override_name))\n\t\tgoto found;\n\n\t/* Check for the override clocksource. */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (strcmp(cs->name, override_name) != 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check to make sure we don't switch to a non-highres\n\t\t * capable clocksource if the tick code is in oneshot\n\t\t * mode (highres or nohz)\n\t\t */\n\t\tif (!(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES) && oneshot) {\n\t\t\t/* Override clocksource cannot be used. */\n\t\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\t\tpr_warn(\"Override clocksource %s is unstable and not HRT compatible - cannot switch while in HRT/NOHZ mode\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t\toverride_name[0] = 0;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * The override cannot be currently verified.\n\t\t\t\t * Deferring to let the watchdog check.\n\t\t\t\t */\n\t\t\t\tpr_info(\"Override clocksource %s is not currently HRT compatible - deferring\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t}\n\t\t} else\n\t\t\t/* Override clocksource can be used. */\n\t\t\tbest = cs;\n\t\tbreak;\n\t}\n\nfound:\n\tif (curr_clocksource != best && !timekeeping_notify(best)) {\n\t\tpr_info(\"Switched to clocksource %s\\n\", best->name);\n\t\tcurr_clocksource = best;\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *curr_clocksource;",
      "static LIST_HEAD(clocksource_list);",
      "static char override_name[CS_NAME_LEN];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Switched to clocksource %s\\n\"",
            "best->name"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_notify",
          "args": [
            "best"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1395-1404",
          "snippet": "int timekeeping_notify(struct clocksource *clock)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tif (tk->tkr_mono.clock == clock)\n\t\treturn 0;\n\tstop_machine(change_clocksource, clock, NULL);\n\ttick_clock_notify();\n\treturn tk->tkr_mono.clock == clock ? 0 : -1;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nint timekeeping_notify(struct clocksource *clock)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tif (tk->tkr_mono.clock == clock)\n\t\treturn 0;\n\tstop_machine(change_clocksource, clock, NULL);\n\ttick_clock_notify();\n\treturn tk->tkr_mono.clock == clock ? 0 : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Override clocksource %s is not currently HRT compatible - deferring\\n\"",
            "cs->name"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Override clocksource %s is unstable and not HRT compatible - cannot switch while in HRT/NOHZ mode\\n\"",
            "cs->name"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cs->name",
            "override_name"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cs",
            "&clocksource_list",
            "list"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "override_name"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_find_best",
          "args": [
            "oneshot",
            "skipcur"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_find_best",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "721-741",
          "snippet": "static struct clocksource *clocksource_find_best(bool oneshot, bool skipcur)\n{\n\tstruct clocksource *cs;\n\n\tif (!finished_booting || list_empty(&clocksource_list))\n\t\treturn NULL;\n\n\t/*\n\t * We pick the clocksource with the highest rating. If oneshot\n\t * mode is active, we pick the highres valid clocksource with\n\t * the best rating.\n\t */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (oneshot && !(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES))\n\t\t\tcontinue;\n\t\treturn cs;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *curr_clocksource;",
            "static LIST_HEAD(clocksource_list);",
            "static int finished_booting;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\nstatic LIST_HEAD(clocksource_list);\nstatic int finished_booting;\n\nstatic struct clocksource *clocksource_find_best(bool oneshot, bool skipcur)\n{\n\tstruct clocksource *cs;\n\n\tif (!finished_booting || list_empty(&clocksource_list))\n\t\treturn NULL;\n\n\t/*\n\t * We pick the clocksource with the highest rating. If oneshot\n\t * mode is active, we pick the highres valid clocksource with\n\t * the best rating.\n\t */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (oneshot && !(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES))\n\t\t\tcontinue;\n\t\treturn cs;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_oneshot_mode_active",
          "args": [],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "tick_oneshot_mode_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-oneshot.c",
          "lines": "110-120",
          "snippet": "int tick_oneshot_mode_active(void)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = __this_cpu_read(tick_cpu_device.mode) == TICKDEV_MODE_ONESHOT;\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nint tick_oneshot_mode_active(void)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = __this_cpu_read(tick_cpu_device.mode) == TICKDEV_MODE_ONESHOT;\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\nstatic LIST_HEAD(clocksource_list);\nstatic char override_name[CS_NAME_LEN];\n\nstatic void __clocksource_select(bool skipcur)\n{\n\tbool oneshot = tick_oneshot_mode_active();\n\tstruct clocksource *best, *cs;\n\n\t/* Find the best suitable clocksource */\n\tbest = clocksource_find_best(oneshot, skipcur);\n\tif (!best)\n\t\treturn;\n\n\tif (!strlen(override_name))\n\t\tgoto found;\n\n\t/* Check for the override clocksource. */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (strcmp(cs->name, override_name) != 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Check to make sure we don't switch to a non-highres\n\t\t * capable clocksource if the tick code is in oneshot\n\t\t * mode (highres or nohz)\n\t\t */\n\t\tif (!(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES) && oneshot) {\n\t\t\t/* Override clocksource cannot be used. */\n\t\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\t\tpr_warn(\"Override clocksource %s is unstable and not HRT compatible - cannot switch while in HRT/NOHZ mode\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t\toverride_name[0] = 0;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * The override cannot be currently verified.\n\t\t\t\t * Deferring to let the watchdog check.\n\t\t\t\t */\n\t\t\t\tpr_info(\"Override clocksource %s is not currently HRT compatible - deferring\\n\",\n\t\t\t\t\tcs->name);\n\t\t\t}\n\t\t} else\n\t\t\t/* Override clocksource can be used. */\n\t\t\tbest = cs;\n\t\tbreak;\n\t}\n\nfound:\n\tif (curr_clocksource != best && !timekeeping_notify(best)) {\n\t\tpr_info(\"Switched to clocksource %s\\n\", best->name);\n\t\tcurr_clocksource = best;\n\t}\n}"
  },
  {
    "function_name": "clocksource_find_best",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "721-741",
    "snippet": "static struct clocksource *clocksource_find_best(bool oneshot, bool skipcur)\n{\n\tstruct clocksource *cs;\n\n\tif (!finished_booting || list_empty(&clocksource_list))\n\t\treturn NULL;\n\n\t/*\n\t * We pick the clocksource with the highest rating. If oneshot\n\t * mode is active, we pick the highres valid clocksource with\n\t * the best rating.\n\t */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (oneshot && !(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES))\n\t\t\tcontinue;\n\t\treturn cs;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *curr_clocksource;",
      "static LIST_HEAD(clocksource_list);",
      "static int finished_booting;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cs",
            "&clocksource_list",
            "list"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clocksource_list"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *curr_clocksource;\nstatic LIST_HEAD(clocksource_list);\nstatic int finished_booting;\n\nstatic struct clocksource *clocksource_find_best(bool oneshot, bool skipcur)\n{\n\tstruct clocksource *cs;\n\n\tif (!finished_booting || list_empty(&clocksource_list))\n\t\treturn NULL;\n\n\t/*\n\t * We pick the clocksource with the highest rating. If oneshot\n\t * mode is active, we pick the highres valid clocksource with\n\t * the best rating.\n\t */\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (oneshot && !(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES))\n\t\t\tcontinue;\n\t\treturn cs;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "clocksource_update_max_deferment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "712-717",
    "snippet": "static inline void clocksource_update_max_deferment(struct clocksource *cs)\n{\n\tcs->max_idle_ns = clocks_calc_max_nsecs(cs->mult, cs->shift,\n\t\t\t\t\t\tcs->maxadj, cs->mask,\n\t\t\t\t\t\t&cs->max_cycles);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clocks_calc_max_nsecs",
          "args": [
            "cs->mult",
            "cs->shift",
            "cs->maxadj",
            "cs->mask",
            "&cs->max_cycles"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "clocks_calc_max_nsecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "677-705",
          "snippet": "u64 clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 *max_cyc)\n{\n\tu64 max_nsecs, max_cycles;\n\n\t/*\n\t * Calculate the maximum number of cycles that we can pass to the\n\t * cyc2ns() function without overflowing a 64-bit result.\n\t */\n\tmax_cycles = ULLONG_MAX;\n\tdo_div(max_cycles, mult+maxadj);\n\n\t/*\n\t * The actual maximum number of cycles we can defer the clocksource is\n\t * determined by the minimum of max_cycles and mask.\n\t * Note: Here we subtract the maxadj to make sure we don't sleep for\n\t * too long if there's a large negative adjustment.\n\t */\n\tmax_cycles = min(max_cycles, mask);\n\tmax_nsecs = clocksource_cyc2ns(max_cycles, mult - maxadj, shift);\n\n\t/* return the max_cycles value as well if requested */\n\tif (max_cyc)\n\t\t*max_cyc = max_cycles;\n\n\t/* Return 50% of the actual maximum, so we can detect bad values */\n\tmax_nsecs >>= 1;\n\n\treturn max_nsecs;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nu64 clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 *max_cyc)\n{\n\tu64 max_nsecs, max_cycles;\n\n\t/*\n\t * Calculate the maximum number of cycles that we can pass to the\n\t * cyc2ns() function without overflowing a 64-bit result.\n\t */\n\tmax_cycles = ULLONG_MAX;\n\tdo_div(max_cycles, mult+maxadj);\n\n\t/*\n\t * The actual maximum number of cycles we can defer the clocksource is\n\t * determined by the minimum of max_cycles and mask.\n\t * Note: Here we subtract the maxadj to make sure we don't sleep for\n\t * too long if there's a large negative adjustment.\n\t */\n\tmax_cycles = min(max_cycles, mask);\n\tmax_nsecs = clocksource_cyc2ns(max_cycles, mult - maxadj, shift);\n\n\t/* return the max_cycles value as well if requested */\n\tif (max_cyc)\n\t\t*max_cyc = max_cycles;\n\n\t/* Return 50% of the actual maximum, so we can detect bad values */\n\tmax_nsecs >>= 1;\n\n\treturn max_nsecs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_update_max_deferment(struct clocksource *cs)\n{\n\tcs->max_idle_ns = clocks_calc_max_nsecs(cs->mult, cs->shift,\n\t\t\t\t\t\tcs->maxadj, cs->mask,\n\t\t\t\t\t\t&cs->max_cycles);\n}"
  },
  {
    "function_name": "clocks_calc_max_nsecs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "677-705",
    "snippet": "u64 clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 *max_cyc)\n{\n\tu64 max_nsecs, max_cycles;\n\n\t/*\n\t * Calculate the maximum number of cycles that we can pass to the\n\t * cyc2ns() function without overflowing a 64-bit result.\n\t */\n\tmax_cycles = ULLONG_MAX;\n\tdo_div(max_cycles, mult+maxadj);\n\n\t/*\n\t * The actual maximum number of cycles we can defer the clocksource is\n\t * determined by the minimum of max_cycles and mask.\n\t * Note: Here we subtract the maxadj to make sure we don't sleep for\n\t * too long if there's a large negative adjustment.\n\t */\n\tmax_cycles = min(max_cycles, mask);\n\tmax_nsecs = clocksource_cyc2ns(max_cycles, mult - maxadj, shift);\n\n\t/* return the max_cycles value as well if requested */\n\tif (max_cyc)\n\t\t*max_cyc = max_cycles;\n\n\t/* Return 50% of the actual maximum, so we can detect bad values */\n\tmax_nsecs >>= 1;\n\n\treturn max_nsecs;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clocksource_cyc2ns",
          "args": [
            "max_cycles",
            "mult - maxadj",
            "shift"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "max_cycles",
            "mask"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_stop_suspend_timing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "574-606",
          "snippet": "u64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;",
            "static u64 suspend_start;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic u64 suspend_start;\n\nu64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "max_cycles",
            "mult+maxadj"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nu64 clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 *max_cyc)\n{\n\tu64 max_nsecs, max_cycles;\n\n\t/*\n\t * Calculate the maximum number of cycles that we can pass to the\n\t * cyc2ns() function without overflowing a 64-bit result.\n\t */\n\tmax_cycles = ULLONG_MAX;\n\tdo_div(max_cycles, mult+maxadj);\n\n\t/*\n\t * The actual maximum number of cycles we can defer the clocksource is\n\t * determined by the minimum of max_cycles and mask.\n\t * Note: Here we subtract the maxadj to make sure we don't sleep for\n\t * too long if there's a large negative adjustment.\n\t */\n\tmax_cycles = min(max_cycles, mask);\n\tmax_nsecs = clocksource_cyc2ns(max_cycles, mult - maxadj, shift);\n\n\t/* return the max_cycles value as well if requested */\n\tif (max_cyc)\n\t\t*max_cyc = max_cycles;\n\n\t/* Return 50% of the actual maximum, so we can detect bad values */\n\tmax_nsecs >>= 1;\n\n\treturn max_nsecs;\n}"
  },
  {
    "function_name": "clocksource_max_adjustment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "651-660",
    "snippet": "static u32 clocksource_max_adjustment(struct clocksource *cs)\n{\n\tu64 ret;\n\t/*\n\t * We won't try to correct for more than 11% adjustments (110,000 ppm),\n\t */\n\tret = (u64)cs->mult * 11;\n\tdo_div(ret,100);\n\treturn (u32)ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "ret",
            "100"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic u32 clocksource_max_adjustment(struct clocksource *cs)\n{\n\tu64 ret;\n\t/*\n\t * We won't try to correct for more than 11% adjustments (110,000 ppm),\n\t */\n\tret = (u64)cs->mult * 11;\n\tdo_div(ret,100);\n\treturn (u32)ret;\n}"
  },
  {
    "function_name": "clocksource_touch_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "641-644",
    "snippet": "void clocksource_touch_watchdog(void)\n{\n\tclocksource_resume_watchdog();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clocksource_resume_watchdog",
          "args": [],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_resume_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "464-464",
          "snippet": "static inline void clocksource_resume_watchdog(void) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_resume_watchdog(void) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nvoid clocksource_touch_watchdog(void)\n{\n\tclocksource_resume_watchdog();\n}"
  },
  {
    "function_name": "clocksource_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "623-632",
    "snippet": "void clocksource_resume(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &clocksource_list, list)\n\t\tif (cs->resume)\n\t\t\tcs->resume(cs);\n\n\tclocksource_resume_watchdog();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clocksource_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clocksource_resume_watchdog",
          "args": [],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_resume_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "464-464",
          "snippet": "static inline void clocksource_resume_watchdog(void) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_resume_watchdog(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "cs->resume",
          "args": [
            "cs"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cs",
            "&clocksource_list",
            "list"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\n\nvoid clocksource_resume(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &clocksource_list, list)\n\t\tif (cs->resume)\n\t\t\tcs->resume(cs);\n\n\tclocksource_resume_watchdog();\n}"
  },
  {
    "function_name": "clocksource_suspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "611-618",
    "snippet": "void clocksource_suspend(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry_reverse(cs, &clocksource_list, list)\n\t\tif (cs->suspend)\n\t\t\tcs->suspend(cs);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clocksource_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cs->suspend",
          "args": [
            "cs"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_reverse",
          "args": [
            "cs",
            "&clocksource_list",
            "list"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\n\nvoid clocksource_suspend(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry_reverse(cs, &clocksource_list, list)\n\t\tif (cs->suspend)\n\t\t\tcs->suspend(cs);\n}"
  },
  {
    "function_name": "clocksource_stop_suspend_timing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "574-606",
    "snippet": "u64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *suspend_clocksource;",
      "static u64 suspend_start;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "suspend_clocksource->disable",
          "args": [
            "suspend_clocksource"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_is_suspend",
          "args": [
            "cs"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_is_suspend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "474-477",
          "snippet": "static bool clocksource_is_suspend(struct clocksource *cs)\n{\n\treturn cs == suspend_clocksource;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\n\nstatic bool clocksource_is_suspend(struct clocksource *cs)\n{\n\treturn cs == suspend_clocksource;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mul_u64_u32_shr",
          "args": [
            "delta",
            "suspend_clocksource->mult",
            "suspend_clocksource->shift"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "now",
            "suspend_start",
            "suspend_clocksource->mask"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping_internal.h",
          "lines": "28-31",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "suspend_clocksource->read",
          "args": [
            "suspend_clocksource"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic u64 suspend_start;\n\nu64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}"
  },
  {
    "function_name": "clocksource_start_suspend_timing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "536-558",
    "snippet": "void clocksource_start_suspend_timing(struct clocksource *cs, u64 start_cycles)\n{\n\tif (!suspend_clocksource)\n\t\treturn;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value as suspend_start to avoid same reading\n\t * from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs)) {\n\t\tsuspend_start = start_cycles;\n\t\treturn;\n\t}\n\n\tif (suspend_clocksource->enable &&\n\t    suspend_clocksource->enable(suspend_clocksource)) {\n\t\tpr_warn_once(\"Failed to enable the non-suspend-able clocksource.\\n\");\n\t\treturn;\n\t}\n\n\tsuspend_start = suspend_clocksource->read(suspend_clocksource);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *suspend_clocksource;",
      "static u64 suspend_start;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "suspend_clocksource->read",
          "args": [
            "suspend_clocksource"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"Failed to enable the non-suspend-able clocksource.\\n\""
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suspend_clocksource->enable",
          "args": [
            "suspend_clocksource"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_is_suspend",
          "args": [
            "cs"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_is_suspend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "474-477",
          "snippet": "static bool clocksource_is_suspend(struct clocksource *cs)\n{\n\treturn cs == suspend_clocksource;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\n\nstatic bool clocksource_is_suspend(struct clocksource *cs)\n{\n\treturn cs == suspend_clocksource;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic u64 suspend_start;\n\nvoid clocksource_start_suspend_timing(struct clocksource *cs, u64 start_cycles)\n{\n\tif (!suspend_clocksource)\n\t\treturn;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value as suspend_start to avoid same reading\n\t * from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs)) {\n\t\tsuspend_start = start_cycles;\n\t\treturn;\n\t}\n\n\tif (suspend_clocksource->enable &&\n\t    suspend_clocksource->enable(suspend_clocksource)) {\n\t\tpr_warn_once(\"Failed to enable the non-suspend-able clocksource.\\n\");\n\t\treturn;\n\t}\n\n\tsuspend_start = suspend_clocksource->read(suspend_clocksource);\n}"
  },
  {
    "function_name": "clocksource_suspend_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "506-521",
    "snippet": "static void clocksource_suspend_select(bool fallback)\n{\n\tstruct clocksource *cs, *old_suspend;\n\n\told_suspend = suspend_clocksource;\n\tif (fallback)\n\t\tsuspend_clocksource = NULL;\n\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\t/* Skip current if we were requested for a fallback. */\n\t\tif (fallback && cs == old_suspend)\n\t\t\tcontinue;\n\n\t\t__clocksource_suspend_select(cs);\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *suspend_clocksource;",
      "static LIST_HEAD(clocksource_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clocksource_suspend_select",
          "args": [
            "cs"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_suspend_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "479-500",
          "snippet": "static void __clocksource_suspend_select(struct clocksource *cs)\n{\n\t/*\n\t * Skip the clocksource which will be stopped in suspend state.\n\t */\n\tif (!(cs->flags & CLOCK_SOURCE_SUSPEND_NONSTOP))\n\t\treturn;\n\n\t/*\n\t * The nonstop clocksource can be selected as the suspend clocksource to\n\t * calculate the suspend time, so it should not supply suspend/resume\n\t * interfaces to suspend the nonstop clocksource when system suspends.\n\t */\n\tif (cs->suspend || cs->resume) {\n\t\tpr_warn(\"Nonstop clocksource %s should not supply suspend/resume interfaces\\n\",\n\t\t\tcs->name);\n\t}\n\n\t/* Pick the best rating. */\n\tif (!suspend_clocksource || cs->rating > suspend_clocksource->rating)\n\t\tsuspend_clocksource = cs;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\n\nstatic void __clocksource_suspend_select(struct clocksource *cs)\n{\n\t/*\n\t * Skip the clocksource which will be stopped in suspend state.\n\t */\n\tif (!(cs->flags & CLOCK_SOURCE_SUSPEND_NONSTOP))\n\t\treturn;\n\n\t/*\n\t * The nonstop clocksource can be selected as the suspend clocksource to\n\t * calculate the suspend time, so it should not supply suspend/resume\n\t * interfaces to suspend the nonstop clocksource when system suspends.\n\t */\n\tif (cs->suspend || cs->resume) {\n\t\tpr_warn(\"Nonstop clocksource %s should not supply suspend/resume interfaces\\n\",\n\t\t\tcs->name);\n\t}\n\n\t/* Pick the best rating. */\n\tif (!suspend_clocksource || cs->rating > suspend_clocksource->rating)\n\t\tsuspend_clocksource = cs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cs",
            "&clocksource_list",
            "list"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic LIST_HEAD(clocksource_list);\n\nstatic void clocksource_suspend_select(bool fallback)\n{\n\tstruct clocksource *cs, *old_suspend;\n\n\told_suspend = suspend_clocksource;\n\tif (fallback)\n\t\tsuspend_clocksource = NULL;\n\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\t/* Skip current if we were requested for a fallback. */\n\t\tif (fallback && cs == old_suspend)\n\t\t\tcontinue;\n\n\t\t__clocksource_suspend_select(cs);\n\t}\n}"
  },
  {
    "function_name": "__clocksource_suspend_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "479-500",
    "snippet": "static void __clocksource_suspend_select(struct clocksource *cs)\n{\n\t/*\n\t * Skip the clocksource which will be stopped in suspend state.\n\t */\n\tif (!(cs->flags & CLOCK_SOURCE_SUSPEND_NONSTOP))\n\t\treturn;\n\n\t/*\n\t * The nonstop clocksource can be selected as the suspend clocksource to\n\t * calculate the suspend time, so it should not supply suspend/resume\n\t * interfaces to suspend the nonstop clocksource when system suspends.\n\t */\n\tif (cs->suspend || cs->resume) {\n\t\tpr_warn(\"Nonstop clocksource %s should not supply suspend/resume interfaces\\n\",\n\t\t\tcs->name);\n\t}\n\n\t/* Pick the best rating. */\n\tif (!suspend_clocksource || cs->rating > suspend_clocksource->rating)\n\t\tsuspend_clocksource = cs;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *suspend_clocksource;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Nonstop clocksource %s should not supply suspend/resume interfaces\\n\"",
            "cs->name"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\n\nstatic void __clocksource_suspend_select(struct clocksource *cs)\n{\n\t/*\n\t * Skip the clocksource which will be stopped in suspend state.\n\t */\n\tif (!(cs->flags & CLOCK_SOURCE_SUSPEND_NONSTOP))\n\t\treturn;\n\n\t/*\n\t * The nonstop clocksource can be selected as the suspend clocksource to\n\t * calculate the suspend time, so it should not supply suspend/resume\n\t * interfaces to suspend the nonstop clocksource when system suspends.\n\t */\n\tif (cs->suspend || cs->resume) {\n\t\tpr_warn(\"Nonstop clocksource %s should not supply suspend/resume interfaces\\n\",\n\t\t\tcs->name);\n\t}\n\n\t/* Pick the best rating. */\n\tif (!suspend_clocksource || cs->rating > suspend_clocksource->rating)\n\t\tsuspend_clocksource = cs;\n}"
  },
  {
    "function_name": "clocksource_is_suspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "474-477",
    "snippet": "static bool clocksource_is_suspend(struct clocksource *cs)\n{\n\treturn cs == suspend_clocksource;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clocksource *suspend_clocksource;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\n\nstatic bool clocksource_is_suspend(struct clocksource *cs)\n{\n\treturn cs == suspend_clocksource;\n}"
  },
  {
    "function_name": "clocksource_watchdog_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "470-470",
    "snippet": "static inline void clocksource_watchdog_unlock(unsigned long *flags) { }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_watchdog_unlock(unsigned long *flags) { }"
  },
  {
    "function_name": "clocksource_watchdog_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "469-469",
    "snippet": "static inline void clocksource_watchdog_lock(unsigned long *flags) { }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_watchdog_lock(unsigned long *flags) { }"
  },
  {
    "function_name": "clocksource_mark_unstable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "467-467",
    "snippet": "void clocksource_mark_unstable(struct clocksource *cs) { }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nvoid clocksource_mark_unstable(struct clocksource *cs) { }"
  },
  {
    "function_name": "clocksource_is_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "466-466",
    "snippet": "static bool clocksource_is_watchdog(struct clocksource *cs) { return false; }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic bool clocksource_is_watchdog(struct clocksource *cs) { return false; }"
  },
  {
    "function_name": "__clocksource_watchdog_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "465-465",
    "snippet": "static inline int __clocksource_watchdog_kthread(void) { return 0; }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline int __clocksource_watchdog_kthread(void) { return 0; }"
  },
  {
    "function_name": "clocksource_resume_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "464-464",
    "snippet": "static inline void clocksource_resume_watchdog(void) { }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_resume_watchdog(void) { }"
  },
  {
    "function_name": "clocksource_dequeue_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "463-463",
    "snippet": "static inline void clocksource_dequeue_watchdog(struct clocksource *cs) { }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_dequeue_watchdog(struct clocksource *cs) { }"
  },
  {
    "function_name": "clocksource_select_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "462-462",
    "snippet": "static void clocksource_select_watchdog(bool fallback) { }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_select_watchdog(bool fallback) { }"
  },
  {
    "function_name": "clocksource_enqueue_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "456-460",
    "snippet": "static void clocksource_enqueue_watchdog(struct clocksource *cs)\n{\n\tif (cs->flags & CLOCK_SOURCE_IS_CONTINUOUS)\n\t\tcs->flags |= CLOCK_SOURCE_VALID_FOR_HRES;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_enqueue_watchdog(struct clocksource *cs)\n{\n\tif (cs->flags & CLOCK_SOURCE_IS_CONTINUOUS)\n\t\tcs->flags |= CLOCK_SOURCE_VALID_FOR_HRES;\n}"
  },
  {
    "function_name": "clocksource_is_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "449-452",
    "snippet": "static bool clocksource_is_watchdog(struct clocksource *cs)\n{\n\treturn cs == watchdog;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic bool clocksource_is_watchdog(struct clocksource *cs)\n{\n\treturn cs == watchdog;\n}"
  },
  {
    "function_name": "clocksource_watchdog_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "440-447",
    "snippet": "static int clocksource_watchdog_kthread(void *data)\n{\n\tmutex_lock(&clocksource_mutex);\n\tif (__clocksource_watchdog_kthread())\n\t\tclocksource_select();\n\tmutex_unlock(&clocksource_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(clocksource_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_select",
          "args": [],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_select_fallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "814-814",
          "snippet": "static inline void clocksource_select_fallback(void) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_select_fallback(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "__clocksource_watchdog_kthread",
          "args": [],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_watchdog_kthread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "465-465",
          "snippet": "static inline int __clocksource_watchdog_kthread(void) { return 0; }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline int __clocksource_watchdog_kthread(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clocksource_mutex"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic DEFINE_MUTEX(clocksource_mutex);\n\nstatic int clocksource_watchdog_kthread(void *data)\n{\n\tmutex_lock(&clocksource_mutex);\n\tif (__clocksource_watchdog_kthread())\n\t\tclocksource_select();\n\tmutex_unlock(&clocksource_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "__clocksource_watchdog_kthread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "415-438",
    "snippet": "static int __clocksource_watchdog_kthread(void)\n{\n\tstruct clocksource *cs, *tmp;\n\tunsigned long flags;\n\tint select = 0;\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\tlist_for_each_entry_safe(cs, tmp, &watchdog_list, wd_list) {\n\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\tlist_del_init(&cs->wd_list);\n\t\t\t__clocksource_change_rating(cs, 0);\n\t\t\tselect = 1;\n\t\t}\n\t\tif (cs->flags & CLOCK_SOURCE_RESELECT) {\n\t\t\tcs->flags &= ~CLOCK_SOURCE_RESELECT;\n\t\t\tselect = 1;\n\t\t}\n\t}\n\t/* Check if the watchdog timer needs to be stopped. */\n\tclocksource_stop_watchdog();\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n\n\treturn select;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&watchdog_lock",
            "flags"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_stop_watchdog",
          "args": [],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_stop_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "330-336",
          "snippet": "static inline void clocksource_stop_watchdog(void)\n{\n\tif (!watchdog_running || (watchdog && !list_empty(&watchdog_list)))\n\t\treturn;\n\tdel_timer(&watchdog_timer);\n\twatchdog_running = 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_stop_watchdog(void)\n{\n\tif (!watchdog_running || (watchdog && !list_empty(&watchdog_list)))\n\t\treturn;\n\tdel_timer(&watchdog_timer);\n\twatchdog_running = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clocksource_change_rating",
          "args": [
            "cs",
            "0"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_change_rating",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "961-966",
          "snippet": "static void __clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tlist_del(&cs->list);\n\tcs->rating = rating;\n\tclocksource_enqueue(cs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void __clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tlist_del(&cs->list);\n\tcs->rating = rating;\n\tclocksource_enqueue(cs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cs->wd_list"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "cs",
            "tmp",
            "&watchdog_list",
            "wd_list"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&watchdog_lock",
            "flags"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic int __clocksource_watchdog_kthread(void)\n{\n\tstruct clocksource *cs, *tmp;\n\tunsigned long flags;\n\tint select = 0;\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\tlist_for_each_entry_safe(cs, tmp, &watchdog_list, wd_list) {\n\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\tlist_del_init(&cs->wd_list);\n\t\t\t__clocksource_change_rating(cs, 0);\n\t\t\tselect = 1;\n\t\t}\n\t\tif (cs->flags & CLOCK_SOURCE_RESELECT) {\n\t\t\tcs->flags &= ~CLOCK_SOURCE_RESELECT;\n\t\t\tselect = 1;\n\t\t}\n\t}\n\t/* Check if the watchdog timer needs to be stopped. */\n\tclocksource_stop_watchdog();\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n\n\treturn select;\n}"
  },
  {
    "function_name": "clocksource_dequeue_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "403-413",
    "snippet": "static void clocksource_dequeue_watchdog(struct clocksource *cs)\n{\n\tif (cs != watchdog) {\n\t\tif (cs->flags & CLOCK_SOURCE_MUST_VERIFY) {\n\t\t\t/* cs is a watched clocksource. */\n\t\t\tlist_del_init(&cs->wd_list);\n\t\t\t/* Check if the watchdog timer needs to be stopped. */\n\t\t\tclocksource_stop_watchdog();\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clocksource_stop_watchdog",
          "args": [],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_stop_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "330-336",
          "snippet": "static inline void clocksource_stop_watchdog(void)\n{\n\tif (!watchdog_running || (watchdog && !list_empty(&watchdog_list)))\n\t\treturn;\n\tdel_timer(&watchdog_timer);\n\twatchdog_running = 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_stop_watchdog(void)\n{\n\tif (!watchdog_running || (watchdog && !list_empty(&watchdog_list)))\n\t\treturn;\n\tdel_timer(&watchdog_timer);\n\twatchdog_running = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cs->wd_list"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_dequeue_watchdog(struct clocksource *cs)\n{\n\tif (cs != watchdog) {\n\t\tif (cs->flags & CLOCK_SOURCE_MUST_VERIFY) {\n\t\t\t/* cs is a watched clocksource. */\n\t\t\tlist_del_init(&cs->wd_list);\n\t\t\t/* Check if the watchdog timer needs to be stopped. */\n\t\t\tclocksource_stop_watchdog();\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "clocksource_select_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "366-401",
    "snippet": "static void clocksource_select_watchdog(bool fallback)\n{\n\tstruct clocksource *cs, *old_wd;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\t/* save current watchdog */\n\told_wd = watchdog;\n\tif (fallback)\n\t\twatchdog = NULL;\n\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\t/* cs is a clocksource to be watched. */\n\t\tif (cs->flags & CLOCK_SOURCE_MUST_VERIFY)\n\t\t\tcontinue;\n\n\t\t/* Skip current if we were requested for a fallback. */\n\t\tif (fallback && cs == old_wd)\n\t\t\tcontinue;\n\n\t\t/* Pick the best watchdog. */\n\t\tif (!watchdog || cs->rating > watchdog->rating)\n\t\t\twatchdog = cs;\n\t}\n\t/* If we failed to find a fallback restore the old one. */\n\tif (!watchdog)\n\t\twatchdog = old_wd;\n\n\t/* If we changed the watchdog we need to reset cycles. */\n\tif (watchdog != old_wd)\n\t\tclocksource_reset_watchdog();\n\n\t/* Check if the watchdog timer needs to be started. */\n\tclocksource_start_watchdog();\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clocksource_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&watchdog_lock",
            "flags"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_start_watchdog",
          "args": [],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_start_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "320-328",
          "snippet": "static inline void clocksource_start_watchdog(void)\n{\n\tif (watchdog_running || !watchdog || list_empty(&watchdog_list))\n\t\treturn;\n\ttimer_setup(&watchdog_timer, clocksource_watchdog, 0);\n\twatchdog_timer.expires = jiffies + WATCHDOG_INTERVAL;\n\tadd_timer_on(&watchdog_timer, cpumask_first(cpu_online_mask));\n\twatchdog_running = 1;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [
            "#define WATCHDOG_INTERVAL (HZ >> 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\n#define WATCHDOG_INTERVAL (HZ >> 1)\n\nstatic inline void clocksource_start_watchdog(void)\n{\n\tif (watchdog_running || !watchdog || list_empty(&watchdog_list))\n\t\treturn;\n\ttimer_setup(&watchdog_timer, clocksource_watchdog, 0);\n\twatchdog_timer.expires = jiffies + WATCHDOG_INTERVAL;\n\tadd_timer_on(&watchdog_timer, cpumask_first(cpu_online_mask));\n\twatchdog_running = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_reset_watchdog",
          "args": [],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_reset_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "338-344",
          "snippet": "static inline void clocksource_reset_watchdog(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &watchdog_list, wd_list)\n\t\tcs->flags &= ~CLOCK_SOURCE_WATCHDOG;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_reset_watchdog(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &watchdog_list, wd_list)\n\t\tcs->flags &= ~CLOCK_SOURCE_WATCHDOG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cs",
            "&clocksource_list",
            "list"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&watchdog_lock",
            "flags"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\n\nstatic void clocksource_select_watchdog(bool fallback)\n{\n\tstruct clocksource *cs, *old_wd;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\t/* save current watchdog */\n\told_wd = watchdog;\n\tif (fallback)\n\t\twatchdog = NULL;\n\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\t/* cs is a clocksource to be watched. */\n\t\tif (cs->flags & CLOCK_SOURCE_MUST_VERIFY)\n\t\t\tcontinue;\n\n\t\t/* Skip current if we were requested for a fallback. */\n\t\tif (fallback && cs == old_wd)\n\t\t\tcontinue;\n\n\t\t/* Pick the best watchdog. */\n\t\tif (!watchdog || cs->rating > watchdog->rating)\n\t\t\twatchdog = cs;\n\t}\n\t/* If we failed to find a fallback restore the old one. */\n\tif (!watchdog)\n\t\twatchdog = old_wd;\n\n\t/* If we changed the watchdog we need to reset cycles. */\n\tif (watchdog != old_wd)\n\t\tclocksource_reset_watchdog();\n\n\t/* Check if the watchdog timer needs to be started. */\n\tclocksource_start_watchdog();\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n}"
  },
  {
    "function_name": "clocksource_enqueue_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "351-364",
    "snippet": "static void clocksource_enqueue_watchdog(struct clocksource *cs)\n{\n\tINIT_LIST_HEAD(&cs->wd_list);\n\n\tif (cs->flags & CLOCK_SOURCE_MUST_VERIFY) {\n\t\t/* cs is a clocksource to be watched. */\n\t\tlist_add(&cs->wd_list, &watchdog_list);\n\t\tcs->flags &= ~CLOCK_SOURCE_WATCHDOG;\n\t} else {\n\t\t/* cs is a watchdog. */\n\t\tif (cs->flags & CLOCK_SOURCE_IS_CONTINUOUS)\n\t\t\tcs->flags |= CLOCK_SOURCE_VALID_FOR_HRES;\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cs->wd_list",
            "&watchdog_list"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cs->wd_list"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_enqueue_watchdog(struct clocksource *cs)\n{\n\tINIT_LIST_HEAD(&cs->wd_list);\n\n\tif (cs->flags & CLOCK_SOURCE_MUST_VERIFY) {\n\t\t/* cs is a clocksource to be watched. */\n\t\tlist_add(&cs->wd_list, &watchdog_list);\n\t\tcs->flags &= ~CLOCK_SOURCE_WATCHDOG;\n\t} else {\n\t\t/* cs is a watchdog. */\n\t\tif (cs->flags & CLOCK_SOURCE_IS_CONTINUOUS)\n\t\t\tcs->flags |= CLOCK_SOURCE_VALID_FOR_HRES;\n\t}\n}"
  },
  {
    "function_name": "clocksource_resume_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "346-349",
    "snippet": "static void clocksource_resume_watchdog(void)\n{\n\tatomic_inc(&watchdog_reset_pending);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&watchdog_reset_pending"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_resume_watchdog(void)\n{\n\tatomic_inc(&watchdog_reset_pending);\n}"
  },
  {
    "function_name": "clocksource_reset_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "338-344",
    "snippet": "static inline void clocksource_reset_watchdog(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &watchdog_list, wd_list)\n\t\tcs->flags &= ~CLOCK_SOURCE_WATCHDOG;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cs",
            "&watchdog_list",
            "wd_list"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_reset_watchdog(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &watchdog_list, wd_list)\n\t\tcs->flags &= ~CLOCK_SOURCE_WATCHDOG;\n}"
  },
  {
    "function_name": "clocksource_stop_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "330-336",
    "snippet": "static inline void clocksource_stop_watchdog(void)\n{\n\tif (!watchdog_running || (watchdog && !list_empty(&watchdog_list)))\n\t\treturn;\n\tdel_timer(&watchdog_timer);\n\twatchdog_running = 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "del_timer",
          "args": [
            "&watchdog_timer"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1273-1298",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&watchdog_list"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic inline void clocksource_stop_watchdog(void)\n{\n\tif (!watchdog_running || (watchdog && !list_empty(&watchdog_list)))\n\t\treturn;\n\tdel_timer(&watchdog_timer);\n\twatchdog_running = 0;\n}"
  },
  {
    "function_name": "clocksource_start_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "320-328",
    "snippet": "static inline void clocksource_start_watchdog(void)\n{\n\tif (watchdog_running || !watchdog || list_empty(&watchdog_list))\n\t\treturn;\n\ttimer_setup(&watchdog_timer, clocksource_watchdog, 0);\n\twatchdog_timer.expires = jiffies + WATCHDOG_INTERVAL;\n\tadd_timer_on(&watchdog_timer, cpumask_first(cpu_online_mask));\n\twatchdog_running = 1;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [
      "#define WATCHDOG_INTERVAL (HZ >> 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_timer_on",
          "args": [
            "&watchdog_timer",
            "cpumask_first(cpu_online_mask)"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "add_timer_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1149-1178",
          "snippet": "void add_timer_on(struct timer_list *timer, int cpu)\n{\n\tstruct timer_base *new_base, *base;\n\tunsigned long flags;\n\n\tBUG_ON(timer_pending(timer) || !timer->function);\n\n\tnew_base = get_timer_cpu_base(timer->flags, cpu);\n\n\t/*\n\t * If @timer was on a different CPU, it should be migrated with the\n\t * old base locked to prevent other operations proceeding with the\n\t * wrong base locked.  See lock_timer_base().\n\t */\n\tbase = lock_timer_base(timer, &flags);\n\tif (base != new_base) {\n\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\traw_spin_unlock(&base->lock);\n\t\tbase = new_base;\n\t\traw_spin_lock(&base->lock);\n\t\tWRITE_ONCE(timer->flags,\n\t\t\t   (timer->flags & ~TIMER_BASEMASK) | cpu);\n\t}\n\tforward_timer_base(base);\n\n\tdebug_activate(timer, timer->expires);\n\tinternal_add_timer(base, timer);\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid add_timer_on(struct timer_list *timer, int cpu)\n{\n\tstruct timer_base *new_base, *base;\n\tunsigned long flags;\n\n\tBUG_ON(timer_pending(timer) || !timer->function);\n\n\tnew_base = get_timer_cpu_base(timer->flags, cpu);\n\n\t/*\n\t * If @timer was on a different CPU, it should be migrated with the\n\t * old base locked to prevent other operations proceeding with the\n\t * wrong base locked.  See lock_timer_base().\n\t */\n\tbase = lock_timer_base(timer, &flags);\n\tif (base != new_base) {\n\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\traw_spin_unlock(&base->lock);\n\t\tbase = new_base;\n\t\traw_spin_lock(&base->lock);\n\t\tWRITE_ONCE(timer->flags,\n\t\t\t   (timer->flags & ~TIMER_BASEMASK) | cpu);\n\t}\n\tforward_timer_base(base);\n\n\tdebug_activate(timer, timer->expires);\n\tinternal_add_timer(base, timer);\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_setup",
          "args": [
            "&watchdog_timer",
            "clocksource_watchdog",
            "0"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&watchdog_list"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\n#define WATCHDOG_INTERVAL (HZ >> 1)\n\nstatic inline void clocksource_start_watchdog(void)\n{\n\tif (watchdog_running || !watchdog || list_empty(&watchdog_list))\n\t\treturn;\n\ttimer_setup(&watchdog_timer, clocksource_watchdog, 0);\n\twatchdog_timer.expires = jiffies + WATCHDOG_INTERVAL;\n\tadd_timer_on(&watchdog_timer, cpumask_first(cpu_online_mask));\n\twatchdog_running = 1;\n}"
  },
  {
    "function_name": "clocksource_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "205-318",
    "snippet": "static void clocksource_watchdog(struct timer_list *unused)\n{\n\tstruct clocksource *cs;\n\tu64 csnow, wdnow, cslast, wdlast, delta;\n\tint64_t wd_nsec, cs_nsec;\n\tint next_cpu, reset_pending;\n\n\tspin_lock(&watchdog_lock);\n\tif (!watchdog_running)\n\t\tgoto out;\n\n\treset_pending = atomic_read(&watchdog_reset_pending);\n\n\tlist_for_each_entry(cs, &watchdog_list, wd_list) {\n\n\t\t/* Clocksource already marked unstable? */\n\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\tif (finished_booting)\n\t\t\t\tschedule_work(&watchdog_work);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\tcsnow = cs->read(cs);\n\t\twdnow = watchdog->read(watchdog);\n\t\tlocal_irq_enable();\n\n\t\t/* Clocksource initialized ? */\n\t\tif (!(cs->flags & CLOCK_SOURCE_WATCHDOG) ||\n\t\t    atomic_read(&watchdog_reset_pending)) {\n\t\t\tcs->flags |= CLOCK_SOURCE_WATCHDOG;\n\t\t\tcs->wd_last = wdnow;\n\t\t\tcs->cs_last = csnow;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdelta = clocksource_delta(wdnow, cs->wd_last, watchdog->mask);\n\t\twd_nsec = clocksource_cyc2ns(delta, watchdog->mult,\n\t\t\t\t\t     watchdog->shift);\n\n\t\tdelta = clocksource_delta(csnow, cs->cs_last, cs->mask);\n\t\tcs_nsec = clocksource_cyc2ns(delta, cs->mult, cs->shift);\n\t\twdlast = cs->wd_last; /* save these in case we print them */\n\t\tcslast = cs->cs_last;\n\t\tcs->cs_last = csnow;\n\t\tcs->wd_last = wdnow;\n\n\t\tif (atomic_read(&watchdog_reset_pending))\n\t\t\tcontinue;\n\n\t\t/* Check the deviation from the watchdog clocksource. */\n\t\tif (abs(cs_nsec - wd_nsec) > WATCHDOG_THRESHOLD) {\n\t\t\tpr_warn(\"timekeeping watchdog on CPU%d: Marking clocksource '%s' as unstable because the skew is too large:\\n\",\n\t\t\t\tsmp_processor_id(), cs->name);\n\t\t\tpr_warn(\"                      '%s' wd_now: %llx wd_last: %llx mask: %llx\\n\",\n\t\t\t\twatchdog->name, wdnow, wdlast, watchdog->mask);\n\t\t\tpr_warn(\"                      '%s' cs_now: %llx cs_last: %llx mask: %llx\\n\",\n\t\t\t\tcs->name, csnow, cslast, cs->mask);\n\t\t\t__clocksource_unstable(cs);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cs == curr_clocksource && cs->tick_stable)\n\t\t\tcs->tick_stable(cs);\n\n\t\tif (!(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES) &&\n\t\t    (cs->flags & CLOCK_SOURCE_IS_CONTINUOUS) &&\n\t\t    (watchdog->flags & CLOCK_SOURCE_IS_CONTINUOUS)) {\n\t\t\t/* Mark it valid for high-res. */\n\t\t\tcs->flags |= CLOCK_SOURCE_VALID_FOR_HRES;\n\n\t\t\t/*\n\t\t\t * clocksource_done_booting() will sort it if\n\t\t\t * finished_booting is not set yet.\n\t\t\t */\n\t\t\tif (!finished_booting)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * If this is not the current clocksource let\n\t\t\t * the watchdog thread reselect it. Due to the\n\t\t\t * change to high res this clocksource might\n\t\t\t * be preferred now. If it is the current\n\t\t\t * clocksource let the tick code know about\n\t\t\t * that change.\n\t\t\t */\n\t\t\tif (cs != curr_clocksource) {\n\t\t\t\tcs->flags |= CLOCK_SOURCE_RESELECT;\n\t\t\t\tschedule_work(&watchdog_work);\n\t\t\t} else {\n\t\t\t\ttick_clock_notify();\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We only clear the watchdog_reset_pending, when we did a\n\t * full cycle through all clocksources.\n\t */\n\tif (reset_pending)\n\t\tatomic_dec(&watchdog_reset_pending);\n\n\t/*\n\t * Cycle through CPUs to check if the CPUs stay synchronized\n\t * to each other.\n\t */\n\tnext_cpu = cpumask_next(raw_smp_processor_id(), cpu_online_mask);\n\tif (next_cpu >= nr_cpu_ids)\n\t\tnext_cpu = cpumask_first(cpu_online_mask);\n\twatchdog_timer.expires += WATCHDOG_INTERVAL;\n\tadd_timer_on(&watchdog_timer, next_cpu);\nout:\n\tspin_unlock(&watchdog_lock);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [
      "#define WATCHDOG_THRESHOLD (NSEC_PER_SEC >> 4)",
      "#define WATCHDOG_INTERVAL (HZ >> 1)"
    ],
    "globals_used": [
      "static struct clocksource *curr_clocksource;",
      "static int finished_booting;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&watchdog_lock"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_timer_on",
          "args": [
            "&watchdog_timer",
            "next_cpu"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "add_timer_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1149-1178",
          "snippet": "void add_timer_on(struct timer_list *timer, int cpu)\n{\n\tstruct timer_base *new_base, *base;\n\tunsigned long flags;\n\n\tBUG_ON(timer_pending(timer) || !timer->function);\n\n\tnew_base = get_timer_cpu_base(timer->flags, cpu);\n\n\t/*\n\t * If @timer was on a different CPU, it should be migrated with the\n\t * old base locked to prevent other operations proceeding with the\n\t * wrong base locked.  See lock_timer_base().\n\t */\n\tbase = lock_timer_base(timer, &flags);\n\tif (base != new_base) {\n\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\traw_spin_unlock(&base->lock);\n\t\tbase = new_base;\n\t\traw_spin_lock(&base->lock);\n\t\tWRITE_ONCE(timer->flags,\n\t\t\t   (timer->flags & ~TIMER_BASEMASK) | cpu);\n\t}\n\tforward_timer_base(base);\n\n\tdebug_activate(timer, timer->expires);\n\tinternal_add_timer(base, timer);\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid add_timer_on(struct timer_list *timer, int cpu)\n{\n\tstruct timer_base *new_base, *base;\n\tunsigned long flags;\n\n\tBUG_ON(timer_pending(timer) || !timer->function);\n\n\tnew_base = get_timer_cpu_base(timer->flags, cpu);\n\n\t/*\n\t * If @timer was on a different CPU, it should be migrated with the\n\t * old base locked to prevent other operations proceeding with the\n\t * wrong base locked.  See lock_timer_base().\n\t */\n\tbase = lock_timer_base(timer, &flags);\n\tif (base != new_base) {\n\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\traw_spin_unlock(&base->lock);\n\t\tbase = new_base;\n\t\traw_spin_lock(&base->lock);\n\t\tWRITE_ONCE(timer->flags,\n\t\t\t   (timer->flags & ~TIMER_BASEMASK) | cpu);\n\t}\n\tforward_timer_base(base);\n\n\tdebug_activate(timer, timer->expires);\n\tinternal_add_timer(base, timer);\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "cpu_online_mask"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "raw_smp_processor_id()",
            "cpu_online_mask"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&watchdog_reset_pending"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_clock_notify",
          "args": [],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "tick_clock_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "1345-1351",
          "snippet": "void tick_clock_notify(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tset_bit(0, &per_cpu(tick_cpu_sched, cpu).check_clocks);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_clock_notify(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tset_bit(0, &per_cpu(tick_cpu_sched, cpu).check_clocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&watchdog_work"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cs->tick_stable",
          "args": [
            "cs"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clocksource_unstable",
          "args": [
            "cs"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "163-183",
          "snippet": "static void __clocksource_unstable(struct clocksource *cs)\n{\n\tcs->flags &= ~(CLOCK_SOURCE_VALID_FOR_HRES | CLOCK_SOURCE_WATCHDOG);\n\tcs->flags |= CLOCK_SOURCE_UNSTABLE;\n\n\t/*\n\t * If the clocksource is registered clocksource_watchdog_kthread() will\n\t * re-rate and re-select.\n\t */\n\tif (list_empty(&cs->list)) {\n\t\tcs->rating = 0;\n\t\treturn;\n\t}\n\n\tif (cs->mark_unstable)\n\t\tcs->mark_unstable(cs);\n\n\t/* kick clocksource_watchdog_kthread() */\n\tif (finished_booting)\n\t\tschedule_work(&watchdog_work);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int finished_booting;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic int finished_booting;\n\nstatic void __clocksource_unstable(struct clocksource *cs)\n{\n\tcs->flags &= ~(CLOCK_SOURCE_VALID_FOR_HRES | CLOCK_SOURCE_WATCHDOG);\n\tcs->flags |= CLOCK_SOURCE_UNSTABLE;\n\n\t/*\n\t * If the clocksource is registered clocksource_watchdog_kthread() will\n\t * re-rate and re-select.\n\t */\n\tif (list_empty(&cs->list)) {\n\t\tcs->rating = 0;\n\t\treturn;\n\t}\n\n\tif (cs->mark_unstable)\n\t\tcs->mark_unstable(cs);\n\n\t/* kick clocksource_watchdog_kthread() */\n\tif (finished_booting)\n\t\tschedule_work(&watchdog_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"                      '%s' cs_now: %llx cs_last: %llx mask: %llx\\n\"",
            "cs->name",
            "csnow",
            "cslast",
            "cs->mask"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"                      '%s' wd_now: %llx wd_last: %llx mask: %llx\\n\"",
            "watchdog->name",
            "wdnow",
            "wdlast",
            "watchdog->mask"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"timekeeping watchdog on CPU%d: Marking clocksource '%s' as unstable because the skew is too large:\\n\"",
            "smp_processor_id()",
            "cs->name"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "cs_nsec - wd_nsec"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "462-469",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&watchdog_reset_pending"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_cyc2ns",
          "args": [
            "delta",
            "cs->mult",
            "cs->shift"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "csnow",
            "cs->cs_last",
            "cs->mask"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping_internal.h",
          "lines": "28-31",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_cyc2ns",
          "args": [
            "delta",
            "watchdog->mult",
            "watchdog->shift"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&watchdog_reset_pending"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "watchdog->read",
          "args": [
            "watchdog"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cs->read",
          "args": [
            "cs"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&watchdog_work"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cs",
            "&watchdog_list",
            "wd_list"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&watchdog_reset_pending"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&watchdog_lock"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\n#define WATCHDOG_THRESHOLD (NSEC_PER_SEC >> 4)\n#define WATCHDOG_INTERVAL (HZ >> 1)\n\nstatic struct clocksource *curr_clocksource;\nstatic int finished_booting;\n\nstatic void clocksource_watchdog(struct timer_list *unused)\n{\n\tstruct clocksource *cs;\n\tu64 csnow, wdnow, cslast, wdlast, delta;\n\tint64_t wd_nsec, cs_nsec;\n\tint next_cpu, reset_pending;\n\n\tspin_lock(&watchdog_lock);\n\tif (!watchdog_running)\n\t\tgoto out;\n\n\treset_pending = atomic_read(&watchdog_reset_pending);\n\n\tlist_for_each_entry(cs, &watchdog_list, wd_list) {\n\n\t\t/* Clocksource already marked unstable? */\n\t\tif (cs->flags & CLOCK_SOURCE_UNSTABLE) {\n\t\t\tif (finished_booting)\n\t\t\t\tschedule_work(&watchdog_work);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\tcsnow = cs->read(cs);\n\t\twdnow = watchdog->read(watchdog);\n\t\tlocal_irq_enable();\n\n\t\t/* Clocksource initialized ? */\n\t\tif (!(cs->flags & CLOCK_SOURCE_WATCHDOG) ||\n\t\t    atomic_read(&watchdog_reset_pending)) {\n\t\t\tcs->flags |= CLOCK_SOURCE_WATCHDOG;\n\t\t\tcs->wd_last = wdnow;\n\t\t\tcs->cs_last = csnow;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdelta = clocksource_delta(wdnow, cs->wd_last, watchdog->mask);\n\t\twd_nsec = clocksource_cyc2ns(delta, watchdog->mult,\n\t\t\t\t\t     watchdog->shift);\n\n\t\tdelta = clocksource_delta(csnow, cs->cs_last, cs->mask);\n\t\tcs_nsec = clocksource_cyc2ns(delta, cs->mult, cs->shift);\n\t\twdlast = cs->wd_last; /* save these in case we print them */\n\t\tcslast = cs->cs_last;\n\t\tcs->cs_last = csnow;\n\t\tcs->wd_last = wdnow;\n\n\t\tif (atomic_read(&watchdog_reset_pending))\n\t\t\tcontinue;\n\n\t\t/* Check the deviation from the watchdog clocksource. */\n\t\tif (abs(cs_nsec - wd_nsec) > WATCHDOG_THRESHOLD) {\n\t\t\tpr_warn(\"timekeeping watchdog on CPU%d: Marking clocksource '%s' as unstable because the skew is too large:\\n\",\n\t\t\t\tsmp_processor_id(), cs->name);\n\t\t\tpr_warn(\"                      '%s' wd_now: %llx wd_last: %llx mask: %llx\\n\",\n\t\t\t\twatchdog->name, wdnow, wdlast, watchdog->mask);\n\t\t\tpr_warn(\"                      '%s' cs_now: %llx cs_last: %llx mask: %llx\\n\",\n\t\t\t\tcs->name, csnow, cslast, cs->mask);\n\t\t\t__clocksource_unstable(cs);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cs == curr_clocksource && cs->tick_stable)\n\t\t\tcs->tick_stable(cs);\n\n\t\tif (!(cs->flags & CLOCK_SOURCE_VALID_FOR_HRES) &&\n\t\t    (cs->flags & CLOCK_SOURCE_IS_CONTINUOUS) &&\n\t\t    (watchdog->flags & CLOCK_SOURCE_IS_CONTINUOUS)) {\n\t\t\t/* Mark it valid for high-res. */\n\t\t\tcs->flags |= CLOCK_SOURCE_VALID_FOR_HRES;\n\n\t\t\t/*\n\t\t\t * clocksource_done_booting() will sort it if\n\t\t\t * finished_booting is not set yet.\n\t\t\t */\n\t\t\tif (!finished_booting)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * If this is not the current clocksource let\n\t\t\t * the watchdog thread reselect it. Due to the\n\t\t\t * change to high res this clocksource might\n\t\t\t * be preferred now. If it is the current\n\t\t\t * clocksource let the tick code know about\n\t\t\t * that change.\n\t\t\t */\n\t\t\tif (cs != curr_clocksource) {\n\t\t\t\tcs->flags |= CLOCK_SOURCE_RESELECT;\n\t\t\t\tschedule_work(&watchdog_work);\n\t\t\t} else {\n\t\t\t\ttick_clock_notify();\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We only clear the watchdog_reset_pending, when we did a\n\t * full cycle through all clocksources.\n\t */\n\tif (reset_pending)\n\t\tatomic_dec(&watchdog_reset_pending);\n\n\t/*\n\t * Cycle through CPUs to check if the CPUs stay synchronized\n\t * to each other.\n\t */\n\tnext_cpu = cpumask_next(raw_smp_processor_id(), cpu_online_mask);\n\tif (next_cpu >= nr_cpu_ids)\n\t\tnext_cpu = cpumask_first(cpu_online_mask);\n\twatchdog_timer.expires += WATCHDOG_INTERVAL;\n\tadd_timer_on(&watchdog_timer, next_cpu);\nout:\n\tspin_unlock(&watchdog_lock);\n}"
  },
  {
    "function_name": "clocksource_mark_unstable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "192-203",
    "snippet": "void clocksource_mark_unstable(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\tif (!(cs->flags & CLOCK_SOURCE_UNSTABLE)) {\n\t\tif (!list_empty(&cs->list) && list_empty(&cs->wd_list))\n\t\t\tlist_add(&cs->wd_list, &watchdog_list);\n\t\t__clocksource_unstable(cs);\n\t}\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&watchdog_lock",
            "flags"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clocksource_unstable",
          "args": [
            "cs"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "__clocksource_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "163-183",
          "snippet": "static void __clocksource_unstable(struct clocksource *cs)\n{\n\tcs->flags &= ~(CLOCK_SOURCE_VALID_FOR_HRES | CLOCK_SOURCE_WATCHDOG);\n\tcs->flags |= CLOCK_SOURCE_UNSTABLE;\n\n\t/*\n\t * If the clocksource is registered clocksource_watchdog_kthread() will\n\t * re-rate and re-select.\n\t */\n\tif (list_empty(&cs->list)) {\n\t\tcs->rating = 0;\n\t\treturn;\n\t}\n\n\tif (cs->mark_unstable)\n\t\tcs->mark_unstable(cs);\n\n\t/* kick clocksource_watchdog_kthread() */\n\tif (finished_booting)\n\t\tschedule_work(&watchdog_work);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int finished_booting;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic int finished_booting;\n\nstatic void __clocksource_unstable(struct clocksource *cs)\n{\n\tcs->flags &= ~(CLOCK_SOURCE_VALID_FOR_HRES | CLOCK_SOURCE_WATCHDOG);\n\tcs->flags |= CLOCK_SOURCE_UNSTABLE;\n\n\t/*\n\t * If the clocksource is registered clocksource_watchdog_kthread() will\n\t * re-rate and re-select.\n\t */\n\tif (list_empty(&cs->list)) {\n\t\tcs->rating = 0;\n\t\treturn;\n\t}\n\n\tif (cs->mark_unstable)\n\t\tcs->mark_unstable(cs);\n\n\t/* kick clocksource_watchdog_kthread() */\n\tif (finished_booting)\n\t\tschedule_work(&watchdog_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cs->wd_list",
            "&watchdog_list"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cs->wd_list"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&watchdog_lock",
            "flags"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nvoid clocksource_mark_unstable(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\tif (!(cs->flags & CLOCK_SOURCE_UNSTABLE)) {\n\t\tif (!list_empty(&cs->list) && list_empty(&cs->wd_list))\n\t\t\tlist_add(&cs->wd_list, &watchdog_list);\n\t\t__clocksource_unstable(cs);\n\t}\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n}"
  },
  {
    "function_name": "__clocksource_unstable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "163-183",
    "snippet": "static void __clocksource_unstable(struct clocksource *cs)\n{\n\tcs->flags &= ~(CLOCK_SOURCE_VALID_FOR_HRES | CLOCK_SOURCE_WATCHDOG);\n\tcs->flags |= CLOCK_SOURCE_UNSTABLE;\n\n\t/*\n\t * If the clocksource is registered clocksource_watchdog_kthread() will\n\t * re-rate and re-select.\n\t */\n\tif (list_empty(&cs->list)) {\n\t\tcs->rating = 0;\n\t\treturn;\n\t}\n\n\tif (cs->mark_unstable)\n\t\tcs->mark_unstable(cs);\n\n\t/* kick clocksource_watchdog_kthread() */\n\tif (finished_booting)\n\t\tschedule_work(&watchdog_work);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int finished_booting;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&watchdog_work"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cs->mark_unstable",
          "args": [
            "cs"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cs->list"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic int finished_booting;\n\nstatic void __clocksource_unstable(struct clocksource *cs)\n{\n\tcs->flags &= ~(CLOCK_SOURCE_VALID_FOR_HRES | CLOCK_SOURCE_WATCHDOG);\n\tcs->flags |= CLOCK_SOURCE_UNSTABLE;\n\n\t/*\n\t * If the clocksource is registered clocksource_watchdog_kthread() will\n\t * re-rate and re-select.\n\t */\n\tif (list_empty(&cs->list)) {\n\t\tcs->rating = 0;\n\t\treturn;\n\t}\n\n\tif (cs->mark_unstable)\n\t\tcs->mark_unstable(cs);\n\n\t/* kick clocksource_watchdog_kthread() */\n\tif (finished_booting)\n\t\tschedule_work(&watchdog_work);\n}"
  },
  {
    "function_name": "clocksource_watchdog_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "145-161",
    "snippet": "static void clocksource_watchdog_work(struct work_struct *work)\n{\n\t/*\n\t * We cannot directly run clocksource_watchdog_kthread() here, because\n\t * clocksource_select() calls timekeeping_notify() which uses\n\t * stop_machine(). One cannot use stop_machine() from a workqueue() due\n\t * lock inversions wrt CPU hotplug.\n\t *\n\t * Also, we only ever run this work once or twice during the lifetime\n\t * of the kernel, so there is no point in creating a more permanent\n\t * kthread for this.\n\t *\n\t * If kthread_run fails the next watchdog scan over the\n\t * watchdog_list will find the unstable clock again.\n\t */\n\tkthread_run(clocksource_watchdog_kthread, NULL, \"kwatchdog\");\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "clocksource_watchdog_kthread",
            "NULL",
            "\"kwatchdog\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void clocksource_watchdog_work(struct work_struct *work)\n{\n\t/*\n\t * We cannot directly run clocksource_watchdog_kthread() here, because\n\t * clocksource_select() calls timekeeping_notify() which uses\n\t * stop_machine(). One cannot use stop_machine() from a workqueue() due\n\t * lock inversions wrt CPU hotplug.\n\t *\n\t * Also, we only ever run this work once or twice during the lifetime\n\t * of the kernel, so there is no point in creating a more permanent\n\t * kthread for this.\n\t *\n\t * If kthread_run fails the next watchdog scan over the\n\t * watchdog_list will find the unstable clock again.\n\t */\n\tkthread_run(clocksource_watchdog_kthread, NULL, \"kwatchdog\");\n}"
  },
  {
    "function_name": "clocksource_watchdog_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "131-134",
    "snippet": "static void inline clocksource_watchdog_unlock(unsigned long *flags)\n{\n\tspin_unlock_irqrestore(&watchdog_lock, *flags);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&watchdog_lock",
            "*flags"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void inline clocksource_watchdog_unlock(unsigned long *flags)\n{\n\tspin_unlock_irqrestore(&watchdog_lock, *flags);\n}"
  },
  {
    "function_name": "clocksource_watchdog_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "126-129",
    "snippet": "static void inline clocksource_watchdog_lock(unsigned long *flags)\n{\n\tspin_lock_irqsave(&watchdog_lock, *flags);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&watchdog_lock",
            "*flags"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic void inline clocksource_watchdog_lock(unsigned long *flags)\n{\n\tspin_lock_irqsave(&watchdog_lock, *flags);\n}"
  },
  {
    "function_name": "clocks_calc_mult_shift",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
    "lines": "62-91",
    "snippet": "void\nclocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 maxsec)\n{\n\tu64 tmp;\n\tu32 sft, sftacc= 32;\n\n\t/*\n\t * Calculate the shift factor which is limiting the conversion\n\t * range:\n\t */\n\ttmp = ((u64)maxsec * from) >> 32;\n\twhile (tmp) {\n\t\ttmp >>=1;\n\t\tsftacc--;\n\t}\n\n\t/*\n\t * Find the conversion shift/mult pair which has the best\n\t * accuracy and fits the maxsec conversion range:\n\t */\n\tfor (sft = 32; sft > 0; sft--) {\n\t\ttmp = (u64) to << sft;\n\t\ttmp += from / 2;\n\t\tdo_div(tmp, from);\n\t\tif ((tmp >> sftacc) == 0)\n\t\t\tbreak;\n\t}\n\t*mult = tmp;\n\t*shift = sft;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/kthread.h>",
      "#include <linux/tick.h>",
      "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tmp",
            "from"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nvoid\nclocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 maxsec)\n{\n\tu64 tmp;\n\tu32 sft, sftacc= 32;\n\n\t/*\n\t * Calculate the shift factor which is limiting the conversion\n\t * range:\n\t */\n\ttmp = ((u64)maxsec * from) >> 32;\n\twhile (tmp) {\n\t\ttmp >>=1;\n\t\tsftacc--;\n\t}\n\n\t/*\n\t * Find the conversion shift/mult pair which has the best\n\t * accuracy and fits the maxsec conversion range:\n\t */\n\tfor (sft = 32; sft > 0; sft--) {\n\t\ttmp = (u64) to << sft;\n\t\ttmp += from / 2;\n\t\tdo_div(tmp, from);\n\t\tif ((tmp >> sftacc) == 0)\n\t\t\tbreak;\n\t}\n\t*mult = tmp;\n\t*shift = sft;\n}"
  }
]