[
  {
    "function_name": "alarm_setitimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/itimer.c",
    "lines": "257-280",
    "snippet": "static unsigned int alarm_setitimer(unsigned int seconds)\n{\n\tstruct itimerval it_new, it_old;\n\n#if BITS_PER_LONG < 64\n\tif (seconds > INT_MAX)\n\t\tseconds = INT_MAX;\n#endif\n\tit_new.it_value.tv_sec = seconds;\n\tit_new.it_value.tv_usec = 0;\n\tit_new.it_interval.tv_sec = it_new.it_interval.tv_usec = 0;\n\n\tdo_setitimer(ITIMER_REAL, &it_new, &it_old);\n\n\t/*\n\t * We can't return 0 if we have an alarm pending ...  And we'd\n\t * better return too much than too little anyway\n\t */\n\tif ((!it_old.it_value.tv_sec && it_old.it_value.tv_usec) ||\n\t      it_old.it_value.tv_usec >= 500000)\n\t\tit_old.it_value.tv_sec++;\n\n\treturn it_old.it_value.tv_sec;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_setitimer",
          "args": [
            "ITIMER_REAL",
            "&it_new",
            "&it_old"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "do_setitimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/itimer.c",
          "lines": "192-241",
          "snippet": "int do_setitimer(int which, struct itimerval *value, struct itimerval *ovalue)\n{\n\tstruct task_struct *tsk = current;\n\tstruct hrtimer *timer;\n\tktime_t expires;\n\n\t/*\n\t * Validate the timevals in value.\n\t */\n\tif (!timeval_valid(&value->it_value) ||\n\t    !timeval_valid(&value->it_interval))\n\t\treturn -EINVAL;\n\n\tswitch (which) {\n\tcase ITIMER_REAL:\nagain:\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\ttimer = &tsk->signal->real_timer;\n\t\tif (ovalue) {\n\t\t\tovalue->it_value = itimer_get_remtime(timer);\n\t\t\tovalue->it_interval\n\t\t\t\t= ktime_to_timeval(tsk->signal->it_real_incr);\n\t\t}\n\t\t/* We are sharing ->siglock with it_real_fn() */\n\t\tif (hrtimer_try_to_cancel(timer) < 0) {\n\t\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\t\tgoto again;\n\t\t}\n\t\texpires = timeval_to_ktime(value->it_value);\n\t\tif (expires != 0) {\n\t\t\ttsk->signal->it_real_incr =\n\t\t\t\ttimeval_to_ktime(value->it_interval);\n\t\t\thrtimer_start(timer, expires, HRTIMER_MODE_REL);\n\t\t} else\n\t\t\ttsk->signal->it_real_incr = 0;\n\n\t\ttrace_itimer_state(ITIMER_REAL, value, 0);\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\tbreak;\n\tcase ITIMER_VIRTUAL:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);\n\t\tbreak;\n\tcase ITIMER_PROF:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nint do_setitimer(int which, struct itimerval *value, struct itimerval *ovalue)\n{\n\tstruct task_struct *tsk = current;\n\tstruct hrtimer *timer;\n\tktime_t expires;\n\n\t/*\n\t * Validate the timevals in value.\n\t */\n\tif (!timeval_valid(&value->it_value) ||\n\t    !timeval_valid(&value->it_interval))\n\t\treturn -EINVAL;\n\n\tswitch (which) {\n\tcase ITIMER_REAL:\nagain:\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\ttimer = &tsk->signal->real_timer;\n\t\tif (ovalue) {\n\t\t\tovalue->it_value = itimer_get_remtime(timer);\n\t\t\tovalue->it_interval\n\t\t\t\t= ktime_to_timeval(tsk->signal->it_real_incr);\n\t\t}\n\t\t/* We are sharing ->siglock with it_real_fn() */\n\t\tif (hrtimer_try_to_cancel(timer) < 0) {\n\t\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\t\tgoto again;\n\t\t}\n\t\texpires = timeval_to_ktime(value->it_value);\n\t\tif (expires != 0) {\n\t\t\ttsk->signal->it_real_incr =\n\t\t\t\ttimeval_to_ktime(value->it_interval);\n\t\t\thrtimer_start(timer, expires, HRTIMER_MODE_REL);\n\t\t} else\n\t\t\ttsk->signal->it_real_incr = 0;\n\n\t\ttrace_itimer_state(ITIMER_REAL, value, 0);\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\tbreak;\n\tcase ITIMER_VIRTUAL:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);\n\t\tbreak;\n\tcase ITIMER_PROF:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic unsigned int alarm_setitimer(unsigned int seconds)\n{\n\tstruct itimerval it_new, it_old;\n\n#if BITS_PER_LONG < 64\n\tif (seconds > INT_MAX)\n\t\tseconds = INT_MAX;\n#endif\n\tit_new.it_value.tv_sec = seconds;\n\tit_new.it_value.tv_usec = 0;\n\tit_new.it_interval.tv_sec = it_new.it_interval.tv_usec = 0;\n\n\tdo_setitimer(ITIMER_REAL, &it_new, &it_old);\n\n\t/*\n\t * We can't return 0 if we have an alarm pending ...  And we'd\n\t * better return too much than too little anyway\n\t */\n\tif ((!it_old.it_value.tv_sec && it_old.it_value.tv_usec) ||\n\t      it_old.it_value.tv_usec >= 500000)\n\t\tit_old.it_value.tv_sec++;\n\n\treturn it_old.it_value.tv_sec;\n}"
  },
  {
    "function_name": "do_setitimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/itimer.c",
    "lines": "192-241",
    "snippet": "int do_setitimer(int which, struct itimerval *value, struct itimerval *ovalue)\n{\n\tstruct task_struct *tsk = current;\n\tstruct hrtimer *timer;\n\tktime_t expires;\n\n\t/*\n\t * Validate the timevals in value.\n\t */\n\tif (!timeval_valid(&value->it_value) ||\n\t    !timeval_valid(&value->it_interval))\n\t\treturn -EINVAL;\n\n\tswitch (which) {\n\tcase ITIMER_REAL:\nagain:\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\ttimer = &tsk->signal->real_timer;\n\t\tif (ovalue) {\n\t\t\tovalue->it_value = itimer_get_remtime(timer);\n\t\t\tovalue->it_interval\n\t\t\t\t= ktime_to_timeval(tsk->signal->it_real_incr);\n\t\t}\n\t\t/* We are sharing ->siglock with it_real_fn() */\n\t\tif (hrtimer_try_to_cancel(timer) < 0) {\n\t\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\t\tgoto again;\n\t\t}\n\t\texpires = timeval_to_ktime(value->it_value);\n\t\tif (expires != 0) {\n\t\t\ttsk->signal->it_real_incr =\n\t\t\t\ttimeval_to_ktime(value->it_interval);\n\t\t\thrtimer_start(timer, expires, HRTIMER_MODE_REL);\n\t\t} else\n\t\t\ttsk->signal->it_real_incr = 0;\n\n\t\ttrace_itimer_state(ITIMER_REAL, value, 0);\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\tbreak;\n\tcase ITIMER_VIRTUAL:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);\n\t\tbreak;\n\tcase ITIMER_PROF:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cpu_itimer",
          "args": [
            "tsk",
            "CPUCLOCK_PROF",
            "value",
            "ovalue"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpu_itimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/itimer.c",
          "lines": "150-184",
          "snippet": "static void set_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   const struct itimerval *const value,\n\t\t\t   struct itimerval *const ovalue)\n{\n\tu64 oval, nval, ointerval, ninterval;\n\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];\n\n\t/*\n\t * Use the to_ktime conversion because that clamps the maximum\n\t * value to KTIME_MAX and avoid multiplication overflows.\n\t */\n\tnval = ktime_to_ns(timeval_to_ktime(value->it_value));\n\tninterval = ktime_to_ns(timeval_to_ktime(value->it_interval));\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\n\toval = it->expires;\n\tointerval = it->incr;\n\tif (oval || nval) {\n\t\tif (nval > 0)\n\t\t\tnval += TICK_NSEC;\n\t\tset_process_cpu_timer(tsk, clock_id, &nval, &oval);\n\t}\n\tit->expires = nval;\n\tit->incr = ninterval;\n\ttrace_itimer_state(clock_id == CPUCLOCK_VIRT ?\n\t\t\t   ITIMER_VIRTUAL : ITIMER_PROF, value, nval);\n\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (ovalue) {\n\t\tovalue->it_value = ns_to_timeval(oval);\n\t\tovalue->it_interval = ns_to_timeval(ointerval);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic void set_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   const struct itimerval *const value,\n\t\t\t   struct itimerval *const ovalue)\n{\n\tu64 oval, nval, ointerval, ninterval;\n\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];\n\n\t/*\n\t * Use the to_ktime conversion because that clamps the maximum\n\t * value to KTIME_MAX and avoid multiplication overflows.\n\t */\n\tnval = ktime_to_ns(timeval_to_ktime(value->it_value));\n\tninterval = ktime_to_ns(timeval_to_ktime(value->it_interval));\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\n\toval = it->expires;\n\tointerval = it->incr;\n\tif (oval || nval) {\n\t\tif (nval > 0)\n\t\t\tnval += TICK_NSEC;\n\t\tset_process_cpu_timer(tsk, clock_id, &nval, &oval);\n\t}\n\tit->expires = nval;\n\tit->incr = ninterval;\n\ttrace_itimer_state(clock_id == CPUCLOCK_VIRT ?\n\t\t\t   ITIMER_VIRTUAL : ITIMER_PROF, value, nval);\n\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (ovalue) {\n\t\tovalue->it_value = ns_to_timeval(oval);\n\t\tovalue->it_interval = ns_to_timeval(ointerval);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_itimer_state",
          "args": [
            "ITIMER_REAL",
            "value",
            "0"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "timer",
            "expires",
            "HRTIMER_MODE_REL"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeval_to_ktime",
          "args": [
            "value->it_interval"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeval_to_ktime",
          "args": [
            "value->it_value"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "timer"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "common_hrtimer_try_to_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "827-830",
          "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_timeval",
          "args": [
            "tsk->signal->it_real_incr"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "itimer_get_remtime",
          "args": [
            "timer"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "itimer_get_remtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/itimer.c",
          "lines": "31-47",
          "snippet": "static struct timeval itimer_get_remtime(struct hrtimer *timer)\n{\n\tktime_t rem = __hrtimer_get_remaining(timer, true);\n\n\t/*\n\t * Racy but safe: if the itimer expires after the above\n\t * hrtimer_get_remtime() call but before this condition\n\t * then we return 0 - which is correct.\n\t */\n\tif (hrtimer_active(timer)) {\n\t\tif (rem <= 0)\n\t\t\trem = NSEC_PER_USEC;\n\t} else\n\t\trem = 0;\n\n\treturn ktime_to_timeval(rem);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct timeval itimer_get_remtime(struct hrtimer *timer)\n{\n\tktime_t rem = __hrtimer_get_remaining(timer, true);\n\n\t/*\n\t * Racy but safe: if the itimer expires after the above\n\t * hrtimer_get_remtime() call but before this condition\n\t * then we return 0 - which is correct.\n\t */\n\tif (hrtimer_active(timer)) {\n\t\tif (rem <= 0)\n\t\t\trem = NSEC_PER_USEC;\n\t} else\n\t\trem = 0;\n\n\treturn ktime_to_timeval(rem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeval_valid",
          "args": [
            "&value->it_interval"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeval_valid",
          "args": [
            "&value->it_value"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nint do_setitimer(int which, struct itimerval *value, struct itimerval *ovalue)\n{\n\tstruct task_struct *tsk = current;\n\tstruct hrtimer *timer;\n\tktime_t expires;\n\n\t/*\n\t * Validate the timevals in value.\n\t */\n\tif (!timeval_valid(&value->it_value) ||\n\t    !timeval_valid(&value->it_interval))\n\t\treturn -EINVAL;\n\n\tswitch (which) {\n\tcase ITIMER_REAL:\nagain:\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\ttimer = &tsk->signal->real_timer;\n\t\tif (ovalue) {\n\t\t\tovalue->it_value = itimer_get_remtime(timer);\n\t\t\tovalue->it_interval\n\t\t\t\t= ktime_to_timeval(tsk->signal->it_real_incr);\n\t\t}\n\t\t/* We are sharing ->siglock with it_real_fn() */\n\t\tif (hrtimer_try_to_cancel(timer) < 0) {\n\t\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\t\tgoto again;\n\t\t}\n\t\texpires = timeval_to_ktime(value->it_value);\n\t\tif (expires != 0) {\n\t\t\ttsk->signal->it_real_incr =\n\t\t\t\ttimeval_to_ktime(value->it_interval);\n\t\t\thrtimer_start(timer, expires, HRTIMER_MODE_REL);\n\t\t} else\n\t\t\ttsk->signal->it_real_incr = 0;\n\n\t\ttrace_itimer_state(ITIMER_REAL, value, 0);\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\tbreak;\n\tcase ITIMER_VIRTUAL:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);\n\t\tbreak;\n\tcase ITIMER_PROF:\n\t\tset_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "set_cpu_itimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/itimer.c",
    "lines": "150-184",
    "snippet": "static void set_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   const struct itimerval *const value,\n\t\t\t   struct itimerval *const ovalue)\n{\n\tu64 oval, nval, ointerval, ninterval;\n\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];\n\n\t/*\n\t * Use the to_ktime conversion because that clamps the maximum\n\t * value to KTIME_MAX and avoid multiplication overflows.\n\t */\n\tnval = ktime_to_ns(timeval_to_ktime(value->it_value));\n\tninterval = ktime_to_ns(timeval_to_ktime(value->it_interval));\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\n\toval = it->expires;\n\tointerval = it->incr;\n\tif (oval || nval) {\n\t\tif (nval > 0)\n\t\t\tnval += TICK_NSEC;\n\t\tset_process_cpu_timer(tsk, clock_id, &nval, &oval);\n\t}\n\tit->expires = nval;\n\tit->incr = ninterval;\n\ttrace_itimer_state(clock_id == CPUCLOCK_VIRT ?\n\t\t\t   ITIMER_VIRTUAL : ITIMER_PROF, value, nval);\n\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (ovalue) {\n\t\tovalue->it_value = ns_to_timeval(oval);\n\t\tovalue->it_interval = ns_to_timeval(ointerval);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_to_timeval",
          "args": [
            "ointerval"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "ns_to_timeval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "456-465",
          "snippet": "struct timeval ns_to_timeval(const s64 nsec)\n{\n\tstruct timespec ts = ns_to_timespec(nsec);\n\tstruct timeval tv;\n\n\ttv.tv_sec = ts.tv_sec;\n\ttv.tv_usec = (suseconds_t) ts.tv_nsec / 1000;\n\n\treturn tv;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timeval ns_to_timeval(const s64 nsec)\n{\n\tstruct timespec ts = ns_to_timespec(nsec);\n\tstruct timeval tv;\n\n\ttv.tv_sec = ts.tv_sec;\n\ttv.tv_usec = (suseconds_t) ts.tv_nsec / 1000;\n\n\treturn tv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_itimer_state",
          "args": [
            "clock_id == CPUCLOCK_VIRT ?\n\t\t\t   ITIMER_VIRTUAL : ITIMER_PROF",
            "value",
            "nval"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_process_cpu_timer",
          "args": [
            "tsk",
            "clock_id",
            "&nval",
            "&oval"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "set_process_cpu_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1202-1247",
          "snippet": "void set_process_cpu_timer(struct task_struct *tsk, unsigned int clock_idx,\n\t\t\t   u64 *newval, u64 *oldval)\n{\n\tu64 now;\n\tint ret;\n\n\tWARN_ON_ONCE(clock_idx == CPUCLOCK_SCHED);\n\tret = cpu_timer_sample_group(clock_idx, tsk, &now);\n\n\tif (oldval && ret != -EINVAL) {\n\t\t/*\n\t\t * We are setting itimer. The *oldval is absolute and we update\n\t\t * it to be relative, *newval argument is relative and we update\n\t\t * it to be absolute.\n\t\t */\n\t\tif (*oldval) {\n\t\t\tif (*oldval <= now) {\n\t\t\t\t/* Just about to fire. */\n\t\t\t\t*oldval = TICK_NSEC;\n\t\t\t} else {\n\t\t\t\t*oldval -= now;\n\t\t\t}\n\t\t}\n\n\t\tif (!*newval)\n\t\t\treturn;\n\t\t*newval += now;\n\t}\n\n\t/*\n\t * Update expiration cache if we are the earliest timer, or eventually\n\t * RLIMIT_CPU limit is earlier than prof_exp cpu timer expire.\n\t */\n\tswitch (clock_idx) {\n\tcase CPUCLOCK_PROF:\n\t\tif (expires_gt(tsk->signal->cputime_expires.prof_exp, *newval))\n\t\t\ttsk->signal->cputime_expires.prof_exp = *newval;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\tif (expires_gt(tsk->signal->cputime_expires.virt_exp, *newval))\n\t\t\ttsk->signal->cputime_expires.virt_exp = *newval;\n\t\tbreak;\n\t}\n\n\ttick_dep_set_signal(tsk->signal, TICK_DEP_BIT_POSIX_TIMER);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nvoid set_process_cpu_timer(struct task_struct *tsk, unsigned int clock_idx,\n\t\t\t   u64 *newval, u64 *oldval)\n{\n\tu64 now;\n\tint ret;\n\n\tWARN_ON_ONCE(clock_idx == CPUCLOCK_SCHED);\n\tret = cpu_timer_sample_group(clock_idx, tsk, &now);\n\n\tif (oldval && ret != -EINVAL) {\n\t\t/*\n\t\t * We are setting itimer. The *oldval is absolute and we update\n\t\t * it to be relative, *newval argument is relative and we update\n\t\t * it to be absolute.\n\t\t */\n\t\tif (*oldval) {\n\t\t\tif (*oldval <= now) {\n\t\t\t\t/* Just about to fire. */\n\t\t\t\t*oldval = TICK_NSEC;\n\t\t\t} else {\n\t\t\t\t*oldval -= now;\n\t\t\t}\n\t\t}\n\n\t\tif (!*newval)\n\t\t\treturn;\n\t\t*newval += now;\n\t}\n\n\t/*\n\t * Update expiration cache if we are the earliest timer, or eventually\n\t * RLIMIT_CPU limit is earlier than prof_exp cpu timer expire.\n\t */\n\tswitch (clock_idx) {\n\tcase CPUCLOCK_PROF:\n\t\tif (expires_gt(tsk->signal->cputime_expires.prof_exp, *newval))\n\t\t\ttsk->signal->cputime_expires.prof_exp = *newval;\n\t\tbreak;\n\tcase CPUCLOCK_VIRT:\n\t\tif (expires_gt(tsk->signal->cputime_expires.virt_exp, *newval))\n\t\t\ttsk->signal->cputime_expires.virt_exp = *newval;\n\t\tbreak;\n\t}\n\n\ttick_dep_set_signal(tsk->signal, TICK_DEP_BIT_POSIX_TIMER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "timeval_to_ktime(value->it_interval)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeval_to_ktime",
          "args": [
            "value->it_interval"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "timeval_to_ktime(value->it_value)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeval_to_ktime",
          "args": [
            "value->it_value"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic void set_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   const struct itimerval *const value,\n\t\t\t   struct itimerval *const ovalue)\n{\n\tu64 oval, nval, ointerval, ninterval;\n\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];\n\n\t/*\n\t * Use the to_ktime conversion because that clamps the maximum\n\t * value to KTIME_MAX and avoid multiplication overflows.\n\t */\n\tnval = ktime_to_ns(timeval_to_ktime(value->it_value));\n\tninterval = ktime_to_ns(timeval_to_ktime(value->it_interval));\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\n\toval = it->expires;\n\tointerval = it->incr;\n\tif (oval || nval) {\n\t\tif (nval > 0)\n\t\t\tnval += TICK_NSEC;\n\t\tset_process_cpu_timer(tsk, clock_id, &nval, &oval);\n\t}\n\tit->expires = nval;\n\tit->incr = ninterval;\n\ttrace_itimer_state(clock_id == CPUCLOCK_VIRT ?\n\t\t\t   ITIMER_VIRTUAL : ITIMER_PROF, value, nval);\n\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (ovalue) {\n\t\tovalue->it_value = ns_to_timeval(oval);\n\t\tovalue->it_interval = ns_to_timeval(ointerval);\n\t}\n}"
  },
  {
    "function_name": "it_real_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/itimer.c",
    "lines": "138-148",
    "snippet": "enum hrtimer_restart it_real_fn(struct hrtimer *timer)\n{\n\tstruct signal_struct *sig =\n\t\tcontainer_of(timer, struct signal_struct, real_timer);\n\tstruct pid *leader_pid = sig->pids[PIDTYPE_TGID];\n\n\ttrace_itimer_expire(ITIMER_REAL, leader_pid, 0);\n\tkill_pid_info(SIGALRM, SEND_SIG_PRIV, leader_pid);\n\n\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_pid_info",
          "args": [
            "SIGALRM",
            "SEND_SIG_PRIV",
            "leader_pid"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "kill_pid_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1354-1374",
          "snippet": "int kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p, PIDTYPE_TGID);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p, PIDTYPE_TGID);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_itimer_expire",
          "args": [
            "ITIMER_REAL",
            "leader_pid",
            "0"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structsignal_struct",
            "real_timer"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nenum hrtimer_restart it_real_fn(struct hrtimer *timer)\n{\n\tstruct signal_struct *sig =\n\t\tcontainer_of(timer, struct signal_struct, real_timer);\n\tstruct pid *leader_pid = sig->pids[PIDTYPE_TGID];\n\n\ttrace_itimer_expire(ITIMER_REAL, leader_pid, 0);\n\tkill_pid_info(SIGALRM, SEND_SIG_PRIV, leader_pid);\n\n\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "do_getitimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/itimer.c",
    "lines": "83-105",
    "snippet": "int do_getitimer(int which, struct itimerval *value)\n{\n\tstruct task_struct *tsk = current;\n\n\tswitch (which) {\n\tcase ITIMER_REAL:\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\tvalue->it_value = itimer_get_remtime(&tsk->signal->real_timer);\n\t\tvalue->it_interval =\n\t\t\tktime_to_timeval(tsk->signal->it_real_incr);\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\tbreak;\n\tcase ITIMER_VIRTUAL:\n\t\tget_cpu_itimer(tsk, CPUCLOCK_VIRT, value);\n\t\tbreak;\n\tcase ITIMER_PROF:\n\t\tget_cpu_itimer(tsk, CPUCLOCK_PROF, value);\n\t\tbreak;\n\tdefault:\n\t\treturn(-EINVAL);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_cpu_itimer",
          "args": [
            "tsk",
            "CPUCLOCK_PROF",
            "value"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "get_cpu_itimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/itimer.c",
          "lines": "49-81",
          "snippet": "static void get_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   struct itimerval *const value)\n{\n\tu64 val, interval;\n\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\n\tval = it->expires;\n\tinterval = it->incr;\n\tif (val) {\n\t\tstruct task_cputime cputime;\n\t\tu64 t;\n\n\t\tthread_group_cputimer(tsk, &cputime);\n\t\tif (clock_id == CPUCLOCK_PROF)\n\t\t\tt = cputime.utime + cputime.stime;\n\t\telse\n\t\t\t/* CPUCLOCK_VIRT */\n\t\t\tt = cputime.utime;\n\n\t\tif (val < t)\n\t\t\t/* about to fire */\n\t\t\tval = TICK_NSEC;\n\t\telse\n\t\t\tval -= t;\n\t}\n\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tvalue->it_value = ns_to_timeval(val);\n\tvalue->it_interval = ns_to_timeval(interval);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic void get_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   struct itimerval *const value)\n{\n\tu64 val, interval;\n\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\n\tval = it->expires;\n\tinterval = it->incr;\n\tif (val) {\n\t\tstruct task_cputime cputime;\n\t\tu64 t;\n\n\t\tthread_group_cputimer(tsk, &cputime);\n\t\tif (clock_id == CPUCLOCK_PROF)\n\t\t\tt = cputime.utime + cputime.stime;\n\t\telse\n\t\t\t/* CPUCLOCK_VIRT */\n\t\t\tt = cputime.utime;\n\n\t\tif (val < t)\n\t\t\t/* about to fire */\n\t\t\tval = TICK_NSEC;\n\t\telse\n\t\t\tval -= t;\n\t}\n\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tvalue->it_value = ns_to_timeval(val);\n\tvalue->it_interval = ns_to_timeval(interval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_timeval",
          "args": [
            "tsk->signal->it_real_incr"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "itimer_get_remtime",
          "args": [
            "&tsk->signal->real_timer"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "itimer_get_remtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/itimer.c",
          "lines": "31-47",
          "snippet": "static struct timeval itimer_get_remtime(struct hrtimer *timer)\n{\n\tktime_t rem = __hrtimer_get_remaining(timer, true);\n\n\t/*\n\t * Racy but safe: if the itimer expires after the above\n\t * hrtimer_get_remtime() call but before this condition\n\t * then we return 0 - which is correct.\n\t */\n\tif (hrtimer_active(timer)) {\n\t\tif (rem <= 0)\n\t\t\trem = NSEC_PER_USEC;\n\t} else\n\t\trem = 0;\n\n\treturn ktime_to_timeval(rem);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct timeval itimer_get_remtime(struct hrtimer *timer)\n{\n\tktime_t rem = __hrtimer_get_remaining(timer, true);\n\n\t/*\n\t * Racy but safe: if the itimer expires after the above\n\t * hrtimer_get_remtime() call but before this condition\n\t * then we return 0 - which is correct.\n\t */\n\tif (hrtimer_active(timer)) {\n\t\tif (rem <= 0)\n\t\t\trem = NSEC_PER_USEC;\n\t} else\n\t\trem = 0;\n\n\treturn ktime_to_timeval(rem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nint do_getitimer(int which, struct itimerval *value)\n{\n\tstruct task_struct *tsk = current;\n\n\tswitch (which) {\n\tcase ITIMER_REAL:\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\tvalue->it_value = itimer_get_remtime(&tsk->signal->real_timer);\n\t\tvalue->it_interval =\n\t\t\tktime_to_timeval(tsk->signal->it_real_incr);\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\t\tbreak;\n\tcase ITIMER_VIRTUAL:\n\t\tget_cpu_itimer(tsk, CPUCLOCK_VIRT, value);\n\t\tbreak;\n\tcase ITIMER_PROF:\n\t\tget_cpu_itimer(tsk, CPUCLOCK_PROF, value);\n\t\tbreak;\n\tdefault:\n\t\treturn(-EINVAL);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "get_cpu_itimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/itimer.c",
    "lines": "49-81",
    "snippet": "static void get_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   struct itimerval *const value)\n{\n\tu64 val, interval;\n\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\n\tval = it->expires;\n\tinterval = it->incr;\n\tif (val) {\n\t\tstruct task_cputime cputime;\n\t\tu64 t;\n\n\t\tthread_group_cputimer(tsk, &cputime);\n\t\tif (clock_id == CPUCLOCK_PROF)\n\t\t\tt = cputime.utime + cputime.stime;\n\t\telse\n\t\t\t/* CPUCLOCK_VIRT */\n\t\t\tt = cputime.utime;\n\n\t\tif (val < t)\n\t\t\t/* about to fire */\n\t\t\tval = TICK_NSEC;\n\t\telse\n\t\t\tval -= t;\n\t}\n\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tvalue->it_value = ns_to_timeval(val);\n\tvalue->it_interval = ns_to_timeval(interval);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_to_timeval",
          "args": [
            "interval"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "ns_to_timeval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "456-465",
          "snippet": "struct timeval ns_to_timeval(const s64 nsec)\n{\n\tstruct timespec ts = ns_to_timespec(nsec);\n\tstruct timeval tv;\n\n\ttv.tv_sec = ts.tv_sec;\n\ttv.tv_usec = (suseconds_t) ts.tv_nsec / 1000;\n\n\treturn tv;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timeval ns_to_timeval(const s64 nsec)\n{\n\tstruct timespec ts = ns_to_timespec(nsec);\n\tstruct timeval tv;\n\n\ttv.tv_sec = ts.tv_sec;\n\ttv.tv_usec = (suseconds_t) ts.tv_nsec / 1000;\n\n\treturn tv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_cputimer",
          "args": [
            "tsk",
            "&cputime"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "thread_group_cputimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "212-237",
          "snippet": "void thread_group_cputimer(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct task_cputime sum;\n\n\t/* Check if cputimer isn't running. This is accessed without locking. */\n\tif (!READ_ONCE(cputimer->running)) {\n\t\t/*\n\t\t * The POSIX timer interface allows for absolute time expiry\n\t\t * values through the TIMER_ABSTIME flag, therefore we have\n\t\t * to synchronize the timer to the clock every time we start it.\n\t\t */\n\t\tthread_group_cputime(tsk, &sum);\n\t\tupdate_gt_cputime(&cputimer->cputime_atomic, &sum);\n\n\t\t/*\n\t\t * We're setting cputimer->running without a lock. Ensure\n\t\t * this only gets written to in one operation. We set\n\t\t * running after update_gt_cputime() as a small optimization,\n\t\t * but barriers are not required because update_gt_cputime()\n\t\t * can handle concurrent updates.\n\t\t */\n\t\tWRITE_ONCE(cputimer->running, true);\n\t}\n\tsample_cputime_atomic(times, &cputimer->cputime_atomic);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nvoid thread_group_cputimer(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct task_cputime sum;\n\n\t/* Check if cputimer isn't running. This is accessed without locking. */\n\tif (!READ_ONCE(cputimer->running)) {\n\t\t/*\n\t\t * The POSIX timer interface allows for absolute time expiry\n\t\t * values through the TIMER_ABSTIME flag, therefore we have\n\t\t * to synchronize the timer to the clock every time we start it.\n\t\t */\n\t\tthread_group_cputime(tsk, &sum);\n\t\tupdate_gt_cputime(&cputimer->cputime_atomic, &sum);\n\n\t\t/*\n\t\t * We're setting cputimer->running without a lock. Ensure\n\t\t * this only gets written to in one operation. We set\n\t\t * running after update_gt_cputime() as a small optimization,\n\t\t * but barriers are not required because update_gt_cputime()\n\t\t * can handle concurrent updates.\n\t\t */\n\t\tWRITE_ONCE(cputimer->running, true);\n\t}\n\tsample_cputime_atomic(times, &cputimer->cputime_atomic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic void get_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   struct itimerval *const value)\n{\n\tu64 val, interval;\n\tstruct cpu_itimer *it = &tsk->signal->it[clock_id];\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\n\tval = it->expires;\n\tinterval = it->incr;\n\tif (val) {\n\t\tstruct task_cputime cputime;\n\t\tu64 t;\n\n\t\tthread_group_cputimer(tsk, &cputime);\n\t\tif (clock_id == CPUCLOCK_PROF)\n\t\t\tt = cputime.utime + cputime.stime;\n\t\telse\n\t\t\t/* CPUCLOCK_VIRT */\n\t\t\tt = cputime.utime;\n\n\t\tif (val < t)\n\t\t\t/* about to fire */\n\t\t\tval = TICK_NSEC;\n\t\telse\n\t\t\tval -= t;\n\t}\n\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tvalue->it_value = ns_to_timeval(val);\n\tvalue->it_interval = ns_to_timeval(interval);\n}"
  },
  {
    "function_name": "itimer_get_remtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/itimer.c",
    "lines": "31-47",
    "snippet": "static struct timeval itimer_get_remtime(struct hrtimer *timer)\n{\n\tktime_t rem = __hrtimer_get_remaining(timer, true);\n\n\t/*\n\t * Racy but safe: if the itimer expires after the above\n\t * hrtimer_get_remtime() call but before this condition\n\t * then we return 0 - which is correct.\n\t */\n\tif (hrtimer_active(timer)) {\n\t\tif (rem <= 0)\n\t\t\trem = NSEC_PER_USEC;\n\t} else\n\t\trem = 0;\n\n\treturn ktime_to_timeval(rem);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_timeval",
          "args": [
            "rem"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_active",
          "args": [
            "timer"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1320-1337",
          "snippet": "bool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nbool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hrtimer_get_remaining",
          "args": [
            "timer",
            "true"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "__hrtimer_get_remaining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1184-1197",
          "snippet": "ktime_t __hrtimer_get_remaining(const struct hrtimer *timer, bool adjust)\n{\n\tunsigned long flags;\n\tktime_t rem;\n\n\tlock_hrtimer_base(timer, &flags);\n\tif (IS_ENABLED(CONFIG_TIME_LOW_RES) && adjust)\n\t\trem = hrtimer_expires_remaining_adjusted(timer);\n\telse\n\t\trem = hrtimer_expires_remaining(timer);\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn rem;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t __hrtimer_get_remaining(const struct hrtimer *timer, bool adjust)\n{\n\tunsigned long flags;\n\tktime_t rem;\n\n\tlock_hrtimer_base(timer, &flags);\n\tif (IS_ENABLED(CONFIG_TIME_LOW_RES) && adjust)\n\t\trem = hrtimer_expires_remaining_adjusted(timer);\n\telse\n\t\trem = hrtimer_expires_remaining(timer);\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn rem;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct timeval itimer_get_remtime(struct hrtimer *timer)\n{\n\tktime_t rem = __hrtimer_get_remaining(timer, true);\n\n\t/*\n\t * Racy but safe: if the itimer expires after the above\n\t * hrtimer_get_remtime() call but before this condition\n\t * then we return 0 - which is correct.\n\t */\n\tif (hrtimer_active(timer)) {\n\t\tif (rem <= 0)\n\t\t\trem = NSEC_PER_USEC;\n\t} else\n\t\trem = 0;\n\n\treturn ktime_to_timeval(rem);\n}"
  },
  {
    "function_name": "getitimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/itimer.c",
    "lines": "107-119",
    "snippet": "SYSCALL_DEFINE2(getitimer, int, which, struct itimerval __user *, value)\n{\n\tint error = -EFAULT;\n\tstruct itimerval get_buffer;\n\n\tif (value) {\n\t\terror = do_getitimer(which, &get_buffer);\n\t\tif (!error &&\n\t\t    copy_to_user(value, &get_buffer, sizeof(get_buffer)))\n\t\t\terror = -EFAULT;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(getitimer, int, which, struct itimerval __user *, value)\n{\n\tint error = -EFAULT;\n\tstruct itimerval get_buffer;\n\n\tif (value) {\n\t\terror = do_getitimer(which, &get_buffer);\n\t\tif (!error &&\n\t\t    copy_to_user(value, &get_buffer, sizeof(get_buffer)))\n\t\t\terror = -EFAULT;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "getitimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/itimer.c",
    "lines": "122-131",
    "snippet": "SYSCALL_DEFINE2(getitimer, int, which,\n\t\t       struct compat_itimerval __user *, it)\n{\n\tstruct itimerval kit;\n\tint error = do_getitimer(which, &kit);\n\n\tif (!error && put_compat_itimerval(it, &kit))\n\t\terror = -EFAULT;\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE2(getitimer, int, which,\n\t\t       struct compat_itimerval __user *, it)\n{\n\tstruct itimerval kit;\n\tint error = do_getitimer(which, &kit);\n\n\tif (!error && put_compat_itimerval(it, &kit))\n\t\terror = -EFAULT;\n\treturn error;\n}"
  },
  {
    "function_name": "alarm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/itimer.c",
    "lines": "286-289",
    "snippet": "SYSCALL_DEFINE1(alarm, unsigned int, seconds)\n{\n\treturn alarm_setitimer(seconds);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE1(alarm, unsigned int, seconds)\n{\n\treturn alarm_setitimer(seconds);\n}"
  },
  {
    "function_name": "setitimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/itimer.c",
    "lines": "293-316",
    "snippet": "SYSCALL_DEFINE3(setitimer, int, which, struct itimerval __user *, value,\n\t\tstruct itimerval __user *, ovalue)\n{\n\tstruct itimerval set_buffer, get_buffer;\n\tint error;\n\n\tif (value) {\n\t\tif(copy_from_user(&set_buffer, value, sizeof(set_buffer)))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(&set_buffer, 0, sizeof(set_buffer));\n\t\tprintk_once(KERN_WARNING \"%s calls setitimer() with new_value NULL pointer.\"\n\t\t\t    \" Misfeature support will be removed\\n\",\n\t\t\t    current->comm);\n\t}\n\n\terror = do_setitimer(which, &set_buffer, ovalue ? &get_buffer : NULL);\n\tif (error || !ovalue)\n\t\treturn error;\n\n\tif (copy_to_user(ovalue, &get_buffer, sizeof(get_buffer)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE3(setitimer, int, which, struct itimerval __user *, value,\n\t\tstruct itimerval __user *, ovalue)\n{\n\tstruct itimerval set_buffer, get_buffer;\n\tint error;\n\n\tif (value) {\n\t\tif(copy_from_user(&set_buffer, value, sizeof(set_buffer)))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(&set_buffer, 0, sizeof(set_buffer));\n\t\tprintk_once(KERN_WARNING \"%s calls setitimer() with new_value NULL pointer.\"\n\t\t\t    \" Misfeature support will be removed\\n\",\n\t\t\t    current->comm);\n\t}\n\n\terror = do_setitimer(which, &set_buffer, ovalue ? &get_buffer : NULL);\n\tif (error || !ovalue)\n\t\treturn error;\n\n\tif (copy_to_user(ovalue, &get_buffer, sizeof(get_buffer)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "setitimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/itimer.c",
    "lines": "319-339",
    "snippet": "SYSCALL_DEFINE3(setitimer, int, which,\n\t\t       struct compat_itimerval __user *, in,\n\t\t       struct compat_itimerval __user *, out)\n{\n\tstruct itimerval kin, kout;\n\tint error;\n\n\tif (in) {\n\t\tif (get_compat_itimerval(&kin, in))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(&kin, 0, sizeof(kin));\n\t}\n\n\terror = do_setitimer(which, &kin, out ? &kout : NULL);\n\tif (error || !out)\n\t\treturn error;\n\tif (put_compat_itimerval(out, &kout))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <trace/events/timer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <trace/events/timer.h>\n#include <linux/hrtimer.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nSYSCALL_DEFINE3(setitimer, int, which,\n\t\t       struct compat_itimerval __user *, in,\n\t\t       struct compat_itimerval __user *, out)\n{\n\tstruct itimerval kin, kout;\n\tint error;\n\n\tif (in) {\n\t\tif (get_compat_itimerval(&kin, in))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(&kin, 0, sizeof(kin));\n\t}\n\n\terror = do_setitimer(which, &kin, out ? &kout : NULL);\n\tif (error || !out)\n\t\treturn error;\n\tif (put_compat_itimerval(out, &kout))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  }
]