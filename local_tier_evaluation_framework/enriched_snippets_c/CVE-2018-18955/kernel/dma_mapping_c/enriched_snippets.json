[
  {
    "function_name": "dma_common_free_remap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/mapping.c",
    "lines": "336-347",
    "snippet": "void dma_common_free_remap(void *cpu_addr, size_t size, unsigned long vm_flags)\n{\n\tstruct vm_struct *area = find_vm_area(cpu_addr);\n\n\tif (!area || (area->flags & vm_flags) != vm_flags) {\n\t\tWARN(1, \"trying to free invalid coherent area: %p\\n\", cpu_addr);\n\t\treturn;\n\t}\n\n\tunmap_kernel_range((unsigned long)cpu_addr, PAGE_ALIGN(size));\n\tvunmap(cpu_addr);\n}",
    "includes": [
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vunmap",
          "args": [
            "cpu_addr"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_kernel_range",
          "args": [
            "(unsigned long)cpu_addr",
            "PAGE_ALIGN(size)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"trying to free invalid coherent area: %p\\n\"",
            "cpu_addr"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vm_area",
          "args": [
            "cpu_addr"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/acpi.h>\n\nvoid dma_common_free_remap(void *cpu_addr, size_t size, unsigned long vm_flags)\n{\n\tstruct vm_struct *area = find_vm_area(cpu_addr);\n\n\tif (!area || (area->flags & vm_flags) != vm_flags) {\n\t\tWARN(1, \"trying to free invalid coherent area: %p\\n\", cpu_addr);\n\t\treturn;\n\t}\n\n\tunmap_kernel_range((unsigned long)cpu_addr, PAGE_ALIGN(size));\n\tvunmap(cpu_addr);\n}"
  },
  {
    "function_name": "dma_common_contiguous_remap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/mapping.c",
    "lines": "309-331",
    "snippet": "void *dma_common_contiguous_remap(struct page *page, size_t size,\n\t\t\tunsigned long vm_flags,\n\t\t\tpgprot_t prot, const void *caller)\n{\n\tint i;\n\tstruct page **pages;\n\tstruct vm_struct *area;\n\n\tpages = kmalloc(sizeof(struct page *) << get_order(size), GFP_KERNEL);\n\tif (!pages)\n\t\treturn NULL;\n\n\tfor (i = 0; i < (size >> PAGE_SHIFT); i++)\n\t\tpages[i] = nth_page(page, i);\n\n\tarea = __dma_common_pages_remap(pages, size, vm_flags, prot, caller);\n\n\tkfree(pages);\n\n\tif (!area)\n\t\treturn NULL;\n\treturn area->addr;\n}",
    "includes": [
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pages"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dma_common_pages_remap",
          "args": [
            "pages",
            "size",
            "vm_flags",
            "prot",
            "caller"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_common_pages_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/mapping.c",
          "lines": "267-283",
          "snippet": "static struct vm_struct *__dma_common_pages_remap(struct page **pages,\n\t\t\tsize_t size, unsigned long vm_flags, pgprot_t prot,\n\t\t\tconst void *caller)\n{\n\tstruct vm_struct *area;\n\n\tarea = get_vm_area_caller(size, vm_flags, caller);\n\tif (!area)\n\t\treturn NULL;\n\n\tif (map_vm_area(area, prot, pages)) {\n\t\tvunmap(area->addr);\n\t\treturn NULL;\n\t}\n\n\treturn area;\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/acpi.h>\n\nstatic struct vm_struct *__dma_common_pages_remap(struct page **pages,\n\t\t\tsize_t size, unsigned long vm_flags, pgprot_t prot,\n\t\t\tconst void *caller)\n{\n\tstruct vm_struct *area;\n\n\tarea = get_vm_area_caller(size, vm_flags, caller);\n\tif (!area)\n\t\treturn NULL;\n\n\tif (map_vm_area(area, prot, pages)) {\n\t\tvunmap(area->addr);\n\t\treturn NULL;\n\t}\n\n\treturn area;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nth_page",
          "args": [
            "page",
            "i"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct page *) << get_order(size)",
            "GFP_KERNEL"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/acpi.h>\n\nvoid *dma_common_contiguous_remap(struct page *page, size_t size,\n\t\t\tunsigned long vm_flags,\n\t\t\tpgprot_t prot, const void *caller)\n{\n\tint i;\n\tstruct page **pages;\n\tstruct vm_struct *area;\n\n\tpages = kmalloc(sizeof(struct page *) << get_order(size), GFP_KERNEL);\n\tif (!pages)\n\t\treturn NULL;\n\n\tfor (i = 0; i < (size >> PAGE_SHIFT); i++)\n\t\tpages[i] = nth_page(page, i);\n\n\tarea = __dma_common_pages_remap(pages, size, vm_flags, prot, caller);\n\n\tkfree(pages);\n\n\tif (!area)\n\t\treturn NULL;\n\treturn area->addr;\n}"
  },
  {
    "function_name": "dma_common_pages_remap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/mapping.c",
    "lines": "289-302",
    "snippet": "void *dma_common_pages_remap(struct page **pages, size_t size,\n\t\t\tunsigned long vm_flags, pgprot_t prot,\n\t\t\tconst void *caller)\n{\n\tstruct vm_struct *area;\n\n\tarea = __dma_common_pages_remap(pages, size, vm_flags, prot, caller);\n\tif (!area)\n\t\treturn NULL;\n\n\tarea->pages = pages;\n\n\treturn area->addr;\n}",
    "includes": [
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dma_common_pages_remap",
          "args": [
            "pages",
            "size",
            "vm_flags",
            "prot",
            "caller"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "__dma_common_pages_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/mapping.c",
          "lines": "267-283",
          "snippet": "static struct vm_struct *__dma_common_pages_remap(struct page **pages,\n\t\t\tsize_t size, unsigned long vm_flags, pgprot_t prot,\n\t\t\tconst void *caller)\n{\n\tstruct vm_struct *area;\n\n\tarea = get_vm_area_caller(size, vm_flags, caller);\n\tif (!area)\n\t\treturn NULL;\n\n\tif (map_vm_area(area, prot, pages)) {\n\t\tvunmap(area->addr);\n\t\treturn NULL;\n\t}\n\n\treturn area;\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-noncoherent.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/acpi.h>\n\nstatic struct vm_struct *__dma_common_pages_remap(struct page **pages,\n\t\t\tsize_t size, unsigned long vm_flags, pgprot_t prot,\n\t\t\tconst void *caller)\n{\n\tstruct vm_struct *area;\n\n\tarea = get_vm_area_caller(size, vm_flags, caller);\n\tif (!area)\n\t\treturn NULL;\n\n\tif (map_vm_area(area, prot, pages)) {\n\t\tvunmap(area->addr);\n\t\treturn NULL;\n\t}\n\n\treturn area;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/acpi.h>\n\nvoid *dma_common_pages_remap(struct page **pages, size_t size,\n\t\t\tunsigned long vm_flags, pgprot_t prot,\n\t\t\tconst void *caller)\n{\n\tstruct vm_struct *area;\n\n\tarea = __dma_common_pages_remap(pages, size, vm_flags, prot, caller);\n\tif (!area)\n\t\treturn NULL;\n\n\tarea->pages = pages;\n\n\treturn area->addr;\n}"
  },
  {
    "function_name": "__dma_common_pages_remap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/mapping.c",
    "lines": "267-283",
    "snippet": "static struct vm_struct *__dma_common_pages_remap(struct page **pages,\n\t\t\tsize_t size, unsigned long vm_flags, pgprot_t prot,\n\t\t\tconst void *caller)\n{\n\tstruct vm_struct *area;\n\n\tarea = get_vm_area_caller(size, vm_flags, caller);\n\tif (!area)\n\t\treturn NULL;\n\n\tif (map_vm_area(area, prot, pages)) {\n\t\tvunmap(area->addr);\n\t\treturn NULL;\n\t}\n\n\treturn area;\n}",
    "includes": [
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vunmap",
          "args": [
            "area->addr"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_vm_area",
          "args": [
            "area",
            "prot",
            "pages"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_vm_area_caller",
          "args": [
            "size",
            "vm_flags",
            "caller"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/acpi.h>\n\nstatic struct vm_struct *__dma_common_pages_remap(struct page **pages,\n\t\t\tsize_t size, unsigned long vm_flags, pgprot_t prot,\n\t\t\tconst void *caller)\n{\n\tstruct vm_struct *area;\n\n\tarea = get_vm_area_caller(size, vm_flags, caller);\n\tif (!area)\n\t\treturn NULL;\n\n\tif (map_vm_area(area, prot, pages)) {\n\t\tvunmap(area->addr);\n\t\treturn NULL;\n\t}\n\n\treturn area;\n}"
  },
  {
    "function_name": "dma_common_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/mapping.c",
    "lines": "231-263",
    "snippet": "int dma_common_mmap(struct device *dev, struct vm_area_struct *vma,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs)\n{\n#ifndef CONFIG_ARCH_NO_COHERENT_DMA_MMAP\n\tunsigned long user_count = vma_pages(vma);\n\tunsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tunsigned long off = vma->vm_pgoff;\n\tunsigned long pfn;\n\tint ret = -ENXIO;\n\n\tvma->vm_page_prot = arch_dma_mmap_pgprot(dev, vma->vm_page_prot, attrs);\n\n\tif (dma_mmap_from_dev_coherent(dev, vma, cpu_addr, size, &ret))\n\t\treturn ret;\n\n\tif (off >= count || user_count > count - off)\n\t\treturn -ENXIO;\n\n\tif (!dev_is_dma_coherent(dev)) {\n\t\tif (!IS_ENABLED(CONFIG_ARCH_HAS_DMA_COHERENT_TO_PFN))\n\t\t\treturn -ENXIO;\n\t\tpfn = arch_dma_coherent_to_pfn(dev, cpu_addr, dma_addr);\n\t} else {\n\t\tpfn = page_to_pfn(virt_to_page(cpu_addr));\n\t}\n\n\treturn remap_pfn_range(vma, vma->vm_start, pfn + vma->vm_pgoff,\n\t\t\tuser_count << PAGE_SHIFT, vma->vm_page_prot);\n#else\n\treturn -ENXIO;\n#endif /* !CONFIG_ARCH_NO_COHERENT_DMA_MMAP */\n}",
    "includes": [
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remap_pfn_range",
          "args": [
            "vma",
            "vma->vm_start",
            "pfn + vma->vm_pgoff",
            "user_count << PAGE_SHIFT",
            "vma->vm_page_prot"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "virt_to_page(cpu_addr)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "cpu_addr"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_dma_coherent_to_pfn",
          "args": [
            "dev",
            "cpu_addr",
            "dma_addr"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ARCH_HAS_DMA_COHERENT_TO_PFN"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_mmap_from_dev_coherent",
          "args": [
            "dev",
            "vma",
            "cpu_addr",
            "size",
            "&ret"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "dma_mmap_from_dev_coherent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/coherent.c",
          "lines": "319-325",
          "snippet": "int dma_mmap_from_dev_coherent(struct device *dev, struct vm_area_struct *vma,\n\t\t\t   void *vaddr, size_t size, int *ret)\n{\n\tstruct dma_coherent_mem *mem = dev_get_coherent_memory(dev);\n\n\treturn __dma_mmap_from_coherent(mem, vma, vaddr, size, ret);\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\nint dma_mmap_from_dev_coherent(struct device *dev, struct vm_area_struct *vma,\n\t\t\t   void *vaddr, size_t size, int *ret)\n{\n\tstruct dma_coherent_mem *mem = dev_get_coherent_memory(dev);\n\n\treturn __dma_mmap_from_coherent(mem, vma, vaddr, size, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_dma_mmap_pgprot",
          "args": [
            "dev",
            "vma->vm_page_prot",
            "attrs"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_pages",
          "args": [
            "vma"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/acpi.h>\n\nint dma_common_mmap(struct device *dev, struct vm_area_struct *vma,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs)\n{\n#ifndef CONFIG_ARCH_NO_COHERENT_DMA_MMAP\n\tunsigned long user_count = vma_pages(vma);\n\tunsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tunsigned long off = vma->vm_pgoff;\n\tunsigned long pfn;\n\tint ret = -ENXIO;\n\n\tvma->vm_page_prot = arch_dma_mmap_pgprot(dev, vma->vm_page_prot, attrs);\n\n\tif (dma_mmap_from_dev_coherent(dev, vma, cpu_addr, size, &ret))\n\t\treturn ret;\n\n\tif (off >= count || user_count > count - off)\n\t\treturn -ENXIO;\n\n\tif (!dev_is_dma_coherent(dev)) {\n\t\tif (!IS_ENABLED(CONFIG_ARCH_HAS_DMA_COHERENT_TO_PFN))\n\t\t\treturn -ENXIO;\n\t\tpfn = arch_dma_coherent_to_pfn(dev, cpu_addr, dma_addr);\n\t} else {\n\t\tpfn = page_to_pfn(virt_to_page(cpu_addr));\n\t}\n\n\treturn remap_pfn_range(vma, vma->vm_start, pfn + vma->vm_pgoff,\n\t\t\tuser_count << PAGE_SHIFT, vma->vm_page_prot);\n#else\n\treturn -ENXIO;\n#endif /* !CONFIG_ARCH_NO_COHERENT_DMA_MMAP */\n}"
  },
  {
    "function_name": "dma_common_get_sgtable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/mapping.c",
    "lines": "204-225",
    "snippet": "int dma_common_get_sgtable(struct device *dev, struct sg_table *sgt,\n\t\t void *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\t unsigned long attrs)\n{\n\tstruct page *page;\n\tint ret;\n\n\tif (!dev_is_dma_coherent(dev)) {\n\t\tif (!IS_ENABLED(CONFIG_ARCH_HAS_DMA_COHERENT_TO_PFN))\n\t\t\treturn -ENXIO;\n\n\t\tpage = pfn_to_page(arch_dma_coherent_to_pfn(dev, cpu_addr,\n\t\t\t\tdma_addr));\n\t} else {\n\t\tpage = virt_to_page(cpu_addr);\n\t}\n\n\tret = sg_alloc_table(sgt, 1, GFP_KERNEL);\n\tif (!ret)\n\t\tsg_set_page(sgt->sgl, page, PAGE_ALIGN(size), 0);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sg_set_page",
          "args": [
            "sgt->sgl",
            "page",
            "PAGE_ALIGN(size)",
            "0"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_alloc_table",
          "args": [
            "sgt",
            "1",
            "GFP_KERNEL"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "cpu_addr"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "arch_dma_coherent_to_pfn(dev, cpu_addr,\n\t\t\t\tdma_addr)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_dma_coherent_to_pfn",
          "args": [
            "dev",
            "cpu_addr",
            "dma_addr"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_ARCH_HAS_DMA_COHERENT_TO_PFN"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/acpi.h>\n\nint dma_common_get_sgtable(struct device *dev, struct sg_table *sgt,\n\t\t void *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\t unsigned long attrs)\n{\n\tstruct page *page;\n\tint ret;\n\n\tif (!dev_is_dma_coherent(dev)) {\n\t\tif (!IS_ENABLED(CONFIG_ARCH_HAS_DMA_COHERENT_TO_PFN))\n\t\t\treturn -ENXIO;\n\n\t\tpage = pfn_to_page(arch_dma_coherent_to_pfn(dev, cpu_addr,\n\t\t\t\tdma_addr));\n\t} else {\n\t\tpage = virt_to_page(cpu_addr);\n\t}\n\n\tret = sg_alloc_table(sgt, 1, GFP_KERNEL);\n\tif (!ret)\n\t\tsg_set_page(sgt->sgl, page, PAGE_ALIGN(size), 0);\n\treturn ret;\n}"
  },
  {
    "function_name": "dmam_release_declared_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/mapping.c",
    "lines": "193-196",
    "snippet": "void dmam_release_declared_memory(struct device *dev)\n{\n\tWARN_ON(devres_destroy(dev, dmam_coherent_decl_release, NULL, NULL));\n}",
    "includes": [
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "devres_destroy(dev, dmam_coherent_decl_release, NULL, NULL)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_destroy",
          "args": [
            "dev",
            "dmam_coherent_decl_release",
            "NULL",
            "NULL"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/acpi.h>\n\nvoid dmam_release_declared_memory(struct device *dev)\n{\n\tWARN_ON(devres_destroy(dev, dmam_coherent_decl_release, NULL, NULL));\n}"
  },
  {
    "function_name": "dmam_declare_coherent_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/mapping.c",
    "lines": "166-184",
    "snippet": "int dmam_declare_coherent_memory(struct device *dev, phys_addr_t phys_addr,\n\t\t\t\t dma_addr_t device_addr, size_t size, int flags)\n{\n\tvoid *res;\n\tint rc;\n\n\tres = devres_alloc(dmam_coherent_decl_release, 0, GFP_KERNEL);\n\tif (!res)\n\t\treturn -ENOMEM;\n\n\trc = dma_declare_coherent_memory(dev, phys_addr, device_addr, size,\n\t\t\t\t\t flags);\n\tif (!rc)\n\t\tdevres_add(dev, res);\n\telse\n\t\tdevres_free(res);\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devres_free",
          "args": [
            "res"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_add",
          "args": [
            "dev",
            "res"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_declare_coherent_memory",
          "args": [
            "dev",
            "phys_addr",
            "device_addr",
            "size",
            "flags"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "dma_declare_coherent_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/coherent.c",
          "lines": "112-126",
          "snippet": "int dma_declare_coherent_memory(struct device *dev, phys_addr_t phys_addr,\n\t\t\t\tdma_addr_t device_addr, size_t size, int flags)\n{\n\tstruct dma_coherent_mem *mem;\n\tint ret;\n\n\tret = dma_init_coherent_memory(phys_addr, device_addr, size, flags, &mem);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dma_assign_coherent_memory(dev, mem);\n\tif (ret)\n\t\tdma_release_coherent_memory(mem);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\nint dma_declare_coherent_memory(struct device *dev, phys_addr_t phys_addr,\n\t\t\t\tdma_addr_t device_addr, size_t size, int flags)\n{\n\tstruct dma_coherent_mem *mem;\n\tint ret;\n\n\tret = dma_init_coherent_memory(phys_addr, device_addr, size, flags, &mem);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dma_assign_coherent_memory(dev, mem);\n\tif (ret)\n\t\tdma_release_coherent_memory(mem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "devres_alloc",
          "args": [
            "dmam_coherent_decl_release",
            "0",
            "GFP_KERNEL"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/acpi.h>\n\nint dmam_declare_coherent_memory(struct device *dev, phys_addr_t phys_addr,\n\t\t\t\t dma_addr_t device_addr, size_t size, int flags)\n{\n\tvoid *res;\n\tint rc;\n\n\tres = devres_alloc(dmam_coherent_decl_release, 0, GFP_KERNEL);\n\tif (!res)\n\t\treturn -ENOMEM;\n\n\trc = dma_declare_coherent_memory(dev, phys_addr, device_addr, size,\n\t\t\t\t\t flags);\n\tif (!rc)\n\t\tdevres_add(dev, res);\n\telse\n\t\tdevres_free(res);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "dmam_coherent_decl_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/mapping.c",
    "lines": "148-151",
    "snippet": "static void dmam_coherent_decl_release(struct device *dev, void *res)\n{\n\tdma_release_declared_memory(dev);\n}",
    "includes": [
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_release_declared_memory",
          "args": [
            "dev"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "dma_release_declared_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/coherent.c",
          "lines": "129-137",
          "snippet": "void dma_release_declared_memory(struct device *dev)\n{\n\tstruct dma_coherent_mem *mem = dev->dma_mem;\n\n\tif (!mem)\n\t\treturn;\n\tdma_release_coherent_memory(mem);\n\tdev->dma_mem = NULL;\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\nvoid dma_release_declared_memory(struct device *dev)\n{\n\tstruct dma_coherent_mem *mem = dev->dma_mem;\n\n\tif (!mem)\n\t\treturn;\n\tdma_release_coherent_memory(mem);\n\tdev->dma_mem = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/acpi.h>\n\nstatic void dmam_coherent_decl_release(struct device *dev, void *res)\n{\n\tdma_release_declared_memory(dev);\n}"
  },
  {
    "function_name": "dmam_alloc_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/mapping.c",
    "lines": "119-143",
    "snippet": "void *dmam_alloc_attrs(struct device *dev, size_t size, dma_addr_t *dma_handle,\n\t\tgfp_t gfp, unsigned long attrs)\n{\n\tstruct dma_devres *dr;\n\tvoid *vaddr;\n\n\tdr = devres_alloc(dmam_release, sizeof(*dr), gfp);\n\tif (!dr)\n\t\treturn NULL;\n\n\tvaddr = dma_alloc_attrs(dev, size, dma_handle, gfp, attrs);\n\tif (!vaddr) {\n\t\tdevres_free(dr);\n\t\treturn NULL;\n\t}\n\n\tdr->vaddr = vaddr;\n\tdr->dma_handle = *dma_handle;\n\tdr->size = size;\n\tdr->attrs = attrs;\n\n\tdevres_add(dev, dr);\n\n\treturn vaddr;\n}",
    "includes": [
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devres_add",
          "args": [
            "dev",
            "dr"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_free",
          "args": [
            "dr"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_alloc_attrs",
          "args": [
            "dev",
            "size",
            "dma_handle",
            "gfp",
            "attrs"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_alloc",
          "args": [
            "dmam_release",
            "sizeof(*dr)",
            "gfp"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/acpi.h>\n\nvoid *dmam_alloc_attrs(struct device *dev, size_t size, dma_addr_t *dma_handle,\n\t\tgfp_t gfp, unsigned long attrs)\n{\n\tstruct dma_devres *dr;\n\tvoid *vaddr;\n\n\tdr = devres_alloc(dmam_release, sizeof(*dr), gfp);\n\tif (!dr)\n\t\treturn NULL;\n\n\tvaddr = dma_alloc_attrs(dev, size, dma_handle, gfp, attrs);\n\tif (!vaddr) {\n\t\tdevres_free(dr);\n\t\treturn NULL;\n\t}\n\n\tdr->vaddr = vaddr;\n\tdr->dma_handle = *dma_handle;\n\tdr->size = size;\n\tdr->attrs = attrs;\n\n\tdevres_add(dev, dr);\n\n\treturn vaddr;\n}"
  },
  {
    "function_name": "dmam_free_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/mapping.c",
    "lines": "95-102",
    "snippet": "void dmam_free_coherent(struct device *dev, size_t size, void *vaddr,\n\t\t\tdma_addr_t dma_handle)\n{\n\tstruct dma_devres match_data = { size, vaddr, dma_handle };\n\n\tdma_free_coherent(dev, size, vaddr, dma_handle);\n\tWARN_ON(devres_destroy(dev, dmam_release, dmam_match, &match_data));\n}",
    "includes": [
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "devres_destroy(dev, dmam_release, dmam_match, &match_data)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_destroy",
          "args": [
            "dev",
            "dmam_release",
            "dmam_match",
            "&match_data"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_free_coherent",
          "args": [
            "dev",
            "size",
            "vaddr",
            "dma_handle"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_free_coherent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1555-1580",
          "snippet": "void debug_dma_free_coherent(struct device *dev, size_t size,\n\t\t\t void *virt, dma_addr_t addr)\n{\n\tstruct dma_debug_entry ref = {\n\t\t.type           = dma_debug_coherent,\n\t\t.dev            = dev,\n\t\t.offset\t\t= offset_in_page(virt),\n\t\t.dev_addr       = addr,\n\t\t.size           = size,\n\t\t.direction      = DMA_BIDIRECTIONAL,\n\t};\n\n\t/* handle vmalloc and linear addresses */\n\tif (!is_vmalloc_addr(virt) && !virt_addr_valid(virt))\n\t\treturn;\n\n\tif (is_vmalloc_addr(virt))\n\t\tref.pfn = vmalloc_to_pfn(virt);\n\telse\n\t\tref.pfn = page_to_pfn(virt_to_page(virt));\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tcheck_unmap(&ref);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_free_coherent(struct device *dev, size_t size,\n\t\t\t void *virt, dma_addr_t addr)\n{\n\tstruct dma_debug_entry ref = {\n\t\t.type           = dma_debug_coherent,\n\t\t.dev            = dev,\n\t\t.offset\t\t= offset_in_page(virt),\n\t\t.dev_addr       = addr,\n\t\t.size           = size,\n\t\t.direction      = DMA_BIDIRECTIONAL,\n\t};\n\n\t/* handle vmalloc and linear addresses */\n\tif (!is_vmalloc_addr(virt) && !virt_addr_valid(virt))\n\t\treturn;\n\n\tif (is_vmalloc_addr(virt))\n\t\tref.pfn = vmalloc_to_pfn(virt);\n\telse\n\t\tref.pfn = page_to_pfn(virt_to_page(virt));\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tcheck_unmap(&ref);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/acpi.h>\n\nvoid dmam_free_coherent(struct device *dev, size_t size, void *vaddr,\n\t\t\tdma_addr_t dma_handle)\n{\n\tstruct dma_devres match_data = { size, vaddr, dma_handle };\n\n\tdma_free_coherent(dev, size, vaddr, dma_handle);\n\tWARN_ON(devres_destroy(dev, dmam_release, dmam_match, &match_data));\n}"
  },
  {
    "function_name": "dmam_alloc_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/mapping.c",
    "lines": "60-83",
    "snippet": "void *dmam_alloc_coherent(struct device *dev, size_t size,\n\t\t\t   dma_addr_t *dma_handle, gfp_t gfp)\n{\n\tstruct dma_devres *dr;\n\tvoid *vaddr;\n\n\tdr = devres_alloc(dmam_release, sizeof(*dr), gfp);\n\tif (!dr)\n\t\treturn NULL;\n\n\tvaddr = dma_alloc_coherent(dev, size, dma_handle, gfp);\n\tif (!vaddr) {\n\t\tdevres_free(dr);\n\t\treturn NULL;\n\t}\n\n\tdr->vaddr = vaddr;\n\tdr->dma_handle = *dma_handle;\n\tdr->size = size;\n\n\tdevres_add(dev, dr);\n\n\treturn vaddr;\n}",
    "includes": [
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "devres_add",
          "args": [
            "dev",
            "dr"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_free",
          "args": [
            "dr"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_alloc_coherent",
          "args": [
            "dev",
            "size",
            "dma_handle",
            "gfp"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "debug_dma_alloc_coherent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/debug.c",
          "lines": "1520-1552",
          "snippet": "void debug_dma_alloc_coherent(struct device *dev, size_t size,\n\t\t\t      dma_addr_t dma_addr, void *virt)\n{\n\tstruct dma_debug_entry *entry;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tif (unlikely(virt == NULL))\n\t\treturn;\n\n\t/* handle vmalloc and linear addresses */\n\tif (!is_vmalloc_addr(virt) && !virt_addr_valid(virt))\n\t\treturn;\n\n\tentry = dma_entry_alloc();\n\tif (!entry)\n\t\treturn;\n\n\tentry->type      = dma_debug_coherent;\n\tentry->dev       = dev;\n\tentry->offset\t = offset_in_page(virt);\n\tentry->size      = size;\n\tentry->dev_addr  = dma_addr;\n\tentry->direction = DMA_BIDIRECTIONAL;\n\n\tif (is_vmalloc_addr(virt))\n\t\tentry->pfn = vmalloc_to_pfn(virt);\n\telse\n\t\tentry->pfn = page_to_pfn(virt_to_page(virt));\n\n\tadd_dma_entry(entry);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>",
            "#include <linux/export.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/dma-debug.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/dma-debug.h>\n#include <linux/stacktrace.h>\n#include <linux/sched/task.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/task_stack.h>\n\nvoid debug_dma_alloc_coherent(struct device *dev, size_t size,\n\t\t\t      dma_addr_t dma_addr, void *virt)\n{\n\tstruct dma_debug_entry *entry;\n\n\tif (unlikely(dma_debug_disabled()))\n\t\treturn;\n\n\tif (unlikely(virt == NULL))\n\t\treturn;\n\n\t/* handle vmalloc and linear addresses */\n\tif (!is_vmalloc_addr(virt) && !virt_addr_valid(virt))\n\t\treturn;\n\n\tentry = dma_entry_alloc();\n\tif (!entry)\n\t\treturn;\n\n\tentry->type      = dma_debug_coherent;\n\tentry->dev       = dev;\n\tentry->offset\t = offset_in_page(virt);\n\tentry->size      = size;\n\tentry->dev_addr  = dma_addr;\n\tentry->direction = DMA_BIDIRECTIONAL;\n\n\tif (is_vmalloc_addr(virt))\n\t\tentry->pfn = vmalloc_to_pfn(virt);\n\telse\n\t\tentry->pfn = page_to_pfn(virt_to_page(virt));\n\n\tadd_dma_entry(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "devres_alloc",
          "args": [
            "dmam_release",
            "sizeof(*dr)",
            "gfp"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/acpi.h>\n\nvoid *dmam_alloc_coherent(struct device *dev, size_t size,\n\t\t\t   dma_addr_t *dma_handle, gfp_t gfp)\n{\n\tstruct dma_devres *dr;\n\tvoid *vaddr;\n\n\tdr = devres_alloc(dmam_release, sizeof(*dr), gfp);\n\tif (!dr)\n\t\treturn NULL;\n\n\tvaddr = dma_alloc_coherent(dev, size, dma_handle, gfp);\n\tif (!vaddr) {\n\t\tdevres_free(dr);\n\t\treturn NULL;\n\t}\n\n\tdr->vaddr = vaddr;\n\tdr->dma_handle = *dma_handle;\n\tdr->size = size;\n\n\tdevres_add(dev, dr);\n\n\treturn vaddr;\n}"
  },
  {
    "function_name": "dmam_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/mapping.c",
    "lines": "35-45",
    "snippet": "static int dmam_match(struct device *dev, void *res, void *match_data)\n{\n\tstruct dma_devres *this = res, *match = match_data;\n\n\tif (this->vaddr == match->vaddr) {\n\t\tWARN_ON(this->size != match->size ||\n\t\t\tthis->dma_handle != match->dma_handle);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "this->size != match->size ||\n\t\t\tthis->dma_handle != match->dma_handle"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/acpi.h>\n\nstatic int dmam_match(struct device *dev, void *res, void *match_data)\n{\n\tstruct dma_devres *this = res, *match = match_data;\n\n\tif (this->vaddr == match->vaddr) {\n\t\tWARN_ON(this->size != match->size ||\n\t\t\tthis->dma_handle != match->dma_handle);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "dmam_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/dma/mapping.c",
    "lines": "27-33",
    "snippet": "static void dmam_release(struct device *dev, void *res)\n{\n\tstruct dma_devres *this = res;\n\n\tdma_free_attrs(dev, this->size, this->vaddr, this->dma_handle,\n\t\t\tthis->attrs);\n}",
    "includes": [
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/of_device.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/dma-noncoherent.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_free_attrs",
          "args": [
            "dev",
            "this->size",
            "this->vaddr",
            "this->dma_handle",
            "this->attrs"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-noncoherent.h>\n#include <linux/acpi.h>\n\nstatic void dmam_release(struct device *dev, void *res)\n{\n\tstruct dma_devres *this = res;\n\n\tdma_free_attrs(dev, this->size, this->vaddr, this->dma_handle,\n\t\t\tthis->attrs);\n}"
  }
]