[
  {
    "function_name": "event_trace_self_tests_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "3435-3443",
    "snippet": "static __init int event_trace_self_tests_init(void)\n{\n\tif (!tracing_selftest_disabled) {\n\t\tevent_trace_self_tests();\n\t\tevent_trace_self_test_with_function();\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trace_self_test_with_function",
          "args": [],
          "line": 3439
        },
        "resolved": true,
        "details": {
          "function_name": "event_trace_self_test_with_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "3430-3432",
          "snippet": "static __init void event_trace_self_test_with_function(void)\n{\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic __init void event_trace_self_test_with_function(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_trace_self_tests",
          "args": [],
          "line": 3438
        },
        "resolved": true,
        "details": {
          "function_name": "event_trace_self_tests_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "3435-3443",
          "snippet": "static __init int event_trace_self_tests_init(void)\n{\n\tif (!tracing_selftest_disabled) {\n\t\tevent_trace_self_tests();\n\t\tevent_trace_self_test_with_function();\n\t}\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic __init int event_trace_self_tests_init(void)\n{\n\tif (!tracing_selftest_disabled) {\n\t\tevent_trace_self_tests();\n\t\tevent_trace_self_test_with_function();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_trace_self_test_with_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "3430-3432",
    "snippet": "static __init void event_trace_self_test_with_function(void)\n{\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic __init void event_trace_self_test_with_function(void)\n{\n}"
  },
  {
    "function_name": "event_trace_self_test_with_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "3412-3428",
    "snippet": "static __init void event_trace_self_test_with_function(void)\n{\n\tint ret;\n\n\tevent_trace_file.tr = top_trace_array();\n\tif (WARN_ON(!event_trace_file.tr))\n\t\treturn;\n\n\tret = register_ftrace_function(&trace_ops);\n\tif (WARN_ON(ret < 0)) {\n\t\tpr_info(\"Failed to enable function tracer for event tests\\n\");\n\t\treturn;\n\t}\n\tpr_info(\"Running tests again, along with the function tracer\\n\");\n\tevent_trace_self_tests();\n\tunregister_ftrace_function(&trace_ops);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "&trace_ops"
          ],
          "line": 3427
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_trace_self_tests",
          "args": [],
          "line": 3426
        },
        "resolved": true,
        "details": {
          "function_name": "event_trace_self_tests_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "3435-3443",
          "snippet": "static __init int event_trace_self_tests_init(void)\n{\n\tif (!tracing_selftest_disabled) {\n\t\tevent_trace_self_tests();\n\t\tevent_trace_self_test_with_function();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic __init int event_trace_self_tests_init(void)\n{\n\tif (!tracing_selftest_disabled) {\n\t\tevent_trace_self_tests();\n\t\tevent_trace_self_test_with_function();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Running tests again, along with the function tracer\\n\""
          ],
          "line": 3425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Failed to enable function tracer for event tests\\n\""
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 3421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!event_trace_file.tr"
          ],
          "line": 3417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "top_trace_array",
          "args": [],
          "line": 3416
        },
        "resolved": true,
        "details": {
          "function_name": "top_trace_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "301-312",
          "snippet": "static inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic __init void event_trace_self_test_with_function(void)\n{\n\tint ret;\n\n\tevent_trace_file.tr = top_trace_array();\n\tif (WARN_ON(!event_trace_file.tr))\n\t\treturn;\n\n\tret = register_ftrace_function(&trace_ops);\n\tif (WARN_ON(ret < 0)) {\n\t\tpr_info(\"Failed to enable function tracer for event tests\\n\");\n\t\treturn;\n\t}\n\tpr_info(\"Running tests again, along with the function tracer\\n\");\n\tevent_trace_self_tests();\n\tunregister_ftrace_function(&trace_ops);\n}"
  },
  {
    "function_name": "function_test_events_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "3368-3404",
    "snippet": "static void __init\nfunction_test_events_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct pt_regs *pt_regs)\n{\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tstruct ftrace_entry *entry;\n\tunsigned long flags;\n\tlong disabled;\n\tint cpu;\n\tint pc;\n\n\tpc = preempt_count();\n\tpreempt_disable_notrace();\n\tcpu = raw_smp_processor_id();\n\tdisabled = atomic_inc_return(&per_cpu(ftrace_test_event_disable, cpu));\n\n\tif (disabled != 1)\n\t\tgoto out;\n\n\tlocal_save_flags(flags);\n\n\tevent = trace_event_buffer_lock_reserve(&buffer, &event_trace_file,\n\t\t\t\t\t\tTRACE_FN, sizeof(*entry),\n\t\t\t\t\t\tflags, pc);\n\tif (!event)\n\t\tgoto out;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ip\t\t\t= ip;\n\tentry->parent_ip\t\t= parent_ip;\n\n\tevent_trigger_unlock_commit(&event_trace_file, buffer, event,\n\t\t\t\t    entry, flags, pc);\n out:\n\tatomic_dec(&per_cpu(ftrace_test_event_disable, cpu));\n\tpreempt_enable_notrace();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 3403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&per_cpu(ftrace_test_event_disable, cpu)"
          ],
          "line": 3402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "ftrace_test_event_disable",
            "cpu"
          ],
          "line": 3402
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_trigger_unlock_commit",
          "args": [
            "&event_trace_file",
            "buffer",
            "event",
            "entry",
            "flags",
            "pc"
          ],
          "line": 3399
        },
        "resolved": true,
        "details": {
          "function_name": "event_trigger_unlock_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1323-1336",
          "snippet": "static inline void\nevent_trigger_unlock_commit(struct trace_event_file *file,\n\t\t\t    struct ring_buffer *buffer,\n\t\t\t    struct ring_buffer_event *event,\n\t\t\t    void *entry, unsigned long irq_flags, int pc)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\n\tif (!__event_trigger_test_discard(file, buffer, event, entry, &tt))\n\t\ttrace_buffer_unlock_commit(file->tr, buffer, event, irq_flags, pc);\n\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void\nevent_trigger_unlock_commit(struct trace_event_file *file,\n\t\t\t    struct ring_buffer *buffer,\n\t\t\t    struct ring_buffer_event *event,\n\t\t\t    void *entry, unsigned long irq_flags, int pc)\n{\n\tenum event_trigger_type tt = ETT_NONE;\n\n\tif (!__event_trigger_test_discard(file, buffer, event, entry, &tt))\n\t\ttrace_buffer_unlock_commit(file->tr, buffer, event, irq_flags, pc);\n\n\tif (tt)\n\t\tevent_triggers_post_call(file, tt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 3395
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "272-275",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_lock_reserve",
          "args": [
            "&buffer",
            "&event_trace_file",
            "TRACE_FN",
            "sizeof(*entry)",
            "flags",
            "pc"
          ],
          "line": 3390
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_lock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2274-2312",
          "snippet": "struct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct ring_buffer **current_rb,\n\t\t\t  struct trace_event_file *trace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\tstruct ring_buffer_event *entry;\n\tint val;\n\n\t*current_rb = trace_file->tr->trace_buffer.buffer;\n\n\tif (!ring_buffer_time_stamp_abs(*current_rb) && (trace_file->flags &\n\t     (EVENT_FILE_FL_SOFT_DISABLED | EVENT_FILE_FL_FILTERED)) &&\n\t    (entry = this_cpu_read(trace_buffered_event))) {\n\t\t/* Try to use the per cpu buffer first */\n\t\tval = this_cpu_inc_return(trace_buffered_event_cnt);\n\t\tif (val == 1) {\n\t\t\ttrace_event_setup(entry, type, flags, pc);\n\t\t\tentry->array[0] = len;\n\t\t\treturn entry;\n\t\t}\n\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t}\n\n\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t    type, len, flags, pc);\n\t/*\n\t * If tracing is off, but we have triggers enabled\n\t * we still need to look at the event data. Use the temp_buffer\n\t * to store the trace event for the tigger to use. It's recusive\n\t * safe and will not be recorded anywhere.\n\t */\n\tif (!entry && trace_file->flags & EVENT_FILE_FL_TRIGGER_COND) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t\t    type, len, flags, pc);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static struct ring_buffer *temp_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic struct ring_buffer *temp_buffer;\n\nstruct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct ring_buffer **current_rb,\n\t\t\t  struct trace_event_file *trace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\tstruct ring_buffer_event *entry;\n\tint val;\n\n\t*current_rb = trace_file->tr->trace_buffer.buffer;\n\n\tif (!ring_buffer_time_stamp_abs(*current_rb) && (trace_file->flags &\n\t     (EVENT_FILE_FL_SOFT_DISABLED | EVENT_FILE_FL_FILTERED)) &&\n\t    (entry = this_cpu_read(trace_buffered_event))) {\n\t\t/* Try to use the per cpu buffer first */\n\t\tval = this_cpu_inc_return(trace_buffered_event_cnt);\n\t\tif (val == 1) {\n\t\t\ttrace_event_setup(entry, type, flags, pc);\n\t\t\tentry->array[0] = len;\n\t\t\treturn entry;\n\t\t}\n\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t}\n\n\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t    type, len, flags, pc);\n\t/*\n\t * If tracing is off, but we have triggers enabled\n\t * we still need to look at the event data. Use the temp_buffer\n\t * to store the trace event for the tigger to use. It's recusive\n\t * safe and will not be recorded anywhere.\n\t */\n\tif (!entry && trace_file->flags & EVENT_FILE_FL_TRIGGER_COND) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t\t    type, len, flags, pc);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_save_flags",
          "args": [
            "flags"
          ],
          "line": 3388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&per_cpu(ftrace_test_event_disable, cpu)"
          ],
          "line": 3383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 3382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 3380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __init\nfunction_test_events_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *op, struct pt_regs *pt_regs)\n{\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tstruct ftrace_entry *entry;\n\tunsigned long flags;\n\tlong disabled;\n\tint cpu;\n\tint pc;\n\n\tpc = preempt_count();\n\tpreempt_disable_notrace();\n\tcpu = raw_smp_processor_id();\n\tdisabled = atomic_inc_return(&per_cpu(ftrace_test_event_disable, cpu));\n\n\tif (disabled != 1)\n\t\tgoto out;\n\n\tlocal_save_flags(flags);\n\n\tevent = trace_event_buffer_lock_reserve(&buffer, &event_trace_file,\n\t\t\t\t\t\tTRACE_FN, sizeof(*entry),\n\t\t\t\t\t\tflags, pc);\n\tif (!event)\n\t\tgoto out;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ip\t\t\t= ip;\n\tentry->parent_ip\t\t= parent_ip;\n\n\tevent_trigger_unlock_commit(&event_trace_file, buffer, event,\n\t\t\t\t    entry, flags, pc);\n out:\n\tatomic_dec(&per_cpu(ftrace_test_event_disable, cpu));\n\tpreempt_enable_notrace();\n}"
  },
  {
    "function_name": "event_trace_self_tests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "3252-3360",
    "snippet": "static __init void event_trace_self_tests(void)\n{\n\tstruct trace_subsystem_dir *dir;\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tstruct event_subsystem *system;\n\tstruct trace_array *tr;\n\tint ret;\n\n\ttr = top_trace_array();\n\tif (!tr)\n\t\treturn;\n\n\tpr_info(\"Running tests on trace events:\\n\");\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\n\t\t/* Only test those that have a probe */\n\t\tif (!call->class || !call->class->probe)\n\t\t\tcontinue;\n\n/*\n * Testing syscall events here is pretty useless, but\n * we still do it if configured. But this is time consuming.\n * What we really need is a user thread to perform the\n * syscalls as we test.\n */\n#ifndef CONFIG_EVENT_TRACE_TEST_SYSCALLS\n\t\tif (call->class->system &&\n\t\t    strcmp(call->class->system, \"syscalls\") == 0)\n\t\t\tcontinue;\n#endif\n\n\t\tpr_info(\"Testing event %s: \", trace_event_name(call));\n\n\t\t/*\n\t\t * If an event is already enabled, someone is using\n\t\t * it and the self test should not be on.\n\t\t */\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED) {\n\t\t\tpr_warn(\"Enabled event during self test!\\n\");\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tftrace_event_enable_disable(file, 1);\n\t\tevent_test_stuff();\n\t\tftrace_event_enable_disable(file, 0);\n\n\t\tpr_cont(\"OK\\n\");\n\t}\n\n\t/* Now test at the sub system level */\n\n\tpr_info(\"Running tests on trace event systems:\\n\");\n\n\tlist_for_each_entry(dir, &tr->systems, list) {\n\n\t\tsystem = dir->subsystem;\n\n\t\t/* the ftrace system is special, skip it */\n\t\tif (strcmp(system->name, \"ftrace\") == 0)\n\t\t\tcontinue;\n\n\t\tpr_info(\"Testing event system %s: \", system->name);\n\n\t\tret = __ftrace_set_clr_event(tr, NULL, system->name, NULL, 1);\n\t\tif (WARN_ON_ONCE(ret)) {\n\t\t\tpr_warn(\"error enabling system %s\\n\",\n\t\t\t\tsystem->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tevent_test_stuff();\n\n\t\tret = __ftrace_set_clr_event(tr, NULL, system->name, NULL, 0);\n\t\tif (WARN_ON_ONCE(ret)) {\n\t\t\tpr_warn(\"error disabling system %s\\n\",\n\t\t\t\tsystem->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_cont(\"OK\\n\");\n\t}\n\n\t/* Test with all events enabled */\n\n\tpr_info(\"Running tests on all trace events:\\n\");\n\tpr_info(\"Testing all events: \");\n\n\tret = __ftrace_set_clr_event(tr, NULL, NULL, NULL, 1);\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error enabling all events\\n\");\n\t\treturn;\n\t}\n\n\tevent_test_stuff();\n\n\t/* reset sysname */\n\tret = __ftrace_set_clr_event(tr, NULL, NULL, NULL, 0);\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error disabling all events\\n\");\n\t\treturn;\n\t}\n\n\tpr_cont(\"OK\\n\");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"OK\\n\""
          ],
          "line": 3359
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error disabling all events\\n\""
          ],
          "line": 3355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 3354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ftrace_set_clr_event",
          "args": [
            "tr",
            "NULL",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 3353
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_set_clr_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "786-796",
          "snippet": "static int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_test_stuff",
          "args": [],
          "line": 3350
        },
        "resolved": true,
        "details": {
          "function_name": "event_test_stuff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "3239-3246",
          "snippet": "static __init void event_test_stuff(void)\n{\n\tstruct task_struct *test_thread;\n\n\ttest_thread = kthread_run(event_test_thread, NULL, \"test-events\");\n\tmsleep(1);\n\tkthread_stop(test_thread);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic __init void event_test_stuff(void)\n{\n\tstruct task_struct *test_thread;\n\n\ttest_thread = kthread_run(event_test_thread, NULL, \"test-events\");\n\tmsleep(1);\n\tkthread_stop(test_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error enabling all events\\n\""
          ],
          "line": 3346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 3345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Testing all events: \""
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Running tests on all trace events:\\n\""
          ],
          "line": 3341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error disabling system %s\\n\"",
            "system->name"
          ],
          "line": 3331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 3330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"error enabling system %s\\n\"",
            "system->name"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 3321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Testing event system %s: \"",
            "system->name"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "system->name",
            "\"ftrace\""
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dir",
            "&tr->systems",
            "list"
          ],
          "line": 3310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Running tests on trace event systems:\\n\""
          ],
          "line": 3308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_event_enable_disable",
          "args": [
            "file",
            "0"
          ],
          "line": 3301
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "493-497",
          "snippet": "static int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 3295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Enabled event during self test!\\n\""
          ],
          "line": 3294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Testing event %s: \"",
            "trace_event_name(call)"
          ],
          "line": 3287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 3287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "call->class->system",
            "\"syscalls\""
          ],
          "line": 3283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 3267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Running tests on trace events:\\n\""
          ],
          "line": 3265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "top_trace_array",
          "args": [],
          "line": 3261
        },
        "resolved": true,
        "details": {
          "function_name": "top_trace_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "301-312",
          "snippet": "static inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic __init void event_trace_self_tests(void)\n{\n\tstruct trace_subsystem_dir *dir;\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tstruct event_subsystem *system;\n\tstruct trace_array *tr;\n\tint ret;\n\n\ttr = top_trace_array();\n\tif (!tr)\n\t\treturn;\n\n\tpr_info(\"Running tests on trace events:\\n\");\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\n\t\t/* Only test those that have a probe */\n\t\tif (!call->class || !call->class->probe)\n\t\t\tcontinue;\n\n/*\n * Testing syscall events here is pretty useless, but\n * we still do it if configured. But this is time consuming.\n * What we really need is a user thread to perform the\n * syscalls as we test.\n */\n#ifndef CONFIG_EVENT_TRACE_TEST_SYSCALLS\n\t\tif (call->class->system &&\n\t\t    strcmp(call->class->system, \"syscalls\") == 0)\n\t\t\tcontinue;\n#endif\n\n\t\tpr_info(\"Testing event %s: \", trace_event_name(call));\n\n\t\t/*\n\t\t * If an event is already enabled, someone is using\n\t\t * it and the self test should not be on.\n\t\t */\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED) {\n\t\t\tpr_warn(\"Enabled event during self test!\\n\");\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tftrace_event_enable_disable(file, 1);\n\t\tevent_test_stuff();\n\t\tftrace_event_enable_disable(file, 0);\n\n\t\tpr_cont(\"OK\\n\");\n\t}\n\n\t/* Now test at the sub system level */\n\n\tpr_info(\"Running tests on trace event systems:\\n\");\n\n\tlist_for_each_entry(dir, &tr->systems, list) {\n\n\t\tsystem = dir->subsystem;\n\n\t\t/* the ftrace system is special, skip it */\n\t\tif (strcmp(system->name, \"ftrace\") == 0)\n\t\t\tcontinue;\n\n\t\tpr_info(\"Testing event system %s: \", system->name);\n\n\t\tret = __ftrace_set_clr_event(tr, NULL, system->name, NULL, 1);\n\t\tif (WARN_ON_ONCE(ret)) {\n\t\t\tpr_warn(\"error enabling system %s\\n\",\n\t\t\t\tsystem->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tevent_test_stuff();\n\n\t\tret = __ftrace_set_clr_event(tr, NULL, system->name, NULL, 0);\n\t\tif (WARN_ON_ONCE(ret)) {\n\t\t\tpr_warn(\"error disabling system %s\\n\",\n\t\t\t\tsystem->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_cont(\"OK\\n\");\n\t}\n\n\t/* Test with all events enabled */\n\n\tpr_info(\"Running tests on all trace events:\\n\");\n\tpr_info(\"Testing all events: \");\n\n\tret = __ftrace_set_clr_event(tr, NULL, NULL, NULL, 1);\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error enabling all events\\n\");\n\t\treturn;\n\t}\n\n\tevent_test_stuff();\n\n\t/* reset sysname */\n\tret = __ftrace_set_clr_event(tr, NULL, NULL, NULL, 0);\n\tif (WARN_ON_ONCE(ret)) {\n\t\tpr_warn(\"error disabling all events\\n\");\n\t\treturn;\n\t}\n\n\tpr_cont(\"OK\\n\");\n}"
  },
  {
    "function_name": "event_test_stuff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "3239-3246",
    "snippet": "static __init void event_test_stuff(void)\n{\n\tstruct task_struct *test_thread;\n\n\ttest_thread = kthread_run(event_test_thread, NULL, \"test-events\");\n\tmsleep(1);\n\tkthread_stop(test_thread);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "test_thread"
          ],
          "line": 3245
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "538-556",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = k->exit_code;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = k->exit_code;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "1"
          ],
          "line": 3244
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1965-1972",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "event_test_thread",
            "NULL",
            "\"test-events\""
          ],
          "line": 3243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic __init void event_test_stuff(void)\n{\n\tstruct task_struct *test_thread;\n\n\ttest_thread = kthread_run(event_test_thread, NULL, \"test-events\");\n\tmsleep(1);\n\tkthread_stop(test_thread);\n}"
  },
  {
    "function_name": "event_test_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "3214-3234",
    "snippet": "static __init int event_test_thread(void *unused)\n{\n\tvoid *test_malloc;\n\n\ttest_malloc = kmalloc(1234, GFP_KERNEL);\n\tif (!test_malloc)\n\t\tpr_info(\"failed to kmalloc\\n\");\n\n\tschedule_on_each_cpu(test_work);\n\n\tkfree(test_malloc);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 3231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 3229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 3228
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 3227
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "98-101",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 3226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "test_malloc"
          ],
          "line": 3224
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_on_each_cpu",
          "args": [
            "test_work"
          ],
          "line": 3222
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_on_each_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3151-3175",
          "snippet": "int schedule_on_each_cpu(work_func_t func)\n{\n\tint cpu;\n\tstruct work_struct __percpu *works;\n\n\tworks = alloc_percpu(struct work_struct);\n\tif (!works)\n\t\treturn -ENOMEM;\n\n\tget_online_cpus();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = per_cpu_ptr(works, cpu);\n\n\t\tINIT_WORK(work, func);\n\t\tschedule_work_on(cpu, work);\n\t}\n\n\tfor_each_online_cpu(cpu)\n\t\tflush_work(per_cpu_ptr(works, cpu));\n\n\tput_online_cpus();\n\tfree_percpu(works);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint schedule_on_each_cpu(work_func_t func)\n{\n\tint cpu;\n\tstruct work_struct __percpu *works;\n\n\tworks = alloc_percpu(struct work_struct);\n\tif (!works)\n\t\treturn -ENOMEM;\n\n\tget_online_cpus();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = per_cpu_ptr(works, cpu);\n\n\t\tINIT_WORK(work, func);\n\t\tschedule_work_on(cpu, work);\n\t}\n\n\tfor_each_online_cpu(cpu)\n\t\tflush_work(per_cpu_ptr(works, cpu));\n\n\tput_online_cpus();\n\tfree_percpu(works);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"failed to kmalloc\\n\""
          ],
          "line": 3220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "1234",
            "GFP_KERNEL"
          ],
          "line": 3218
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic __init int event_test_thread(void *unused)\n{\n\tvoid *test_malloc;\n\n\ttest_malloc = kmalloc(1234, GFP_KERNEL);\n\tif (!test_malloc)\n\t\tpr_info(\"failed to kmalloc\\n\");\n\n\tschedule_on_each_cpu(test_work);\n\n\tkfree(test_malloc);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "test_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "3201-3212",
    "snippet": "static __init void test_work(struct work_struct *dummy)\n{\n\tspin_lock(&test_spinlock);\n\tspin_lock_irq(&test_spinlock_irq);\n\tudelay(1);\n\tspin_unlock_irq(&test_spinlock_irq);\n\tspin_unlock(&test_spinlock);\n\n\tmutex_lock(&test_mutex);\n\tmsleep(1);\n\tmutex_unlock(&test_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&test_mutex"
          ],
          "line": 3211
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "1"
          ],
          "line": 3210
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1965-1972",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&test_mutex"
          ],
          "line": 3209
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&test_spinlock"
          ],
          "line": 3207
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&test_spinlock_irq"
          ],
          "line": 3206
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "1"
          ],
          "line": 3205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&test_spinlock_irq"
          ],
          "line": 3204
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&test_spinlock"
          ],
          "line": 3203
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic __init void test_work(struct work_struct *dummy)\n{\n\tspin_lock(&test_spinlock);\n\tspin_lock_irq(&test_spinlock_irq);\n\tudelay(1);\n\tspin_unlock_irq(&test_spinlock_irq);\n\tspin_unlock(&test_spinlock);\n\n\tmutex_lock(&test_mutex);\n\tmsleep(1);\n\tmutex_unlock(&test_mutex);\n}"
  },
  {
    "function_name": "trace_event_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "3188-3193",
    "snippet": "void __init trace_event_init(void)\n{\n\tevent_trace_memsetup();\n\tinit_ftrace_syscalls();\n\tevent_trace_enable();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_trace_enable",
          "args": [],
          "line": 3192
        },
        "resolved": true,
        "details": {
          "function_name": "event_trace_enable_again",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "3135-3146",
          "snippet": "static __init int event_trace_enable_again(void)\n{\n\tstruct trace_array *tr;\n\n\ttr = top_trace_array();\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tearly_enable_events(tr, true);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic __init int event_trace_enable_again(void)\n{\n\tstruct trace_array *tr;\n\n\ttr = top_trace_array();\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tearly_enable_events(tr, true);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_ftrace_syscalls",
          "args": [],
          "line": 3191
        },
        "resolved": true,
        "details": {
          "function_name": "init_ftrace_syscalls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1804-1804",
          "snippet": "static inline void init_ftrace_syscalls(void) { }",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void init_ftrace_syscalls(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "event_trace_memsetup",
          "args": [],
          "line": 3190
        },
        "resolved": true,
        "details": {
          "function_name": "event_trace_memsetup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "3053-3058",
          "snippet": "static __init int event_trace_memsetup(void)\n{\n\tfield_cachep = KMEM_CACHE(ftrace_event_field, SLAB_PANIC);\n\tfile_cachep = KMEM_CACHE(trace_event_file, SLAB_PANIC);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *field_cachep;",
            "static struct kmem_cache *file_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic struct kmem_cache *field_cachep;\nstatic struct kmem_cache *file_cachep;\n\nstatic __init int event_trace_memsetup(void)\n{\n\tfield_cachep = KMEM_CACHE(ftrace_event_field, SLAB_PANIC);\n\tfile_cachep = KMEM_CACHE(trace_event_file, SLAB_PANIC);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nvoid __init trace_event_init(void)\n{\n\tevent_trace_memsetup();\n\tinit_ftrace_syscalls();\n\tevent_trace_enable();\n}"
  },
  {
    "function_name": "event_trace_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "3150-3186",
    "snippet": "__init int event_trace_init(void)\n{\n\tstruct trace_array *tr;\n\tstruct dentry *d_tracer;\n\tstruct dentry *entry;\n\tint ret;\n\n\ttr = top_trace_array();\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\td_tracer = tracing_init_dentry();\n\tif (IS_ERR(d_tracer))\n\t\treturn 0;\n\n\tentry = tracefs_create_file(\"available_events\", 0444, d_tracer,\n\t\t\t\t    tr, &ftrace_avail_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'available_events' entry\\n\");\n\n\tif (trace_define_generic_fields())\n\t\tpr_warn(\"tracing: Failed to allocated generic fields\");\n\n\tif (trace_define_common_fields())\n\t\tpr_warn(\"tracing: Failed to allocate common fields\");\n\n\tret = early_event_add_tracer(d_tracer, tr);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_MODULES\n\tret = register_module_notifier(&trace_module_nb);\n\tif (ret)\n\t\tpr_warn(\"Failed to register trace events module notifier\\n\");\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations ftrace_avail_fops = {\n\t.open = ftrace_event_avail_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to register trace events module notifier\\n\""
          ],
          "line": 3183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_module_notifier",
          "args": [
            "&trace_module_nb"
          ],
          "line": 3181
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_module_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "304-307",
          "snippet": "int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(module_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_event_add_tracer",
          "args": [
            "d_tracer",
            "tr"
          ],
          "line": 3176
        },
        "resolved": true,
        "details": {
          "function_name": "early_event_add_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "3005-3024",
          "snippet": "static __init int\nearly_event_add_tracer(struct dentry *parent, struct trace_array *tr)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\n\tret = create_event_toplevel_files(parent, tr);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tdown_write(&trace_event_sem);\n\t__trace_early_add_event_dirs(tr);\n\tup_write(&trace_event_sem);\n\n out_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic __init int\nearly_event_add_tracer(struct dentry *parent, struct trace_array *tr)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\n\tret = create_event_toplevel_files(parent, tr);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tdown_write(&trace_event_sem);\n\t__trace_early_add_event_dirs(tr);\n\tup_write(&trace_event_sem);\n\n out_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"tracing: Failed to allocate common fields\""
          ],
          "line": 3174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_define_common_fields",
          "args": [],
          "line": 3173
        },
        "resolved": true,
        "details": {
          "function_name": "trace_define_common_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "182-193",
          "snippet": "static int trace_define_common_fields(void)\n{\n\tint ret;\n\tstruct trace_entry ent;\n\n\t__common_field(unsigned short, type);\n\t__common_field(unsigned char, flags);\n\t__common_field(unsigned char, preempt_count);\n\t__common_field(int, pid);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int trace_define_common_fields(void)\n{\n\tint ret;\n\tstruct trace_entry ent;\n\n\t__common_field(unsigned short, type);\n\t__common_field(unsigned char, flags);\n\t__common_field(unsigned char, preempt_count);\n\t__common_field(int, pid);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"tracing: Failed to allocated generic fields\""
          ],
          "line": 3171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_define_generic_fields",
          "args": [],
          "line": 3170
        },
        "resolved": true,
        "details": {
          "function_name": "trace_define_generic_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "170-180",
          "snippet": "static int trace_define_generic_fields(void)\n{\n\tint ret;\n\n\t__generic_field(int, CPU, FILTER_CPU);\n\t__generic_field(int, cpu, FILTER_CPU);\n\t__generic_field(char *, COMM, FILTER_COMM);\n\t__generic_field(char *, comm, FILTER_COMM);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int trace_define_generic_fields(void)\n{\n\tint ret;\n\n\t__generic_field(int, CPU, FILTER_CPU);\n\t__generic_field(int, cpu, FILTER_CPU);\n\t__generic_field(char *, COMM, FILTER_COMM);\n\t__generic_field(char *, comm, FILTER_COMM);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'available_events' entry\\n\""
          ],
          "line": 3168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"available_events\"",
            "0444",
            "d_tracer",
            "tr",
            "&ftrace_avail_fops"
          ],
          "line": 3165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "d_tracer"
          ],
          "line": 3162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_init_dentry",
          "args": [],
          "line": 3161
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_init_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8023-8050",
          "snippet": "struct dentry *tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn NULL;\n\n\tif (WARN_ON(!tracefs_initialized()) ||\n\t\t(IS_ENABLED(CONFIG_DEBUG_FS) &&\n\t\t WARN_ON(!debugfs_initialized())))\n\t\treturn ERR_PTR(-ENODEV);\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kerenl.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\tif (!tr->dir) {\n\t\tpr_warn_once(\"Could not create debugfs directory 'tracing'\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nstruct dentry *tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn NULL;\n\n\tif (WARN_ON(!tracefs_initialized()) ||\n\t\t(IS_ENABLED(CONFIG_DEBUG_FS) &&\n\t\t WARN_ON(!debugfs_initialized())))\n\t\treturn ERR_PTR(-ENODEV);\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kerenl.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\tif (!tr->dir) {\n\t\tpr_warn_once(\"Could not create debugfs directory 'tracing'\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "top_trace_array",
          "args": [],
          "line": 3157
        },
        "resolved": true,
        "details": {
          "function_name": "top_trace_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "301-312",
          "snippet": "static inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic const struct file_operations ftrace_avail_fops = {\n\t.open = ftrace_event_avail_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n\n__init int event_trace_init(void)\n{\n\tstruct trace_array *tr;\n\tstruct dentry *d_tracer;\n\tstruct dentry *entry;\n\tint ret;\n\n\ttr = top_trace_array();\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\td_tracer = tracing_init_dentry();\n\tif (IS_ERR(d_tracer))\n\t\treturn 0;\n\n\tentry = tracefs_create_file(\"available_events\", 0444, d_tracer,\n\t\t\t\t    tr, &ftrace_avail_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'available_events' entry\\n\");\n\n\tif (trace_define_generic_fields())\n\t\tpr_warn(\"tracing: Failed to allocated generic fields\");\n\n\tif (trace_define_common_fields())\n\t\tpr_warn(\"tracing: Failed to allocate common fields\");\n\n\tret = early_event_add_tracer(d_tracer, tr);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_MODULES\n\tret = register_module_notifier(&trace_module_nb);\n\tif (ret)\n\t\tpr_warn(\"Failed to register trace events module notifier\\n\");\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "event_trace_enable_again",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "3135-3146",
    "snippet": "static __init int event_trace_enable_again(void)\n{\n\tstruct trace_array *tr;\n\n\ttr = top_trace_array();\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tearly_enable_events(tr, true);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "early_enable_events",
          "args": [
            "tr",
            "true"
          ],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "early_enable_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "3060-3087",
          "snippet": "static __init void\nearly_enable_events(struct trace_array *tr, bool disable_first)\n{\n\tchar *buf = bootup_event_buf;\n\tchar *token;\n\tint ret;\n\n\twhile (true) {\n\t\ttoken = strsep(&buf, \",\");\n\n\t\tif (!token)\n\t\t\tbreak;\n\n\t\tif (*token) {\n\t\t\t/* Restarting syscalls requires that we stop them first */\n\t\t\tif (disable_first)\n\t\t\t\tftrace_set_clr_event(tr, token, 0);\n\n\t\t\tret = ftrace_set_clr_event(tr, token, 1);\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Failed to enable trace event: %s\\n\", token);\n\t\t}\n\n\t\t/* Put back the comma to allow this to be called again */\n\t\tif (buf)\n\t\t\t*(buf - 1) = ',';\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char bootup_event_buf[COMMAND_LINE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic char bootup_event_buf[COMMAND_LINE_SIZE];\n\nstatic __init void\nearly_enable_events(struct trace_array *tr, bool disable_first)\n{\n\tchar *buf = bootup_event_buf;\n\tchar *token;\n\tint ret;\n\n\twhile (true) {\n\t\ttoken = strsep(&buf, \",\");\n\n\t\tif (!token)\n\t\t\tbreak;\n\n\t\tif (*token) {\n\t\t\t/* Restarting syscalls requires that we stop them first */\n\t\t\tif (disable_first)\n\t\t\t\tftrace_set_clr_event(tr, token, 0);\n\n\t\t\tret = ftrace_set_clr_event(tr, token, 1);\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Failed to enable trace event: %s\\n\", token);\n\t\t}\n\n\t\t/* Put back the comma to allow this to be called again */\n\t\tif (buf)\n\t\t\t*(buf - 1) = ',';\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "top_trace_array",
          "args": [],
          "line": 3139
        },
        "resolved": true,
        "details": {
          "function_name": "top_trace_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "301-312",
          "snippet": "static inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic __init int event_trace_enable_again(void)\n{\n\tstruct trace_array *tr;\n\n\ttr = top_trace_array();\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tearly_enable_events(tr, true);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_trace_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "3089-3123",
    "snippet": "static __init int event_trace_enable(void)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_call **iter, *call;\n\tint ret;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tfor_each_event(iter, __start_ftrace_events, __stop_ftrace_events) {\n\n\t\tcall = *iter;\n\t\tret = event_init(call);\n\t\tif (!ret)\n\t\t\tlist_add(&call->list, &ftrace_events);\n\t}\n\n\t/*\n\t * We need the top trace array to have a working set of trace\n\t * points at early init, before the debug files and directories\n\t * are created. Create the file entries now, and attach them\n\t * to the actual file dentries later.\n\t */\n\t__trace_early_add_events(tr);\n\n\tearly_enable_events(tr, false);\n\n\ttrace_printk_start_comm();\n\n\tregister_event_cmds();\n\n\tregister_trigger_cmds();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);",
      "extern struct trace_event_call *__start_ftrace_events[];",
      "extern struct trace_event_call *__stop_ftrace_events[];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_trigger_cmds",
          "args": [],
          "line": 3120
        },
        "resolved": true,
        "details": {
          "function_name": "register_trigger_cmds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "1625-1635",
          "snippet": "__init int register_trigger_cmds(void)\n{\n\tregister_trigger_traceon_traceoff_cmds();\n\tregister_trigger_snapshot_cmd();\n\tregister_trigger_stacktrace_cmd();\n\tregister_trigger_enable_disable_cmds();\n\tregister_trigger_hist_enable_disable_cmds();\n\tregister_trigger_hist_cmd();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\n__init int register_trigger_cmds(void)\n{\n\tregister_trigger_traceon_traceoff_cmds();\n\tregister_trigger_snapshot_cmd();\n\tregister_trigger_stacktrace_cmd();\n\tregister_trigger_enable_disable_cmds();\n\tregister_trigger_hist_enable_disable_cmds();\n\tregister_trigger_hist_cmd();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_event_cmds",
          "args": [],
          "line": 3118
        },
        "resolved": true,
        "details": {
          "function_name": "register_event_cmds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2836-2836",
          "snippet": "static inline int register_event_cmds(void) { return 0; }",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic inline int register_event_cmds(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "trace_printk_start_comm",
          "args": [],
          "line": 3116
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_start_comm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2882-2888",
          "snippet": "void trace_printk_start_comm(void)\n{\n\t/* Start tracing comms if trace printk is set */\n\tif (!buffers_allocated)\n\t\treturn;\n\ttracing_start_cmdline_record();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int buffers_allocated;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int buffers_allocated;\n\nvoid trace_printk_start_comm(void)\n{\n\t/* Start tracing comms if trace printk is set */\n\tif (!buffers_allocated)\n\t\treturn;\n\ttracing_start_cmdline_record();\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_enable_events",
          "args": [
            "tr",
            "false"
          ],
          "line": 3114
        },
        "resolved": true,
        "details": {
          "function_name": "early_enable_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "3060-3087",
          "snippet": "static __init void\nearly_enable_events(struct trace_array *tr, bool disable_first)\n{\n\tchar *buf = bootup_event_buf;\n\tchar *token;\n\tint ret;\n\n\twhile (true) {\n\t\ttoken = strsep(&buf, \",\");\n\n\t\tif (!token)\n\t\t\tbreak;\n\n\t\tif (*token) {\n\t\t\t/* Restarting syscalls requires that we stop them first */\n\t\t\tif (disable_first)\n\t\t\t\tftrace_set_clr_event(tr, token, 0);\n\n\t\t\tret = ftrace_set_clr_event(tr, token, 1);\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Failed to enable trace event: %s\\n\", token);\n\t\t}\n\n\t\t/* Put back the comma to allow this to be called again */\n\t\tif (buf)\n\t\t\t*(buf - 1) = ',';\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char bootup_event_buf[COMMAND_LINE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic char bootup_event_buf[COMMAND_LINE_SIZE];\n\nstatic __init void\nearly_enable_events(struct trace_array *tr, bool disable_first)\n{\n\tchar *buf = bootup_event_buf;\n\tchar *token;\n\tint ret;\n\n\twhile (true) {\n\t\ttoken = strsep(&buf, \",\");\n\n\t\tif (!token)\n\t\t\tbreak;\n\n\t\tif (*token) {\n\t\t\t/* Restarting syscalls requires that we stop them first */\n\t\t\tif (disable_first)\n\t\t\t\tftrace_set_clr_event(tr, token, 0);\n\n\t\t\tret = ftrace_set_clr_event(tr, token, 1);\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Failed to enable trace event: %s\\n\", token);\n\t\t}\n\n\t\t/* Put back the comma to allow this to be called again */\n\t\tif (buf)\n\t\t\t*(buf - 1) = ',';\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_early_add_events",
          "args": [
            "tr"
          ],
          "line": 3112
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_early_add_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2867-2883",
          "snippet": "static __init void\n__trace_early_add_events(struct trace_array *tr)\n{\n\tstruct trace_event_call *call;\n\tint ret;\n\n\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\t/* Early boot up should not have any modules loaded */\n\t\tif (WARN_ON_ONCE(call->mod))\n\t\t\tcontinue;\n\n\t\tret = __trace_early_add_new_event(call, tr);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create early event %s\\n\",\n\t\t\t\ttrace_event_name(call));\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic __init void\n__trace_early_add_events(struct trace_array *tr)\n{\n\tstruct trace_event_call *call;\n\tint ret;\n\n\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\t/* Early boot up should not have any modules loaded */\n\t\tif (WARN_ON_ONCE(call->mod))\n\t\t\tcontinue;\n\n\t\tret = __trace_early_add_new_event(call, tr);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create early event %s\\n\",\n\t\t\t\ttrace_event_name(call));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&call->list",
            "&ftrace_events"
          ],
          "line": 3103
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_init",
          "args": [
            "call"
          ],
          "line": 3101
        },
        "resolved": true,
        "details": {
          "function_name": "event_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2082-2098",
          "snippet": "static int event_init(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tconst char *name;\n\n\tname = trace_event_name(call);\n\tif (WARN_ON(!name))\n\t\treturn -EINVAL;\n\n\tif (call->class->raw_init) {\n\t\tret = call->class->raw_init(call);\n\t\tif (ret < 0 && ret != -ENOSYS)\n\t\t\tpr_warn(\"Could not initialize trace events/%s\\n\", name);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int event_init(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tconst char *name;\n\n\tname = trace_event_name(call);\n\tif (WARN_ON(!name))\n\t\treturn -EINVAL;\n\n\tif (call->class->raw_init) {\n\t\tret = call->class->raw_init(call);\n\t\tif (ret < 0 && ret != -ENOSYS)\n\t\t\tpr_warn(\"Could not initialize trace events/%s\\n\", name);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_event",
          "args": [
            "iter",
            "__start_ftrace_events",
            "__stop_ftrace_events"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "top_trace_array",
          "args": [],
          "line": 3091
        },
        "resolved": true,
        "details": {
          "function_name": "top_trace_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "301-312",
          "snippet": "static inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\nextern struct trace_event_call *__start_ftrace_events[];\nextern struct trace_event_call *__stop_ftrace_events[];\n\nstatic __init int event_trace_enable(void)\n{\n\tstruct trace_array *tr = top_trace_array();\n\tstruct trace_event_call **iter, *call;\n\tint ret;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\tfor_each_event(iter, __start_ftrace_events, __stop_ftrace_events) {\n\n\t\tcall = *iter;\n\t\tret = event_init(call);\n\t\tif (!ret)\n\t\t\tlist_add(&call->list, &ftrace_events);\n\t}\n\n\t/*\n\t * We need the top trace array to have a working set of trace\n\t * points at early init, before the debug files and directories\n\t * are created. Create the file entries now, and attach them\n\t * to the actual file dentries later.\n\t */\n\t__trace_early_add_events(tr);\n\n\tearly_enable_events(tr, false);\n\n\ttrace_printk_start_comm();\n\n\tregister_event_cmds();\n\n\tregister_trigger_cmds();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "early_enable_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "3060-3087",
    "snippet": "static __init void\nearly_enable_events(struct trace_array *tr, bool disable_first)\n{\n\tchar *buf = bootup_event_buf;\n\tchar *token;\n\tint ret;\n\n\twhile (true) {\n\t\ttoken = strsep(&buf, \",\");\n\n\t\tif (!token)\n\t\t\tbreak;\n\n\t\tif (*token) {\n\t\t\t/* Restarting syscalls requires that we stop them first */\n\t\t\tif (disable_first)\n\t\t\t\tftrace_set_clr_event(tr, token, 0);\n\n\t\t\tret = ftrace_set_clr_event(tr, token, 1);\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Failed to enable trace event: %s\\n\", token);\n\t\t}\n\n\t\t/* Put back the comma to allow this to be called again */\n\t\tif (buf)\n\t\t\t*(buf - 1) = ',';\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char bootup_event_buf[COMMAND_LINE_SIZE]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to enable trace event: %s\\n\"",
            "token"
          ],
          "line": 3080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_set_clr_event",
          "args": [
            "tr",
            "token",
            "1"
          ],
          "line": 3078
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_clr_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "798-834",
          "snippet": "static int ftrace_set_clr_event(struct trace_array *tr, char *buf, int set)\n{\n\tchar *event = NULL, *sub = NULL, *match;\n\tint ret;\n\n\t/*\n\t * The buf format can be <subsystem>:<event-name>\n\t *  *:<event-name> means any event by that name.\n\t *  :<event-name> is the same.\n\t *\n\t *  <subsystem>:* means all events in that subsystem\n\t *  <subsystem>: means the same.\n\t *\n\t *  <name> (no ':') means all events in a subsystem with\n\t *  the name <name> or any event that matches <name>\n\t */\n\n\tmatch = strsep(&buf, \":\");\n\tif (buf) {\n\t\tsub = match;\n\t\tevent = buf;\n\t\tmatch = NULL;\n\n\t\tif (!strlen(sub) || strcmp(sub, \"*\") == 0)\n\t\t\tsub = NULL;\n\t\tif (!strlen(event) || strcmp(event, \"*\") == 0)\n\t\t\tevent = NULL;\n\t}\n\n\tret = __ftrace_set_clr_event(tr, match, sub, event, set);\n\n\t/* Put back the colon to allow this to be called again */\n\tif (buf)\n\t\t*(buf - 1) = ':';\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_set_clr_event(struct trace_array *tr, char *buf, int set)\n{\n\tchar *event = NULL, *sub = NULL, *match;\n\tint ret;\n\n\t/*\n\t * The buf format can be <subsystem>:<event-name>\n\t *  *:<event-name> means any event by that name.\n\t *  :<event-name> is the same.\n\t *\n\t *  <subsystem>:* means all events in that subsystem\n\t *  <subsystem>: means the same.\n\t *\n\t *  <name> (no ':') means all events in a subsystem with\n\t *  the name <name> or any event that matches <name>\n\t */\n\n\tmatch = strsep(&buf, \":\");\n\tif (buf) {\n\t\tsub = match;\n\t\tevent = buf;\n\t\tmatch = NULL;\n\n\t\tif (!strlen(sub) || strcmp(sub, \"*\") == 0)\n\t\t\tsub = NULL;\n\t\tif (!strlen(event) || strcmp(event, \"*\") == 0)\n\t\t\tevent = NULL;\n\t}\n\n\tret = __ftrace_set_clr_event(tr, match, sub, event, set);\n\n\t/* Put back the colon to allow this to be called again */\n\tif (buf)\n\t\t*(buf - 1) = ':';\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&buf",
            "\",\""
          ],
          "line": 3068
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic char bootup_event_buf[COMMAND_LINE_SIZE];\n\nstatic __init void\nearly_enable_events(struct trace_array *tr, bool disable_first)\n{\n\tchar *buf = bootup_event_buf;\n\tchar *token;\n\tint ret;\n\n\twhile (true) {\n\t\ttoken = strsep(&buf, \",\");\n\n\t\tif (!token)\n\t\t\tbreak;\n\n\t\tif (*token) {\n\t\t\t/* Restarting syscalls requires that we stop them first */\n\t\t\tif (disable_first)\n\t\t\t\tftrace_set_clr_event(tr, token, 0);\n\n\t\t\tret = ftrace_set_clr_event(tr, token, 1);\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Failed to enable trace event: %s\\n\", token);\n\t\t}\n\n\t\t/* Put back the comma to allow this to be called again */\n\t\tif (buf)\n\t\t\t*(buf - 1) = ',';\n\t}\n}"
  },
  {
    "function_name": "event_trace_memsetup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "3053-3058",
    "snippet": "static __init int event_trace_memsetup(void)\n{\n\tfield_cachep = KMEM_CACHE(ftrace_event_field, SLAB_PANIC);\n\tfile_cachep = KMEM_CACHE(trace_event_file, SLAB_PANIC);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *field_cachep;",
      "static struct kmem_cache *file_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "trace_event_file",
            "SLAB_PANIC"
          ],
          "line": 3056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "ftrace_event_field",
            "SLAB_PANIC"
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic struct kmem_cache *field_cachep;\nstatic struct kmem_cache *file_cachep;\n\nstatic __init int event_trace_memsetup(void)\n{\n\tfield_cachep = KMEM_CACHE(ftrace_event_field, SLAB_PANIC);\n\tfile_cachep = KMEM_CACHE(trace_event_file, SLAB_PANIC);\n\treturn 0;\n}"
  },
  {
    "function_name": "event_trace_del_tracer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "3027-3051",
    "snippet": "int event_trace_del_tracer(struct trace_array *tr)\n{\n\tlockdep_assert_held(&event_mutex);\n\n\t/* Disable any event triggers and associated soft-disabled events */\n\tclear_event_triggers(tr);\n\n\t/* Clear the pid list */\n\t__ftrace_clear_event_pids(tr);\n\n\t/* Disable any running events */\n\t__ftrace_set_clr_event_nolock(tr, NULL, NULL, NULL, 0);\n\n\t/* Make sure no more events are being executed */\n\ttracepoint_synchronize_unregister();\n\n\tdown_write(&trace_event_sem);\n\t__trace_remove_event_dirs(tr);\n\ttracefs_remove_recursive(tr->event_dir);\n\tup_write(&trace_event_sem);\n\n\ttr->event_dir = NULL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 3046
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracefs_remove_recursive",
          "args": [
            "tr->event_dir"
          ],
          "line": 3045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_remove_event_dirs",
          "args": [
            "tr"
          ],
          "line": 3044
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_remove_event_dirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2886-2893",
          "snippet": "static void\n__trace_remove_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_file *file, *next;\n\n\tlist_for_each_entry_safe(file, next, &tr->events, list)\n\t\tremove_event_file_dir(file);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void\n__trace_remove_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_file *file, *next;\n\n\tlist_for_each_entry_safe(file, next, &tr->events, list)\n\t\tremove_event_file_dir(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 3043
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ftrace_set_clr_event_nolock",
          "args": [
            "tr",
            "NULL",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 3038
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_set_clr_event_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "738-784",
          "snippet": "static int\n__ftrace_set_clr_event_nolock(struct trace_array *tr, const char *match,\n\t\t\t      const char *sub, const char *event, int set)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\tint ret = -EINVAL;\n\tint eret = 0;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class || !call->class->reg)\n\t\t\tcontinue;\n\n\t\tif (call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\t\tcontinue;\n\n\t\tif (match &&\n\t\t    strcmp(match, name) != 0 &&\n\t\t    strcmp(match, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (sub && strcmp(sub, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (event && strcmp(event, name) != 0)\n\t\t\tcontinue;\n\n\t\tret = ftrace_event_enable_disable(file, set);\n\n\t\t/*\n\t\t * Save the first error and return that. Some events\n\t\t * may still have been enabled, but let the user\n\t\t * know that something went wrong.\n\t\t */\n\t\tif (ret && !eret)\n\t\t\teret = ret;\n\n\t\tret = eret;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__ftrace_set_clr_event_nolock(struct trace_array *tr, const char *match,\n\t\t\t      const char *sub, const char *event, int set)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\tint ret = -EINVAL;\n\tint eret = 0;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class || !call->class->reg)\n\t\t\tcontinue;\n\n\t\tif (call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\t\tcontinue;\n\n\t\tif (match &&\n\t\t    strcmp(match, name) != 0 &&\n\t\t    strcmp(match, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (sub && strcmp(sub, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (event && strcmp(event, name) != 0)\n\t\t\tcontinue;\n\n\t\tret = ftrace_event_enable_disable(file, set);\n\n\t\t/*\n\t\t * Save the first error and return that. Some events\n\t\t * may still have been enabled, but let the user\n\t\t * know that something went wrong.\n\t\t */\n\t\tif (ret && !eret)\n\t\t\teret = ret;\n\n\t\tret = eret;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_clear_event_pids",
          "args": [
            "tr"
          ],
          "line": 3035
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_clear_event_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "607-643",
          "snippet": "static void __ftrace_clear_event_pids(struct trace_array *tr)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\tif (!pid_list)\n\t\treturn;\n\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_pre, tr);\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_post, tr);\n\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tclear_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t}\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu_ptr(tr->trace_buffer.data, cpu)->ignore_pid = false;\n\n\trcu_assign_pointer(tr->filtered_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\ttracepoint_synchronize_unregister();\n\n\ttrace_free_pid_list(pid_list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void __ftrace_clear_event_pids(struct trace_array *tr)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\tif (!pid_list)\n\t\treturn;\n\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_pre, tr);\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_post, tr);\n\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tclear_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t}\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu_ptr(tr->trace_buffer.data, cpu)->ignore_pid = false;\n\n\trcu_assign_pointer(tr->filtered_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\ttracepoint_synchronize_unregister();\n\n\ttrace_free_pid_list(pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_event_triggers",
          "args": [
            "tr"
          ],
          "line": 3032
        },
        "resolved": true,
        "details": {
          "function_name": "clear_event_triggers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "467-481",
          "snippet": "void\nclear_event_triggers(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tstruct event_trigger_data *data, *n;\n\t\tlist_for_each_entry_safe(data, n, &file->triggers, list) {\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tlist_del_rcu(&data->list);\n\t\t\tif (data->ops->free)\n\t\t\t\tdata->ops->free(data->ops, data);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid\nclear_event_triggers(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tstruct event_trigger_data *data, *n;\n\t\tlist_for_each_entry_safe(data, n, &file->triggers, list) {\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tlist_del_rcu(&data->list);\n\t\t\tif (data->ops->free)\n\t\t\t\tdata->ops->free(data->ops, data);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 3029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nint event_trace_del_tracer(struct trace_array *tr)\n{\n\tlockdep_assert_held(&event_mutex);\n\n\t/* Disable any event triggers and associated soft-disabled events */\n\tclear_event_triggers(tr);\n\n\t/* Clear the pid list */\n\t__ftrace_clear_event_pids(tr);\n\n\t/* Disable any running events */\n\t__ftrace_set_clr_event_nolock(tr, NULL, NULL, NULL, 0);\n\n\t/* Make sure no more events are being executed */\n\ttracepoint_synchronize_unregister();\n\n\tdown_write(&trace_event_sem);\n\t__trace_remove_event_dirs(tr);\n\ttracefs_remove_recursive(tr->event_dir);\n\tup_write(&trace_event_sem);\n\n\ttr->event_dir = NULL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "early_event_add_tracer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "3005-3024",
    "snippet": "static __init int\nearly_event_add_tracer(struct dentry *parent, struct trace_array *tr)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\n\tret = create_event_toplevel_files(parent, tr);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tdown_write(&trace_event_sem);\n\t__trace_early_add_event_dirs(tr);\n\tup_write(&trace_event_sem);\n\n out_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 3021
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 3018
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_early_add_event_dirs",
          "args": [
            "tr"
          ],
          "line": 3017
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_early_add_event_dirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2846-2859",
          "snippet": "static __init void\n__trace_early_add_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\tint ret;\n\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tret = event_create_dir(tr->event_dir, file);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create directory for event %s\\n\",\n\t\t\t\ttrace_event_name(file->event_call));\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic __init void\n__trace_early_add_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\tint ret;\n\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tret = event_create_dir(tr->event_dir, file);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create directory for event %s\\n\",\n\t\t\t\ttrace_event_name(file->event_call));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 3016
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_event_toplevel_files",
          "args": [
            "parent",
            "tr"
          ],
          "line": 3012
        },
        "resolved": true,
        "details": {
          "function_name": "create_event_toplevel_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2919-2968",
          "snippet": "static int\ncreate_event_toplevel_files(struct dentry *parent, struct trace_array *tr)\n{\n\tstruct dentry *d_events;\n\tstruct dentry *entry;\n\n\tentry = tracefs_create_file(\"set_event\", 0644, parent,\n\t\t\t\t    tr, &ftrace_set_event_fops);\n\tif (!entry) {\n\t\tpr_warn(\"Could not create tracefs 'set_event' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\td_events = tracefs_create_dir(\"events\", parent);\n\tif (!d_events) {\n\t\tpr_warn(\"Could not create tracefs 'events' directory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tentry = trace_create_file(\"enable\", 0644, d_events,\n\t\t\t\t  tr, &ftrace_tr_enable_fops);\n\tif (!entry) {\n\t\tpr_warn(\"Could not create tracefs 'enable' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* There are not as crucial, just warn if they are not created */\n\n\tentry = tracefs_create_file(\"set_event_pid\", 0644, parent,\n\t\t\t\t    tr, &ftrace_set_event_pid_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'set_event_pid' entry\\n\");\n\n\t/* ring buffer internal formats */\n\tentry = trace_create_file(\"header_page\", 0444, d_events,\n\t\t\t\t  ring_buffer_print_page_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'header_page' entry\\n\");\n\n\tentry = trace_create_file(\"header_event\", 0444, d_events,\n\t\t\t\t  ring_buffer_print_entry_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'header_event' entry\\n\");\n\n\ttr->event_dir = d_events;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations ftrace_set_event_fops = {\n\t.open = ftrace_event_set_open,\n\t.read = seq_read,\n\t.write = ftrace_event_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};",
            "static const struct file_operations ftrace_set_event_pid_fops = {\n\t.open = ftrace_event_set_pid_open,\n\t.read = seq_read,\n\t.write = ftrace_event_pid_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};",
            "static const struct file_operations ftrace_tr_enable_fops = {\n\t.open = system_tr_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};",
            "static const struct file_operations ftrace_show_header_fops = {\n\t.open = tracing_open_generic,\n\t.read = show_header,\n\t.llseek = default_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic const struct file_operations ftrace_set_event_fops = {\n\t.open = ftrace_event_set_open,\n\t.read = seq_read,\n\t.write = ftrace_event_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};\nstatic const struct file_operations ftrace_set_event_pid_fops = {\n\t.open = ftrace_event_set_pid_open,\n\t.read = seq_read,\n\t.write = ftrace_event_pid_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};\nstatic const struct file_operations ftrace_tr_enable_fops = {\n\t.open = system_tr_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};\nstatic const struct file_operations ftrace_show_header_fops = {\n\t.open = tracing_open_generic,\n\t.read = show_header,\n\t.llseek = default_llseek,\n};\n\nstatic int\ncreate_event_toplevel_files(struct dentry *parent, struct trace_array *tr)\n{\n\tstruct dentry *d_events;\n\tstruct dentry *entry;\n\n\tentry = tracefs_create_file(\"set_event\", 0644, parent,\n\t\t\t\t    tr, &ftrace_set_event_fops);\n\tif (!entry) {\n\t\tpr_warn(\"Could not create tracefs 'set_event' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\td_events = tracefs_create_dir(\"events\", parent);\n\tif (!d_events) {\n\t\tpr_warn(\"Could not create tracefs 'events' directory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tentry = trace_create_file(\"enable\", 0644, d_events,\n\t\t\t\t  tr, &ftrace_tr_enable_fops);\n\tif (!entry) {\n\t\tpr_warn(\"Could not create tracefs 'enable' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* There are not as crucial, just warn if they are not created */\n\n\tentry = tracefs_create_file(\"set_event_pid\", 0644, parent,\n\t\t\t\t    tr, &ftrace_set_event_pid_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'set_event_pid' entry\\n\");\n\n\t/* ring buffer internal formats */\n\tentry = trace_create_file(\"header_page\", 0444, d_events,\n\t\t\t\t  ring_buffer_print_page_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'header_page' entry\\n\");\n\n\tentry = trace_create_file(\"header_event\", 0444, d_events,\n\t\t\t\t  ring_buffer_print_entry_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'header_event' entry\\n\");\n\n\ttr->event_dir = d_events;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 3010
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic __init int\nearly_event_add_tracer(struct dentry *parent, struct trace_array *tr)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\n\tret = create_event_toplevel_files(parent, tr);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tdown_write(&trace_event_sem);\n\t__trace_early_add_event_dirs(tr);\n\tup_write(&trace_event_sem);\n\n out_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "event_trace_add_tracer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2983-2999",
    "snippet": "int event_trace_add_tracer(struct dentry *parent, struct trace_array *tr)\n{\n\tint ret;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tret = create_event_toplevel_files(parent, tr);\n\tif (ret)\n\t\tgoto out;\n\n\tdown_write(&trace_event_sem);\n\t__trace_add_event_dirs(tr);\n\tup_write(&trace_event_sem);\n\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 2995
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_add_event_dirs",
          "args": [
            "tr"
          ],
          "line": 2994
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_add_event_dirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2465-2477",
          "snippet": "static void\n__trace_add_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_call *call;\n\tint ret;\n\n\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\tret = __trace_add_new_event(call, tr);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create directory for event %s\\n\",\n\t\t\t\ttrace_event_name(call));\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void\n__trace_add_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_call *call;\n\tint ret;\n\n\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\tret = __trace_add_new_event(call, tr);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create directory for event %s\\n\",\n\t\t\t\ttrace_event_name(call));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 2993
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_event_toplevel_files",
          "args": [
            "parent",
            "tr"
          ],
          "line": 2989
        },
        "resolved": true,
        "details": {
          "function_name": "create_event_toplevel_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2919-2968",
          "snippet": "static int\ncreate_event_toplevel_files(struct dentry *parent, struct trace_array *tr)\n{\n\tstruct dentry *d_events;\n\tstruct dentry *entry;\n\n\tentry = tracefs_create_file(\"set_event\", 0644, parent,\n\t\t\t\t    tr, &ftrace_set_event_fops);\n\tif (!entry) {\n\t\tpr_warn(\"Could not create tracefs 'set_event' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\td_events = tracefs_create_dir(\"events\", parent);\n\tif (!d_events) {\n\t\tpr_warn(\"Could not create tracefs 'events' directory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tentry = trace_create_file(\"enable\", 0644, d_events,\n\t\t\t\t  tr, &ftrace_tr_enable_fops);\n\tif (!entry) {\n\t\tpr_warn(\"Could not create tracefs 'enable' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* There are not as crucial, just warn if they are not created */\n\n\tentry = tracefs_create_file(\"set_event_pid\", 0644, parent,\n\t\t\t\t    tr, &ftrace_set_event_pid_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'set_event_pid' entry\\n\");\n\n\t/* ring buffer internal formats */\n\tentry = trace_create_file(\"header_page\", 0444, d_events,\n\t\t\t\t  ring_buffer_print_page_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'header_page' entry\\n\");\n\n\tentry = trace_create_file(\"header_event\", 0444, d_events,\n\t\t\t\t  ring_buffer_print_entry_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'header_event' entry\\n\");\n\n\ttr->event_dir = d_events;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations ftrace_set_event_fops = {\n\t.open = ftrace_event_set_open,\n\t.read = seq_read,\n\t.write = ftrace_event_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};",
            "static const struct file_operations ftrace_set_event_pid_fops = {\n\t.open = ftrace_event_set_pid_open,\n\t.read = seq_read,\n\t.write = ftrace_event_pid_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};",
            "static const struct file_operations ftrace_tr_enable_fops = {\n\t.open = system_tr_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};",
            "static const struct file_operations ftrace_show_header_fops = {\n\t.open = tracing_open_generic,\n\t.read = show_header,\n\t.llseek = default_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic const struct file_operations ftrace_set_event_fops = {\n\t.open = ftrace_event_set_open,\n\t.read = seq_read,\n\t.write = ftrace_event_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};\nstatic const struct file_operations ftrace_set_event_pid_fops = {\n\t.open = ftrace_event_set_pid_open,\n\t.read = seq_read,\n\t.write = ftrace_event_pid_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};\nstatic const struct file_operations ftrace_tr_enable_fops = {\n\t.open = system_tr_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};\nstatic const struct file_operations ftrace_show_header_fops = {\n\t.open = tracing_open_generic,\n\t.read = show_header,\n\t.llseek = default_llseek,\n};\n\nstatic int\ncreate_event_toplevel_files(struct dentry *parent, struct trace_array *tr)\n{\n\tstruct dentry *d_events;\n\tstruct dentry *entry;\n\n\tentry = tracefs_create_file(\"set_event\", 0644, parent,\n\t\t\t\t    tr, &ftrace_set_event_fops);\n\tif (!entry) {\n\t\tpr_warn(\"Could not create tracefs 'set_event' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\td_events = tracefs_create_dir(\"events\", parent);\n\tif (!d_events) {\n\t\tpr_warn(\"Could not create tracefs 'events' directory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tentry = trace_create_file(\"enable\", 0644, d_events,\n\t\t\t\t  tr, &ftrace_tr_enable_fops);\n\tif (!entry) {\n\t\tpr_warn(\"Could not create tracefs 'enable' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* There are not as crucial, just warn if they are not created */\n\n\tentry = tracefs_create_file(\"set_event_pid\", 0644, parent,\n\t\t\t\t    tr, &ftrace_set_event_pid_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'set_event_pid' entry\\n\");\n\n\t/* ring buffer internal formats */\n\tentry = trace_create_file(\"header_page\", 0444, d_events,\n\t\t\t\t  ring_buffer_print_page_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'header_page' entry\\n\");\n\n\tentry = trace_create_file(\"header_event\", 0444, d_events,\n\t\t\t\t  ring_buffer_print_entry_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'header_event' entry\\n\");\n\n\ttr->event_dir = d_events;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&event_mutex"
          ],
          "line": 2987
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nint event_trace_add_tracer(struct dentry *parent, struct trace_array *tr)\n{\n\tint ret;\n\n\tlockdep_assert_held(&event_mutex);\n\n\tret = create_event_toplevel_files(parent, tr);\n\tif (ret)\n\t\tgoto out;\n\n\tdown_write(&trace_event_sem);\n\t__trace_add_event_dirs(tr);\n\tup_write(&trace_event_sem);\n\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "create_event_toplevel_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2919-2968",
    "snippet": "static int\ncreate_event_toplevel_files(struct dentry *parent, struct trace_array *tr)\n{\n\tstruct dentry *d_events;\n\tstruct dentry *entry;\n\n\tentry = tracefs_create_file(\"set_event\", 0644, parent,\n\t\t\t\t    tr, &ftrace_set_event_fops);\n\tif (!entry) {\n\t\tpr_warn(\"Could not create tracefs 'set_event' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\td_events = tracefs_create_dir(\"events\", parent);\n\tif (!d_events) {\n\t\tpr_warn(\"Could not create tracefs 'events' directory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tentry = trace_create_file(\"enable\", 0644, d_events,\n\t\t\t\t  tr, &ftrace_tr_enable_fops);\n\tif (!entry) {\n\t\tpr_warn(\"Could not create tracefs 'enable' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* There are not as crucial, just warn if they are not created */\n\n\tentry = tracefs_create_file(\"set_event_pid\", 0644, parent,\n\t\t\t\t    tr, &ftrace_set_event_pid_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'set_event_pid' entry\\n\");\n\n\t/* ring buffer internal formats */\n\tentry = trace_create_file(\"header_page\", 0444, d_events,\n\t\t\t\t  ring_buffer_print_page_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'header_page' entry\\n\");\n\n\tentry = trace_create_file(\"header_event\", 0444, d_events,\n\t\t\t\t  ring_buffer_print_entry_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'header_event' entry\\n\");\n\n\ttr->event_dir = d_events;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations ftrace_set_event_fops = {\n\t.open = ftrace_event_set_open,\n\t.read = seq_read,\n\t.write = ftrace_event_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};",
      "static const struct file_operations ftrace_set_event_pid_fops = {\n\t.open = ftrace_event_set_pid_open,\n\t.read = seq_read,\n\t.write = ftrace_event_pid_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};",
      "static const struct file_operations ftrace_tr_enable_fops = {\n\t.open = system_tr_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};",
      "static const struct file_operations ftrace_show_header_fops = {\n\t.open = tracing_open_generic,\n\t.read = show_header,\n\t.llseek = default_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'header_event' entry\\n\""
          ],
          "line": 2963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"header_event\"",
            "0444",
            "d_events",
            "ring_buffer_print_entry_header",
            "&ftrace_show_header_fops"
          ],
          "line": 2959
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "7459-7472",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'header_page' entry\\n\""
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'set_event_pid' entry\\n\""
          ],
          "line": 2950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"set_event_pid\"",
            "0644",
            "parent",
            "tr",
            "&ftrace_set_event_pid_fops"
          ],
          "line": 2947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'enable' entry\\n\""
          ],
          "line": 2941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'events' directory\\n\""
          ],
          "line": 2934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_dir",
          "args": [
            "\"events\"",
            "parent"
          ],
          "line": 2932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'set_event' entry\\n\""
          ],
          "line": 2928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"set_event\"",
            "0644",
            "parent",
            "tr",
            "&ftrace_set_event_fops"
          ],
          "line": 2925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic const struct file_operations ftrace_set_event_fops = {\n\t.open = ftrace_event_set_open,\n\t.read = seq_read,\n\t.write = ftrace_event_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};\nstatic const struct file_operations ftrace_set_event_pid_fops = {\n\t.open = ftrace_event_set_pid_open,\n\t.read = seq_read,\n\t.write = ftrace_event_pid_write,\n\t.llseek = seq_lseek,\n\t.release = ftrace_event_release,\n};\nstatic const struct file_operations ftrace_tr_enable_fops = {\n\t.open = system_tr_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};\nstatic const struct file_operations ftrace_show_header_fops = {\n\t.open = tracing_open_generic,\n\t.read = show_header,\n\t.llseek = default_llseek,\n};\n\nstatic int\ncreate_event_toplevel_files(struct dentry *parent, struct trace_array *tr)\n{\n\tstruct dentry *d_events;\n\tstruct dentry *entry;\n\n\tentry = tracefs_create_file(\"set_event\", 0644, parent,\n\t\t\t\t    tr, &ftrace_set_event_fops);\n\tif (!entry) {\n\t\tpr_warn(\"Could not create tracefs 'set_event' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\td_events = tracefs_create_dir(\"events\", parent);\n\tif (!d_events) {\n\t\tpr_warn(\"Could not create tracefs 'events' directory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tentry = trace_create_file(\"enable\", 0644, d_events,\n\t\t\t\t  tr, &ftrace_tr_enable_fops);\n\tif (!entry) {\n\t\tpr_warn(\"Could not create tracefs 'enable' entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* There are not as crucial, just warn if they are not created */\n\n\tentry = tracefs_create_file(\"set_event_pid\", 0644, parent,\n\t\t\t\t    tr, &ftrace_set_event_pid_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'set_event_pid' entry\\n\");\n\n\t/* ring buffer internal formats */\n\tentry = trace_create_file(\"header_page\", 0444, d_events,\n\t\t\t\t  ring_buffer_print_page_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'header_page' entry\\n\");\n\n\tentry = trace_create_file(\"header_event\", 0444, d_events,\n\t\t\t\t  ring_buffer_print_entry_header,\n\t\t\t\t  &ftrace_show_header_fops);\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'header_event' entry\\n\");\n\n\ttr->event_dir = d_events;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_trace_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2908-2915",
    "snippet": "static __init int setup_trace_event(char *str)\n{\n\tstrlcpy(bootup_event_buf, str, COMMAND_LINE_SIZE);\n\tring_buffer_expanded = true;\n\ttracing_selftest_disabled = true;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char bootup_event_buf[COMMAND_LINE_SIZE]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "bootup_event_buf",
            "str",
            "COMMAND_LINE_SIZE"
          ],
          "line": 2910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic char bootup_event_buf[COMMAND_LINE_SIZE];\n\nstatic __init int setup_trace_event(char *str)\n{\n\tstrlcpy(bootup_event_buf, str, COMMAND_LINE_SIZE);\n\tring_buffer_expanded = true;\n\ttracing_selftest_disabled = true;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "__add_event_to_tracers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2895-2901",
    "snippet": "static void __add_event_to_tracers(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list)\n\t\t__trace_add_new_event(call, tr);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__trace_add_new_event",
          "args": [
            "call",
            "tr"
          ],
          "line": 2900
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_add_new_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2275-2285",
          "snippet": "static int\n__trace_add_new_event(struct trace_event_call *call, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\treturn event_create_dir(tr->event_dir, file);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__trace_add_new_event(struct trace_event_call *call, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\treturn event_create_dir(tr->event_dir, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tr",
            "&ftrace_trace_arrays",
            "list"
          ],
          "line": 2899
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void __add_event_to_tracers(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list)\n\t\t__trace_add_new_event(call, tr);\n}"
  },
  {
    "function_name": "__trace_remove_event_dirs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2886-2893",
    "snippet": "static void\n__trace_remove_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_file *file, *next;\n\n\tlist_for_each_entry_safe(file, next, &tr->events, list)\n\t\tremove_event_file_dir(file);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_event_file_dir",
          "args": [
            "file"
          ],
          "line": 2892
        },
        "resolved": true,
        "details": {
          "function_name": "remove_event_file_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "713-733",
          "snippet": "static void remove_event_file_dir(struct trace_event_file *file)\n{\n\tstruct dentry *dir = file->dir;\n\tstruct dentry *child;\n\n\tif (dir) {\n\t\tspin_lock(&dir->d_lock);\t/* probably unneeded */\n\t\tlist_for_each_entry(child, &dir->d_subdirs, d_child) {\n\t\t\tif (d_really_is_positive(child))\t/* probably unneeded */\n\t\t\t\td_inode(child)->i_private = NULL;\n\t\t}\n\t\tspin_unlock(&dir->d_lock);\n\n\t\ttracefs_remove_recursive(dir);\n\t}\n\n\tlist_del(&file->list);\n\tremove_subsystem(file->system);\n\tfree_event_filter(file->filter);\n\tkmem_cache_free(file_cachep, file);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *file_cachep;",
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic struct kmem_cache *file_cachep;\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void remove_event_file_dir(struct trace_event_file *file)\n{\n\tstruct dentry *dir = file->dir;\n\tstruct dentry *child;\n\n\tif (dir) {\n\t\tspin_lock(&dir->d_lock);\t/* probably unneeded */\n\t\tlist_for_each_entry(child, &dir->d_subdirs, d_child) {\n\t\t\tif (d_really_is_positive(child))\t/* probably unneeded */\n\t\t\t\td_inode(child)->i_private = NULL;\n\t\t}\n\t\tspin_unlock(&dir->d_lock);\n\n\t\ttracefs_remove_recursive(dir);\n\t}\n\n\tlist_del(&file->list);\n\tremove_subsystem(file->system);\n\tfree_event_filter(file->filter);\n\tkmem_cache_free(file_cachep, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "file",
            "next",
            "&tr->events",
            "list"
          ],
          "line": 2891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void\n__trace_remove_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_file *file, *next;\n\n\tlist_for_each_entry_safe(file, next, &tr->events, list)\n\t\tremove_event_file_dir(file);\n}"
  },
  {
    "function_name": "__trace_early_add_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2867-2883",
    "snippet": "static __init void\n__trace_early_add_events(struct trace_array *tr)\n{\n\tstruct trace_event_call *call;\n\tint ret;\n\n\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\t/* Early boot up should not have any modules loaded */\n\t\tif (WARN_ON_ONCE(call->mod))\n\t\t\tcontinue;\n\n\t\tret = __trace_early_add_new_event(call, tr);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create early event %s\\n\",\n\t\t\t\ttrace_event_name(call));\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create early event %s\\n\"",
            "trace_event_name(call)"
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_early_add_new_event",
          "args": [
            "call",
            "tr"
          ],
          "line": 2878
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_early_add_new_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2292-2303",
          "snippet": "static __init int\n__trace_early_add_new_event(struct trace_event_call *call,\n\t\t\t    struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic __init int\n__trace_early_add_new_event(struct trace_event_call *call,\n\t\t\t    struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "call->mod"
          ],
          "line": 2875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "call",
            "&ftrace_events",
            "list"
          ],
          "line": 2873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic __init void\n__trace_early_add_events(struct trace_array *tr)\n{\n\tstruct trace_event_call *call;\n\tint ret;\n\n\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\t/* Early boot up should not have any modules loaded */\n\t\tif (WARN_ON_ONCE(call->mod))\n\t\t\tcontinue;\n\n\t\tret = __trace_early_add_new_event(call, tr);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create early event %s\\n\",\n\t\t\t\ttrace_event_name(call));\n\t}\n}"
  },
  {
    "function_name": "__trace_early_add_event_dirs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2846-2859",
    "snippet": "static __init void\n__trace_early_add_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\tint ret;\n\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tret = event_create_dir(tr->event_dir, file);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create directory for event %s\\n\",\n\t\t\t\ttrace_event_name(file->event_call));\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create directory for event %s\\n\"",
            "trace_event_name(file->event_call)"
          ],
          "line": 2856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "file->event_call"
          ],
          "line": 2857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_create_dir",
          "args": [
            "tr->event_dir",
            "file"
          ],
          "line": 2854
        },
        "resolved": true,
        "details": {
          "function_name": "event_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "1959-2032",
          "snippet": "static int\nevent_create_dir(struct dentry *parent, struct trace_event_file *file)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tstruct list_head *head;\n\tstruct dentry *d_events;\n\tconst char *name;\n\tint ret;\n\n\t/*\n\t * If the trace point header did not define TRACE_SYSTEM\n\t * then the system would be called \"TRACE_SYSTEM\".\n\t */\n\tif (strcmp(call->class->system, TRACE_SYSTEM) != 0) {\n\t\td_events = event_subsystem_dir(tr, call->class->system, file, parent);\n\t\tif (!d_events)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\td_events = parent;\n\n\tname = trace_event_name(call);\n\tfile->dir = tracefs_create_dir(name, d_events);\n\tif (!file->dir) {\n\t\tpr_warn(\"Could not create tracefs '%s' directory\\n\", name);\n\t\treturn -1;\n\t}\n\n\tif (call->class->reg && !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\ttrace_create_file(\"enable\", 0644, file->dir, file,\n\t\t\t\t  &ftrace_enable_fops);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->event.type && call->class->reg)\n\t\ttrace_create_file(\"id\", 0444, file->dir,\n\t\t\t\t  (void *)(long)call->event.type,\n\t\t\t\t  &ftrace_event_id_fops);\n#endif\n\n\t/*\n\t * Other events may have the same class. Only update\n\t * the fields if they are not already defined.\n\t */\n\thead = trace_get_fields(call);\n\tif (list_empty(head)) {\n\t\tret = call->class->define_fields(call);\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"Could not initialize trace point events/%s\\n\",\n\t\t\t\tname);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/*\n\t * Only event directories that can be enabled should have\n\t * triggers or filters.\n\t */\n\tif (!(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)) {\n\t\ttrace_create_file(\"filter\", 0644, file->dir, file,\n\t\t\t\t  &ftrace_event_filter_fops);\n\n\t\ttrace_create_file(\"trigger\", 0644, file->dir, file,\n\t\t\t\t  &event_trigger_fops);\n\t}\n\n#ifdef CONFIG_HIST_TRIGGERS\n\ttrace_create_file(\"hist\", 0444, file->dir, file,\n\t\t\t  &event_hist_fops);\n#endif\n\ttrace_create_file(\"format\", 0444, file->dir, call,\n\t\t\t  &ftrace_event_format_fops);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [
            "#define TRACE_SYSTEM \"TRACE_SYSTEM\""
          ],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static const struct file_operations ftrace_enable_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_enable_read,\n\t.write = event_enable_write,\n\t.llseek = default_llseek,\n};",
            "static const struct file_operations ftrace_event_format_fops = {\n\t.open = trace_format_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};",
            "static const struct file_operations ftrace_event_id_fops = {\n\t.read = event_id_read,\n\t.llseek = default_llseek,\n};",
            "static const struct file_operations ftrace_event_filter_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_filter_read,\n\t.write = event_filter_write,\n\t.llseek = default_llseek,\n};",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#define TRACE_SYSTEM \"TRACE_SYSTEM\"\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic const struct file_operations ftrace_enable_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_enable_read,\n\t.write = event_enable_write,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations ftrace_event_format_fops = {\n\t.open = trace_format_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\nstatic const struct file_operations ftrace_event_id_fops = {\n\t.read = event_id_read,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations ftrace_event_filter_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_filter_read,\n\t.write = event_filter_write,\n\t.llseek = default_llseek,\n};\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\nevent_create_dir(struct dentry *parent, struct trace_event_file *file)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tstruct list_head *head;\n\tstruct dentry *d_events;\n\tconst char *name;\n\tint ret;\n\n\t/*\n\t * If the trace point header did not define TRACE_SYSTEM\n\t * then the system would be called \"TRACE_SYSTEM\".\n\t */\n\tif (strcmp(call->class->system, TRACE_SYSTEM) != 0) {\n\t\td_events = event_subsystem_dir(tr, call->class->system, file, parent);\n\t\tif (!d_events)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\td_events = parent;\n\n\tname = trace_event_name(call);\n\tfile->dir = tracefs_create_dir(name, d_events);\n\tif (!file->dir) {\n\t\tpr_warn(\"Could not create tracefs '%s' directory\\n\", name);\n\t\treturn -1;\n\t}\n\n\tif (call->class->reg && !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\ttrace_create_file(\"enable\", 0644, file->dir, file,\n\t\t\t\t  &ftrace_enable_fops);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->event.type && call->class->reg)\n\t\ttrace_create_file(\"id\", 0444, file->dir,\n\t\t\t\t  (void *)(long)call->event.type,\n\t\t\t\t  &ftrace_event_id_fops);\n#endif\n\n\t/*\n\t * Other events may have the same class. Only update\n\t * the fields if they are not already defined.\n\t */\n\thead = trace_get_fields(call);\n\tif (list_empty(head)) {\n\t\tret = call->class->define_fields(call);\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"Could not initialize trace point events/%s\\n\",\n\t\t\t\tname);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/*\n\t * Only event directories that can be enabled should have\n\t * triggers or filters.\n\t */\n\tif (!(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)) {\n\t\ttrace_create_file(\"filter\", 0644, file->dir, file,\n\t\t\t\t  &ftrace_event_filter_fops);\n\n\t\ttrace_create_file(\"trigger\", 0644, file->dir, file,\n\t\t\t\t  &event_trigger_fops);\n\t}\n\n#ifdef CONFIG_HIST_TRIGGERS\n\ttrace_create_file(\"hist\", 0444, file->dir, file,\n\t\t\t  &event_hist_fops);\n#endif\n\ttrace_create_file(\"format\", 0444, file->dir, call,\n\t\t\t  &ftrace_event_format_fops);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic __init void\n__trace_early_add_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\tint ret;\n\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tret = event_create_dir(tr->event_dir, file);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create directory for event %s\\n\",\n\t\t\t\ttrace_event_name(file->event_call));\n\t}\n}"
  },
  {
    "function_name": "register_event_cmds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2836-2836",
    "snippet": "static inline int register_event_cmds(void) { return 0; }",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic inline int register_event_cmds(void) { return 0; }"
  },
  {
    "function_name": "register_event_cmds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2823-2834",
    "snippet": "static __init int register_event_cmds(void)\n{\n\tint ret;\n\n\tret = register_ftrace_command(&event_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_ftrace_command(&event_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_ftrace_command(&event_enable_cmd);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_ftrace_command",
          "args": [
            "&event_enable_cmd"
          ],
          "line": 2832
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4560-4577",
          "snippet": "__init int unregister_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n__init int unregister_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic __init int register_event_cmds(void)\n{\n\tint ret;\n\n\tret = register_ftrace_command(&event_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_ftrace_command(&event_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_ftrace_command(&event_enable_cmd);\n\treturn ret;\n}"
  },
  {
    "function_name": "event_enable_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2703-2811",
    "snippet": "static int\nevent_enable_func(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t  char *glob, char *cmd, char *param, int enabled)\n{\n\tstruct trace_event_file *file;\n\tstruct ftrace_probe_ops *ops;\n\tstruct event_probe_data *data;\n\tconst char *system;\n\tconst char *event;\n\tchar *number;\n\tbool enable;\n\tint ret;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enabled || !param)\n\t\treturn -EINVAL;\n\n\tsystem = strsep(&param, \":\");\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tevent = strsep(&param, \":\");\n\n\tmutex_lock(&event_mutex);\n\n\tret = -EINVAL;\n\tfile = find_event_file(tr, system, event);\n\tif (!file)\n\t\tgoto out;\n\n\tenable = strcmp(cmd, ENABLE_EVENT_STR) == 0;\n\n\tif (enable)\n\t\tops = param ? &event_enable_count_probe_ops : &event_enable_probe_ops;\n\telse\n\t\tops = param ? &event_disable_count_probe_ops : &event_disable_probe_ops;\n\n\tif (glob[0] == '!') {\n\t\tret = unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\t\tgoto out;\n\t}\n\n\tret = -ENOMEM;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\tgoto out;\n\n\tdata->enable = enable;\n\tdata->count = -1;\n\tdata->file = file;\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tret = -EINVAL;\n\tif (!strlen(number))\n\t\tgoto out_free;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, &data->count);\n\tif (ret)\n\t\tgoto out_free;\n\n out_reg:\n\t/* Don't let event modules unload while probe registered */\n\tret = try_module_get(file->event_call->mod);\n\tif (!ret) {\n\t\tret = -EBUSY;\n\t\tgoto out_free;\n\t}\n\n\tret = __ftrace_event_enable_disable(file, 1, 1);\n\tif (ret < 0)\n\t\tgoto out_put;\n\n\tret = register_ftrace_function_probe(glob, tr, ops, data);\n\t/*\n\t * The above returns on success the # of functions enabled,\n\t * but if it didn't find any functions it returns zero.\n\t * Consider no functions a failure too.\n\t */\n\tif (!ret) {\n\t\tret = -ENOENT;\n\t\tgoto out_disable;\n\t} else if (ret < 0)\n\t\tgoto out_disable;\n\t/* Just return zero, not the number of enabled functions */\n\tret = 0;\n out:\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n\n out_disable:\n\t__ftrace_event_enable_disable(file, 0, 1);\n out_put:\n\tmodule_put(file->event_call->mod);\n out_free:\n\tkfree(data);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [
      "#define ENABLE_EVENT_STR\t\"enable_event\""
    ],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 2809
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "file->event_call->mod"
          ],
          "line": 2807
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1132-1143",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_event_enable_disable",
          "args": [
            "file",
            "0",
            "1"
          ],
          "line": 2805
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_event_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "369-485",
          "snippet": "static int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 2801
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_ftrace_function_probe",
          "args": [
            "glob",
            "tr",
            "ops",
            "data"
          ],
          "line": 2787
        },
        "resolved": true,
        "details": {
          "function_name": "register_ftrace_function_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4259-4391",
          "snippet": "int\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nregister_ftrace_function_probe(char *glob, struct trace_array *tr,\n\t\t\t       struct ftrace_probe_ops *probe_ops,\n\t\t\t       void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint count = 0;\n\tint size;\n\tint ret;\n\tint i;\n\n\tif (WARN_ON(!tr))\n\t\treturn -EINVAL;\n\n\t/* We do not support '!' for function probes */\n\tif (WARN_ON(glob[0] == '!'))\n\t\treturn -EINVAL;\n\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes) {\n\t\tprobe = kzalloc(sizeof(*probe), GFP_KERNEL);\n\t\tif (!probe) {\n\t\t\tmutex_unlock(&ftrace_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tprobe->probe_ops = probe_ops;\n\t\tprobe->ops.func = function_trace_probe_call;\n\t\tprobe->tr = tr;\n\t\tftrace_ops_init(&probe->ops);\n\t\tlist_add(&probe->list, &tr->func_probes);\n\t}\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\n\tret = ftrace_match_records(hash, glob, strlen(glob));\n\n\t/* Nothing found? */\n\tif (!ret)\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The caller might want to do something special\n\t\t\t * for each function we find. We call the callback\n\t\t\t * to give the caller an opportunity to do so.\n\t\t\t */\n\t\t\tif (probe_ops->init) {\n\t\t\t\tret = probe_ops->init(probe_ops, tr,\n\t\t\t\t\t\t      entry->ip, data,\n\t\t\t\t\t\t      &probe->data);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (probe_ops->free && count)\n\t\t\t\t\t\tprobe_ops->free(probe_ops, tr,\n\t\t\t\t\t\t\t\t0, probe->data);\n\t\t\t\t\tprobe->data = NULL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (!count) {\n\t\t/* Nothing was added? */\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\tif (ret < 0)\n\t\tgoto err_unlock;\n\n\t/* One ref for each new function traced */\n\tprobe->ref += count;\n\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_ENABLED))\n\t\tret = ftrace_startup(&probe->ops, 0);\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (!ret)\n\t\tret = count;\n out:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock:\n\tif (!probe_ops->free || !count)\n\t\tgoto out_unlock;\n\n\t/* Failed to do the move, need to call the free functions */\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry(entry, &hash->buckets[i], hlist) {\n\t\t\tif (ftrace_lookup_ip(old_hash, entry->ip))\n\t\t\t\tcontinue;\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\t}\n\t}\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "file->event_call->mod"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1113-1129",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "number",
            "0",
            "&data->count"
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "number"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&param",
            "\":\""
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function_probe_func",
          "args": [
            "glob+1",
            "tr",
            "ops"
          ],
          "line": 2744
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function_probe_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4393-4520",
          "snippet": "int\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_sched();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_sched();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "ENABLE_EVENT_STR"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_event_file",
          "args": [
            "tr",
            "system",
            "event"
          ],
          "line": 2732
        },
        "resolved": true,
        "details": {
          "function_name": "find_event_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2503-2514",
          "snippet": "struct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstruct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 2729
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&param",
            "\":\""
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&param",
            "\":\""
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#define ENABLE_EVENT_STR\t\"enable_event\"\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int\nevent_enable_func(struct trace_array *tr, struct ftrace_hash *hash,\n\t\t  char *glob, char *cmd, char *param, int enabled)\n{\n\tstruct trace_event_file *file;\n\tstruct ftrace_probe_ops *ops;\n\tstruct event_probe_data *data;\n\tconst char *system;\n\tconst char *event;\n\tchar *number;\n\tbool enable;\n\tint ret;\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\t/* hash funcs only work with set_ftrace_filter */\n\tif (!enabled || !param)\n\t\treturn -EINVAL;\n\n\tsystem = strsep(&param, \":\");\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tevent = strsep(&param, \":\");\n\n\tmutex_lock(&event_mutex);\n\n\tret = -EINVAL;\n\tfile = find_event_file(tr, system, event);\n\tif (!file)\n\t\tgoto out;\n\n\tenable = strcmp(cmd, ENABLE_EVENT_STR) == 0;\n\n\tif (enable)\n\t\tops = param ? &event_enable_count_probe_ops : &event_enable_probe_ops;\n\telse\n\t\tops = param ? &event_disable_count_probe_ops : &event_disable_probe_ops;\n\n\tif (glob[0] == '!') {\n\t\tret = unregister_ftrace_function_probe_func(glob+1, tr, ops);\n\t\tgoto out;\n\t}\n\n\tret = -ENOMEM;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\tgoto out;\n\n\tdata->enable = enable;\n\tdata->count = -1;\n\tdata->file = file;\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \":\");\n\n\tret = -EINVAL;\n\tif (!strlen(number))\n\t\tgoto out_free;\n\n\t/*\n\t * We use the callback data field (which is a pointer)\n\t * as our counter.\n\t */\n\tret = kstrtoul(number, 0, &data->count);\n\tif (ret)\n\t\tgoto out_free;\n\n out_reg:\n\t/* Don't let event modules unload while probe registered */\n\tret = try_module_get(file->event_call->mod);\n\tif (!ret) {\n\t\tret = -EBUSY;\n\t\tgoto out_free;\n\t}\n\n\tret = __ftrace_event_enable_disable(file, 1, 1);\n\tif (ret < 0)\n\t\tgoto out_put;\n\n\tret = register_ftrace_function_probe(glob, tr, ops, data);\n\t/*\n\t * The above returns on success the # of functions enabled,\n\t * but if it didn't find any functions it returns zero.\n\t * Consider no functions a failure too.\n\t */\n\tif (!ret) {\n\t\tret = -ENOENT;\n\t\tgoto out_disable;\n\t} else if (ret < 0)\n\t\tgoto out_disable;\n\t/* Just return zero, not the number of enabled functions */\n\tret = 0;\n out:\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n\n out_disable:\n\t__ftrace_event_enable_disable(file, 0, 1);\n out_put:\n\tmodule_put(file->event_call->mod);\n out_free:\n\tkfree(data);\n\tgoto out;\n}"
  },
  {
    "function_name": "event_enable_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2650-2673",
    "snippet": "static void\nevent_enable_free(struct ftrace_probe_ops *ops, struct trace_array *tr,\n\t\t  unsigned long ip, void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tstruct event_probe_data *edata;\n\n\tif (!ip) {\n\t\tif (!mapper)\n\t\t\treturn;\n\t\tfree_ftrace_func_mapper(mapper, free_probe_data);\n\t\treturn;\n\t}\n\n\tedata = ftrace_func_mapper_remove_ip(mapper, ip);\n\n\tif (WARN_ON_ONCE(!edata))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(edata->ref <= 0))\n\t\treturn;\n\n\tfree_probe_data(edata);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_probe_data",
          "args": [
            "edata"
          ],
          "line": 2672
        },
        "resolved": true,
        "details": {
          "function_name": "free_probe_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2636-2648",
          "snippet": "static int free_probe_data(void *data)\n{\n\tstruct event_probe_data *edata = data;\n\n\tedata->ref--;\n\tif (!edata->ref) {\n\t\t/* Remove the SOFT_MODE flag */\n\t\t__ftrace_event_enable_disable(edata->file, 0, 1);\n\t\tmodule_put(edata->file->event_call->mod);\n\t\tkfree(edata);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int free_probe_data(void *data)\n{\n\tstruct event_probe_data *edata = data;\n\n\tedata->ref--;\n\tif (!edata->ref) {\n\t\t/* Remove the SOFT_MODE flag */\n\t\t__ftrace_event_enable_disable(edata->file, 0, 1);\n\t\tmodule_put(edata->file->event_call->mod);\n\t\tkfree(edata);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "edata->ref <= 0"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!edata"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_func_mapper_remove_ip",
          "args": [
            "mapper",
            "ip"
          ],
          "line": 2664
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_remove_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4176-4194",
          "snippet": "void *ftrace_func_mapper_remove_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t   unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tvoid *data;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\tdata = map->data;\n\n\tremove_hash_entry(&mapper->hash, entry);\n\tkfree(entry);\n\n\treturn data;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid *ftrace_func_mapper_remove_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t   unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tvoid *data;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\tdata = map->data;\n\n\tremove_hash_entry(&mapper->hash, entry);\n\tkfree(entry);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ftrace_func_mapper",
          "args": [
            "mapper",
            "free_probe_data"
          ],
          "line": 2660
        },
        "resolved": true,
        "details": {
          "function_name": "free_ftrace_func_mapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4204-4223",
          "snippet": "void free_ftrace_func_mapper(struct ftrace_func_mapper *mapper,\n\t\t\t     ftrace_mapper_func free_func)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tstruct hlist_head *hhd;\n\tint size = 1 << mapper->hash.size_bits;\n\tint i;\n\n\tif (free_func && mapper->hash.count) {\n\t\tfor (i = 0; i < size; i++) {\n\t\t\thhd = &mapper->hash.buckets[i];\n\t\t\thlist_for_each_entry(entry, hhd, hlist) {\n\t\t\t\tmap = (struct ftrace_func_map *)entry;\n\t\t\t\tfree_func(map);\n\t\t\t}\n\t\t}\n\t}\n\tfree_ftrace_hash(&mapper->hash);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid free_ftrace_func_mapper(struct ftrace_func_mapper *mapper,\n\t\t\t     ftrace_mapper_func free_func)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\tstruct hlist_head *hhd;\n\tint size = 1 << mapper->hash.size_bits;\n\tint i;\n\n\tif (free_func && mapper->hash.count) {\n\t\tfor (i = 0; i < size; i++) {\n\t\t\thhd = &mapper->hash.buckets[i];\n\t\t\thlist_for_each_entry(entry, hhd, hlist) {\n\t\t\t\tmap = (struct ftrace_func_map *)entry;\n\t\t\t\tfree_func(map);\n\t\t\t}\n\t\t}\n\t}\n\tfree_ftrace_hash(&mapper->hash);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void\nevent_enable_free(struct ftrace_probe_ops *ops, struct trace_array *tr,\n\t\t  unsigned long ip, void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tstruct event_probe_data *edata;\n\n\tif (!ip) {\n\t\tif (!mapper)\n\t\t\treturn;\n\t\tfree_ftrace_func_mapper(mapper, free_probe_data);\n\t\treturn;\n\t}\n\n\tedata = ftrace_func_mapper_remove_ip(mapper, ip);\n\n\tif (WARN_ON_ONCE(!edata))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(edata->ref <= 0))\n\t\treturn;\n\n\tfree_probe_data(edata);\n}"
  },
  {
    "function_name": "free_probe_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2636-2648",
    "snippet": "static int free_probe_data(void *data)\n{\n\tstruct event_probe_data *edata = data;\n\n\tedata->ref--;\n\tif (!edata->ref) {\n\t\t/* Remove the SOFT_MODE flag */\n\t\t__ftrace_event_enable_disable(edata->file, 0, 1);\n\t\tmodule_put(edata->file->event_call->mod);\n\t\tkfree(edata);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "edata"
          ],
          "line": 2645
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "edata->file->event_call->mod"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1132-1143",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_event_enable_disable",
          "args": [
            "edata->file",
            "0",
            "1"
          ],
          "line": 2643
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_event_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "369-485",
          "snippet": "static int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int free_probe_data(void *data)\n{\n\tstruct event_probe_data *edata = data;\n\n\tedata->ref--;\n\tif (!edata->ref) {\n\t\t/* Remove the SOFT_MODE flag */\n\t\t__ftrace_event_enable_disable(edata->file, 0, 1);\n\t\tmodule_put(edata->file->event_call->mod);\n\t\tkfree(edata);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "event_enable_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2612-2634",
    "snippet": "static int\nevent_enable_init(struct ftrace_probe_ops *ops, struct trace_array *tr,\n\t\t  unsigned long ip, void *init_data, void **data)\n{\n\tstruct ftrace_func_mapper *mapper = *data;\n\tstruct event_probe_data *edata = init_data;\n\tint ret;\n\n\tif (!mapper) {\n\t\tmapper = allocate_ftrace_func_mapper();\n\t\tif (!mapper)\n\t\t\treturn -ENODEV;\n\t\t*data = mapper;\n\t}\n\n\tret = ftrace_func_mapper_add_ip(mapper, ip, edata);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tedata->ref++;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_func_mapper_add_ip",
          "args": [
            "mapper",
            "ip",
            "edata"
          ],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_add_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4144-4164",
          "snippet": "int ftrace_func_mapper_add_ip(struct ftrace_func_mapper *mapper,\n\t\t\t      unsigned long ip, void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (entry)\n\t\treturn -EBUSY;\n\n\tmap = kmalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmap->entry.ip = ip;\n\tmap->data = data;\n\n\t__add_hash_entry(&mapper->hash, &map->entry);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_func_mapper_add_ip(struct ftrace_func_mapper *mapper,\n\t\t\t      unsigned long ip, void *data)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (entry)\n\t\treturn -EBUSY;\n\n\tmap = kmalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmap->entry.ip = ip;\n\tmap->data = data;\n\n\t__add_hash_entry(&mapper->hash, &map->entry);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocate_ftrace_func_mapper",
          "args": [],
          "line": 2621
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_ftrace_func_mapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4098-4109",
          "snippet": "struct ftrace_func_mapper *allocate_ftrace_func_mapper(void)\n{\n\tstruct ftrace_hash *hash;\n\n\t/*\n\t * The mapper is simply a ftrace_hash, but since the entries\n\t * in the hash are not ftrace_func_entry type, we define it\n\t * as a separate structure.\n\t */\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\treturn (struct ftrace_func_mapper *)hash;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nstruct ftrace_func_mapper *allocate_ftrace_func_mapper(void)\n{\n\tstruct ftrace_hash *hash;\n\n\t/*\n\t * The mapper is simply a ftrace_hash, but since the entries\n\t * in the hash are not ftrace_func_entry type, we define it\n\t * as a separate structure.\n\t */\n\thash = alloc_ftrace_hash(FTRACE_HASH_DEFAULT_BITS);\n\treturn (struct ftrace_func_mapper *)hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int\nevent_enable_init(struct ftrace_probe_ops *ops, struct trace_array *tr,\n\t\t  unsigned long ip, void *init_data, void **data)\n{\n\tstruct ftrace_func_mapper *mapper = *data;\n\tstruct event_probe_data *edata = init_data;\n\tint ret;\n\n\tif (!mapper) {\n\t\tmapper = allocate_ftrace_func_mapper();\n\t\tif (!mapper)\n\t\t\treturn -ENODEV;\n\t\t*data = mapper;\n\t}\n\n\tret = ftrace_func_mapper_add_ip(mapper, ip, edata);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tedata->ref++;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_enable_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2582-2610",
    "snippet": "static int\nevent_enable_print(struct seq_file *m, unsigned long ip,\n\t\t   struct ftrace_probe_ops *ops, void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tstruct event_probe_data *edata;\n\tvoid **pdata;\n\n\tpdata = ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (WARN_ON_ONCE(!pdata || !*pdata))\n\t\treturn 0;\n\n\tedata = *pdata;\n\n\tseq_printf(m, \"%ps:\", (void *)ip);\n\n\tseq_printf(m, \"%s:%s:%s\",\n\t\t   edata->enable ? ENABLE_EVENT_STR : DISABLE_EVENT_STR,\n\t\t   edata->file->event_call->class->system,\n\t\t   trace_event_name(edata->file->event_call));\n\n\tif (edata->count == -1)\n\t\tseq_puts(m, \":unlimited\\n\");\n\telse\n\t\tseq_printf(m, \":count=%ld\\n\", edata->count);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [
      "#define DISABLE_EVENT_STR\t\"disable_event\"",
      "#define ENABLE_EVENT_STR\t\"enable_event\""
    ],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\":count=%ld\\n\"",
            "edata->count"
          ],
          "line": 2607
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\":unlimited\\n\""
          ],
          "line": 2605
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "edata->file->event_call"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!pdata || !*pdata"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_func_mapper_find_ip",
          "args": [
            "mapper",
            "ip"
          ],
          "line": 2590
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_find_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4122-4134",
          "snippet": "void **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#define DISABLE_EVENT_STR\t\"disable_event\"\n#define ENABLE_EVENT_STR\t\"enable_event\"\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int\nevent_enable_print(struct seq_file *m, unsigned long ip,\n\t\t   struct ftrace_probe_ops *ops, void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tstruct event_probe_data *edata;\n\tvoid **pdata;\n\n\tpdata = ftrace_func_mapper_find_ip(mapper, ip);\n\n\tif (WARN_ON_ONCE(!pdata || !*pdata))\n\t\treturn 0;\n\n\tedata = *pdata;\n\n\tseq_printf(m, \"%ps:\", (void *)ip);\n\n\tseq_printf(m, \"%s:%s:%s\",\n\t\t   edata->enable ? ENABLE_EVENT_STR : DISABLE_EVENT_STR,\n\t\t   edata->file->event_call->class->system,\n\t\t   trace_event_name(edata->file->event_call));\n\n\tif (edata->count == -1)\n\t\tseq_puts(m, \":unlimited\\n\");\n\telse\n\t\tseq_printf(m, \":count=%ld\\n\", edata->count);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_enable_count_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2554-2580",
    "snippet": "static void\nevent_enable_count_probe(unsigned long ip, unsigned long parent_ip,\n\t\t\t struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t\t void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tstruct event_probe_data *edata;\n\tvoid **pdata;\n\n\tpdata = ftrace_func_mapper_find_ip(mapper, ip);\n\tif (!pdata || !*pdata)\n\t\treturn;\n\n\tedata = *pdata;\n\n\tif (!edata->count)\n\t\treturn;\n\n\t/* Skip if the event is in a state we want to switch to */\n\tif (edata->enable == !(edata->file->flags & EVENT_FILE_FL_SOFT_DISABLED))\n\t\treturn;\n\n\tif (edata->count != -1)\n\t\t(edata->count)--;\n\n\tupdate_event_probe(edata);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_event_probe",
          "args": [
            "edata"
          ],
          "line": 2579
        },
        "resolved": true,
        "details": {
          "function_name": "update_event_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2529-2535",
          "snippet": "static void update_event_probe(struct event_probe_data *data)\n{\n\tif (data->enable)\n\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n\telse\n\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void update_event_probe(struct event_probe_data *data)\n{\n\tif (data->enable)\n\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n\telse\n\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_func_mapper_find_ip",
          "args": [
            "mapper",
            "ip"
          ],
          "line": 2563
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_find_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4122-4134",
          "snippet": "void **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void\nevent_enable_count_probe(unsigned long ip, unsigned long parent_ip,\n\t\t\t struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t\t void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tstruct event_probe_data *edata;\n\tvoid **pdata;\n\n\tpdata = ftrace_func_mapper_find_ip(mapper, ip);\n\tif (!pdata || !*pdata)\n\t\treturn;\n\n\tedata = *pdata;\n\n\tif (!edata->count)\n\t\treturn;\n\n\t/* Skip if the event is in a state we want to switch to */\n\tif (edata->enable == !(edata->file->flags & EVENT_FILE_FL_SOFT_DISABLED))\n\t\treturn;\n\n\tif (edata->count != -1)\n\t\t(edata->count)--;\n\n\tupdate_event_probe(edata);\n}"
  },
  {
    "function_name": "event_enable_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2537-2552",
    "snippet": "static void\nevent_enable_probe(unsigned long ip, unsigned long parent_ip,\n\t\t   struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tstruct event_probe_data *edata;\n\tvoid **pdata;\n\n\tpdata = ftrace_func_mapper_find_ip(mapper, ip);\n\tif (!pdata || !*pdata)\n\t\treturn;\n\n\tedata = *pdata;\n\tupdate_event_probe(edata);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_event_probe",
          "args": [
            "edata"
          ],
          "line": 2551
        },
        "resolved": true,
        "details": {
          "function_name": "update_event_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2529-2535",
          "snippet": "static void update_event_probe(struct event_probe_data *data)\n{\n\tif (data->enable)\n\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n\telse\n\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void update_event_probe(struct event_probe_data *data)\n{\n\tif (data->enable)\n\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n\telse\n\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_func_mapper_find_ip",
          "args": [
            "mapper",
            "ip"
          ],
          "line": 2546
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_func_mapper_find_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4122-4134",
          "snippet": "void **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid **ftrace_func_mapper_find_ip(struct ftrace_func_mapper *mapper,\n\t\t\t\t  unsigned long ip)\n{\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_map *map;\n\n\tentry = ftrace_lookup_ip(&mapper->hash, ip);\n\tif (!entry)\n\t\treturn NULL;\n\n\tmap = (struct ftrace_func_map *)entry;\n\treturn &map->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void\nevent_enable_probe(unsigned long ip, unsigned long parent_ip,\n\t\t   struct trace_array *tr, struct ftrace_probe_ops *ops,\n\t\t   void *data)\n{\n\tstruct ftrace_func_mapper *mapper = data;\n\tstruct event_probe_data *edata;\n\tvoid **pdata;\n\n\tpdata = ftrace_func_mapper_find_ip(mapper, ip);\n\tif (!pdata || !*pdata)\n\t\treturn;\n\n\tedata = *pdata;\n\tupdate_event_probe(edata);\n}"
  },
  {
    "function_name": "update_event_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2529-2535",
    "snippet": "static void update_event_probe(struct event_probe_data *data)\n{\n\tif (data->enable)\n\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n\telse\n\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EVENT_FILE_FL_SOFT_DISABLED_BIT",
            "&data->file->flags"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EVENT_FILE_FL_SOFT_DISABLED_BIT",
            "&data->file->flags"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "792-801",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void update_event_probe(struct event_probe_data *data)\n{\n\tif (data->enable)\n\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n\telse\n\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &data->file->flags);\n}"
  },
  {
    "function_name": "find_event_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2503-2514",
    "snippet": "struct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__find_event_file",
          "args": [
            "tr",
            "system",
            "event"
          ],
          "line": 2508
        },
        "resolved": true,
        "details": {
          "function_name": "__find_event_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2480-2500",
          "snippet": "struct trace_event_file *\n__find_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class)\n\t\t\tcontinue;\n\n\t\tif (strcmp(event, name) == 0 &&\n\t\t    strcmp(system, call->class->system) == 0)\n\t\t\treturn file;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstruct trace_event_file *\n__find_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class)\n\t\t\tcontinue;\n\n\t\tif (strcmp(event, name) == 0 &&\n\t\t    strcmp(system, call->class->system) == 0)\n\t\t\treturn file;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstruct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}"
  },
  {
    "function_name": "__find_event_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2480-2500",
    "snippet": "struct trace_event_file *\n__find_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class)\n\t\t\tcontinue;\n\n\t\tif (strcmp(event, name) == 0 &&\n\t\t    strcmp(system, call->class->system) == 0)\n\t\t\treturn file;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "system",
            "call->class->system"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "event",
            "name"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstruct trace_event_file *\n__find_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class)\n\t\t\tcontinue;\n\n\t\tif (strcmp(event, name) == 0 &&\n\t\t    strcmp(system, call->class->system) == 0)\n\t\t\treturn file;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "__trace_add_event_dirs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2465-2477",
    "snippet": "static void\n__trace_add_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_call *call;\n\tint ret;\n\n\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\tret = __trace_add_new_event(call, tr);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create directory for event %s\\n\",\n\t\t\t\ttrace_event_name(call));\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create directory for event %s\\n\"",
            "trace_event_name(call)"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_add_new_event",
          "args": [
            "call",
            "tr"
          ],
          "line": 2472
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_add_new_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2275-2285",
          "snippet": "static int\n__trace_add_new_event(struct trace_event_call *call, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\treturn event_create_dir(tr->event_dir, file);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__trace_add_new_event(struct trace_event_call *call, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\treturn event_create_dir(tr->event_dir, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "call",
            "&ftrace_events",
            "list"
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void\n__trace_add_event_dirs(struct trace_array *tr)\n{\n\tstruct trace_event_call *call;\n\tint ret;\n\n\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\tret = __trace_add_new_event(call, tr);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Could not create directory for event %s\\n\",\n\t\t\t\ttrace_event_name(call));\n\t}\n}"
  },
  {
    "function_name": "trace_module_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2437-2456",
    "snippet": "static int trace_module_notify(struct notifier_block *self,\n\t\t\t       unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\tswitch (val) {\n\tcase MODULE_STATE_COMING:\n\t\ttrace_module_add_events(mod);\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\ttrace_module_remove_events(mod);\n\t\tbreak;\n\t}\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_module_remove_events",
          "args": [
            "mod"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "trace_module_remove_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2415-2435",
          "snippet": "static void trace_module_remove_events(struct module *mod)\n{\n\tstruct trace_event_call *call, *p;\n\n\tdown_write(&trace_event_sem);\n\tlist_for_each_entry_safe(call, p, &ftrace_events, list) {\n\t\tif (call->mod == mod)\n\t\t\t__trace_remove_event_call(call);\n\t}\n\tup_write(&trace_event_sem);\n\n\t/*\n\t * It is safest to reset the ring buffer if the module being unloaded\n\t * registered any events that were used. The only worry is if\n\t * a new module gets loaded, and takes on the same id as the events\n\t * of this module. When printing out the buffer, traced events left\n\t * over from this module may be passed to the new module events and\n\t * unexpected results may occur.\n\t */\n\ttracing_reset_all_online_cpus();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void trace_module_remove_events(struct module *mod)\n{\n\tstruct trace_event_call *call, *p;\n\n\tdown_write(&trace_event_sem);\n\tlist_for_each_entry_safe(call, p, &ftrace_events, list) {\n\t\tif (call->mod == mod)\n\t\t\t__trace_remove_event_call(call);\n\t}\n\tup_write(&trace_event_sem);\n\n\t/*\n\t * It is safest to reset the ring buffer if the module being unloaded\n\t * registered any events that were used. The only worry is if\n\t * a new module gets loaded, and takes on the same id as the events\n\t * of this module. When printing out the buffer, traced events left\n\t * over from this module may be passed to the new module events and\n\t * unexpected results may occur.\n\t */\n\ttracing_reset_all_online_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_module_add_events",
          "args": [
            "mod"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "trace_module_add_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2392-2413",
          "snippet": "static void trace_module_add_events(struct module *mod)\n{\n\tstruct trace_event_call **call, **start, **end;\n\n\tif (!mod->num_trace_events)\n\t\treturn;\n\n\t/* Don't add infrastructure for mods without tracepoints */\n\tif (trace_module_has_bad_taint(mod)) {\n\t\tpr_err(\"%s: module has bad taint, not creating trace events\\n\",\n\t\t       mod->name);\n\t\treturn;\n\t}\n\n\tstart = mod->trace_events;\n\tend = mod->trace_events + mod->num_trace_events;\n\n\tfor_each_event(call, start, end) {\n\t\t__register_event(*call, mod);\n\t\t__add_event_to_tracers(*call);\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void trace_module_add_events(struct module *mod)\n{\n\tstruct trace_event_call **call, **start, **end;\n\n\tif (!mod->num_trace_events)\n\t\treturn;\n\n\t/* Don't add infrastructure for mods without tracepoints */\n\tif (trace_module_has_bad_taint(mod)) {\n\t\tpr_err(\"%s: module has bad taint, not creating trace events\\n\",\n\t\t       mod->name);\n\t\treturn;\n\t}\n\n\tstart = mod->trace_events;\n\tend = mod->trace_events + mod->num_trace_events;\n\n\tfor_each_event(call, start, end) {\n\t\t__register_event(*call, mod);\n\t\t__add_event_to_tracers(*call);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 2443
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int trace_module_notify(struct notifier_block *self,\n\t\t\t       unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\tswitch (val) {\n\tcase MODULE_STATE_COMING:\n\t\ttrace_module_add_events(mod);\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\ttrace_module_remove_events(mod);\n\t\tbreak;\n\t}\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_module_remove_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2415-2435",
    "snippet": "static void trace_module_remove_events(struct module *mod)\n{\n\tstruct trace_event_call *call, *p;\n\n\tdown_write(&trace_event_sem);\n\tlist_for_each_entry_safe(call, p, &ftrace_events, list) {\n\t\tif (call->mod == mod)\n\t\t\t__trace_remove_event_call(call);\n\t}\n\tup_write(&trace_event_sem);\n\n\t/*\n\t * It is safest to reset the ring buffer if the module being unloaded\n\t * registered any events that were used. The only worry is if\n\t * a new module gets loaded, and takes on the same id as the events\n\t * of this module. When printing out the buffer, traced events left\n\t * over from this module may be passed to the new module events and\n\t * unexpected results may occur.\n\t */\n\ttracing_reset_all_online_cpus();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_reset_all_online_cpus",
          "args": [],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_reset_all_online_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1712-1725",
          "snippet": "void tracing_reset_all_online_cpus(void)\n{\n\tstruct trace_array *tr;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->clear_trace)\n\t\t\tcontinue;\n\t\ttr->clear_trace = false;\n\t\ttracing_reset_online_cpus(&tr->trace_buffer);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\ttracing_reset_online_cpus(&tr->max_buffer);\n#endif\n\t}\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid tracing_reset_all_online_cpus(void)\n{\n\tstruct trace_array *tr;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (!tr->clear_trace)\n\t\t\tcontinue;\n\t\ttr->clear_trace = false;\n\t\ttracing_reset_online_cpus(&tr->trace_buffer);\n#ifdef CONFIG_TRACER_MAX_TRACE\n\t\ttracing_reset_online_cpus(&tr->max_buffer);\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_remove_event_call",
          "args": [
            "call"
          ],
          "line": 2422
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_remove_event_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2328-2334",
          "snippet": "static void __trace_remove_event_call(struct trace_event_call *call)\n{\n\tevent_remove(call);\n\ttrace_destroy_fields(call);\n\tfree_event_filter(call->filter);\n\tcall->filter = NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void __trace_remove_event_call(struct trace_event_call *call)\n{\n\tevent_remove(call);\n\ttrace_destroy_fields(call);\n\tfree_event_filter(call->filter);\n\tcall->filter = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "call",
            "p",
            "&ftrace_events",
            "list"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void trace_module_remove_events(struct module *mod)\n{\n\tstruct trace_event_call *call, *p;\n\n\tdown_write(&trace_event_sem);\n\tlist_for_each_entry_safe(call, p, &ftrace_events, list) {\n\t\tif (call->mod == mod)\n\t\t\t__trace_remove_event_call(call);\n\t}\n\tup_write(&trace_event_sem);\n\n\t/*\n\t * It is safest to reset the ring buffer if the module being unloaded\n\t * registered any events that were used. The only worry is if\n\t * a new module gets loaded, and takes on the same id as the events\n\t * of this module. When printing out the buffer, traced events left\n\t * over from this module may be passed to the new module events and\n\t * unexpected results may occur.\n\t */\n\ttracing_reset_all_online_cpus();\n}"
  },
  {
    "function_name": "trace_module_add_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2392-2413",
    "snippet": "static void trace_module_add_events(struct module *mod)\n{\n\tstruct trace_event_call **call, **start, **end;\n\n\tif (!mod->num_trace_events)\n\t\treturn;\n\n\t/* Don't add infrastructure for mods without tracepoints */\n\tif (trace_module_has_bad_taint(mod)) {\n\t\tpr_err(\"%s: module has bad taint, not creating trace events\\n\",\n\t\t       mod->name);\n\t\treturn;\n\t}\n\n\tstart = mod->trace_events;\n\tend = mod->trace_events + mod->num_trace_events;\n\n\tfor_each_event(call, start, end) {\n\t\t__register_event(*call, mod);\n\t\t__add_event_to_tracers(*call);\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_event_to_tracers",
          "args": [
            "*call"
          ],
          "line": 2411
        },
        "resolved": true,
        "details": {
          "function_name": "__add_event_to_tracers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2895-2901",
          "snippet": "static void __add_event_to_tracers(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list)\n\t\t__trace_add_new_event(call, tr);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void __add_event_to_tracers(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list)\n\t\t__trace_add_new_event(call, tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__register_event",
          "args": [
            "*call",
            "mod"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "__register_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2100-2113",
          "snippet": "static int\n__register_event(struct trace_event_call *call, struct module *mod)\n{\n\tint ret;\n\n\tret = event_init(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlist_add(&call->list, &ftrace_events);\n\tcall->mod = mod;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__register_event(struct trace_event_call *call, struct module *mod)\n{\n\tint ret;\n\n\tret = event_init(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlist_add(&call->list, &ftrace_events);\n\tcall->mod = mod;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_event",
          "args": [
            "call",
            "start",
            "end"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: module has bad taint, not creating trace events\\n\"",
            "mod->name"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_module_has_bad_taint",
          "args": [
            "mod"
          ],
          "line": 2400
        },
        "resolved": true,
        "details": {
          "function_name": "trace_module_has_bad_taint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "388-392",
          "snippet": "bool trace_module_has_bad_taint(struct module *mod)\n{\n\treturn mod->taints & ~((1 << TAINT_OOT_MODULE) | (1 << TAINT_CRAP) |\n\t\t\t       (1 << TAINT_UNSIGNED_MODULE));\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nbool trace_module_has_bad_taint(struct module *mod)\n{\n\treturn mod->taints & ~((1 << TAINT_OOT_MODULE) | (1 << TAINT_CRAP) |\n\t\t\t       (1 << TAINT_UNSIGNED_MODULE));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void trace_module_add_events(struct module *mod)\n{\n\tstruct trace_event_call **call, **start, **end;\n\n\tif (!mod->num_trace_events)\n\t\treturn;\n\n\t/* Don't add infrastructure for mods without tracepoints */\n\tif (trace_module_has_bad_taint(mod)) {\n\t\tpr_err(\"%s: module has bad taint, not creating trace events\\n\",\n\t\t       mod->name);\n\t\treturn;\n\t}\n\n\tstart = mod->trace_events;\n\tend = mod->trace_events + mod->num_trace_events;\n\n\tfor_each_event(call, start, end) {\n\t\t__register_event(*call, mod);\n\t\t__add_event_to_tracers(*call);\n\t}\n}"
  },
  {
    "function_name": "trace_remove_event_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2370-2383",
    "snippet": "int trace_remove_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\tdown_write(&trace_event_sem);\n\tret = probe_remove_event_call(call);\n\tup_write(&trace_event_sem);\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_remove_event_call",
          "args": [
            "call"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "probe_remove_event_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2336-2367",
          "snippet": "static int probe_remove_event_call(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\tstruct trace_event_file *file;\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->perf_refcount)\n\t\treturn -EBUSY;\n#endif\n\tdo_for_each_event_file(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We can't rely on ftrace_event_enable_disable(enable => 0)\n\t\t * we are going to do, EVENT_FILE_FL_SOFT_MODE can suppress\n\t\t * TRACE_REG_UNREGISTER.\n\t\t */\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED)\n\t\t\treturn -EBUSY;\n\t\t/*\n\t\t * The do_for_each_event_file_safe() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n\n\t__trace_remove_event_call(call);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int probe_remove_event_call(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\tstruct trace_event_file *file;\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->perf_refcount)\n\t\treturn -EBUSY;\n#endif\n\tdo_for_each_event_file(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We can't rely on ftrace_event_enable_disable(enable => 0)\n\t\t * we are going to do, EVENT_FILE_FL_SOFT_MODE can suppress\n\t\t * TRACE_REG_UNREGISTER.\n\t\t */\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED)\n\t\t\treturn -EBUSY;\n\t\t/*\n\t\t * The do_for_each_event_file_safe() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n\n\t__trace_remove_event_call(call);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_remove_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\tdown_write(&trace_event_sem);\n\tret = probe_remove_event_call(call);\n\tup_write(&trace_event_sem);\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "probe_remove_event_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2336-2367",
    "snippet": "static int probe_remove_event_call(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\tstruct trace_event_file *file;\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->perf_refcount)\n\t\treturn -EBUSY;\n#endif\n\tdo_for_each_event_file(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We can't rely on ftrace_event_enable_disable(enable => 0)\n\t\t * we are going to do, EVENT_FILE_FL_SOFT_MODE can suppress\n\t\t * TRACE_REG_UNREGISTER.\n\t\t */\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED)\n\t\t\treturn -EBUSY;\n\t\t/*\n\t\t * The do_for_each_event_file_safe() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n\n\t__trace_remove_event_call(call);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__trace_remove_event_call",
          "args": [
            "call"
          ],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_remove_event_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2328-2334",
          "snippet": "static void __trace_remove_event_call(struct trace_event_call *call)\n{\n\tevent_remove(call);\n\ttrace_destroy_fields(call);\n\tfree_event_filter(call->filter);\n\tcall->filter = NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void __trace_remove_event_call(struct trace_event_call *call)\n{\n\tevent_remove(call);\n\ttrace_destroy_fields(call);\n\tfree_event_filter(call->filter);\n\tcall->filter = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_for_each_event_file",
          "args": [],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_for_each_event_file",
          "args": [
            "tr",
            "file"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int probe_remove_event_call(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\tstruct trace_event_file *file;\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->perf_refcount)\n\t\treturn -EBUSY;\n#endif\n\tdo_for_each_event_file(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We can't rely on ftrace_event_enable_disable(enable => 0)\n\t\t * we are going to do, EVENT_FILE_FL_SOFT_MODE can suppress\n\t\t * TRACE_REG_UNREGISTER.\n\t\t */\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED)\n\t\t\treturn -EBUSY;\n\t\t/*\n\t\t * The do_for_each_event_file_safe() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n\n\t__trace_remove_event_call(call);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__trace_remove_event_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2328-2334",
    "snippet": "static void __trace_remove_event_call(struct trace_event_call *call)\n{\n\tevent_remove(call);\n\ttrace_destroy_fields(call);\n\tfree_event_filter(call->filter);\n\tcall->filter = NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_event_filter",
          "args": [
            "call->filter"
          ],
          "line": 2332
        },
        "resolved": true,
        "details": {
          "function_name": "free_event_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1017-1020",
          "snippet": "void free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_destroy_fields",
          "args": [
            "call"
          ],
          "line": 2331
        },
        "resolved": true,
        "details": {
          "function_name": "trace_destroy_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "195-205",
          "snippet": "static void trace_destroy_fields(struct trace_event_call *call)\n{\n\tstruct ftrace_event_field *field, *next;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tlist_for_each_entry_safe(field, next, head, link) {\n\t\tlist_del(&field->link);\n\t\tkmem_cache_free(field_cachep, field);\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *field_cachep;",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic struct kmem_cache *field_cachep;\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void trace_destroy_fields(struct trace_event_call *call)\n{\n\tstruct ftrace_event_field *field, *next;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tlist_for_each_entry_safe(field, next, head, link) {\n\t\tlist_del(&field->link);\n\t\tkmem_cache_free(field_cachep, field);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_remove",
          "args": [
            "call"
          ],
          "line": 2330
        },
        "resolved": true,
        "details": {
          "function_name": "event_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2054-2080",
          "snippet": "static void event_remove(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\tstruct trace_event_file *file;\n\n\tdo_for_each_event_file(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\n\t\tif (file->flags & EVENT_FILE_FL_WAS_ENABLED)\n\t\t\ttr->clear_trace = true;\n\n\t\tftrace_event_enable_disable(file, 0);\n\t\t/*\n\t\t * The do_for_each_event_file() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n\n\tif (call->event.funcs)\n\t\t__unregister_trace_event(&call->event);\n\tremove_event_from_tracers(call);\n\tlist_del(&call->list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void event_remove(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\tstruct trace_event_file *file;\n\n\tdo_for_each_event_file(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\n\t\tif (file->flags & EVENT_FILE_FL_WAS_ENABLED)\n\t\t\ttr->clear_trace = true;\n\n\t\tftrace_event_enable_disable(file, 0);\n\t\t/*\n\t\t * The do_for_each_event_file() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n\n\tif (call->event.funcs)\n\t\t__unregister_trace_event(&call->event);\n\tremove_event_from_tracers(call);\n\tlist_del(&call->list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void __trace_remove_event_call(struct trace_event_call *call)\n{\n\tevent_remove(call);\n\ttrace_destroy_fields(call);\n\tfree_event_filter(call->filter);\n\tcall->filter = NULL;\n}"
  },
  {
    "function_name": "trace_add_event_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2309-2322",
    "snippet": "int trace_add_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tret = __register_event(call, NULL);\n\tif (ret >= 0)\n\t\t__add_event_to_tracers(call);\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__add_event_to_tracers",
          "args": [
            "call"
          ],
          "line": 2317
        },
        "resolved": true,
        "details": {
          "function_name": "__add_event_to_tracers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2895-2901",
          "snippet": "static void __add_event_to_tracers(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list)\n\t\t__trace_add_new_event(call, tr);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void __add_event_to_tracers(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list)\n\t\t__trace_add_new_event(call, tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__register_event",
          "args": [
            "call",
            "NULL"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "__register_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2100-2113",
          "snippet": "static int\n__register_event(struct trace_event_call *call, struct module *mod)\n{\n\tint ret;\n\n\tret = event_init(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlist_add(&call->list, &ftrace_events);\n\tcall->mod = mod;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__register_event(struct trace_event_call *call, struct module *mod)\n{\n\tint ret;\n\n\tret = event_init(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlist_add(&call->list, &ftrace_events);\n\tcall->mod = mod;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_add_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tret = __register_event(call, NULL);\n\tif (ret >= 0)\n\t\t__add_event_to_tracers(call);\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "__trace_early_add_new_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2292-2303",
    "snippet": "static __init int\n__trace_early_add_new_event(struct trace_event_call *call,\n\t\t\t    struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_create_new_event",
          "args": [
            "call",
            "tr"
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_new_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2254-2272",
          "snippet": "static struct trace_event_file *\ntrace_create_new_event(struct trace_event_call *call,\n\t\t       struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = kmem_cache_alloc(file_cachep, GFP_TRACE);\n\tif (!file)\n\t\treturn NULL;\n\n\tfile->event_call = call;\n\tfile->tr = tr;\n\tatomic_set(&file->sm_ref, 0);\n\tatomic_set(&file->tm_ref, 0);\n\tINIT_LIST_HEAD(&file->triggers);\n\tlist_add(&file->list, &tr->events);\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [
            "#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)"
          ],
          "globals_used": [
            "static struct kmem_cache *file_cachep;",
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)\n\nstatic struct kmem_cache *file_cachep;\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic struct trace_event_file *\ntrace_create_new_event(struct trace_event_call *call,\n\t\t       struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = kmem_cache_alloc(file_cachep, GFP_TRACE);\n\tif (!file)\n\t\treturn NULL;\n\n\tfile->event_call = call;\n\tfile->tr = tr;\n\tatomic_set(&file->sm_ref, 0);\n\tatomic_set(&file->tm_ref, 0);\n\tINIT_LIST_HEAD(&file->triggers);\n\tlist_add(&file->list, &tr->events);\n\n\treturn file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic __init int\n__trace_early_add_new_event(struct trace_event_call *call,\n\t\t\t    struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__trace_add_new_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2275-2285",
    "snippet": "static int\n__trace_add_new_event(struct trace_event_call *call, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\treturn event_create_dir(tr->event_dir, file);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_create_dir",
          "args": [
            "tr->event_dir",
            "file"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "event_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "1959-2032",
          "snippet": "static int\nevent_create_dir(struct dentry *parent, struct trace_event_file *file)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tstruct list_head *head;\n\tstruct dentry *d_events;\n\tconst char *name;\n\tint ret;\n\n\t/*\n\t * If the trace point header did not define TRACE_SYSTEM\n\t * then the system would be called \"TRACE_SYSTEM\".\n\t */\n\tif (strcmp(call->class->system, TRACE_SYSTEM) != 0) {\n\t\td_events = event_subsystem_dir(tr, call->class->system, file, parent);\n\t\tif (!d_events)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\td_events = parent;\n\n\tname = trace_event_name(call);\n\tfile->dir = tracefs_create_dir(name, d_events);\n\tif (!file->dir) {\n\t\tpr_warn(\"Could not create tracefs '%s' directory\\n\", name);\n\t\treturn -1;\n\t}\n\n\tif (call->class->reg && !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\ttrace_create_file(\"enable\", 0644, file->dir, file,\n\t\t\t\t  &ftrace_enable_fops);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->event.type && call->class->reg)\n\t\ttrace_create_file(\"id\", 0444, file->dir,\n\t\t\t\t  (void *)(long)call->event.type,\n\t\t\t\t  &ftrace_event_id_fops);\n#endif\n\n\t/*\n\t * Other events may have the same class. Only update\n\t * the fields if they are not already defined.\n\t */\n\thead = trace_get_fields(call);\n\tif (list_empty(head)) {\n\t\tret = call->class->define_fields(call);\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"Could not initialize trace point events/%s\\n\",\n\t\t\t\tname);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/*\n\t * Only event directories that can be enabled should have\n\t * triggers or filters.\n\t */\n\tif (!(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)) {\n\t\ttrace_create_file(\"filter\", 0644, file->dir, file,\n\t\t\t\t  &ftrace_event_filter_fops);\n\n\t\ttrace_create_file(\"trigger\", 0644, file->dir, file,\n\t\t\t\t  &event_trigger_fops);\n\t}\n\n#ifdef CONFIG_HIST_TRIGGERS\n\ttrace_create_file(\"hist\", 0444, file->dir, file,\n\t\t\t  &event_hist_fops);\n#endif\n\ttrace_create_file(\"format\", 0444, file->dir, call,\n\t\t\t  &ftrace_event_format_fops);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [
            "#define TRACE_SYSTEM \"TRACE_SYSTEM\""
          ],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static const struct file_operations ftrace_enable_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_enable_read,\n\t.write = event_enable_write,\n\t.llseek = default_llseek,\n};",
            "static const struct file_operations ftrace_event_format_fops = {\n\t.open = trace_format_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};",
            "static const struct file_operations ftrace_event_id_fops = {\n\t.read = event_id_read,\n\t.llseek = default_llseek,\n};",
            "static const struct file_operations ftrace_event_filter_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_filter_read,\n\t.write = event_filter_write,\n\t.llseek = default_llseek,\n};",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#define TRACE_SYSTEM \"TRACE_SYSTEM\"\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic const struct file_operations ftrace_enable_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_enable_read,\n\t.write = event_enable_write,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations ftrace_event_format_fops = {\n\t.open = trace_format_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\nstatic const struct file_operations ftrace_event_id_fops = {\n\t.read = event_id_read,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations ftrace_event_filter_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_filter_read,\n\t.write = event_filter_write,\n\t.llseek = default_llseek,\n};\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\nevent_create_dir(struct dentry *parent, struct trace_event_file *file)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tstruct list_head *head;\n\tstruct dentry *d_events;\n\tconst char *name;\n\tint ret;\n\n\t/*\n\t * If the trace point header did not define TRACE_SYSTEM\n\t * then the system would be called \"TRACE_SYSTEM\".\n\t */\n\tif (strcmp(call->class->system, TRACE_SYSTEM) != 0) {\n\t\td_events = event_subsystem_dir(tr, call->class->system, file, parent);\n\t\tif (!d_events)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\td_events = parent;\n\n\tname = trace_event_name(call);\n\tfile->dir = tracefs_create_dir(name, d_events);\n\tif (!file->dir) {\n\t\tpr_warn(\"Could not create tracefs '%s' directory\\n\", name);\n\t\treturn -1;\n\t}\n\n\tif (call->class->reg && !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\ttrace_create_file(\"enable\", 0644, file->dir, file,\n\t\t\t\t  &ftrace_enable_fops);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->event.type && call->class->reg)\n\t\ttrace_create_file(\"id\", 0444, file->dir,\n\t\t\t\t  (void *)(long)call->event.type,\n\t\t\t\t  &ftrace_event_id_fops);\n#endif\n\n\t/*\n\t * Other events may have the same class. Only update\n\t * the fields if they are not already defined.\n\t */\n\thead = trace_get_fields(call);\n\tif (list_empty(head)) {\n\t\tret = call->class->define_fields(call);\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"Could not initialize trace point events/%s\\n\",\n\t\t\t\tname);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/*\n\t * Only event directories that can be enabled should have\n\t * triggers or filters.\n\t */\n\tif (!(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)) {\n\t\ttrace_create_file(\"filter\", 0644, file->dir, file,\n\t\t\t\t  &ftrace_event_filter_fops);\n\n\t\ttrace_create_file(\"trigger\", 0644, file->dir, file,\n\t\t\t\t  &event_trigger_fops);\n\t}\n\n#ifdef CONFIG_HIST_TRIGGERS\n\ttrace_create_file(\"hist\", 0444, file->dir, file,\n\t\t\t  &event_hist_fops);\n#endif\n\ttrace_create_file(\"format\", 0444, file->dir, call,\n\t\t\t  &ftrace_event_format_fops);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_create_new_event",
          "args": [
            "call",
            "tr"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_new_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2254-2272",
          "snippet": "static struct trace_event_file *\ntrace_create_new_event(struct trace_event_call *call,\n\t\t       struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = kmem_cache_alloc(file_cachep, GFP_TRACE);\n\tif (!file)\n\t\treturn NULL;\n\n\tfile->event_call = call;\n\tfile->tr = tr;\n\tatomic_set(&file->sm_ref, 0);\n\tatomic_set(&file->tm_ref, 0);\n\tINIT_LIST_HEAD(&file->triggers);\n\tlist_add(&file->list, &tr->events);\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [
            "#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)"
          ],
          "globals_used": [
            "static struct kmem_cache *file_cachep;",
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)\n\nstatic struct kmem_cache *file_cachep;\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic struct trace_event_file *\ntrace_create_new_event(struct trace_event_call *call,\n\t\t       struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = kmem_cache_alloc(file_cachep, GFP_TRACE);\n\tif (!file)\n\t\treturn NULL;\n\n\tfile->event_call = call;\n\tfile->tr = tr;\n\tatomic_set(&file->sm_ref, 0);\n\tatomic_set(&file->tm_ref, 0);\n\tINIT_LIST_HEAD(&file->triggers);\n\tlist_add(&file->list, &tr->events);\n\n\treturn file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__trace_add_new_event(struct trace_event_call *call, struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = trace_create_new_event(call, tr);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\treturn event_create_dir(tr->event_dir, file);\n}"
  },
  {
    "function_name": "trace_create_new_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2254-2272",
    "snippet": "static struct trace_event_file *\ntrace_create_new_event(struct trace_event_call *call,\n\t\t       struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = kmem_cache_alloc(file_cachep, GFP_TRACE);\n\tif (!file)\n\t\treturn NULL;\n\n\tfile->event_call = call;\n\tfile->tr = tr;\n\tatomic_set(&file->sm_ref, 0);\n\tatomic_set(&file->tm_ref, 0);\n\tINIT_LIST_HEAD(&file->triggers);\n\tlist_add(&file->list, &tr->events);\n\n\treturn file;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [
      "#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)"
    ],
    "globals_used": [
      "static struct kmem_cache *file_cachep;",
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&file->list",
            "&tr->events"
          ],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&file->triggers"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&file->tm_ref",
            "0"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&file->sm_ref",
            "0"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "file_cachep",
            "GFP_TRACE"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)\n\nstatic struct kmem_cache *file_cachep;\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic struct trace_event_file *\ntrace_create_new_event(struct trace_event_call *call,\n\t\t       struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tfile = kmem_cache_alloc(file_cachep, GFP_TRACE);\n\tif (!file)\n\t\treturn NULL;\n\n\tfile->event_call = call;\n\tfile->tr = tr;\n\tatomic_set(&file->sm_ref, 0);\n\tatomic_set(&file->tm_ref, 0);\n\tINIT_LIST_HEAD(&file->triggers);\n\tlist_add(&file->list, &tr->events);\n\n\treturn file;\n}"
  },
  {
    "function_name": "trace_event_eval_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2213-2252",
    "snippet": "void trace_event_eval_update(struct trace_eval_map **map, int len)\n{\n\tstruct trace_event_call *call, *p;\n\tconst char *last_system = NULL;\n\tbool first = false;\n\tint last_i;\n\tint i;\n\n\tdown_write(&trace_event_sem);\n\tlist_for_each_entry_safe(call, p, &ftrace_events, list) {\n\t\t/* events are usually grouped together with systems */\n\t\tif (!last_system || call->class->system != last_system) {\n\t\t\tfirst = true;\n\t\t\tlast_i = 0;\n\t\t\tlast_system = call->class->system;\n\t\t}\n\n\t\t/*\n\t\t * Since calls are grouped by systems, the likelyhood that the\n\t\t * next call in the iteration belongs to the same system as the\n\t\t * previous call is high. As an optimization, we skip seaching\n\t\t * for a map[] that matches the call's system if the last call\n\t\t * was from the same system. That's what last_i is for. If the\n\t\t * call has the same system as the previous call, then last_i\n\t\t * will be the index of the first map[] that has a matching\n\t\t * system.\n\t\t */\n\t\tfor (i = last_i; i < len; i++) {\n\t\t\tif (call->class->system == map[i]->system) {\n\t\t\t\t/* Save the first system if need be */\n\t\t\t\tif (first) {\n\t\t\t\t\tlast_i = i;\n\t\t\t\t\tfirst = false;\n\t\t\t\t}\n\t\t\t\tupdate_event_printk(call, map[i]);\n\t\t\t}\n\t\t}\n\t}\n\tup_write(&trace_event_sem);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_event_printk",
          "args": [
            "call",
            "map[i]"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "update_event_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2137-2211",
          "snippet": "static void update_event_printk(struct trace_event_call *call,\n\t\t\t\tstruct trace_eval_map *map)\n{\n\tchar *ptr;\n\tint quote = 0;\n\tint len = strlen(map->eval_string);\n\n\tfor (ptr = call->print_fmt; *ptr; ptr++) {\n\t\tif (*ptr == '\\\\') {\n\t\t\tptr++;\n\t\t\t/* paranoid */\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*ptr == '\"') {\n\t\t\tquote ^= 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (quote)\n\t\t\tcontinue;\n\t\tif (isdigit(*ptr)) {\n\t\t\t/* skip numbers */\n\t\t\tdo {\n\t\t\t\tptr++;\n\t\t\t\t/* Check for alpha chars like ULL */\n\t\t\t} while (isalnum(*ptr));\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * A number must have some kind of delimiter after\n\t\t\t * it, and we can ignore that too.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (isalpha(*ptr) || *ptr == '_') {\n\t\t\tif (strncmp(map->eval_string, ptr, len) == 0 &&\n\t\t\t    !isalnum(ptr[len]) && ptr[len] != '_') {\n\t\t\t\tptr = eval_replace(ptr, map, len);\n\t\t\t\t/* enum/sizeof string smaller than value */\n\t\t\t\tif (WARN_ON_ONCE(!ptr))\n\t\t\t\t\treturn;\n\t\t\t\t/*\n\t\t\t\t * No need to decrement here, as eval_replace()\n\t\t\t\t * returns the pointer to the character passed\n\t\t\t\t * the eval, and two evals can not be placed\n\t\t\t\t * back to back without something in between.\n\t\t\t\t * We can skip that something in between.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\tskip_more:\n\t\t\tdo {\n\t\t\t\tptr++;\n\t\t\t} while (isalnum(*ptr) || *ptr == '_');\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If what comes after this variable is a '.' or\n\t\t\t * '->' then we can continue to ignore that string.\n\t\t\t */\n\t\t\tif (*ptr == '.' || (ptr[0] == '-' && ptr[1] == '>')) {\n\t\t\t\tptr += *ptr == '.' ? 1 : 2;\n\t\t\t\tif (!*ptr)\n\t\t\t\t\tbreak;\n\t\t\t\tgoto skip_more;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Once again, we can skip the delimiter that came\n\t\t\t * after the string.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void update_event_printk(struct trace_event_call *call,\n\t\t\t\tstruct trace_eval_map *map)\n{\n\tchar *ptr;\n\tint quote = 0;\n\tint len = strlen(map->eval_string);\n\n\tfor (ptr = call->print_fmt; *ptr; ptr++) {\n\t\tif (*ptr == '\\\\') {\n\t\t\tptr++;\n\t\t\t/* paranoid */\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*ptr == '\"') {\n\t\t\tquote ^= 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (quote)\n\t\t\tcontinue;\n\t\tif (isdigit(*ptr)) {\n\t\t\t/* skip numbers */\n\t\t\tdo {\n\t\t\t\tptr++;\n\t\t\t\t/* Check for alpha chars like ULL */\n\t\t\t} while (isalnum(*ptr));\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * A number must have some kind of delimiter after\n\t\t\t * it, and we can ignore that too.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (isalpha(*ptr) || *ptr == '_') {\n\t\t\tif (strncmp(map->eval_string, ptr, len) == 0 &&\n\t\t\t    !isalnum(ptr[len]) && ptr[len] != '_') {\n\t\t\t\tptr = eval_replace(ptr, map, len);\n\t\t\t\t/* enum/sizeof string smaller than value */\n\t\t\t\tif (WARN_ON_ONCE(!ptr))\n\t\t\t\t\treturn;\n\t\t\t\t/*\n\t\t\t\t * No need to decrement here, as eval_replace()\n\t\t\t\t * returns the pointer to the character passed\n\t\t\t\t * the eval, and two evals can not be placed\n\t\t\t\t * back to back without something in between.\n\t\t\t\t * We can skip that something in between.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\tskip_more:\n\t\t\tdo {\n\t\t\t\tptr++;\n\t\t\t} while (isalnum(*ptr) || *ptr == '_');\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If what comes after this variable is a '.' or\n\t\t\t * '->' then we can continue to ignore that string.\n\t\t\t */\n\t\t\tif (*ptr == '.' || (ptr[0] == '-' && ptr[1] == '>')) {\n\t\t\t\tptr += *ptr == '.' ? 1 : 2;\n\t\t\t\tif (!*ptr)\n\t\t\t\t\tbreak;\n\t\t\t\tgoto skip_more;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Once again, we can skip the delimiter that came\n\t\t\t * after the string.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "call",
            "p",
            "&ftrace_events",
            "list"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&trace_event_sem"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nvoid trace_event_eval_update(struct trace_eval_map **map, int len)\n{\n\tstruct trace_event_call *call, *p;\n\tconst char *last_system = NULL;\n\tbool first = false;\n\tint last_i;\n\tint i;\n\n\tdown_write(&trace_event_sem);\n\tlist_for_each_entry_safe(call, p, &ftrace_events, list) {\n\t\t/* events are usually grouped together with systems */\n\t\tif (!last_system || call->class->system != last_system) {\n\t\t\tfirst = true;\n\t\t\tlast_i = 0;\n\t\t\tlast_system = call->class->system;\n\t\t}\n\n\t\t/*\n\t\t * Since calls are grouped by systems, the likelyhood that the\n\t\t * next call in the iteration belongs to the same system as the\n\t\t * previous call is high. As an optimization, we skip seaching\n\t\t * for a map[] that matches the call's system if the last call\n\t\t * was from the same system. That's what last_i is for. If the\n\t\t * call has the same system as the previous call, then last_i\n\t\t * will be the index of the first map[] that has a matching\n\t\t * system.\n\t\t */\n\t\tfor (i = last_i; i < len; i++) {\n\t\t\tif (call->class->system == map[i]->system) {\n\t\t\t\t/* Save the first system if need be */\n\t\t\t\tif (first) {\n\t\t\t\t\tlast_i = i;\n\t\t\t\t\tfirst = false;\n\t\t\t\t}\n\t\t\t\tupdate_event_printk(call, map[i]);\n\t\t\t}\n\t\t}\n\t}\n\tup_write(&trace_event_sem);\n}"
  },
  {
    "function_name": "update_event_printk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2137-2211",
    "snippet": "static void update_event_printk(struct trace_event_call *call,\n\t\t\t\tstruct trace_eval_map *map)\n{\n\tchar *ptr;\n\tint quote = 0;\n\tint len = strlen(map->eval_string);\n\n\tfor (ptr = call->print_fmt; *ptr; ptr++) {\n\t\tif (*ptr == '\\\\') {\n\t\t\tptr++;\n\t\t\t/* paranoid */\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*ptr == '\"') {\n\t\t\tquote ^= 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (quote)\n\t\t\tcontinue;\n\t\tif (isdigit(*ptr)) {\n\t\t\t/* skip numbers */\n\t\t\tdo {\n\t\t\t\tptr++;\n\t\t\t\t/* Check for alpha chars like ULL */\n\t\t\t} while (isalnum(*ptr));\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * A number must have some kind of delimiter after\n\t\t\t * it, and we can ignore that too.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (isalpha(*ptr) || *ptr == '_') {\n\t\t\tif (strncmp(map->eval_string, ptr, len) == 0 &&\n\t\t\t    !isalnum(ptr[len]) && ptr[len] != '_') {\n\t\t\t\tptr = eval_replace(ptr, map, len);\n\t\t\t\t/* enum/sizeof string smaller than value */\n\t\t\t\tif (WARN_ON_ONCE(!ptr))\n\t\t\t\t\treturn;\n\t\t\t\t/*\n\t\t\t\t * No need to decrement here, as eval_replace()\n\t\t\t\t * returns the pointer to the character passed\n\t\t\t\t * the eval, and two evals can not be placed\n\t\t\t\t * back to back without something in between.\n\t\t\t\t * We can skip that something in between.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\tskip_more:\n\t\t\tdo {\n\t\t\t\tptr++;\n\t\t\t} while (isalnum(*ptr) || *ptr == '_');\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If what comes after this variable is a '.' or\n\t\t\t * '->' then we can continue to ignore that string.\n\t\t\t */\n\t\t\tif (*ptr == '.' || (ptr[0] == '-' && ptr[1] == '>')) {\n\t\t\t\tptr += *ptr == '.' ? 1 : 2;\n\t\t\t\tif (!*ptr)\n\t\t\t\t\tbreak;\n\t\t\t\tgoto skip_more;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Once again, we can skip the delimiter that came\n\t\t\t * after the string.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "*ptr"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!ptr"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eval_replace",
          "args": [
            "ptr",
            "map",
            "len"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "eval_replace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2115-2135",
          "snippet": "static char *eval_replace(char *ptr, struct trace_eval_map *map, int len)\n{\n\tint rlen;\n\tint elen;\n\n\t/* Find the length of the eval value as a string */\n\telen = snprintf(ptr, 0, \"%ld\", map->eval_value);\n\t/* Make sure there's enough room to replace the string with the value */\n\tif (len < elen)\n\t\treturn NULL;\n\n\tsnprintf(ptr, elen + 1, \"%ld\", map->eval_value);\n\n\t/* Get the rest of the string of ptr */\n\trlen = strlen(ptr + len);\n\tmemmove(ptr + elen, ptr + len, rlen);\n\t/* Make sure we end the new string */\n\tptr[elen + rlen] = 0;\n\n\treturn ptr + elen;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic char *eval_replace(char *ptr, struct trace_eval_map *map, int len)\n{\n\tint rlen;\n\tint elen;\n\n\t/* Find the length of the eval value as a string */\n\telen = snprintf(ptr, 0, \"%ld\", map->eval_value);\n\t/* Make sure there's enough room to replace the string with the value */\n\tif (len < elen)\n\t\treturn NULL;\n\n\tsnprintf(ptr, elen + 1, \"%ld\", map->eval_value);\n\n\t/* Get the rest of the string of ptr */\n\trlen = strlen(ptr + len);\n\tmemmove(ptr + elen, ptr + len, rlen);\n\t/* Make sure we end the new string */\n\tptr[elen + rlen] = 0;\n\n\treturn ptr + elen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "ptr[len]"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "map->eval_string",
            "ptr",
            "len"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "*ptr"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "*ptr"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*ptr"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "map->eval_string"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void update_event_printk(struct trace_event_call *call,\n\t\t\t\tstruct trace_eval_map *map)\n{\n\tchar *ptr;\n\tint quote = 0;\n\tint len = strlen(map->eval_string);\n\n\tfor (ptr = call->print_fmt; *ptr; ptr++) {\n\t\tif (*ptr == '\\\\') {\n\t\t\tptr++;\n\t\t\t/* paranoid */\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*ptr == '\"') {\n\t\t\tquote ^= 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (quote)\n\t\t\tcontinue;\n\t\tif (isdigit(*ptr)) {\n\t\t\t/* skip numbers */\n\t\t\tdo {\n\t\t\t\tptr++;\n\t\t\t\t/* Check for alpha chars like ULL */\n\t\t\t} while (isalnum(*ptr));\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * A number must have some kind of delimiter after\n\t\t\t * it, and we can ignore that too.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (isalpha(*ptr) || *ptr == '_') {\n\t\t\tif (strncmp(map->eval_string, ptr, len) == 0 &&\n\t\t\t    !isalnum(ptr[len]) && ptr[len] != '_') {\n\t\t\t\tptr = eval_replace(ptr, map, len);\n\t\t\t\t/* enum/sizeof string smaller than value */\n\t\t\t\tif (WARN_ON_ONCE(!ptr))\n\t\t\t\t\treturn;\n\t\t\t\t/*\n\t\t\t\t * No need to decrement here, as eval_replace()\n\t\t\t\t * returns the pointer to the character passed\n\t\t\t\t * the eval, and two evals can not be placed\n\t\t\t\t * back to back without something in between.\n\t\t\t\t * We can skip that something in between.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\tskip_more:\n\t\t\tdo {\n\t\t\t\tptr++;\n\t\t\t} while (isalnum(*ptr) || *ptr == '_');\n\t\t\tif (!*ptr)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If what comes after this variable is a '.' or\n\t\t\t * '->' then we can continue to ignore that string.\n\t\t\t */\n\t\t\tif (*ptr == '.' || (ptr[0] == '-' && ptr[1] == '>')) {\n\t\t\t\tptr += *ptr == '.' ? 1 : 2;\n\t\t\t\tif (!*ptr)\n\t\t\t\t\tbreak;\n\t\t\t\tgoto skip_more;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Once again, we can skip the delimiter that came\n\t\t\t * after the string.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "eval_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2115-2135",
    "snippet": "static char *eval_replace(char *ptr, struct trace_eval_map *map, int len)\n{\n\tint rlen;\n\tint elen;\n\n\t/* Find the length of the eval value as a string */\n\telen = snprintf(ptr, 0, \"%ld\", map->eval_value);\n\t/* Make sure there's enough room to replace the string with the value */\n\tif (len < elen)\n\t\treturn NULL;\n\n\tsnprintf(ptr, elen + 1, \"%ld\", map->eval_value);\n\n\t/* Get the rest of the string of ptr */\n\trlen = strlen(ptr + len);\n\tmemmove(ptr + elen, ptr + len, rlen);\n\t/* Make sure we end the new string */\n\tptr[elen + rlen] = 0;\n\n\treturn ptr + elen;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "ptr + elen",
            "ptr + len",
            "rlen"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr + len"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ptr",
            "elen + 1",
            "\"%ld\"",
            "map->eval_value"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ptr",
            "0",
            "\"%ld\"",
            "map->eval_value"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic char *eval_replace(char *ptr, struct trace_eval_map *map, int len)\n{\n\tint rlen;\n\tint elen;\n\n\t/* Find the length of the eval value as a string */\n\telen = snprintf(ptr, 0, \"%ld\", map->eval_value);\n\t/* Make sure there's enough room to replace the string with the value */\n\tif (len < elen)\n\t\treturn NULL;\n\n\tsnprintf(ptr, elen + 1, \"%ld\", map->eval_value);\n\n\t/* Get the rest of the string of ptr */\n\trlen = strlen(ptr + len);\n\tmemmove(ptr + elen, ptr + len, rlen);\n\t/* Make sure we end the new string */\n\tptr[elen + rlen] = 0;\n\n\treturn ptr + elen;\n}"
  },
  {
    "function_name": "__register_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2100-2113",
    "snippet": "static int\n__register_event(struct trace_event_call *call, struct module *mod)\n{\n\tint ret;\n\n\tret = event_init(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlist_add(&call->list, &ftrace_events);\n\tcall->mod = mod;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&call->list",
            "&ftrace_events"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_init",
          "args": [
            "call"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "event_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2082-2098",
          "snippet": "static int event_init(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tconst char *name;\n\n\tname = trace_event_name(call);\n\tif (WARN_ON(!name))\n\t\treturn -EINVAL;\n\n\tif (call->class->raw_init) {\n\t\tret = call->class->raw_init(call);\n\t\tif (ret < 0 && ret != -ENOSYS)\n\t\t\tpr_warn(\"Could not initialize trace events/%s\\n\", name);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int event_init(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tconst char *name;\n\n\tname = trace_event_name(call);\n\tif (WARN_ON(!name))\n\t\treturn -EINVAL;\n\n\tif (call->class->raw_init) {\n\t\tret = call->class->raw_init(call);\n\t\tif (ret < 0 && ret != -ENOSYS)\n\t\t\tpr_warn(\"Could not initialize trace events/%s\\n\", name);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__register_event(struct trace_event_call *call, struct module *mod)\n{\n\tint ret;\n\n\tret = event_init(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlist_add(&call->list, &ftrace_events);\n\tcall->mod = mod;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2082-2098",
    "snippet": "static int event_init(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tconst char *name;\n\n\tname = trace_event_name(call);\n\tif (WARN_ON(!name))\n\t\treturn -EINVAL;\n\n\tif (call->class->raw_init) {\n\t\tret = call->class->raw_init(call);\n\t\tif (ret < 0 && ret != -ENOSYS)\n\t\t\tpr_warn(\"Could not initialize trace events/%s\\n\", name);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not initialize trace events/%s\\n\"",
            "name"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call->class->raw_init",
          "args": [
            "call"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!name"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int event_init(struct trace_event_call *call)\n{\n\tint ret = 0;\n\tconst char *name;\n\n\tname = trace_event_name(call);\n\tif (WARN_ON(!name))\n\t\treturn -EINVAL;\n\n\tif (call->class->raw_init) {\n\t\tret = call->class->raw_init(call);\n\t\tif (ret < 0 && ret != -ENOSYS)\n\t\t\tpr_warn(\"Could not initialize trace events/%s\\n\", name);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "event_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2054-2080",
    "snippet": "static void event_remove(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\tstruct trace_event_file *file;\n\n\tdo_for_each_event_file(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\n\t\tif (file->flags & EVENT_FILE_FL_WAS_ENABLED)\n\t\t\ttr->clear_trace = true;\n\n\t\tftrace_event_enable_disable(file, 0);\n\t\t/*\n\t\t * The do_for_each_event_file() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n\n\tif (call->event.funcs)\n\t\t__unregister_trace_event(&call->event);\n\tremove_event_from_tracers(call);\n\tlist_del(&call->list);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&call->list"
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_event_from_tracers",
          "args": [
            "call"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "remove_event_from_tracers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2034-2052",
          "snippet": "static void remove_event_from_tracers(struct trace_event_call *call)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr;\n\n\tdo_for_each_event_file_safe(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\n\t\tremove_event_file_dir(file);\n\t\t/*\n\t\t * The do_for_each_event_file_safe() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void remove_event_from_tracers(struct trace_event_call *call)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr;\n\n\tdo_for_each_event_file_safe(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\n\t\tremove_event_file_dir(file);\n\t\t/*\n\t\t * The do_for_each_event_file_safe() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__unregister_trace_event",
          "args": [
            "&call->event"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_trace_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_output.c",
          "lines": "807-812",
          "snippet": "int __unregister_trace_event(struct trace_event *event)\n{\n\thlist_del(&event->node);\n\tlist_del(&event->list);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint __unregister_trace_event(struct trace_event *event)\n{\n\thlist_del(&event->node);\n\tlist_del(&event->list);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_for_each_event_file",
          "args": [],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_event_enable_disable",
          "args": [
            "file",
            "0"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "493-497",
          "snippet": "static int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_event_file",
          "args": [
            "tr",
            "file"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void event_remove(struct trace_event_call *call)\n{\n\tstruct trace_array *tr;\n\tstruct trace_event_file *file;\n\n\tdo_for_each_event_file(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\n\t\tif (file->flags & EVENT_FILE_FL_WAS_ENABLED)\n\t\t\ttr->clear_trace = true;\n\n\t\tftrace_event_enable_disable(file, 0);\n\t\t/*\n\t\t * The do_for_each_event_file() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n\n\tif (call->event.funcs)\n\t\t__unregister_trace_event(&call->event);\n\tremove_event_from_tracers(call);\n\tlist_del(&call->list);\n}"
  },
  {
    "function_name": "remove_event_from_tracers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "2034-2052",
    "snippet": "static void remove_event_from_tracers(struct trace_event_call *call)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr;\n\n\tdo_for_each_event_file_safe(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\n\t\tremove_event_file_dir(file);\n\t\t/*\n\t\t * The do_for_each_event_file_safe() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_for_each_event_file",
          "args": [],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_event_file_dir",
          "args": [
            "file"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "remove_event_file_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "713-733",
          "snippet": "static void remove_event_file_dir(struct trace_event_file *file)\n{\n\tstruct dentry *dir = file->dir;\n\tstruct dentry *child;\n\n\tif (dir) {\n\t\tspin_lock(&dir->d_lock);\t/* probably unneeded */\n\t\tlist_for_each_entry(child, &dir->d_subdirs, d_child) {\n\t\t\tif (d_really_is_positive(child))\t/* probably unneeded */\n\t\t\t\td_inode(child)->i_private = NULL;\n\t\t}\n\t\tspin_unlock(&dir->d_lock);\n\n\t\ttracefs_remove_recursive(dir);\n\t}\n\n\tlist_del(&file->list);\n\tremove_subsystem(file->system);\n\tfree_event_filter(file->filter);\n\tkmem_cache_free(file_cachep, file);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *file_cachep;",
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic struct kmem_cache *file_cachep;\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void remove_event_file_dir(struct trace_event_file *file)\n{\n\tstruct dentry *dir = file->dir;\n\tstruct dentry *child;\n\n\tif (dir) {\n\t\tspin_lock(&dir->d_lock);\t/* probably unneeded */\n\t\tlist_for_each_entry(child, &dir->d_subdirs, d_child) {\n\t\t\tif (d_really_is_positive(child))\t/* probably unneeded */\n\t\t\t\td_inode(child)->i_private = NULL;\n\t\t}\n\t\tspin_unlock(&dir->d_lock);\n\n\t\ttracefs_remove_recursive(dir);\n\t}\n\n\tlist_del(&file->list);\n\tremove_subsystem(file->system);\n\tfree_event_filter(file->filter);\n\tkmem_cache_free(file_cachep, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_event_file_safe",
          "args": [
            "tr",
            "file"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void remove_event_from_tracers(struct trace_event_call *call)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr;\n\n\tdo_for_each_event_file_safe(tr, file) {\n\t\tif (file->event_call != call)\n\t\t\tcontinue;\n\n\t\tremove_event_file_dir(file);\n\t\t/*\n\t\t * The do_for_each_event_file_safe() is\n\t\t * a double loop. After finding the call for this\n\t\t * trace_array, we use break to jump to the next\n\t\t * trace_array.\n\t\t */\n\t\tbreak;\n\t} while_for_each_event_file();\n}"
  },
  {
    "function_name": "event_create_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1959-2032",
    "snippet": "static int\nevent_create_dir(struct dentry *parent, struct trace_event_file *file)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tstruct list_head *head;\n\tstruct dentry *d_events;\n\tconst char *name;\n\tint ret;\n\n\t/*\n\t * If the trace point header did not define TRACE_SYSTEM\n\t * then the system would be called \"TRACE_SYSTEM\".\n\t */\n\tif (strcmp(call->class->system, TRACE_SYSTEM) != 0) {\n\t\td_events = event_subsystem_dir(tr, call->class->system, file, parent);\n\t\tif (!d_events)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\td_events = parent;\n\n\tname = trace_event_name(call);\n\tfile->dir = tracefs_create_dir(name, d_events);\n\tif (!file->dir) {\n\t\tpr_warn(\"Could not create tracefs '%s' directory\\n\", name);\n\t\treturn -1;\n\t}\n\n\tif (call->class->reg && !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\ttrace_create_file(\"enable\", 0644, file->dir, file,\n\t\t\t\t  &ftrace_enable_fops);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->event.type && call->class->reg)\n\t\ttrace_create_file(\"id\", 0444, file->dir,\n\t\t\t\t  (void *)(long)call->event.type,\n\t\t\t\t  &ftrace_event_id_fops);\n#endif\n\n\t/*\n\t * Other events may have the same class. Only update\n\t * the fields if they are not already defined.\n\t */\n\thead = trace_get_fields(call);\n\tif (list_empty(head)) {\n\t\tret = call->class->define_fields(call);\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"Could not initialize trace point events/%s\\n\",\n\t\t\t\tname);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/*\n\t * Only event directories that can be enabled should have\n\t * triggers or filters.\n\t */\n\tif (!(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)) {\n\t\ttrace_create_file(\"filter\", 0644, file->dir, file,\n\t\t\t\t  &ftrace_event_filter_fops);\n\n\t\ttrace_create_file(\"trigger\", 0644, file->dir, file,\n\t\t\t\t  &event_trigger_fops);\n\t}\n\n#ifdef CONFIG_HIST_TRIGGERS\n\ttrace_create_file(\"hist\", 0444, file->dir, file,\n\t\t\t  &event_hist_fops);\n#endif\n\ttrace_create_file(\"format\", 0444, file->dir, call,\n\t\t\t  &ftrace_event_format_fops);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [
      "#define TRACE_SYSTEM \"TRACE_SYSTEM\""
    ],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static const struct file_operations ftrace_enable_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_enable_read,\n\t.write = event_enable_write,\n\t.llseek = default_llseek,\n};",
      "static const struct file_operations ftrace_event_format_fops = {\n\t.open = trace_format_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};",
      "static const struct file_operations ftrace_event_id_fops = {\n\t.read = event_id_read,\n\t.llseek = default_llseek,\n};",
      "static const struct file_operations ftrace_event_filter_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_filter_read,\n\t.write = event_filter_write,\n\t.llseek = default_llseek,\n};",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"format\"",
            "0444",
            "file->dir",
            "call",
            "&ftrace_event_format_fops"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "7459-7472",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not initialize trace point events/%s\\n\"",
            "name"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call->class->define_fields",
          "args": [
            "call"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_get_fields",
          "args": [
            "call"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "73-79",
          "snippet": "static struct list_head *\ntrace_get_fields(struct trace_event_call *event_call)\n{\n\tif (!event_call->class->get_fields)\n\t\treturn &event_call->class->fields;\n\treturn event_call->class->get_fields(event_call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic struct list_head *\ntrace_get_fields(struct trace_event_call *event_call)\n{\n\tif (!event_call->class->get_fields)\n\t\treturn &event_call->class->fields;\n\treturn event_call->class->get_fields(event_call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs '%s' directory\\n\"",
            "name"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_dir",
          "args": [
            "name",
            "d_events"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_subsystem_dir",
          "args": [
            "tr",
            "call->class->system",
            "file",
            "parent"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "event_subsystem_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "1884-1957",
          "snippet": "static struct dentry *\nevent_subsystem_dir(struct trace_array *tr, const char *name,\n\t\t    struct trace_event_file *file, struct dentry *parent)\n{\n\tstruct trace_subsystem_dir *dir;\n\tstruct event_subsystem *system;\n\tstruct dentry *entry;\n\n\t/* First see if we did not already create this dir */\n\tlist_for_each_entry(dir, &tr->systems, list) {\n\t\tsystem = dir->subsystem;\n\t\tif (strcmp(system->name, name) == 0) {\n\t\t\tdir->nr_events++;\n\t\t\tfile->system = dir;\n\t\t\treturn dir->entry;\n\t\t}\n\t}\n\n\t/* Now see if the system itself exists. */\n\tlist_for_each_entry(system, &event_subsystems, list) {\n\t\tif (strcmp(system->name, name) == 0)\n\t\t\tbreak;\n\t}\n\t/* Reset system variable when not found */\n\tif (&system->list == &event_subsystems)\n\t\tsystem = NULL;\n\n\tdir = kmalloc(sizeof(*dir), GFP_KERNEL);\n\tif (!dir)\n\t\tgoto out_fail;\n\n\tif (!system) {\n\t\tsystem = create_new_subsystem(name);\n\t\tif (!system)\n\t\t\tgoto out_free;\n\t} else\n\t\t__get_system(system);\n\n\tdir->entry = tracefs_create_dir(name, parent);\n\tif (!dir->entry) {\n\t\tpr_warn(\"Failed to create system directory %s\\n\", name);\n\t\t__put_system(system);\n\t\tgoto out_free;\n\t}\n\n\tdir->tr = tr;\n\tdir->ref_count = 1;\n\tdir->nr_events = 1;\n\tdir->subsystem = system;\n\tfile->system = dir;\n\n\tentry = tracefs_create_file(\"filter\", 0644, dir->entry, dir,\n\t\t\t\t    &ftrace_subsystem_filter_fops);\n\tif (!entry) {\n\t\tkfree(system->filter);\n\t\tsystem->filter = NULL;\n\t\tpr_warn(\"Could not create tracefs '%s/filter' entry\\n\", name);\n\t}\n\n\ttrace_create_file(\"enable\", 0644, dir->entry, dir,\n\t\t\t  &ftrace_system_enable_fops);\n\n\tlist_add(&dir->list, &tr->systems);\n\n\treturn dir->entry;\n\n out_free:\n\tkfree(dir);\n out_fail:\n\t/* Only print this message if failed on memory allocation */\n\tif (!dir || !system)\n\t\tpr_warn(\"No memory to create event subsystem %s\\n\", name);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(event_subsystems);",
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static const struct file_operations ftrace_subsystem_filter_fops = {\n\t.open = subsystem_open,\n\t.read = subsystem_filter_read,\n\t.write = subsystem_filter_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};",
            "static const struct file_operations ftrace_system_enable_fops = {\n\t.open = subsystem_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic LIST_HEAD(event_subsystems);\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic const struct file_operations ftrace_subsystem_filter_fops = {\n\t.open = subsystem_open,\n\t.read = subsystem_filter_read,\n\t.write = subsystem_filter_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};\nstatic const struct file_operations ftrace_system_enable_fops = {\n\t.open = subsystem_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};\n\nstatic struct dentry *\nevent_subsystem_dir(struct trace_array *tr, const char *name,\n\t\t    struct trace_event_file *file, struct dentry *parent)\n{\n\tstruct trace_subsystem_dir *dir;\n\tstruct event_subsystem *system;\n\tstruct dentry *entry;\n\n\t/* First see if we did not already create this dir */\n\tlist_for_each_entry(dir, &tr->systems, list) {\n\t\tsystem = dir->subsystem;\n\t\tif (strcmp(system->name, name) == 0) {\n\t\t\tdir->nr_events++;\n\t\t\tfile->system = dir;\n\t\t\treturn dir->entry;\n\t\t}\n\t}\n\n\t/* Now see if the system itself exists. */\n\tlist_for_each_entry(system, &event_subsystems, list) {\n\t\tif (strcmp(system->name, name) == 0)\n\t\t\tbreak;\n\t}\n\t/* Reset system variable when not found */\n\tif (&system->list == &event_subsystems)\n\t\tsystem = NULL;\n\n\tdir = kmalloc(sizeof(*dir), GFP_KERNEL);\n\tif (!dir)\n\t\tgoto out_fail;\n\n\tif (!system) {\n\t\tsystem = create_new_subsystem(name);\n\t\tif (!system)\n\t\t\tgoto out_free;\n\t} else\n\t\t__get_system(system);\n\n\tdir->entry = tracefs_create_dir(name, parent);\n\tif (!dir->entry) {\n\t\tpr_warn(\"Failed to create system directory %s\\n\", name);\n\t\t__put_system(system);\n\t\tgoto out_free;\n\t}\n\n\tdir->tr = tr;\n\tdir->ref_count = 1;\n\tdir->nr_events = 1;\n\tdir->subsystem = system;\n\tfile->system = dir;\n\n\tentry = tracefs_create_file(\"filter\", 0644, dir->entry, dir,\n\t\t\t\t    &ftrace_subsystem_filter_fops);\n\tif (!entry) {\n\t\tkfree(system->filter);\n\t\tsystem->filter = NULL;\n\t\tpr_warn(\"Could not create tracefs '%s/filter' entry\\n\", name);\n\t}\n\n\ttrace_create_file(\"enable\", 0644, dir->entry, dir,\n\t\t\t  &ftrace_system_enable_fops);\n\n\tlist_add(&dir->list, &tr->systems);\n\n\treturn dir->entry;\n\n out_free:\n\tkfree(dir);\n out_fail:\n\t/* Only print this message if failed on memory allocation */\n\tif (!dir || !system)\n\t\tpr_warn(\"No memory to create event subsystem %s\\n\", name);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "call->class->system",
            "TRACE_SYSTEM"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#define TRACE_SYSTEM \"TRACE_SYSTEM\"\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic const struct file_operations ftrace_enable_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_enable_read,\n\t.write = event_enable_write,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations ftrace_event_format_fops = {\n\t.open = trace_format_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\nstatic const struct file_operations ftrace_event_id_fops = {\n\t.read = event_id_read,\n\t.llseek = default_llseek,\n};\nstatic const struct file_operations ftrace_event_filter_fops = {\n\t.open = tracing_open_generic,\n\t.read = event_filter_read,\n\t.write = event_filter_write,\n\t.llseek = default_llseek,\n};\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\nevent_create_dir(struct dentry *parent, struct trace_event_file *file)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tstruct list_head *head;\n\tstruct dentry *d_events;\n\tconst char *name;\n\tint ret;\n\n\t/*\n\t * If the trace point header did not define TRACE_SYSTEM\n\t * then the system would be called \"TRACE_SYSTEM\".\n\t */\n\tif (strcmp(call->class->system, TRACE_SYSTEM) != 0) {\n\t\td_events = event_subsystem_dir(tr, call->class->system, file, parent);\n\t\tif (!d_events)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\td_events = parent;\n\n\tname = trace_event_name(call);\n\tfile->dir = tracefs_create_dir(name, d_events);\n\tif (!file->dir) {\n\t\tpr_warn(\"Could not create tracefs '%s' directory\\n\", name);\n\t\treturn -1;\n\t}\n\n\tif (call->class->reg && !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\ttrace_create_file(\"enable\", 0644, file->dir, file,\n\t\t\t\t  &ftrace_enable_fops);\n\n#ifdef CONFIG_PERF_EVENTS\n\tif (call->event.type && call->class->reg)\n\t\ttrace_create_file(\"id\", 0444, file->dir,\n\t\t\t\t  (void *)(long)call->event.type,\n\t\t\t\t  &ftrace_event_id_fops);\n#endif\n\n\t/*\n\t * Other events may have the same class. Only update\n\t * the fields if they are not already defined.\n\t */\n\thead = trace_get_fields(call);\n\tif (list_empty(head)) {\n\t\tret = call->class->define_fields(call);\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"Could not initialize trace point events/%s\\n\",\n\t\t\t\tname);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/*\n\t * Only event directories that can be enabled should have\n\t * triggers or filters.\n\t */\n\tif (!(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)) {\n\t\ttrace_create_file(\"filter\", 0644, file->dir, file,\n\t\t\t\t  &ftrace_event_filter_fops);\n\n\t\ttrace_create_file(\"trigger\", 0644, file->dir, file,\n\t\t\t\t  &event_trigger_fops);\n\t}\n\n#ifdef CONFIG_HIST_TRIGGERS\n\ttrace_create_file(\"hist\", 0444, file->dir, file,\n\t\t\t  &event_hist_fops);\n#endif\n\ttrace_create_file(\"format\", 0444, file->dir, call,\n\t\t\t  &ftrace_event_format_fops);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_subsystem_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1884-1957",
    "snippet": "static struct dentry *\nevent_subsystem_dir(struct trace_array *tr, const char *name,\n\t\t    struct trace_event_file *file, struct dentry *parent)\n{\n\tstruct trace_subsystem_dir *dir;\n\tstruct event_subsystem *system;\n\tstruct dentry *entry;\n\n\t/* First see if we did not already create this dir */\n\tlist_for_each_entry(dir, &tr->systems, list) {\n\t\tsystem = dir->subsystem;\n\t\tif (strcmp(system->name, name) == 0) {\n\t\t\tdir->nr_events++;\n\t\t\tfile->system = dir;\n\t\t\treturn dir->entry;\n\t\t}\n\t}\n\n\t/* Now see if the system itself exists. */\n\tlist_for_each_entry(system, &event_subsystems, list) {\n\t\tif (strcmp(system->name, name) == 0)\n\t\t\tbreak;\n\t}\n\t/* Reset system variable when not found */\n\tif (&system->list == &event_subsystems)\n\t\tsystem = NULL;\n\n\tdir = kmalloc(sizeof(*dir), GFP_KERNEL);\n\tif (!dir)\n\t\tgoto out_fail;\n\n\tif (!system) {\n\t\tsystem = create_new_subsystem(name);\n\t\tif (!system)\n\t\t\tgoto out_free;\n\t} else\n\t\t__get_system(system);\n\n\tdir->entry = tracefs_create_dir(name, parent);\n\tif (!dir->entry) {\n\t\tpr_warn(\"Failed to create system directory %s\\n\", name);\n\t\t__put_system(system);\n\t\tgoto out_free;\n\t}\n\n\tdir->tr = tr;\n\tdir->ref_count = 1;\n\tdir->nr_events = 1;\n\tdir->subsystem = system;\n\tfile->system = dir;\n\n\tentry = tracefs_create_file(\"filter\", 0644, dir->entry, dir,\n\t\t\t\t    &ftrace_subsystem_filter_fops);\n\tif (!entry) {\n\t\tkfree(system->filter);\n\t\tsystem->filter = NULL;\n\t\tpr_warn(\"Could not create tracefs '%s/filter' entry\\n\", name);\n\t}\n\n\ttrace_create_file(\"enable\", 0644, dir->entry, dir,\n\t\t\t  &ftrace_system_enable_fops);\n\n\tlist_add(&dir->list, &tr->systems);\n\n\treturn dir->entry;\n\n out_free:\n\tkfree(dir);\n out_fail:\n\t/* Only print this message if failed on memory allocation */\n\tif (!dir || !system)\n\t\tpr_warn(\"No memory to create event subsystem %s\\n\", name);\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(event_subsystems);",
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static const struct file_operations ftrace_subsystem_filter_fops = {\n\t.open = subsystem_open,\n\t.read = subsystem_filter_read,\n\t.write = subsystem_filter_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};",
      "static const struct file_operations ftrace_system_enable_fops = {\n\t.open = subsystem_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"No memory to create event subsystem %s\\n\"",
            "name"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dir"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dir->list",
            "&tr->systems"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"enable\"",
            "0644",
            "dir->entry",
            "dir",
            "&ftrace_system_enable_fops"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "7459-7472",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs '%s/filter' entry\\n\"",
            "name"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"filter\"",
            "0644",
            "dir->entry",
            "dir",
            "&ftrace_subsystem_filter_fops"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_system",
          "args": [
            "system"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "__put_system_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "683-692",
          "snippet": "static void __put_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\t/* If the subsystem is about to be freed, the dir must be too */\n\tWARN_ON_ONCE(system_refcount(dir->subsystem) == 1 && dir->ref_count != 1);\n\n\t__put_system(dir->subsystem);\n\tif (!--dir->ref_count)\n\t\tkfree(dir);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __put_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\t/* If the subsystem is about to be freed, the dir must be too */\n\tWARN_ON_ONCE(system_refcount(dir->subsystem) == 1 && dir->ref_count != 1);\n\n\t__put_system(dir->subsystem);\n\tif (!--dir->ref_count)\n\t\tkfree(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to create system directory %s\\n\"",
            "name"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_dir",
          "args": [
            "name",
            "parent"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_system",
          "args": [
            "system"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "__get_system_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "676-681",
          "snippet": "static void __get_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\tdir->ref_count++;\n\t__get_system(dir->subsystem);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __get_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\tdir->ref_count++;\n\t__get_system(dir->subsystem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_new_subsystem",
          "args": [
            "name"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "create_new_subsystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "1851-1882",
          "snippet": "static struct event_subsystem *\ncreate_new_subsystem(const char *name)\n{\n\tstruct event_subsystem *system;\n\n\t/* need to create new entry */\n\tsystem = kmalloc(sizeof(*system), GFP_KERNEL);\n\tif (!system)\n\t\treturn NULL;\n\n\tsystem->ref_count = 1;\n\n\t/* Only allocate if dynamic (kprobes and modules) */\n\tsystem->name = kstrdup_const(name, GFP_KERNEL);\n\tif (!system->name)\n\t\tgoto out_free;\n\n\tsystem->filter = NULL;\n\n\tsystem->filter = kzalloc(sizeof(struct event_filter), GFP_KERNEL);\n\tif (!system->filter)\n\t\tgoto out_free;\n\n\tlist_add(&system->list, &event_subsystems);\n\n\treturn system;\n\n out_free:\n\tkfree_const(system->name);\n\tkfree(system);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(event_subsystems);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic LIST_HEAD(event_subsystems);\n\nstatic struct event_subsystem *\ncreate_new_subsystem(const char *name)\n{\n\tstruct event_subsystem *system;\n\n\t/* need to create new entry */\n\tsystem = kmalloc(sizeof(*system), GFP_KERNEL);\n\tif (!system)\n\t\treturn NULL;\n\n\tsystem->ref_count = 1;\n\n\t/* Only allocate if dynamic (kprobes and modules) */\n\tsystem->name = kstrdup_const(name, GFP_KERNEL);\n\tif (!system->name)\n\t\tgoto out_free;\n\n\tsystem->filter = NULL;\n\n\tsystem->filter = kzalloc(sizeof(struct event_filter), GFP_KERNEL);\n\tif (!system->filter)\n\t\tgoto out_free;\n\n\tlist_add(&system->list, &event_subsystems);\n\n\treturn system;\n\n out_free:\n\tkfree_const(system->name);\n\tkfree(system);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*dir)",
            "GFP_KERNEL"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "system->name",
            "name"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "system",
            "&event_subsystems",
            "list"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "system->name",
            "name"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dir",
            "&tr->systems",
            "list"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic LIST_HEAD(event_subsystems);\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic const struct file_operations ftrace_subsystem_filter_fops = {\n\t.open = subsystem_open,\n\t.read = subsystem_filter_read,\n\t.write = subsystem_filter_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};\nstatic const struct file_operations ftrace_system_enable_fops = {\n\t.open = subsystem_open,\n\t.read = system_enable_read,\n\t.write = system_enable_write,\n\t.llseek = default_llseek,\n\t.release = subsystem_release,\n};\n\nstatic struct dentry *\nevent_subsystem_dir(struct trace_array *tr, const char *name,\n\t\t    struct trace_event_file *file, struct dentry *parent)\n{\n\tstruct trace_subsystem_dir *dir;\n\tstruct event_subsystem *system;\n\tstruct dentry *entry;\n\n\t/* First see if we did not already create this dir */\n\tlist_for_each_entry(dir, &tr->systems, list) {\n\t\tsystem = dir->subsystem;\n\t\tif (strcmp(system->name, name) == 0) {\n\t\t\tdir->nr_events++;\n\t\t\tfile->system = dir;\n\t\t\treturn dir->entry;\n\t\t}\n\t}\n\n\t/* Now see if the system itself exists. */\n\tlist_for_each_entry(system, &event_subsystems, list) {\n\t\tif (strcmp(system->name, name) == 0)\n\t\t\tbreak;\n\t}\n\t/* Reset system variable when not found */\n\tif (&system->list == &event_subsystems)\n\t\tsystem = NULL;\n\n\tdir = kmalloc(sizeof(*dir), GFP_KERNEL);\n\tif (!dir)\n\t\tgoto out_fail;\n\n\tif (!system) {\n\t\tsystem = create_new_subsystem(name);\n\t\tif (!system)\n\t\t\tgoto out_free;\n\t} else\n\t\t__get_system(system);\n\n\tdir->entry = tracefs_create_dir(name, parent);\n\tif (!dir->entry) {\n\t\tpr_warn(\"Failed to create system directory %s\\n\", name);\n\t\t__put_system(system);\n\t\tgoto out_free;\n\t}\n\n\tdir->tr = tr;\n\tdir->ref_count = 1;\n\tdir->nr_events = 1;\n\tdir->subsystem = system;\n\tfile->system = dir;\n\n\tentry = tracefs_create_file(\"filter\", 0644, dir->entry, dir,\n\t\t\t\t    &ftrace_subsystem_filter_fops);\n\tif (!entry) {\n\t\tkfree(system->filter);\n\t\tsystem->filter = NULL;\n\t\tpr_warn(\"Could not create tracefs '%s/filter' entry\\n\", name);\n\t}\n\n\ttrace_create_file(\"enable\", 0644, dir->entry, dir,\n\t\t\t  &ftrace_system_enable_fops);\n\n\tlist_add(&dir->list, &tr->systems);\n\n\treturn dir->entry;\n\n out_free:\n\tkfree(dir);\n out_fail:\n\t/* Only print this message if failed on memory allocation */\n\tif (!dir || !system)\n\t\tpr_warn(\"No memory to create event subsystem %s\\n\", name);\n\treturn NULL;\n}"
  },
  {
    "function_name": "create_new_subsystem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1851-1882",
    "snippet": "static struct event_subsystem *\ncreate_new_subsystem(const char *name)\n{\n\tstruct event_subsystem *system;\n\n\t/* need to create new entry */\n\tsystem = kmalloc(sizeof(*system), GFP_KERNEL);\n\tif (!system)\n\t\treturn NULL;\n\n\tsystem->ref_count = 1;\n\n\t/* Only allocate if dynamic (kprobes and modules) */\n\tsystem->name = kstrdup_const(name, GFP_KERNEL);\n\tif (!system->name)\n\t\tgoto out_free;\n\n\tsystem->filter = NULL;\n\n\tsystem->filter = kzalloc(sizeof(struct event_filter), GFP_KERNEL);\n\tif (!system->filter)\n\t\tgoto out_free;\n\n\tlist_add(&system->list, &event_subsystems);\n\n\treturn system;\n\n out_free:\n\tkfree_const(system->name);\n\tkfree(system);\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(event_subsystems);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "system"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_const",
          "args": [
            "system->name"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&system->list",
            "&event_subsystems"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct event_filter)",
            "GFP_KERNEL"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup_const",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*system)",
            "GFP_KERNEL"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic LIST_HEAD(event_subsystems);\n\nstatic struct event_subsystem *\ncreate_new_subsystem(const char *name)\n{\n\tstruct event_subsystem *system;\n\n\t/* need to create new entry */\n\tsystem = kmalloc(sizeof(*system), GFP_KERNEL);\n\tif (!system)\n\t\treturn NULL;\n\n\tsystem->ref_count = 1;\n\n\t/* Only allocate if dynamic (kprobes and modules) */\n\tsystem->name = kstrdup_const(name, GFP_KERNEL);\n\tif (!system->name)\n\t\tgoto out_free;\n\n\tsystem->filter = NULL;\n\n\tsystem->filter = kzalloc(sizeof(struct event_filter), GFP_KERNEL);\n\tif (!system->filter)\n\t\tgoto out_free;\n\n\tlist_add(&system->list, &event_subsystems);\n\n\treturn system;\n\n out_free:\n\tkfree_const(system->name);\n\tkfree(system);\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_event_set_pid_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1831-1849",
    "snippet": "static int\nftrace_event_set_pid_open(struct inode *inode, struct file *file)\n{\n\tconst struct seq_operations *seq_ops = &show_set_pid_seq_ops;\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC))\n\t\tftrace_clear_event_pids(tr);\n\n\tret = ftrace_event_open(inode, file, seq_ops);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static const struct seq_operations show_set_pid_seq_ops = {\n\t.start = p_start,\n\t.next = p_next,\n\t.show = trace_pid_show,\n\t.stop = p_stop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "298-303",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_event_open",
          "args": [
            "inode",
            "file",
            "seq_ops"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "1777-1792",
          "snippet": "static int\nftrace_event_open(struct inode *inode, struct file *file,\n\t\t  const struct seq_operations *seq_ops)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\tm = file->private_data;\n\t/* copy tr over to seq ops */\n\tm->private = inode->i_private;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int\nftrace_event_open(struct inode *inode, struct file *file,\n\t\t  const struct seq_operations *seq_ops)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\tm = file->private_data;\n\t/* copy tr over to seq ops */\n\tm->private = inode->i_private;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_clear_event_pids",
          "args": [
            "tr"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_clear_event_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "645-650",
          "snippet": "static void ftrace_clear_event_pids(struct trace_array *tr)\n{\n\tmutex_lock(&event_mutex);\n\t__ftrace_clear_event_pids(tr);\n\tmutex_unlock(&event_mutex);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void ftrace_clear_event_pids(struct trace_array *tr)\n{\n\tmutex_lock(&event_mutex);\n\t__ftrace_clear_event_pids(tr);\n\tmutex_unlock(&event_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_get",
          "args": [
            "tr"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "274-290",
          "snippet": "int trace_array_get(struct trace_array *this_tr)\n{\n\tstruct trace_array *tr;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr == this_tr) {\n\t\t\ttr->ref++;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_array_get(struct trace_array *this_tr)\n{\n\tstruct trace_array *tr;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr == this_tr) {\n\t\t\ttr->ref++;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic const struct seq_operations show_set_pid_seq_ops = {\n\t.start = p_start,\n\t.next = p_next,\n\t.show = trace_pid_show,\n\t.stop = p_stop,\n};\n\nstatic int\nftrace_event_set_pid_open(struct inode *inode, struct file *file)\n{\n\tconst struct seq_operations *seq_ops = &show_set_pid_seq_ops;\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC))\n\t\tftrace_clear_event_pids(tr);\n\n\tret = ftrace_event_open(inode, file, seq_ops);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_event_set_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1811-1829",
    "snippet": "static int\nftrace_event_set_open(struct inode *inode, struct file *file)\n{\n\tconst struct seq_operations *seq_ops = &show_set_event_seq_ops;\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC))\n\t\tftrace_clear_events(tr);\n\n\tret = ftrace_event_open(inode, file, seq_ops);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static const struct seq_operations show_set_event_seq_ops = {\n\t.start = s_start,\n\t.next = s_next,\n\t.show = t_show,\n\t.stop = t_stop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "298-303",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_event_open",
          "args": [
            "inode",
            "file",
            "seq_ops"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "1777-1792",
          "snippet": "static int\nftrace_event_open(struct inode *inode, struct file *file,\n\t\t  const struct seq_operations *seq_ops)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\tm = file->private_data;\n\t/* copy tr over to seq ops */\n\tm->private = inode->i_private;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int\nftrace_event_open(struct inode *inode, struct file *file,\n\t\t  const struct seq_operations *seq_ops)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\tm = file->private_data;\n\t/* copy tr over to seq ops */\n\tm->private = inode->i_private;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_clear_events",
          "args": [
            "tr"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_clear_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "499-508",
          "snippet": "static void ftrace_clear_events(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tmutex_lock(&event_mutex);\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tftrace_event_enable_disable(file, 0);\n\t}\n\tmutex_unlock(&event_mutex);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void ftrace_clear_events(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tmutex_lock(&event_mutex);\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tftrace_event_enable_disable(file, 0);\n\t}\n\tmutex_unlock(&event_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_get",
          "args": [
            "tr"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "274-290",
          "snippet": "int trace_array_get(struct trace_array *this_tr)\n{\n\tstruct trace_array *tr;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr == this_tr) {\n\t\t\ttr->ref++;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_array_get(struct trace_array *this_tr)\n{\n\tstruct trace_array *tr;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr == this_tr) {\n\t\t\ttr->ref++;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic const struct seq_operations show_set_event_seq_ops = {\n\t.start = s_start,\n\t.next = s_next,\n\t.show = t_show,\n\t.stop = t_stop,\n};\n\nstatic int\nftrace_event_set_open(struct inode *inode, struct file *file)\n{\n\tconst struct seq_operations *seq_ops = &show_set_event_seq_ops;\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\tif ((file->f_mode & FMODE_WRITE) &&\n\t    (file->f_flags & O_TRUNC))\n\t\tftrace_clear_events(tr);\n\n\tret = ftrace_event_open(inode, file, seq_ops);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_event_avail_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1803-1809",
    "snippet": "static int\nftrace_event_avail_open(struct inode *inode, struct file *file)\n{\n\tconst struct seq_operations *seq_ops = &show_event_seq_ops;\n\n\treturn ftrace_event_open(inode, file, seq_ops);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static const struct seq_operations show_event_seq_ops = {\n\t.start = t_start,\n\t.next = t_next,\n\t.show = t_show,\n\t.stop = t_stop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_event_open",
          "args": [
            "inode",
            "file",
            "seq_ops"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "1777-1792",
          "snippet": "static int\nftrace_event_open(struct inode *inode, struct file *file,\n\t\t  const struct seq_operations *seq_ops)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\tm = file->private_data;\n\t/* copy tr over to seq ops */\n\tm->private = inode->i_private;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int\nftrace_event_open(struct inode *inode, struct file *file,\n\t\t  const struct seq_operations *seq_ops)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\tm = file->private_data;\n\t/* copy tr over to seq ops */\n\tm->private = inode->i_private;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic const struct seq_operations show_event_seq_ops = {\n\t.start = t_start,\n\t.next = t_next,\n\t.show = t_show,\n\t.stop = t_stop,\n};\n\nstatic int\nftrace_event_avail_open(struct inode *inode, struct file *file)\n{\n\tconst struct seq_operations *seq_ops = &show_event_seq_ops;\n\n\treturn ftrace_event_open(inode, file, seq_ops);\n}"
  },
  {
    "function_name": "ftrace_event_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1794-1801",
    "snippet": "static int ftrace_event_release(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\ttrace_array_put(tr);\n\n\treturn seq_release(inode, file);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "219-233",
          "snippet": "static int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "298-303",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int ftrace_event_release(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\ttrace_array_put(tr);\n\n\treturn seq_release(inode, file);\n}"
  },
  {
    "function_name": "ftrace_event_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1777-1792",
    "snippet": "static int\nftrace_event_open(struct inode *inode, struct file *file,\n\t\t  const struct seq_operations *seq_ops)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\tm = file->private_data;\n\t/* copy tr over to seq ops */\n\tm->private = inode->i_private;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "seq_ops"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "179-213",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int\nftrace_event_open(struct inode *inode, struct file *file,\n\t\t  const struct seq_operations *seq_ops)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\tm = file->private_data;\n\t/* copy tr over to seq ops */\n\tm->private = inode->i_private;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_event_pid_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1592-1670",
    "snippet": "static ssize_t\nftrace_event_pid_write(struct file *filp, const char __user *ubuf,\n\t\t       size_t cnt, loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids = NULL;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&event_mutex);\n\n\tfiltered_pids = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trcu_assign_pointer(tr->filtered_pids, pid_list);\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tset_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t}\n\n\tif (filtered_pids) {\n\t\ttracepoint_synchronize_unregister();\n\t\ttrace_free_pid_list(filtered_pids);\n\t} else if (pid_list) {\n\t\t/*\n\t\t * Register a probe that is called before all other probes\n\t\t * to set ignore_pid if next or prev do not match.\n\t\t * Register a probe this is called after all other probes\n\t\t * to only keep ignore_pid set if next pid matches.\n\t\t */\n\t\tregister_trace_prio_sched_switch(event_filter_pid_sched_switch_probe_pre,\n\t\t\t\t\t\t tr, INT_MAX);\n\t\tregister_trace_prio_sched_switch(event_filter_pid_sched_switch_probe_post,\n\t\t\t\t\t\t tr, 0);\n\n\t\tregister_trace_prio_sched_wakeup(event_filter_pid_sched_wakeup_probe_pre,\n\t\t\t\t\t\t tr, INT_MAX);\n\t\tregister_trace_prio_sched_wakeup(event_filter_pid_sched_wakeup_probe_post,\n\t\t\t\t\t\t tr, 0);\n\n\t\tregister_trace_prio_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_pre,\n\t\t\t\t\t\t     tr, INT_MAX);\n\t\tregister_trace_prio_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_post,\n\t\t\t\t\t\t     tr, 0);\n\n\t\tregister_trace_prio_sched_waking(event_filter_pid_sched_wakeup_probe_pre,\n\t\t\t\t\t\t tr, INT_MAX);\n\t\tregister_trace_prio_sched_waking(event_filter_pid_sched_wakeup_probe_post,\n\t\t\t\t\t\t tr, 0);\n\t}\n\n\t/*\n\t * Ignoring of pids is done at task switch. But we have to\n\t * check for those tasks that are currently running.\n\t * Always do this in case a pid was appended or removed.\n\t */\n\ton_each_cpu(ignore_task_cpu, tr, 1);\n\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "ignore_task_cpu",
            "tr",
            "1"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "on_each_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/up.c",
          "lines": "37-45",
          "snippet": "int on_each_cpu(smp_call_func_t func, void *info, int wait)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint on_each_cpu(smp_call_func_t func, void *info, int wait)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_trace_prio_sched_waking",
          "args": [
            "event_filter_pid_sched_wakeup_probe_post",
            "tr",
            "0"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_prio_sched_waking",
          "args": [
            "event_filter_pid_sched_wakeup_probe_pre",
            "tr",
            "INT_MAX"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_prio_sched_wakeup_new",
          "args": [
            "event_filter_pid_sched_wakeup_probe_post",
            "tr",
            "0"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_prio_sched_wakeup_new",
          "args": [
            "event_filter_pid_sched_wakeup_probe_pre",
            "tr",
            "INT_MAX"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_prio_sched_wakeup",
          "args": [
            "event_filter_pid_sched_wakeup_probe_post",
            "tr",
            "0"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_prio_sched_wakeup",
          "args": [
            "event_filter_pid_sched_wakeup_probe_pre",
            "tr",
            "INT_MAX"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_prio_sched_switch",
          "args": [
            "event_filter_pid_sched_switch_probe_post",
            "tr",
            "0"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_prio_sched_switch",
          "args": [
            "event_filter_pid_sched_switch_probe_pre",
            "tr",
            "INT_MAX"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_free_pid_list",
          "args": [
            "filtered_pids"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "trace_free_pid_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "318-322",
          "snippet": "void trace_free_pid_list(struct trace_pid_list *pid_list)\n{\n\tvfree(pid_list->pids);\n\tkfree(pid_list);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_free_pid_list(struct trace_pid_list *pid_list)\n{\n\tvfree(pid_list->pids);\n\tkfree(pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EVENT_FILE_FL_PID_FILTER_BIT",
            "&file->flags"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tr->filtered_pids",
            "pid_list"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_pid_write",
          "args": [
            "filtered_pids",
            "&pid_list",
            "ubuf",
            "cnt"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_pid_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6558-6606",
          "snippet": "static ssize_t\nftrace_pid_write(struct file *filp, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids = NULL;\n\tstruct trace_pid_list *pid_list;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\tfiltered_pids = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trcu_assign_pointer(tr->function_pids, pid_list);\n\n\tif (filtered_pids) {\n\t\tsynchronize_sched();\n\t\ttrace_free_pid_list(filtered_pids);\n\t} else if (pid_list) {\n\t\t/* Register a probe to set whether to ignore the tracing of a task */\n\t\tregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\t}\n\n\t/*\n\t * Ignoring of pids is done at task switch. But we have to\n\t * check for those tasks that are currently running.\n\t * Always do this in case a pid was appended or removed.\n\t */\n\ton_each_cpu(ignore_task_cpu, tr, 1);\n\n\tftrace_update_pid_func();\n\tftrace_startup_all(0);\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic ssize_t\nftrace_pid_write(struct file *filp, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids = NULL;\n\tstruct trace_pid_list *pid_list;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\tfiltered_pids = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     lockdep_is_held(&ftrace_lock));\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trcu_assign_pointer(tr->function_pids, pid_list);\n\n\tif (filtered_pids) {\n\t\tsynchronize_sched();\n\t\ttrace_free_pid_list(filtered_pids);\n\t} else if (pid_list) {\n\t\t/* Register a probe to set whether to ignore the tracing of a task */\n\t\tregister_trace_sched_switch(ftrace_filter_pid_sched_switch_probe, tr);\n\t}\n\n\t/*\n\t * Ignoring of pids is done at task switch. But we have to\n\t * check for those tasks that are currently running.\n\t * Always do this in case a pid was appended or removed.\n\t */\n\ton_each_cpu(ignore_task_cpu, tr, 1);\n\n\tftrace_update_pid_func();\n\tftrace_startup_all(0);\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->filtered_pids",
            "lockdep_is_held(&event_mutex)"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&event_mutex"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_update_buffers",
          "args": [],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_update_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "5302-5313",
          "snippet": "int tracing_update_buffers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tif (!ring_buffer_expanded)\n\t\tret = __tracing_resize_ring_buffer(&global_trace, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool ring_buffer_expanded;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static unsigned long\t\ttrace_buf_size = TRACE_BUF_SIZE_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nbool ring_buffer_expanded;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic unsigned long\t\ttrace_buf_size = TRACE_BUF_SIZE_DEFAULT;\n\nint tracing_update_buffers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tif (!ring_buffer_expanded)\n\t\tret = __tracing_resize_ring_buffer(&global_trace, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nftrace_event_pid_write(struct file *filp, const char __user *ubuf,\n\t\t       size_t cnt, loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *filtered_pids = NULL;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tssize_t ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&event_mutex);\n\n\tfiltered_pids = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\n\tret = trace_pid_write(filtered_pids, &pid_list, ubuf, cnt);\n\tif (ret < 0)\n\t\tgoto out;\n\n\trcu_assign_pointer(tr->filtered_pids, pid_list);\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tset_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t}\n\n\tif (filtered_pids) {\n\t\ttracepoint_synchronize_unregister();\n\t\ttrace_free_pid_list(filtered_pids);\n\t} else if (pid_list) {\n\t\t/*\n\t\t * Register a probe that is called before all other probes\n\t\t * to set ignore_pid if next or prev do not match.\n\t\t * Register a probe this is called after all other probes\n\t\t * to only keep ignore_pid set if next pid matches.\n\t\t */\n\t\tregister_trace_prio_sched_switch(event_filter_pid_sched_switch_probe_pre,\n\t\t\t\t\t\t tr, INT_MAX);\n\t\tregister_trace_prio_sched_switch(event_filter_pid_sched_switch_probe_post,\n\t\t\t\t\t\t tr, 0);\n\n\t\tregister_trace_prio_sched_wakeup(event_filter_pid_sched_wakeup_probe_pre,\n\t\t\t\t\t\t tr, INT_MAX);\n\t\tregister_trace_prio_sched_wakeup(event_filter_pid_sched_wakeup_probe_post,\n\t\t\t\t\t\t tr, 0);\n\n\t\tregister_trace_prio_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_pre,\n\t\t\t\t\t\t     tr, INT_MAX);\n\t\tregister_trace_prio_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_post,\n\t\t\t\t\t\t     tr, 0);\n\n\t\tregister_trace_prio_sched_waking(event_filter_pid_sched_wakeup_probe_pre,\n\t\t\t\t\t\t tr, INT_MAX);\n\t\tregister_trace_prio_sched_waking(event_filter_pid_sched_wakeup_probe_post,\n\t\t\t\t\t\t tr, 0);\n\t}\n\n\t/*\n\t * Ignoring of pids is done at task switch. But we have to\n\t * check for those tasks that are currently running.\n\t * Always do this in case a pid was appended or removed.\n\t */\n\ton_each_cpu(ignore_task_cpu, tr, 1);\n\n out:\n\tmutex_unlock(&event_mutex);\n\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ignore_task_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1576-1590",
    "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     mutex_is_locked(&event_mutex));\n\n\tthis_cpu_write(tr->trace_buffer.data->ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tr->trace_buffer.data->ignore_pid",
            "trace_ignore_this_task(pid_list, current)"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ignore_this_task",
          "args": [
            "pid_list",
            "current"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ignore_this_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "353-364",
          "snippet": "bool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids, struct task_struct *task)\n{\n\t/*\n\t * Return false, because if filtered_pids does not exist,\n\t * all pids are good to trace.\n\t */\n\tif (!filtered_pids)\n\t\treturn false;\n\n\treturn !trace_find_filtered_pid(filtered_pids, task->pid);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids, struct task_struct *task)\n{\n\t/*\n\t * Return false, because if filtered_pids does not exist,\n\t * all pids are good to trace.\n\t */\n\tif (!filtered_pids)\n\t\treturn false;\n\n\treturn !trace_find_filtered_pid(filtered_pids, task->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->filtered_pids",
            "mutex_is_locked(&event_mutex)"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&event_mutex"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     mutex_is_locked(&event_mutex));\n\n\tthis_cpu_write(tr->trace_buffer.data->ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
  },
  {
    "function_name": "show_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1551-1574",
    "snippet": "static ssize_t\nshow_header(struct file *filp, char __user *ubuf, size_t cnt, loff_t *ppos)\n{\n\tint (*func)(struct trace_seq *s) = filp->private_data;\n\tstruct trace_seq *s;\n\tint r;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ttrace_seq_init(s);\n\n\tfunc(s);\n\tr = simple_read_from_buffer(ubuf, cnt, ppos,\n\t\t\t\t    s->buffer, trace_seq_used(s));\n\n\tkfree(s);\n\n\treturn r;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "ubuf",
            "cnt",
            "ppos",
            "s->buffer",
            "trace_seq_used(s)"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_used",
          "args": [
            "s"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "s"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_init",
          "args": [
            "s"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "39-43",
          "snippet": "static inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nstatic inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*s)",
            "GFP_KERNEL"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nshow_header(struct file *filp, char __user *ubuf, size_t cnt, loff_t *ppos)\n{\n\tint (*func)(struct trace_seq *s) = filp->private_data;\n\tstruct trace_seq *s;\n\tint r;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ttrace_seq_init(s);\n\n\tfunc(s);\n\tr = simple_read_from_buffer(ubuf, cnt, ppos,\n\t\t\t\t    s->buffer, trace_seq_used(s));\n\n\tkfree(s);\n\n\treturn r;\n}"
  },
  {
    "function_name": "subsystem_filter_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1526-1549",
    "snippet": "static ssize_t\nsubsystem_filter_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t       loff_t *ppos)\n{\n\tstruct trace_subsystem_dir *dir = filp->private_data;\n\tchar *buf;\n\tint err;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\terr = apply_subsystem_event_filter(dir, buf);\n\tkfree(buf);\n\tif (err < 0)\n\t\treturn err;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_subsystem_event_filter",
          "args": [
            "dir",
            "buf"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "apply_subsystem_event_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1816-1857",
          "snippet": "int apply_subsystem_event_filter(struct trace_subsystem_dir *dir,\n\t\t\t\t char *filter_string)\n{\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_array *tr = dir->tr;\n\tstruct event_filter *filter = NULL;\n\tint err = 0;\n\n\tmutex_lock(&event_mutex);\n\n\t/* Make sure the system still has events */\n\tif (!dir->nr_events) {\n\t\terr = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_free_subsystem_preds(dir, tr);\n\t\tremove_filter_string(system->filter);\n\t\tfilter = system->filter;\n\t\tsystem->filter = NULL;\n\t\t/* Ensure all filters are no longer used */\n\t\ttracepoint_synchronize_unregister();\n\t\tfilter_free_subsystem_filters(dir, tr);\n\t\t__free_filter(filter);\n\t\tgoto out_unlock;\n\t}\n\n\terr = create_system_filter(dir, tr, filter_string, &filter);\n\tif (filter) {\n\t\t/*\n\t\t * No event actually uses the system filter\n\t\t * we can free it without synchronize_sched().\n\t\t */\n\t\t__free_filter(system->filter);\n\t\tsystem->filter = filter;\n\t}\nout_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint apply_subsystem_event_filter(struct trace_subsystem_dir *dir,\n\t\t\t\t char *filter_string)\n{\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_array *tr = dir->tr;\n\tstruct event_filter *filter = NULL;\n\tint err = 0;\n\n\tmutex_lock(&event_mutex);\n\n\t/* Make sure the system still has events */\n\tif (!dir->nr_events) {\n\t\terr = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_free_subsystem_preds(dir, tr);\n\t\tremove_filter_string(system->filter);\n\t\tfilter = system->filter;\n\t\tsystem->filter = NULL;\n\t\t/* Ensure all filters are no longer used */\n\t\ttracepoint_synchronize_unregister();\n\t\tfilter_free_subsystem_filters(dir, tr);\n\t\t__free_filter(filter);\n\t\tgoto out_unlock;\n\t}\n\n\terr = create_system_filter(dir, tr, filter_string, &filter);\n\tif (filter) {\n\t\t/*\n\t\t * No event actually uses the system filter\n\t\t * we can free it without synchronize_sched().\n\t\t */\n\t\t__free_filter(system->filter);\n\t\tsystem->filter = filter;\n\t}\nout_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "buf"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "buf"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "ubuf",
            "cnt"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nsubsystem_filter_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t       loff_t *ppos)\n{\n\tstruct trace_subsystem_dir *dir = filp->private_data;\n\tchar *buf;\n\tint err;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\terr = apply_subsystem_event_filter(dir, buf);\n\tkfree(buf);\n\tif (err < 0)\n\t\treturn err;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}"
  },
  {
    "function_name": "subsystem_filter_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1499-1524",
    "snippet": "static ssize_t\nsubsystem_filter_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t      loff_t *ppos)\n{\n\tstruct trace_subsystem_dir *dir = filp->private_data;\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_seq *s;\n\tint r;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ttrace_seq_init(s);\n\n\tprint_subsystem_event_filter(system, s);\n\tr = simple_read_from_buffer(ubuf, cnt, ppos,\n\t\t\t\t    s->buffer, trace_seq_used(s));\n\n\tkfree(s);\n\n\treturn r;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "ubuf",
            "cnt",
            "ppos",
            "s->buffer",
            "trace_seq_used(s)"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_used",
          "args": [
            "s"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_subsystem_event_filter",
          "args": [
            "system",
            "s"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "print_subsystem_event_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "969-981",
          "snippet": "void print_subsystem_event_filter(struct event_subsystem *system,\n\t\t\t\t  struct trace_seq *s)\n{\n\tstruct event_filter *filter;\n\n\tmutex_lock(&event_mutex);\n\tfilter = system->filter;\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, DEFAULT_SYS_FILTER_MESSAGE \"\\n\");\n\tmutex_unlock(&event_mutex);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define DEFAULT_SYS_FILTER_MESSAGE\t\t\t\t\t\\\n\t\"### global filter ###\\n\"\t\t\t\t\t\\\n\t\"# Use this to set filters for multiple events.\\n\"\t\t\\\n\t\"# Only events with the given fields will be affected.\\n\"\t\\\n\t\"# If no events are modified, an error message will be displayed here\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\n#define DEFAULT_SYS_FILTER_MESSAGE\t\t\t\t\t\\\n\t\"### global filter ###\\n\"\t\t\t\t\t\\\n\t\"# Use this to set filters for multiple events.\\n\"\t\t\\\n\t\"# Only events with the given fields will be affected.\\n\"\t\\\n\t\"# If no events are modified, an error message will be displayed here\"\n\nvoid print_subsystem_event_filter(struct event_subsystem *system,\n\t\t\t\t  struct trace_seq *s)\n{\n\tstruct event_filter *filter;\n\n\tmutex_lock(&event_mutex);\n\tfilter = system->filter;\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, DEFAULT_SYS_FILTER_MESSAGE \"\\n\");\n\tmutex_unlock(&event_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_init",
          "args": [
            "s"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "39-43",
          "snippet": "static inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nstatic inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*s)",
            "GFP_KERNEL"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nsubsystem_filter_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t      loff_t *ppos)\n{\n\tstruct trace_subsystem_dir *dir = filp->private_data;\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_seq *s;\n\tint r;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ttrace_seq_init(s);\n\n\tprint_subsystem_event_filter(system, s);\n\tr = simple_read_from_buffer(ubuf, cnt, ppos,\n\t\t\t\t    s->buffer, trace_seq_used(s));\n\n\tkfree(s);\n\n\treturn r;\n}"
  },
  {
    "function_name": "subsystem_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1480-1497",
    "snippet": "static int subsystem_release(struct inode *inode, struct file *file)\n{\n\tstruct trace_subsystem_dir *dir = file->private_data;\n\n\ttrace_array_put(dir->tr);\n\n\t/*\n\t * If dir->subsystem is NULL, then this is a temporary\n\t * descriptor that was made for a trace_array to enable\n\t * all subsystems.\n\t */\n\tif (dir->subsystem)\n\t\tput_system(dir);\n\telse\n\t\tkfree(dir);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dir"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_system",
          "args": [
            "dir"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "put_system",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "694-699",
          "snippet": "static void put_system(struct trace_subsystem_dir *dir)\n{\n\tmutex_lock(&event_mutex);\n\t__put_system_dir(dir);\n\tmutex_unlock(&event_mutex);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void put_system(struct trace_subsystem_dir *dir)\n{\n\tmutex_lock(&event_mutex);\n\t__put_system_dir(dir);\n\tmutex_unlock(&event_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "dir->tr"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "298-303",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int subsystem_release(struct inode *inode, struct file *file)\n{\n\tstruct trace_subsystem_dir *dir = file->private_data;\n\n\ttrace_array_put(dir->tr);\n\n\t/*\n\t * If dir->subsystem is NULL, then this is a temporary\n\t * descriptor that was made for a trace_array to enable\n\t * all subsystems.\n\t */\n\tif (dir->subsystem)\n\t\tput_system(dir);\n\telse\n\t\tkfree(dir);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "system_tr_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1447-1478",
    "snippet": "static int system_tr_open(struct inode *inode, struct file *filp)\n{\n\tstruct trace_subsystem_dir *dir;\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tif (tracing_is_disabled())\n\t\treturn -ENODEV;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\t/* Make a temporary dir that has no system but points to tr */\n\tdir = kzalloc(sizeof(*dir), GFP_KERNEL);\n\tif (!dir) {\n\t\ttrace_array_put(tr);\n\t\treturn -ENOMEM;\n\t}\n\n\tdir->tr = tr;\n\n\tret = tracing_open_generic(inode, filp);\n\tif (ret < 0) {\n\t\ttrace_array_put(tr);\n\t\tkfree(dir);\n\t\treturn ret;\n\t}\n\n\tfilp->private_data = dir;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dir"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "298-303",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_open_generic",
          "args": [
            "inode",
            "filp"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_open_generic_tr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "3952-3965",
          "snippet": "static int tracing_open_generic_tr(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\tfilp->private_data = inode->i_private;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic __always_inline struct;\n\nstatic int tracing_open_generic_tr(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\tfilp->private_data = inode->i_private;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*dir)",
            "GFP_KERNEL"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_array_get",
          "args": [
            "tr"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "274-290",
          "snippet": "int trace_array_get(struct trace_array *this_tr)\n{\n\tstruct trace_array *tr;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr == this_tr) {\n\t\t\ttr->ref++;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_array_get(struct trace_array *this_tr)\n{\n\tstruct trace_array *tr;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr == this_tr) {\n\t\t\ttr->ref++;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_is_disabled",
          "args": [],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "3943-3946",
          "snippet": "bool tracing_is_disabled(void)\n{\n\treturn (tracing_disabled) ? true: false;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\n\nbool tracing_is_disabled(void)\n{\n\treturn (tracing_disabled) ? true: false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int system_tr_open(struct inode *inode, struct file *filp)\n{\n\tstruct trace_subsystem_dir *dir;\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tif (tracing_is_disabled())\n\t\treturn -ENODEV;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\t/* Make a temporary dir that has no system but points to tr */\n\tdir = kzalloc(sizeof(*dir), GFP_KERNEL);\n\tif (!dir) {\n\t\ttrace_array_put(tr);\n\t\treturn -ENOMEM;\n\t}\n\n\tdir->tr = tr;\n\n\tret = tracing_open_generic(inode, filp);\n\tif (ret < 0) {\n\t\ttrace_array_put(tr);\n\t\tkfree(dir);\n\t\treturn ret;\n\t}\n\n\tfilp->private_data = dir;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "subsystem_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1397-1445",
    "snippet": "static int subsystem_open(struct inode *inode, struct file *filp)\n{\n\tstruct event_subsystem *system = NULL;\n\tstruct trace_subsystem_dir *dir = NULL; /* Initialize for gcc */\n\tstruct trace_array *tr;\n\tint ret;\n\n\tif (tracing_is_disabled())\n\t\treturn -ENODEV;\n\n\t/* Make sure the system still exists */\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tlist_for_each_entry(dir, &tr->systems, list) {\n\t\t\tif (dir == inode->i_private) {\n\t\t\t\t/* Don't open systems with no events */\n\t\t\t\tif (dir->nr_events) {\n\t\t\t\t\t__get_system_dir(dir);\n\t\t\t\t\tsystem = dir->subsystem;\n\t\t\t\t}\n\t\t\t\tgoto exit_loop;\n\t\t\t}\n\t\t}\n\t}\n exit_loop:\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\tif (!system)\n\t\treturn -ENODEV;\n\n\t/* Some versions of gcc think dir can be uninitialized here */\n\tWARN_ON(!dir);\n\n\t/* Still need to increment the ref count of the system */\n\tif (trace_array_get(tr) < 0) {\n\t\tput_system(dir);\n\t\treturn -ENODEV;\n\t}\n\n\tret = tracing_open_generic(inode, filp);\n\tif (ret < 0) {\n\t\ttrace_array_put(tr);\n\t\tput_system(dir);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_system",
          "args": [
            "dir"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "put_system",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "694-699",
          "snippet": "static void put_system(struct trace_subsystem_dir *dir)\n{\n\tmutex_lock(&event_mutex);\n\t__put_system_dir(dir);\n\tmutex_unlock(&event_mutex);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void put_system(struct trace_subsystem_dir *dir)\n{\n\tmutex_lock(&event_mutex);\n\t__put_system_dir(dir);\n\tmutex_unlock(&event_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "298-303",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_open_generic",
          "args": [
            "inode",
            "filp"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_open_generic_tr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "3952-3965",
          "snippet": "static int tracing_open_generic_tr(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\tfilp->private_data = inode->i_private;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic __always_inline struct;\n\nstatic int tracing_open_generic_tr(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\tfilp->private_data = inode->i_private;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_get",
          "args": [
            "tr"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "274-290",
          "snippet": "int trace_array_get(struct trace_array *this_tr)\n{\n\tstruct trace_array *tr;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr == this_tr) {\n\t\t\ttr->ref++;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_array_get(struct trace_array *this_tr)\n{\n\tstruct trace_array *tr;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr == this_tr) {\n\t\t\ttr->ref++;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!dir"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_system_dir",
          "args": [
            "dir"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "__get_system_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "676-681",
          "snippet": "static void __get_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\tdir->ref_count++;\n\t__get_system(dir->subsystem);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __get_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\tdir->ref_count++;\n\t__get_system(dir->subsystem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dir",
            "&tr->systems",
            "list"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tr",
            "&ftrace_trace_arrays",
            "list"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&trace_types_lock"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_is_disabled",
          "args": [],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "3943-3946",
          "snippet": "bool tracing_is_disabled(void)\n{\n\treturn (tracing_disabled) ? true: false;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\n\nbool tracing_is_disabled(void)\n{\n\treturn (tracing_disabled) ? true: false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int subsystem_open(struct inode *inode, struct file *filp)\n{\n\tstruct event_subsystem *system = NULL;\n\tstruct trace_subsystem_dir *dir = NULL; /* Initialize for gcc */\n\tstruct trace_array *tr;\n\tint ret;\n\n\tif (tracing_is_disabled())\n\t\treturn -ENODEV;\n\n\t/* Make sure the system still exists */\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tlist_for_each_entry(dir, &tr->systems, list) {\n\t\t\tif (dir == inode->i_private) {\n\t\t\t\t/* Don't open systems with no events */\n\t\t\t\tif (dir->nr_events) {\n\t\t\t\t\t__get_system_dir(dir);\n\t\t\t\t\tsystem = dir->subsystem;\n\t\t\t\t}\n\t\t\t\tgoto exit_loop;\n\t\t\t}\n\t\t}\n\t}\n exit_loop:\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\tif (!system)\n\t\treturn -ENODEV;\n\n\t/* Some versions of gcc think dir can be uninitialized here */\n\tWARN_ON(!dir);\n\n\t/* Still need to increment the ref count of the system */\n\tif (trace_array_get(tr) < 0) {\n\t\tput_system(dir);\n\t\treturn -ENODEV;\n\t}\n\n\tret = tracing_open_generic(inode, filp);\n\tif (ret < 0) {\n\t\ttrace_array_put(tr);\n\t\tput_system(dir);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "event_filter_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1365-1393",
    "snippet": "static ssize_t\nevent_filter_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t   loff_t *ppos)\n{\n\tstruct trace_event_file *file;\n\tchar *buf;\n\tint err = -ENODEV;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tmutex_lock(&event_mutex);\n\tfile = event_file_data(filp);\n\tif (file)\n\t\terr = apply_event_filter(file, buf);\n\tmutex_unlock(&event_mutex);\n\n\tkfree(buf);\n\tif (err < 0)\n\t\treturn err;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_event_filter",
          "args": [
            "file",
            "buf"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "apply_event_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1765-1814",
          "snippet": "int apply_event_filter(struct trace_event_file *file, char *filter_string)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct event_filter *filter = NULL;\n\tint err;\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_disable(file);\n\t\tfilter = event_filter(file);\n\n\t\tif (!filter)\n\t\t\treturn 0;\n\n\t\tevent_clear_filter(file);\n\n\t\t/* Make sure the filter is not being used */\n\t\ttracepoint_synchronize_unregister();\n\t\t__free_filter(filter);\n\n\t\treturn 0;\n\t}\n\n\terr = create_filter(call, filter_string, true, &filter);\n\n\t/*\n\t * Always swap the call filter with the new filter\n\t * even if there was an error. If there was an error\n\t * in the filter, we disable the filter and show the error\n\t * string\n\t */\n\tif (filter) {\n\t\tstruct event_filter *tmp;\n\n\t\ttmp = event_filter(file);\n\t\tif (!err)\n\t\t\tevent_set_filtered_flag(file);\n\t\telse\n\t\t\tfilter_disable(file);\n\n\t\tevent_set_filter(file, filter);\n\n\t\tif (tmp) {\n\t\t\t/* Make sure the call is done with the filter */\n\t\t\ttracepoint_synchronize_unregister();\n\t\t\t__free_filter(tmp);\n\t\t}\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint apply_event_filter(struct trace_event_file *file, char *filter_string)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct event_filter *filter = NULL;\n\tint err;\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_disable(file);\n\t\tfilter = event_filter(file);\n\n\t\tif (!filter)\n\t\t\treturn 0;\n\n\t\tevent_clear_filter(file);\n\n\t\t/* Make sure the filter is not being used */\n\t\ttracepoint_synchronize_unregister();\n\t\t__free_filter(filter);\n\n\t\treturn 0;\n\t}\n\n\terr = create_filter(call, filter_string, true, &filter);\n\n\t/*\n\t * Always swap the call filter with the new filter\n\t * even if there was an error. If there was an error\n\t * in the filter, we disable the filter and show the error\n\t * string\n\t */\n\tif (filter) {\n\t\tstruct event_filter *tmp;\n\n\t\ttmp = event_filter(file);\n\t\tif (!err)\n\t\t\tevent_set_filtered_flag(file);\n\t\telse\n\t\t\tfilter_disable(file);\n\n\t\tevent_set_filter(file, filter);\n\n\t\tif (tmp) {\n\t\t\t/* Make sure the call is done with the filter */\n\t\t\ttracepoint_synchronize_unregister();\n\t\t\t__free_filter(tmp);\n\t\t}\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "filp"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1463-1466",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "buf"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "buf"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "ubuf",
            "cnt"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nevent_filter_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t   loff_t *ppos)\n{\n\tstruct trace_event_file *file;\n\tchar *buf;\n\tint err = -ENODEV;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tmutex_lock(&event_mutex);\n\tfile = event_file_data(filp);\n\tif (file)\n\t\terr = apply_event_filter(file, buf);\n\tmutex_unlock(&event_mutex);\n\n\tkfree(buf);\n\tif (err < 0)\n\t\treturn err;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}"
  },
  {
    "function_name": "event_filter_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1332-1363",
    "snippet": "static ssize_t\nevent_filter_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t  loff_t *ppos)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_seq *s;\n\tint r = -ENODEV;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ttrace_seq_init(s);\n\n\tmutex_lock(&event_mutex);\n\tfile = event_file_data(filp);\n\tif (file)\n\t\tprint_event_filter(file, s);\n\tmutex_unlock(&event_mutex);\n\n\tif (file)\n\t\tr = simple_read_from_buffer(ubuf, cnt, ppos,\n\t\t\t\t\t    s->buffer, trace_seq_used(s));\n\n\tkfree(s);\n\n\treturn r;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "ubuf",
            "cnt",
            "ppos",
            "s->buffer",
            "trace_seq_used(s)"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_used",
          "args": [
            "s"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_event_filter",
          "args": [
            "file",
            "s"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "print_event_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "959-967",
          "snippet": "void print_event_filter(struct trace_event_file *file, struct trace_seq *s)\n{\n\tstruct event_filter *filter = event_filter(file);\n\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, \"none\\n\");\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid print_event_filter(struct trace_event_file *file, struct trace_seq *s)\n{\n\tstruct event_filter *filter = event_filter(file);\n\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, \"none\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "filp"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1463-1466",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_init",
          "args": [
            "s"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "39-43",
          "snippet": "static inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nstatic inline void __trace_seq_init(struct trace_seq *s)\n{\n\tif (unlikely(!s->seq.size))\n\t\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*s)",
            "GFP_KERNEL"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nevent_filter_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t  loff_t *ppos)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_seq *s;\n\tint r = -ENODEV;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\ttrace_seq_init(s);\n\n\tmutex_lock(&event_mutex);\n\tfile = event_file_data(filp);\n\tif (file)\n\t\tprint_event_filter(file, s);\n\tmutex_unlock(&event_mutex);\n\n\tif (file)\n\t\tr = simple_read_from_buffer(ubuf, cnt, ppos,\n\t\t\t\t\t    s->buffer, trace_seq_used(s));\n\n\tkfree(s);\n\n\treturn r;\n}"
  },
  {
    "function_name": "event_id_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1314-1330",
    "snippet": "static ssize_t\nevent_id_read(struct file *filp, char __user *ubuf, size_t cnt, loff_t *ppos)\n{\n\tint id = (long)event_file_data(filp);\n\tchar buf[32];\n\tint len;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\tif (unlikely(!id))\n\t\treturn -ENODEV;\n\n\tlen = sprintf(buf, \"%d\\n\", id);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, len);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "ubuf",
            "cnt",
            "ppos",
            "buf",
            "len"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "id"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!id"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "filp"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1463-1466",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nevent_id_read(struct file *filp, char __user *ubuf, size_t cnt, loff_t *ppos)\n{\n\tint id = (long)event_file_data(filp);\n\tchar buf[32];\n\tint len;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\tif (unlikely(!id))\n\t\treturn -ENODEV;\n\n\tlen = sprintf(buf, \"%d\\n\", id);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, len);\n}"
  },
  {
    "function_name": "trace_format_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1299-1312",
    "snippet": "static int trace_format_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = seq_open(file, &trace_format_seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tm = file->private_data;\n\tm->private = file;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations trace_format_seq_ops = {\n\t.start\t\t= f_start,\n\t.next\t\t= f_next,\n\t.stop\t\t= f_stop,\n\t.show\t\t= f_show,\n};",
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&trace_format_seq_ops"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "179-213",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic const struct seq_operations trace_format_seq_ops = {\n\t.start\t\t= f_start,\n\t.next\t\t= f_next,\n\t.stop\t\t= f_stop,\n\t.show\t\t= f_show,\n};\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int trace_format_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = seq_open(file, &trace_format_seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tm = file->private_data;\n\tm->private = file;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "f_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1287-1290",
    "snippet": "static void f_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void f_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "f_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1271-1285",
    "snippet": "static void *f_start(struct seq_file *m, loff_t *pos)\n{\n\tvoid *p = (void *)FORMAT_HEADER;\n\tloff_t l = 0;\n\n\t/* ->stop() is called even if ->start() fails */\n\tmutex_lock(&event_mutex);\n\tif (!event_file_data(m->private))\n\t\treturn ERR_PTR(-ENODEV);\n\n\twhile (l < *pos && p)\n\t\tp = f_next(m, p, &l);\n\n\treturn p;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f_next",
          "args": [
            "m",
            "p",
            "&l"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "f_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "1189-1219",
          "snippet": "static void *f_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_call *call = event_file_data(m->private);\n\tstruct list_head *common_head = &ftrace_common_fields;\n\tstruct list_head *head = trace_get_fields(call);\n\tstruct list_head *node = v;\n\n\t(*pos)++;\n\n\tswitch ((unsigned long)v) {\n\tcase FORMAT_HEADER:\n\t\tnode = common_head;\n\t\tbreak;\n\n\tcase FORMAT_FIELD_SEPERATOR:\n\t\tnode = head;\n\t\tbreak;\n\n\tcase FORMAT_PRINTFMT:\n\t\t/* all done */\n\t\treturn NULL;\n\t}\n\n\tnode = node->prev;\n\tif (node == common_head)\n\t\treturn (void *)FORMAT_FIELD_SEPERATOR;\n\telse if (node == head)\n\t\treturn (void *)FORMAT_PRINTFMT;\n\telse\n\t\treturn node;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ftrace_common_fields);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic LIST_HEAD(ftrace_common_fields);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void *f_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_call *call = event_file_data(m->private);\n\tstruct list_head *common_head = &ftrace_common_fields;\n\tstruct list_head *head = trace_get_fields(call);\n\tstruct list_head *node = v;\n\n\t(*pos)++;\n\n\tswitch ((unsigned long)v) {\n\tcase FORMAT_HEADER:\n\t\tnode = common_head;\n\t\tbreak;\n\n\tcase FORMAT_FIELD_SEPERATOR:\n\t\tnode = head;\n\t\tbreak;\n\n\tcase FORMAT_PRINTFMT:\n\t\t/* all done */\n\t\treturn NULL;\n\t}\n\n\tnode = node->prev;\n\tif (node == common_head)\n\t\treturn (void *)FORMAT_FIELD_SEPERATOR;\n\telse if (node == head)\n\t\treturn (void *)FORMAT_PRINTFMT;\n\telse\n\t\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENODEV"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "m->private"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1463-1466",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void *f_start(struct seq_file *m, loff_t *pos)\n{\n\tvoid *p = (void *)FORMAT_HEADER;\n\tloff_t l = 0;\n\n\t/* ->stop() is called even if ->start() fails */\n\tmutex_lock(&event_mutex);\n\tif (!event_file_data(m->private))\n\t\treturn ERR_PTR(-ENODEV);\n\n\twhile (l < *pos && p)\n\t\tp = f_next(m, p, &l);\n\n\treturn p;\n}"
  },
  {
    "function_name": "f_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1221-1269",
    "snippet": "static int f_show(struct seq_file *m, void *v)\n{\n\tstruct trace_event_call *call = event_file_data(m->private);\n\tstruct ftrace_event_field *field;\n\tconst char *array_descriptor;\n\n\tswitch ((unsigned long)v) {\n\tcase FORMAT_HEADER:\n\t\tseq_printf(m, \"name: %s\\n\", trace_event_name(call));\n\t\tseq_printf(m, \"ID: %d\\n\", call->event.type);\n\t\tseq_puts(m, \"format:\\n\");\n\t\treturn 0;\n\n\tcase FORMAT_FIELD_SEPERATOR:\n\t\tseq_putc(m, '\\n');\n\t\treturn 0;\n\n\tcase FORMAT_PRINTFMT:\n\t\tseq_printf(m, \"\\nprint fmt: %s\\n\",\n\t\t\t   call->print_fmt);\n\t\treturn 0;\n\t}\n\n\tfield = list_entry(v, struct ftrace_event_field, link);\n\t/*\n\t * Smartly shows the array type(except dynamic array).\n\t * Normal:\n\t *\tfield:TYPE VAR\n\t * If TYPE := TYPE[LEN], it is shown:\n\t *\tfield:TYPE VAR[LEN]\n\t */\n\tarray_descriptor = strchr(field->type, '[');\n\n\tif (!strncmp(field->type, \"__data_loc\", 10))\n\t\tarray_descriptor = NULL;\n\n\tif (!array_descriptor)\n\t\tseq_printf(m, \"\\tfield:%s %s;\\toffset:%u;\\tsize:%u;\\tsigned:%d;\\n\",\n\t\t\t   field->type, field->name, field->offset,\n\t\t\t   field->size, !!field->is_signed);\n\telse\n\t\tseq_printf(m, \"\\tfield:%.*s %s%s;\\toffset:%u;\\tsize:%u;\\tsigned:%d;\\n\",\n\t\t\t   (int)(array_descriptor - field->type),\n\t\t\t   field->type, field->name,\n\t\t\t   array_descriptor, field->offset,\n\t\t\t   field->size, !!field->is_signed);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\tfield:%.*s %s%s;\\toffset:%u;\\tsize:%u;\\tsigned:%d;\\n\"",
            "(int)(array_descriptor - field->type)",
            "field->type",
            "field->name",
            "array_descriptor",
            "field->offset",
            "field->size",
            "!!field->is_signed"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "field->type",
            "\"__data_loc\"",
            "10"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "field->type",
            "'['"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "v",
            "structftrace_event_field",
            "link"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"format:\\n\""
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "m->private"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1463-1466",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int f_show(struct seq_file *m, void *v)\n{\n\tstruct trace_event_call *call = event_file_data(m->private);\n\tstruct ftrace_event_field *field;\n\tconst char *array_descriptor;\n\n\tswitch ((unsigned long)v) {\n\tcase FORMAT_HEADER:\n\t\tseq_printf(m, \"name: %s\\n\", trace_event_name(call));\n\t\tseq_printf(m, \"ID: %d\\n\", call->event.type);\n\t\tseq_puts(m, \"format:\\n\");\n\t\treturn 0;\n\n\tcase FORMAT_FIELD_SEPERATOR:\n\t\tseq_putc(m, '\\n');\n\t\treturn 0;\n\n\tcase FORMAT_PRINTFMT:\n\t\tseq_printf(m, \"\\nprint fmt: %s\\n\",\n\t\t\t   call->print_fmt);\n\t\treturn 0;\n\t}\n\n\tfield = list_entry(v, struct ftrace_event_field, link);\n\t/*\n\t * Smartly shows the array type(except dynamic array).\n\t * Normal:\n\t *\tfield:TYPE VAR\n\t * If TYPE := TYPE[LEN], it is shown:\n\t *\tfield:TYPE VAR[LEN]\n\t */\n\tarray_descriptor = strchr(field->type, '[');\n\n\tif (!strncmp(field->type, \"__data_loc\", 10))\n\t\tarray_descriptor = NULL;\n\n\tif (!array_descriptor)\n\t\tseq_printf(m, \"\\tfield:%s %s;\\toffset:%u;\\tsize:%u;\\tsigned:%d;\\n\",\n\t\t\t   field->type, field->name, field->offset,\n\t\t\t   field->size, !!field->is_signed);\n\telse\n\t\tseq_printf(m, \"\\tfield:%.*s %s%s;\\toffset:%u;\\tsize:%u;\\tsigned:%d;\\n\",\n\t\t\t   (int)(array_descriptor - field->type),\n\t\t\t   field->type, field->name,\n\t\t\t   array_descriptor, field->offset,\n\t\t\t   field->size, !!field->is_signed);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "f_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1189-1219",
    "snippet": "static void *f_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_call *call = event_file_data(m->private);\n\tstruct list_head *common_head = &ftrace_common_fields;\n\tstruct list_head *head = trace_get_fields(call);\n\tstruct list_head *node = v;\n\n\t(*pos)++;\n\n\tswitch ((unsigned long)v) {\n\tcase FORMAT_HEADER:\n\t\tnode = common_head;\n\t\tbreak;\n\n\tcase FORMAT_FIELD_SEPERATOR:\n\t\tnode = head;\n\t\tbreak;\n\n\tcase FORMAT_PRINTFMT:\n\t\t/* all done */\n\t\treturn NULL;\n\t}\n\n\tnode = node->prev;\n\tif (node == common_head)\n\t\treturn (void *)FORMAT_FIELD_SEPERATOR;\n\telse if (node == head)\n\t\treturn (void *)FORMAT_PRINTFMT;\n\telse\n\t\treturn node;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(ftrace_common_fields);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_get_fields",
          "args": [
            "call"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "73-79",
          "snippet": "static struct list_head *\ntrace_get_fields(struct trace_event_call *event_call)\n{\n\tif (!event_call->class->get_fields)\n\t\treturn &event_call->class->fields;\n\treturn event_call->class->get_fields(event_call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic struct list_head *\ntrace_get_fields(struct trace_event_call *event_call)\n{\n\tif (!event_call->class->get_fields)\n\t\treturn &event_call->class->fields;\n\treturn event_call->class->get_fields(event_call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "m->private"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1463-1466",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic LIST_HEAD(ftrace_common_fields);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void *f_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_call *call = event_file_data(m->private);\n\tstruct list_head *common_head = &ftrace_common_fields;\n\tstruct list_head *head = trace_get_fields(call);\n\tstruct list_head *node = v;\n\n\t(*pos)++;\n\n\tswitch ((unsigned long)v) {\n\tcase FORMAT_HEADER:\n\t\tnode = common_head;\n\t\tbreak;\n\n\tcase FORMAT_FIELD_SEPERATOR:\n\t\tnode = head;\n\t\tbreak;\n\n\tcase FORMAT_PRINTFMT:\n\t\t/* all done */\n\t\treturn NULL;\n\t}\n\n\tnode = node->prev;\n\tif (node == common_head)\n\t\treturn (void *)FORMAT_FIELD_SEPERATOR;\n\telse if (node == head)\n\t\treturn (void *)FORMAT_PRINTFMT;\n\telse\n\t\treturn node;\n}"
  },
  {
    "function_name": "system_enable_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1143-1181",
    "snippet": "static ssize_t\nsystem_enable_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t    loff_t *ppos)\n{\n\tstruct trace_subsystem_dir *dir = filp->private_data;\n\tstruct event_subsystem *system = dir->subsystem;\n\tconst char *name = NULL;\n\tunsigned long val;\n\tssize_t ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val != 0 && val != 1)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Opening of \"enable\" adds a ref count to system,\n\t * so the name is safe to use.\n\t */\n\tif (system)\n\t\tname = system->name;\n\n\tret = __ftrace_set_clr_event(dir->tr, NULL, name, NULL, val);\n\tif (ret)\n\t\tgoto out;\n\n\tret = cnt;\n\nout:\n\t*ppos += cnt;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_set_clr_event",
          "args": [
            "dir->tr",
            "NULL",
            "name",
            "NULL",
            "val"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_set_clr_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "786-796",
          "snippet": "static int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_update_buffers",
          "args": [],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_update_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "5302-5313",
          "snippet": "int tracing_update_buffers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tif (!ring_buffer_expanded)\n\t\tret = __tracing_resize_ring_buffer(&global_trace, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool ring_buffer_expanded;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static unsigned long\t\ttrace_buf_size = TRACE_BUF_SIZE_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nbool ring_buffer_expanded;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic unsigned long\t\ttrace_buf_size = TRACE_BUF_SIZE_DEFAULT;\n\nint tracing_update_buffers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tif (!ring_buffer_expanded)\n\t\tret = __tracing_resize_ring_buffer(&global_trace, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul_from_user",
          "args": [
            "ubuf",
            "cnt",
            "10",
            "&val"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nsystem_enable_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t    loff_t *ppos)\n{\n\tstruct trace_subsystem_dir *dir = filp->private_data;\n\tstruct event_subsystem *system = dir->subsystem;\n\tconst char *name = NULL;\n\tunsigned long val;\n\tssize_t ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val != 0 && val != 1)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Opening of \"enable\" adds a ref count to system,\n\t * so the name is safe to use.\n\t */\n\tif (system)\n\t\tname = system->name;\n\n\tret = __ftrace_set_clr_event(dir->tr, NULL, name, NULL, val);\n\tif (ret)\n\t\tgoto out;\n\n\tret = cnt;\n\nout:\n\t*ppos += cnt;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "system_enable_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1097-1141",
    "snippet": "static ssize_t\nsystem_enable_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t   loff_t *ppos)\n{\n\tconst char set_to_char[4] = { '?', '0', '1', 'X' };\n\tstruct trace_subsystem_dir *dir = filp->private_data;\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_event_call *call;\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr = dir->tr;\n\tchar buf[2];\n\tint set = 0;\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tcall = file->event_call;\n\t\tif (!trace_event_name(call) || !call->class || !call->class->reg)\n\t\t\tcontinue;\n\n\t\tif (system && strcmp(call->class->system, system->name) != 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We need to find out if all the events are set\n\t\t * or if all events or cleared, or if we have\n\t\t * a mixture.\n\t\t */\n\t\tset |= (1 << !!(file->flags & EVENT_FILE_FL_ENABLED));\n\n\t\t/*\n\t\t * If we have a mixture, no need to look further.\n\t\t */\n\t\tif (set == 3)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tbuf[0] = set_to_char[set];\n\tbuf[1] = '\\n';\n\n\tret = simple_read_from_buffer(ubuf, cnt, ppos, buf, 2);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "ubuf",
            "cnt",
            "ppos",
            "buf",
            "2"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "call->class->system",
            "system->name"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic ssize_t\nsystem_enable_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t   loff_t *ppos)\n{\n\tconst char set_to_char[4] = { '?', '0', '1', 'X' };\n\tstruct trace_subsystem_dir *dir = filp->private_data;\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_event_call *call;\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr = dir->tr;\n\tchar buf[2];\n\tint set = 0;\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tcall = file->event_call;\n\t\tif (!trace_event_name(call) || !call->class || !call->class->reg)\n\t\t\tcontinue;\n\n\t\tif (system && strcmp(call->class->system, system->name) != 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We need to find out if all the events are set\n\t\t * or if all events or cleared, or if we have\n\t\t * a mixture.\n\t\t */\n\t\tset |= (1 << !!(file->flags & EVENT_FILE_FL_ENABLED));\n\n\t\t/*\n\t\t * If we have a mixture, no need to look further.\n\t\t */\n\t\tif (set == 3)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tbuf[0] = set_to_char[set];\n\tbuf[1] = '\\n';\n\n\tret = simple_read_from_buffer(ubuf, cnt, ppos, buf, 2);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "event_enable_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1061-1095",
    "snippet": "static ssize_t\nevent_enable_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t   loff_t *ppos)\n{\n\tstruct trace_event_file *file;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (val) {\n\tcase 0:\n\tcase 1:\n\t\tret = -ENODEV;\n\t\tmutex_lock(&event_mutex);\n\t\tfile = event_file_data(filp);\n\t\tif (likely(file))\n\t\t\tret = ftrace_event_enable_disable(file, val);\n\t\tmutex_unlock(&event_mutex);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*ppos += cnt;\n\n\treturn ret ? ret : cnt;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_event_enable_disable",
          "args": [
            "file",
            "val"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "493-497",
          "snippet": "static int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "file"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "filp"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1463-1466",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_update_buffers",
          "args": [],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_update_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "5302-5313",
          "snippet": "int tracing_update_buffers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tif (!ring_buffer_expanded)\n\t\tret = __tracing_resize_ring_buffer(&global_trace, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool ring_buffer_expanded;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static unsigned long\t\ttrace_buf_size = TRACE_BUF_SIZE_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nbool ring_buffer_expanded;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic unsigned long\t\ttrace_buf_size = TRACE_BUF_SIZE_DEFAULT;\n\nint tracing_update_buffers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tif (!ring_buffer_expanded)\n\t\tret = __tracing_resize_ring_buffer(&global_trace, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul_from_user",
          "args": [
            "ubuf",
            "cnt",
            "10",
            "&val"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nevent_enable_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t   loff_t *ppos)\n{\n\tstruct trace_event_file *file;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (val) {\n\tcase 0:\n\tcase 1:\n\t\tret = -ENODEV;\n\t\tmutex_lock(&event_mutex);\n\t\tfile = event_file_data(filp);\n\t\tif (likely(file))\n\t\t\tret = ftrace_event_enable_disable(file, val);\n\t\tmutex_unlock(&event_mutex);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*ppos += cnt;\n\n\treturn ret ? ret : cnt;\n}"
  },
  {
    "function_name": "event_enable_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1031-1059",
    "snippet": "static ssize_t\nevent_enable_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t  loff_t *ppos)\n{\n\tstruct trace_event_file *file;\n\tunsigned long flags;\n\tchar buf[4] = \"0\";\n\n\tmutex_lock(&event_mutex);\n\tfile = event_file_data(filp);\n\tif (likely(file))\n\t\tflags = file->flags;\n\tmutex_unlock(&event_mutex);\n\n\tif (!file)\n\t\treturn -ENODEV;\n\n\tif (flags & EVENT_FILE_FL_ENABLED &&\n\t    !(flags & EVENT_FILE_FL_SOFT_DISABLED))\n\t\tstrcpy(buf, \"1\");\n\n\tif (flags & EVENT_FILE_FL_SOFT_DISABLED ||\n\t    flags & EVENT_FILE_FL_SOFT_MODE)\n\t\tstrcat(buf, \"*\");\n\n\tstrcat(buf, \"\\n\");\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, strlen(buf));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "ubuf",
            "cnt",
            "ppos",
            "buf",
            "strlen(buf)"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "buf",
            "\"\\n\""
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "buf",
            "\"*\""
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buf",
            "\"1\""
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "file"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "filp"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1463-1466",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nevent_enable_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t  loff_t *ppos)\n{\n\tstruct trace_event_file *file;\n\tunsigned long flags;\n\tchar buf[4] = \"0\";\n\n\tmutex_lock(&event_mutex);\n\tfile = event_file_data(filp);\n\tif (likely(file))\n\t\tflags = file->flags;\n\tmutex_unlock(&event_mutex);\n\n\tif (!file)\n\t\treturn -ENODEV;\n\n\tif (flags & EVENT_FILE_FL_ENABLED &&\n\t    !(flags & EVENT_FILE_FL_SOFT_DISABLED))\n\t\tstrcpy(buf, \"1\");\n\n\tif (flags & EVENT_FILE_FL_SOFT_DISABLED ||\n\t    flags & EVENT_FILE_FL_SOFT_MODE)\n\t\tstrcat(buf, \"*\");\n\n\tstrcat(buf, \"\\n\");\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, strlen(buf));\n}"
  },
  {
    "function_name": "p_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1024-1029",
    "snippet": "static void p_stop(struct seq_file *m, void *p)\n\t__releases(RCU)\n{\n\trcu_read_unlock_sched();\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "RCU"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void p_stop(struct seq_file *m, void *p)\n\t__releases(RCU)\n{\n\trcu_read_unlock_sched();\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "p_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "1001-1022",
    "snippet": "static void *p_start(struct seq_file *m, loff_t *pos)\n\t__acquires(RCU)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = m->private;\n\n\t/*\n\t * Grab the mutex, to keep calls to p_next() having the same\n\t * tr->filtered_pids as p_start() has.\n\t * If we just passed the tr->filtered_pids around, then RCU would\n\t * have been enough, but doing that makes things more complex.\n\t */\n\tmutex_lock(&event_mutex);\n\trcu_read_lock_sched();\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\n\tif (!pid_list)\n\t\treturn NULL;\n\n\treturn trace_pid_start(pid_list, pos);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_pid_start",
          "args": [
            "pid_list",
            "pos"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "trace_pid_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "441-455",
          "snippet": "void *trace_pid_start(struct trace_pid_list *pid_list, loff_t *pos)\n{\n\tunsigned long pid;\n\tloff_t l = 0;\n\n\tpid = find_first_bit(pid_list->pids, pid_list->pid_max);\n\tif (pid >= pid_list->pid_max)\n\t\treturn NULL;\n\n\t/* Return pid + 1 so that zero can be the exit value */\n\tfor (pid++; pid && l < *pos;\n\t     pid = (unsigned long)trace_pid_next(pid_list, (void *)pid, &l))\n\t\t;\n\treturn (void *)pid;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid *trace_pid_start(struct trace_pid_list *pid_list, loff_t *pos)\n{\n\tunsigned long pid;\n\tloff_t l = 0;\n\n\tpid = find_first_bit(pid_list->pids, pid_list->pid_max);\n\tif (pid >= pid_list->pid_max)\n\t\treturn NULL;\n\n\t/* Return pid + 1 so that zero can be the exit value */\n\tfor (pid++; pid && l < *pos;\n\t     pid = (unsigned long)trace_pid_next(pid_list, (void *)pid, &l))\n\t\t;\n\treturn (void *)pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_pids"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "106-119",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "RCU"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void *p_start(struct seq_file *m, loff_t *pos)\n\t__acquires(RCU)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = m->private;\n\n\t/*\n\t * Grab the mutex, to keep calls to p_next() having the same\n\t * tr->filtered_pids as p_start() has.\n\t * If we just passed the tr->filtered_pids around, then RCU would\n\t * have been enough, but doing that makes things more complex.\n\t */\n\tmutex_lock(&event_mutex);\n\trcu_read_lock_sched();\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\n\tif (!pid_list)\n\t\treturn NULL;\n\n\treturn trace_pid_start(pid_list, pos);\n}"
  },
  {
    "function_name": "p_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "992-999",
    "snippet": "static void *\np_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *pid_list = rcu_dereference_sched(tr->filtered_pids);\n\n\treturn trace_pid_next(pid_list, v, pos);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_pid_next",
          "args": [
            "pid_list",
            "v",
            "pos"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "trace_pid_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "414-428",
          "snippet": "void *trace_pid_next(struct trace_pid_list *pid_list, void *v, loff_t *pos)\n{\n\tunsigned long pid = (unsigned long)v;\n\n\t(*pos)++;\n\n\t/* pid already is +1 of the actual prevous bit */\n\tpid = find_next_bit(pid_list->pids, pid_list->pid_max, pid);\n\n\t/* Return pid + 1 to allow zero to be represented */\n\tif (pid < pid_list->pid_max)\n\t\treturn (void *)(pid + 1);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid *trace_pid_next(struct trace_pid_list *pid_list, void *v, loff_t *pos)\n{\n\tunsigned long pid = (unsigned long)v;\n\n\t(*pos)++;\n\n\t/* pid already is +1 of the actual prevous bit */\n\tpid = find_next_bit(pid_list->pids, pid_list->pid_max, pid);\n\n\t/* Return pid + 1 to allow zero to be represented */\n\tif (pid < pid_list->pid_max)\n\t\treturn (void *)(pid + 1);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_pids"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void *\np_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct trace_pid_list *pid_list = rcu_dereference_sched(tr->filtered_pids);\n\n\treturn trace_pid_next(pid_list, v, pos);\n}"
  },
  {
    "function_name": "t_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "987-990",
    "snippet": "static void t_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void t_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "t_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "975-985",
    "snippet": "static int t_show(struct seq_file *m, void *v)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_event_call *call = file->event_call;\n\n\tif (strcmp(call->class->system, TRACE_SYSTEM) != 0)\n\t\tseq_printf(m, \"%s:\", call->class->system);\n\tseq_printf(m, \"%s\\n\", trace_event_name(call));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [
      "#define TRACE_SYSTEM \"TRACE_SYSTEM\""
    ],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\n\"",
            "trace_event_name(call)"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "call->class->system",
            "TRACE_SYSTEM"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#define TRACE_SYSTEM \"TRACE_SYSTEM\"\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int t_show(struct seq_file *m, void *v)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_event_call *call = file->event_call;\n\n\tif (strcmp(call->class->system, TRACE_SYSTEM) != 0)\n\t\tseq_printf(m, \"%s:\", call->class->system);\n\tseq_printf(m, \"%s\\n\", trace_event_name(call));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "s_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "958-973",
    "snippet": "static void *s_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr = m->private;\n\tloff_t l;\n\n\tmutex_lock(&event_mutex);\n\n\tfile = list_entry(&tr->events, struct trace_event_file, list);\n\tfor (l = 0; l <= *pos; ) {\n\t\tfile = s_next(m, file, &l);\n\t\tif (!file)\n\t\t\tbreak;\n\t}\n\treturn file;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "s_next",
          "args": [
            "m",
            "file",
            "&l"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "s_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "942-956",
          "snippet": "static void *\ns_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_array *tr = m->private;\n\n\t(*pos)++;\n\n\tlist_for_each_entry_continue(file, &tr->events, list) {\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED)\n\t\t\treturn file;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void *\ns_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_array *tr = m->private;\n\n\t(*pos)++;\n\n\tlist_for_each_entry_continue(file, &tr->events, list) {\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED)\n\t\t\treturn file;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "&tr->events",
            "structtrace_event_file",
            "list"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void *s_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr = m->private;\n\tloff_t l;\n\n\tmutex_lock(&event_mutex);\n\n\tfile = list_entry(&tr->events, struct trace_event_file, list);\n\tfor (l = 0; l <= *pos; ) {\n\t\tfile = s_next(m, file, &l);\n\t\tif (!file)\n\t\t\tbreak;\n\t}\n\treturn file;\n}"
  },
  {
    "function_name": "s_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "942-956",
    "snippet": "static void *\ns_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_array *tr = m->private;\n\n\t(*pos)++;\n\n\tlist_for_each_entry_continue(file, &tr->events, list) {\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED)\n\t\t\treturn file;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_continue",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void *\ns_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_array *tr = m->private;\n\n\t(*pos)++;\n\n\tlist_for_each_entry_continue(file, &tr->events, list) {\n\t\tif (file->flags & EVENT_FILE_FL_ENABLED)\n\t\t\treturn file;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "t_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "925-940",
    "snippet": "static void *t_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr = m->private;\n\tloff_t l;\n\n\tmutex_lock(&event_mutex);\n\n\tfile = list_entry(&tr->events, struct trace_event_file, list);\n\tfor (l = 0; l <= *pos; ) {\n\t\tfile = t_next(m, file, &l);\n\t\tif (!file)\n\t\t\tbreak;\n\t}\n\treturn file;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "t_next",
          "args": [
            "m",
            "file",
            "&l"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "t_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "902-923",
          "snippet": "static void *\nt_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_event_call *call;\n\tstruct trace_array *tr = m->private;\n\n\t(*pos)++;\n\n\tlist_for_each_entry_continue(file, &tr->events, list) {\n\t\tcall = file->event_call;\n\t\t/*\n\t\t * The ftrace subsystem is for showing formats only.\n\t\t * They can not be enabled or disabled via the event files.\n\t\t */\n\t\tif (call->class && call->class->reg &&\n\t\t    !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\t\treturn file;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void *\nt_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_event_call *call;\n\tstruct trace_array *tr = m->private;\n\n\t(*pos)++;\n\n\tlist_for_each_entry_continue(file, &tr->events, list) {\n\t\tcall = file->event_call;\n\t\t/*\n\t\t * The ftrace subsystem is for showing formats only.\n\t\t * They can not be enabled or disabled via the event files.\n\t\t */\n\t\tif (call->class && call->class->reg &&\n\t\t    !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\t\treturn file;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "&tr->events",
            "structtrace_event_file",
            "list"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void *t_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr = m->private;\n\tloff_t l;\n\n\tmutex_lock(&event_mutex);\n\n\tfile = list_entry(&tr->events, struct trace_event_file, list);\n\tfor (l = 0; l <= *pos; ) {\n\t\tfile = t_next(m, file, &l);\n\t\tif (!file)\n\t\t\tbreak;\n\t}\n\treturn file;\n}"
  },
  {
    "function_name": "t_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "902-923",
    "snippet": "static void *\nt_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_event_call *call;\n\tstruct trace_array *tr = m->private;\n\n\t(*pos)++;\n\n\tlist_for_each_entry_continue(file, &tr->events, list) {\n\t\tcall = file->event_call;\n\t\t/*\n\t\t * The ftrace subsystem is for showing formats only.\n\t\t * They can not be enabled or disabled via the event files.\n\t\t */\n\t\tif (call->class && call->class->reg &&\n\t\t    !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\t\treturn file;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_continue",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void *\nt_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_event_file *file = v;\n\tstruct trace_event_call *call;\n\tstruct trace_array *tr = m->private;\n\n\t(*pos)++;\n\n\tlist_for_each_entry_continue(file, &tr->events, list) {\n\t\tcall = file->event_call;\n\t\t/*\n\t\t * The ftrace subsystem is for showing formats only.\n\t\t * They can not be enabled or disabled via the event files.\n\t\t */\n\t\tif (call->class && call->class->reg &&\n\t\t    !(call->flags & TRACE_EVENT_FL_IGNORE_ENABLE))\n\t\t\treturn file;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ftrace_event_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "862-900",
    "snippet": "static ssize_t\nftrace_event_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos)\n{\n\tstruct trace_parser parser;\n\tstruct seq_file *m = file->private_data;\n\tstruct trace_array *tr = m->private;\n\tssize_t read, ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (trace_parser_get_init(&parser, EVENT_BUF_SIZE + 1))\n\t\treturn -ENOMEM;\n\n\tread = trace_get_user(&parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded((&parser))) {\n\t\tint set = 1;\n\n\t\tif (*parser.buffer == '!')\n\t\t\tset = 0;\n\n\t\tret = ftrace_set_clr_event(tr, parser.buffer + !set, set);\n\t\tif (ret)\n\t\t\tgoto out_put;\n\t}\n\n\tret = read;\n\n out_put:\n\ttrace_parser_put(&parser);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [
      "#define EVENT_BUF_SIZE\t\t127"
    ],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_parser_put",
          "args": [
            "&parser"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1199-1203",
          "snippet": "void trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_parser_put(struct trace_parser *parser)\n{\n\tkfree(parser->buffer);\n\tparser->buffer = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_set_clr_event",
          "args": [
            "tr",
            "parser.buffer + !set",
            "set"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_clr_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "798-834",
          "snippet": "static int ftrace_set_clr_event(struct trace_array *tr, char *buf, int set)\n{\n\tchar *event = NULL, *sub = NULL, *match;\n\tint ret;\n\n\t/*\n\t * The buf format can be <subsystem>:<event-name>\n\t *  *:<event-name> means any event by that name.\n\t *  :<event-name> is the same.\n\t *\n\t *  <subsystem>:* means all events in that subsystem\n\t *  <subsystem>: means the same.\n\t *\n\t *  <name> (no ':') means all events in a subsystem with\n\t *  the name <name> or any event that matches <name>\n\t */\n\n\tmatch = strsep(&buf, \":\");\n\tif (buf) {\n\t\tsub = match;\n\t\tevent = buf;\n\t\tmatch = NULL;\n\n\t\tif (!strlen(sub) || strcmp(sub, \"*\") == 0)\n\t\t\tsub = NULL;\n\t\tif (!strlen(event) || strcmp(event, \"*\") == 0)\n\t\t\tevent = NULL;\n\t}\n\n\tret = __ftrace_set_clr_event(tr, match, sub, event, set);\n\n\t/* Put back the colon to allow this to be called again */\n\tif (buf)\n\t\t*(buf - 1) = ':';\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_set_clr_event(struct trace_array *tr, char *buf, int set)\n{\n\tchar *event = NULL, *sub = NULL, *match;\n\tint ret;\n\n\t/*\n\t * The buf format can be <subsystem>:<event-name>\n\t *  *:<event-name> means any event by that name.\n\t *  :<event-name> is the same.\n\t *\n\t *  <subsystem>:* means all events in that subsystem\n\t *  <subsystem>: means the same.\n\t *\n\t *  <name> (no ':') means all events in a subsystem with\n\t *  the name <name> or any event that matches <name>\n\t */\n\n\tmatch = strsep(&buf, \":\");\n\tif (buf) {\n\t\tsub = match;\n\t\tevent = buf;\n\t\tmatch = NULL;\n\n\t\tif (!strlen(sub) || strcmp(sub, \"*\") == 0)\n\t\t\tsub = NULL;\n\t\tif (!strlen(event) || strcmp(event, \"*\") == 0)\n\t\t\tevent = NULL;\n\t}\n\n\tret = __ftrace_set_clr_event(tr, match, sub, event, set);\n\n\t/* Put back the colon to allow this to be called again */\n\tif (buf)\n\t\t*(buf - 1) = ':';\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_loaded",
          "args": [
            "(&parser)"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_loaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1058-1061",
          "snippet": "static inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->idx != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_get_user",
          "args": [
            "&parser",
            "ubuf",
            "cnt",
            "ppos"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1216-1291",
          "snippet": "int trace_get_user(struct trace_parser *parser, const char __user *ubuf,\n\tsize_t cnt, loff_t *ppos)\n{\n\tchar ch;\n\tsize_t read = 0;\n\tssize_t ret;\n\n\tif (!*ppos)\n\t\ttrace_parser_clear(parser);\n\n\tret = get_user(ch, ubuf++);\n\tif (ret)\n\t\tgoto out;\n\n\tread++;\n\tcnt--;\n\n\t/*\n\t * The parser is not finished with the last write,\n\t * continue reading the user input without skipping spaces.\n\t */\n\tif (!parser->cont) {\n\t\t/* skip white space */\n\t\twhile (cnt && isspace(ch)) {\n\t\t\tret = get_user(ch, ubuf++);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tread++;\n\t\t\tcnt--;\n\t\t}\n\n\t\tparser->idx = 0;\n\n\t\t/* only spaces were written */\n\t\tif (isspace(ch) || !ch) {\n\t\t\t*ppos += read;\n\t\t\tret = read;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* read the non-space input */\n\twhile (cnt && !isspace(ch) && ch) {\n\t\tif (parser->idx < parser->size - 1)\n\t\t\tparser->buffer[parser->idx++] = ch;\n\t\telse {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_user(ch, ubuf++);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tread++;\n\t\tcnt--;\n\t}\n\n\t/* We either got finished input or we have to wait for another call. */\n\tif (isspace(ch) || !ch) {\n\t\tparser->buffer[parser->idx] = 0;\n\t\tparser->cont = false;\n\t} else if (parser->idx < parser->size - 1) {\n\t\tparser->cont = true;\n\t\tparser->buffer[parser->idx++] = ch;\n\t\t/* Make sure the parsed string always terminates with '\\0'. */\n\t\tparser->buffer[parser->idx] = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ppos += read;\n\tret = read;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_get_user(struct trace_parser *parser, const char __user *ubuf,\n\tsize_t cnt, loff_t *ppos)\n{\n\tchar ch;\n\tsize_t read = 0;\n\tssize_t ret;\n\n\tif (!*ppos)\n\t\ttrace_parser_clear(parser);\n\n\tret = get_user(ch, ubuf++);\n\tif (ret)\n\t\tgoto out;\n\n\tread++;\n\tcnt--;\n\n\t/*\n\t * The parser is not finished with the last write,\n\t * continue reading the user input without skipping spaces.\n\t */\n\tif (!parser->cont) {\n\t\t/* skip white space */\n\t\twhile (cnt && isspace(ch)) {\n\t\t\tret = get_user(ch, ubuf++);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tread++;\n\t\t\tcnt--;\n\t\t}\n\n\t\tparser->idx = 0;\n\n\t\t/* only spaces were written */\n\t\tif (isspace(ch) || !ch) {\n\t\t\t*ppos += read;\n\t\t\tret = read;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* read the non-space input */\n\twhile (cnt && !isspace(ch) && ch) {\n\t\tif (parser->idx < parser->size - 1)\n\t\t\tparser->buffer[parser->idx++] = ch;\n\t\telse {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_user(ch, ubuf++);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tread++;\n\t\tcnt--;\n\t}\n\n\t/* We either got finished input or we have to wait for another call. */\n\tif (isspace(ch) || !ch) {\n\t\tparser->buffer[parser->idx] = 0;\n\t\tparser->cont = false;\n\t} else if (parser->idx < parser->size - 1) {\n\t\tparser->cont = true;\n\t\tparser->buffer[parser->idx++] = ch;\n\t\t/* Make sure the parsed string always terminates with '\\0'. */\n\t\tparser->buffer[parser->idx] = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*ppos += read;\n\tret = read;\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_parser_get_init",
          "args": [
            "&parser",
            "EVENT_BUF_SIZE + 1"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parser_get_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1184-1194",
          "snippet": "int trace_parser_get_init(struct trace_parser *parser, int size)\n{\n\tmemset(parser, 0, sizeof(*parser));\n\n\tparser->buffer = kmalloc(size, GFP_KERNEL);\n\tif (!parser->buffer)\n\t\treturn 1;\n\n\tparser->size = size;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_parser_get_init(struct trace_parser *parser, int size)\n{\n\tmemset(parser, 0, sizeof(*parser));\n\n\tparser->buffer = kmalloc(size, GFP_KERNEL);\n\tif (!parser->buffer)\n\t\treturn 1;\n\n\tparser->size = size;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_update_buffers",
          "args": [],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_update_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "5302-5313",
          "snippet": "int tracing_update_buffers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tif (!ring_buffer_expanded)\n\t\tret = __tracing_resize_ring_buffer(&global_trace, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool ring_buffer_expanded;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static unsigned long\t\ttrace_buf_size = TRACE_BUF_SIZE_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nbool ring_buffer_expanded;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic unsigned long\t\ttrace_buf_size = TRACE_BUF_SIZE_DEFAULT;\n\nint tracing_update_buffers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tif (!ring_buffer_expanded)\n\t\tret = __tracing_resize_ring_buffer(&global_trace, trace_buf_size,\n\t\t\t\t\t\tRING_BUFFER_ALL_CPUS);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#define EVENT_BUF_SIZE\t\t127\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic ssize_t\nftrace_event_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos)\n{\n\tstruct trace_parser parser;\n\tstruct seq_file *m = file->private_data;\n\tstruct trace_array *tr = m->private;\n\tssize_t read, ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (trace_parser_get_init(&parser, EVENT_BUF_SIZE + 1))\n\t\treturn -ENOMEM;\n\n\tread = trace_get_user(&parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded((&parser))) {\n\t\tint set = 1;\n\n\t\tif (*parser.buffer == '!')\n\t\t\tset = 0;\n\n\t\tret = ftrace_set_clr_event(tr, parser.buffer + !set, set);\n\t\tif (ret)\n\t\t\tgoto out_put;\n\t}\n\n\tret = read;\n\n out_put:\n\ttrace_parser_put(&parser);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_set_clr_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "848-856",
    "snippet": "int trace_set_clr_event(const char *system, const char *event, int set)\n{\n\tstruct trace_array *tr = top_trace_array();\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_set_clr_event",
          "args": [
            "tr",
            "NULL",
            "system",
            "event",
            "set"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_set_clr_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "786-796",
          "snippet": "static int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "top_trace_array",
          "args": [],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "top_trace_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "301-312",
          "snippet": "static inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn NULL;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\tWARN_ON(!(tr->flags & TRACE_ARRAY_FL_GLOBAL));\n\treturn tr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nint trace_set_clr_event(const char *system, const char *event, int set)\n{\n\tstruct trace_array *tr = top_trace_array();\n\n\tif (!tr)\n\t\treturn -ENODEV;\n\n\treturn __ftrace_set_clr_event(tr, NULL, system, event, set);\n}"
  },
  {
    "function_name": "ftrace_set_clr_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "798-834",
    "snippet": "static int ftrace_set_clr_event(struct trace_array *tr, char *buf, int set)\n{\n\tchar *event = NULL, *sub = NULL, *match;\n\tint ret;\n\n\t/*\n\t * The buf format can be <subsystem>:<event-name>\n\t *  *:<event-name> means any event by that name.\n\t *  :<event-name> is the same.\n\t *\n\t *  <subsystem>:* means all events in that subsystem\n\t *  <subsystem>: means the same.\n\t *\n\t *  <name> (no ':') means all events in a subsystem with\n\t *  the name <name> or any event that matches <name>\n\t */\n\n\tmatch = strsep(&buf, \":\");\n\tif (buf) {\n\t\tsub = match;\n\t\tevent = buf;\n\t\tmatch = NULL;\n\n\t\tif (!strlen(sub) || strcmp(sub, \"*\") == 0)\n\t\t\tsub = NULL;\n\t\tif (!strlen(event) || strcmp(event, \"*\") == 0)\n\t\t\tevent = NULL;\n\t}\n\n\tret = __ftrace_set_clr_event(tr, match, sub, event, set);\n\n\t/* Put back the colon to allow this to be called again */\n\tif (buf)\n\t\t*(buf - 1) = ':';\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_set_clr_event",
          "args": [
            "tr",
            "match",
            "sub",
            "event",
            "set"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_set_clr_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "786-796",
          "snippet": "static int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "event",
            "\"*\""
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "event"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "sub",
            "\"*\""
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&buf",
            "\":\""
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_set_clr_event(struct trace_array *tr, char *buf, int set)\n{\n\tchar *event = NULL, *sub = NULL, *match;\n\tint ret;\n\n\t/*\n\t * The buf format can be <subsystem>:<event-name>\n\t *  *:<event-name> means any event by that name.\n\t *  :<event-name> is the same.\n\t *\n\t *  <subsystem>:* means all events in that subsystem\n\t *  <subsystem>: means the same.\n\t *\n\t *  <name> (no ':') means all events in a subsystem with\n\t *  the name <name> or any event that matches <name>\n\t */\n\n\tmatch = strsep(&buf, \":\");\n\tif (buf) {\n\t\tsub = match;\n\t\tevent = buf;\n\t\tmatch = NULL;\n\n\t\tif (!strlen(sub) || strcmp(sub, \"*\") == 0)\n\t\t\tsub = NULL;\n\t\tif (!strlen(event) || strcmp(event, \"*\") == 0)\n\t\t\tevent = NULL;\n\t}\n\n\tret = __ftrace_set_clr_event(tr, match, sub, event, set);\n\n\t/* Put back the colon to allow this to be called again */\n\tif (buf)\n\t\t*(buf - 1) = ':';\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__ftrace_set_clr_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "786-796",
    "snippet": "static int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_set_clr_event_nolock",
          "args": [
            "tr",
            "match",
            "sub",
            "event",
            "set"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_set_clr_event_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "738-784",
          "snippet": "static int\n__ftrace_set_clr_event_nolock(struct trace_array *tr, const char *match,\n\t\t\t      const char *sub, const char *event, int set)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\tint ret = -EINVAL;\n\tint eret = 0;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class || !call->class->reg)\n\t\t\tcontinue;\n\n\t\tif (call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\t\tcontinue;\n\n\t\tif (match &&\n\t\t    strcmp(match, name) != 0 &&\n\t\t    strcmp(match, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (sub && strcmp(sub, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (event && strcmp(event, name) != 0)\n\t\t\tcontinue;\n\n\t\tret = ftrace_event_enable_disable(file, set);\n\n\t\t/*\n\t\t * Save the first error and return that. Some events\n\t\t * may still have been enabled, but let the user\n\t\t * know that something went wrong.\n\t\t */\n\t\tif (ret && !eret)\n\t\t\teret = ret;\n\n\t\tret = eret;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__ftrace_set_clr_event_nolock(struct trace_array *tr, const char *match,\n\t\t\t      const char *sub, const char *event, int set)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\tint ret = -EINVAL;\n\tint eret = 0;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class || !call->class->reg)\n\t\t\tcontinue;\n\n\t\tif (call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\t\tcontinue;\n\n\t\tif (match &&\n\t\t    strcmp(match, name) != 0 &&\n\t\t    strcmp(match, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (sub && strcmp(sub, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (event && strcmp(event, name) != 0)\n\t\t\tcontinue;\n\n\t\tret = ftrace_event_enable_disable(file, set);\n\n\t\t/*\n\t\t * Save the first error and return that. Some events\n\t\t * may still have been enabled, but let the user\n\t\t * know that something went wrong.\n\t\t */\n\t\tif (ret && !eret)\n\t\t\teret = ret;\n\n\t\tret = eret;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int __ftrace_set_clr_event(struct trace_array *tr, const char *match,\n\t\t\t\t  const char *sub, const char *event, int set)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tret = __ftrace_set_clr_event_nolock(tr, match, sub, event, set);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__ftrace_set_clr_event_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "738-784",
    "snippet": "static int\n__ftrace_set_clr_event_nolock(struct trace_array *tr, const char *match,\n\t\t\t      const char *sub, const char *event, int set)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\tint ret = -EINVAL;\n\tint eret = 0;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class || !call->class->reg)\n\t\t\tcontinue;\n\n\t\tif (call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\t\tcontinue;\n\n\t\tif (match &&\n\t\t    strcmp(match, name) != 0 &&\n\t\t    strcmp(match, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (sub && strcmp(sub, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (event && strcmp(event, name) != 0)\n\t\t\tcontinue;\n\n\t\tret = ftrace_event_enable_disable(file, set);\n\n\t\t/*\n\t\t * Save the first error and return that. Some events\n\t\t * may still have been enabled, but let the user\n\t\t * know that something went wrong.\n\t\t */\n\t\tif (ret && !eret)\n\t\t\teret = ret;\n\n\t\tret = eret;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_event_enable_disable",
          "args": [
            "file",
            "set"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "493-497",
          "snippet": "static int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "event",
            "name"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "sub",
            "call->class->system"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "match",
            "call->class->system"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "match",
            "name"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int\n__ftrace_set_clr_event_nolock(struct trace_array *tr, const char *match,\n\t\t\t      const char *sub, const char *event, int set)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\tint ret = -EINVAL;\n\tint eret = 0;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class || !call->class->reg)\n\t\t\tcontinue;\n\n\t\tif (call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\t\tcontinue;\n\n\t\tif (match &&\n\t\t    strcmp(match, name) != 0 &&\n\t\t    strcmp(match, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (sub && strcmp(sub, call->class->system) != 0)\n\t\t\tcontinue;\n\n\t\tif (event && strcmp(event, name) != 0)\n\t\t\tcontinue;\n\n\t\tret = ftrace_event_enable_disable(file, set);\n\n\t\t/*\n\t\t * Save the first error and return that. Some events\n\t\t * may still have been enabled, but let the user\n\t\t * know that something went wrong.\n\t\t */\n\t\tif (ret && !eret)\n\t\t\teret = ret;\n\n\t\tret = eret;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "remove_event_file_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "713-733",
    "snippet": "static void remove_event_file_dir(struct trace_event_file *file)\n{\n\tstruct dentry *dir = file->dir;\n\tstruct dentry *child;\n\n\tif (dir) {\n\t\tspin_lock(&dir->d_lock);\t/* probably unneeded */\n\t\tlist_for_each_entry(child, &dir->d_subdirs, d_child) {\n\t\t\tif (d_really_is_positive(child))\t/* probably unneeded */\n\t\t\t\td_inode(child)->i_private = NULL;\n\t\t}\n\t\tspin_unlock(&dir->d_lock);\n\n\t\ttracefs_remove_recursive(dir);\n\t}\n\n\tlist_del(&file->list);\n\tremove_subsystem(file->system);\n\tfree_event_filter(file->filter);\n\tkmem_cache_free(file_cachep, file);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *file_cachep;",
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "file_cachep",
            "file"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_event_filter",
          "args": [
            "file->filter"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "free_event_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1017-1020",
          "snippet": "void free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_subsystem",
          "args": [
            "file->system"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "remove_subsystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "701-711",
          "snippet": "static void remove_subsystem(struct trace_subsystem_dir *dir)\n{\n\tif (!dir)\n\t\treturn;\n\n\tif (!--dir->nr_events) {\n\t\ttracefs_remove_recursive(dir->entry);\n\t\tlist_del(&dir->list);\n\t\t__put_system_dir(dir);\n\t}\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void remove_subsystem(struct trace_subsystem_dir *dir)\n{\n\tif (!dir)\n\t\treturn;\n\n\tif (!--dir->nr_events) {\n\t\ttracefs_remove_recursive(dir->entry);\n\t\tlist_del(&dir->list);\n\t\t__put_system_dir(dir);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&file->list"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracefs_remove_recursive",
          "args": [
            "dir"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dir->d_lock"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "child"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_really_is_positive",
          "args": [
            "child"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&dir->d_subdirs",
            "d_child"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dir->d_lock"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic struct kmem_cache *file_cachep;\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void remove_event_file_dir(struct trace_event_file *file)\n{\n\tstruct dentry *dir = file->dir;\n\tstruct dentry *child;\n\n\tif (dir) {\n\t\tspin_lock(&dir->d_lock);\t/* probably unneeded */\n\t\tlist_for_each_entry(child, &dir->d_subdirs, d_child) {\n\t\t\tif (d_really_is_positive(child))\t/* probably unneeded */\n\t\t\t\td_inode(child)->i_private = NULL;\n\t\t}\n\t\tspin_unlock(&dir->d_lock);\n\n\t\ttracefs_remove_recursive(dir);\n\t}\n\n\tlist_del(&file->list);\n\tremove_subsystem(file->system);\n\tfree_event_filter(file->filter);\n\tkmem_cache_free(file_cachep, file);\n}"
  },
  {
    "function_name": "remove_subsystem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "701-711",
    "snippet": "static void remove_subsystem(struct trace_subsystem_dir *dir)\n{\n\tif (!dir)\n\t\treturn;\n\n\tif (!--dir->nr_events) {\n\t\ttracefs_remove_recursive(dir->entry);\n\t\tlist_del(&dir->list);\n\t\t__put_system_dir(dir);\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_system_dir",
          "args": [
            "dir"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "__put_system_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "683-692",
          "snippet": "static void __put_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\t/* If the subsystem is about to be freed, the dir must be too */\n\tWARN_ON_ONCE(system_refcount(dir->subsystem) == 1 && dir->ref_count != 1);\n\n\t__put_system(dir->subsystem);\n\tif (!--dir->ref_count)\n\t\tkfree(dir);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __put_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\t/* If the subsystem is about to be freed, the dir must be too */\n\tWARN_ON_ONCE(system_refcount(dir->subsystem) == 1 && dir->ref_count != 1);\n\n\t__put_system(dir->subsystem);\n\tif (!--dir->ref_count)\n\t\tkfree(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&dir->list"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracefs_remove_recursive",
          "args": [
            "dir->entry"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void remove_subsystem(struct trace_subsystem_dir *dir)\n{\n\tif (!dir)\n\t\treturn;\n\n\tif (!--dir->nr_events) {\n\t\ttracefs_remove_recursive(dir->entry);\n\t\tlist_del(&dir->list);\n\t\t__put_system_dir(dir);\n\t}\n}"
  },
  {
    "function_name": "put_system",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "694-699",
    "snippet": "static void put_system(struct trace_subsystem_dir *dir)\n{\n\tmutex_lock(&event_mutex);\n\t__put_system_dir(dir);\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_system_dir",
          "args": [
            "dir"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "__put_system_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "683-692",
          "snippet": "static void __put_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\t/* If the subsystem is about to be freed, the dir must be too */\n\tWARN_ON_ONCE(system_refcount(dir->subsystem) == 1 && dir->ref_count != 1);\n\n\t__put_system(dir->subsystem);\n\tif (!--dir->ref_count)\n\t\tkfree(dir);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __put_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\t/* If the subsystem is about to be freed, the dir must be too */\n\tWARN_ON_ONCE(system_refcount(dir->subsystem) == 1 && dir->ref_count != 1);\n\n\t__put_system(dir->subsystem);\n\tif (!--dir->ref_count)\n\t\tkfree(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void put_system(struct trace_subsystem_dir *dir)\n{\n\tmutex_lock(&event_mutex);\n\t__put_system_dir(dir);\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "__put_system_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "683-692",
    "snippet": "static void __put_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\t/* If the subsystem is about to be freed, the dir must be too */\n\tWARN_ON_ONCE(system_refcount(dir->subsystem) == 1 && dir->ref_count != 1);\n\n\t__put_system(dir->subsystem);\n\tif (!--dir->ref_count)\n\t\tkfree(dir);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dir"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_system",
          "args": [
            "dir->subsystem"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "__put_system_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "683-692",
          "snippet": "static void __put_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\t/* If the subsystem is about to be freed, the dir must be too */\n\tWARN_ON_ONCE(system_refcount(dir->subsystem) == 1 && dir->ref_count != 1);\n\n\t__put_system(dir->subsystem);\n\tif (!--dir->ref_count)\n\t\tkfree(dir);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "system_refcount(dir->subsystem) == 1 && dir->ref_count != 1"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system_refcount",
          "args": [
            "dir->subsystem"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "55-58",
          "snippet": "static int system_refcount_dec(struct event_subsystem *system)\n{\n\treturn --system->ref_count;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_dec(struct event_subsystem *system)\n{\n\treturn --system->ref_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dir->ref_count == 0"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __put_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\t/* If the subsystem is about to be freed, the dir must be too */\n\tWARN_ON_ONCE(system_refcount(dir->subsystem) == 1 && dir->ref_count != 1);\n\n\t__put_system(dir->subsystem);\n\tif (!--dir->ref_count)\n\t\tkfree(dir);\n}"
  },
  {
    "function_name": "__get_system_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "676-681",
    "snippet": "static void __get_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\tdir->ref_count++;\n\t__get_system(dir->subsystem);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_system",
          "args": [
            "dir->subsystem"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "__get_system_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "676-681",
          "snippet": "static void __get_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\tdir->ref_count++;\n\t__get_system(dir->subsystem);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dir->ref_count == 0"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __get_system_dir(struct trace_subsystem_dir *dir)\n{\n\tWARN_ON_ONCE(dir->ref_count == 0);\n\tdir->ref_count++;\n\t__get_system(dir->subsystem);\n}"
  },
  {
    "function_name": "__get_system",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "670-674",
    "snippet": "static void __get_system(struct event_subsystem *system)\n{\n\tWARN_ON_ONCE(system_refcount(system) == 0);\n\tsystem_refcount_inc(system);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "system_refcount_inc",
          "args": [
            "system"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "50-53",
          "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "system_refcount(system) == 0"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "system_refcount",
          "args": [
            "system"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "55-58",
          "snippet": "static int system_refcount_dec(struct event_subsystem *system)\n{\n\treturn --system->ref_count;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_dec(struct event_subsystem *system)\n{\n\treturn --system->ref_count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __get_system(struct event_subsystem *system)\n{\n\tWARN_ON_ONCE(system_refcount(system) == 0);\n\tsystem_refcount_inc(system);\n}"
  },
  {
    "function_name": "__put_system",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "652-668",
    "snippet": "static void __put_system(struct event_subsystem *system)\n{\n\tstruct event_filter *filter = system->filter;\n\n\tWARN_ON_ONCE(system_refcount(system) == 0);\n\tif (system_refcount_dec(system))\n\t\treturn;\n\n\tlist_del(&system->list);\n\n\tif (filter) {\n\t\tkfree(filter->filter_string);\n\t\tkfree(filter);\n\t}\n\tkfree_const(system->name);\n\tkfree(system);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "system"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_const",
          "args": [
            "system->name"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&system->list"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "system_refcount_dec",
          "args": [
            "system"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "system_refcount_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "55-58",
          "snippet": "static int system_refcount_dec(struct event_subsystem *system)\n{\n\treturn --system->ref_count;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_dec(struct event_subsystem *system)\n{\n\treturn --system->ref_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "system_refcount(system) == 0"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __put_system(struct event_subsystem *system)\n{\n\tstruct event_filter *filter = system->filter;\n\n\tWARN_ON_ONCE(system_refcount(system) == 0);\n\tif (system_refcount_dec(system))\n\t\treturn;\n\n\tlist_del(&system->list);\n\n\tif (filter) {\n\t\tkfree(filter->filter_string);\n\t\tkfree(filter);\n\t}\n\tkfree_const(system->name);\n\tkfree(system);\n}"
  },
  {
    "function_name": "ftrace_clear_event_pids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "645-650",
    "snippet": "static void ftrace_clear_event_pids(struct trace_array *tr)\n{\n\tmutex_lock(&event_mutex);\n\t__ftrace_clear_event_pids(tr);\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ftrace_clear_event_pids",
          "args": [
            "tr"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_clear_event_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "607-643",
          "snippet": "static void __ftrace_clear_event_pids(struct trace_array *tr)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\tif (!pid_list)\n\t\treturn;\n\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_pre, tr);\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_post, tr);\n\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tclear_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t}\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu_ptr(tr->trace_buffer.data, cpu)->ignore_pid = false;\n\n\trcu_assign_pointer(tr->filtered_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\ttracepoint_synchronize_unregister();\n\n\ttrace_free_pid_list(pid_list);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void __ftrace_clear_event_pids(struct trace_array *tr)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\tif (!pid_list)\n\t\treturn;\n\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_pre, tr);\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_post, tr);\n\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tclear_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t}\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu_ptr(tr->trace_buffer.data, cpu)->ignore_pid = false;\n\n\trcu_assign_pointer(tr->filtered_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\ttracepoint_synchronize_unregister();\n\n\ttrace_free_pid_list(pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void ftrace_clear_event_pids(struct trace_array *tr)\n{\n\tmutex_lock(&event_mutex);\n\t__ftrace_clear_event_pids(tr);\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "__ftrace_clear_event_pids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "607-643",
    "snippet": "static void __ftrace_clear_event_pids(struct trace_array *tr)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\tif (!pid_list)\n\t\treturn;\n\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_pre, tr);\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_post, tr);\n\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tclear_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t}\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu_ptr(tr->trace_buffer.data, cpu)->ignore_pid = false;\n\n\trcu_assign_pointer(tr->filtered_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\ttracepoint_synchronize_unregister();\n\n\ttrace_free_pid_list(pid_list);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_free_pid_list",
          "args": [
            "pid_list"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "trace_free_pid_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "318-322",
          "snippet": "void trace_free_pid_list(struct trace_pid_list *pid_list)\n{\n\tvfree(pid_list->pids);\n\tkfree(pid_list);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_free_pid_list(struct trace_pid_list *pid_list)\n{\n\tvfree(pid_list->pids);\n\tkfree(pid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tr->filtered_pids",
            "NULL"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EVENT_FILE_FL_PID_FILTER_BIT",
            "&file->flags"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "792-801",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_waking",
          "args": [
            "event_filter_pid_sched_wakeup_probe_post",
            "tr"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_waking",
          "args": [
            "event_filter_pid_sched_wakeup_probe_pre",
            "tr"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup_new",
          "args": [
            "event_filter_pid_sched_wakeup_probe_post",
            "tr"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup_new",
          "args": [
            "event_filter_pid_sched_wakeup_probe_pre",
            "tr"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup",
          "args": [
            "event_filter_pid_sched_wakeup_probe_post",
            "tr"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_wakeup",
          "args": [
            "event_filter_pid_sched_wakeup_probe_pre",
            "tr"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_switch",
          "args": [
            "event_filter_pid_sched_switch_probe_post",
            "tr"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_switch",
          "args": [
            "event_filter_pid_sched_switch_probe_pre",
            "tr"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tr->filtered_pids",
            "lockdep_is_held(&event_mutex)"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&event_mutex"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void __ftrace_clear_event_pids(struct trace_array *tr)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_event_file *file;\n\tint cpu;\n\n\tpid_list = rcu_dereference_protected(tr->filtered_pids,\n\t\t\t\t\t     lockdep_is_held(&event_mutex));\n\tif (!pid_list)\n\t\treturn;\n\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_pre, tr);\n\tunregister_trace_sched_switch(event_filter_pid_sched_switch_probe_post, tr);\n\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_wakeup_new(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_pre, tr);\n\tunregister_trace_sched_waking(event_filter_pid_sched_wakeup_probe_post, tr);\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tclear_bit(EVENT_FILE_FL_PID_FILTER_BIT, &file->flags);\n\t}\n\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu_ptr(tr->trace_buffer.data, cpu)->ignore_pid = false;\n\n\trcu_assign_pointer(tr->filtered_pids, NULL);\n\n\t/* Wait till all users are no longer using pid filtering */\n\ttracepoint_synchronize_unregister();\n\n\ttrace_free_pid_list(pid_list);\n}"
  },
  {
    "function_name": "event_filter_pid_sched_wakeup_probe_post",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "590-605",
    "snippet": "static void\nevent_filter_pid_sched_wakeup_probe_post(void *data, struct task_struct *task)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/* Nothing to do if we are not tracing */\n\tif (this_cpu_read(tr->trace_buffer.data->ignore_pid))\n\t\treturn;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\n\t/* Set tracing if current is enabled */\n\tthis_cpu_write(tr->trace_buffer.data->ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tr->trace_buffer.data->ignore_pid",
            "trace_ignore_this_task(pid_list, current)"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ignore_this_task",
          "args": [
            "pid_list",
            "current"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ignore_this_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "353-364",
          "snippet": "bool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids, struct task_struct *task)\n{\n\t/*\n\t * Return false, because if filtered_pids does not exist,\n\t * all pids are good to trace.\n\t */\n\tif (!filtered_pids)\n\t\treturn false;\n\n\treturn !trace_find_filtered_pid(filtered_pids, task->pid);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids, struct task_struct *task)\n{\n\t/*\n\t * Return false, because if filtered_pids does not exist,\n\t * all pids are good to trace.\n\t */\n\tif (!filtered_pids)\n\t\treturn false;\n\n\treturn !trace_find_filtered_pid(filtered_pids, task->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_pids"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "tr->trace_buffer.data->ignore_pid"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void\nevent_filter_pid_sched_wakeup_probe_post(void *data, struct task_struct *task)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/* Nothing to do if we are not tracing */\n\tif (this_cpu_read(tr->trace_buffer.data->ignore_pid))\n\t\treturn;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\n\t/* Set tracing if current is enabled */\n\tthis_cpu_write(tr->trace_buffer.data->ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
  },
  {
    "function_name": "event_filter_pid_sched_wakeup_probe_pre",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "574-588",
    "snippet": "static void\nevent_filter_pid_sched_wakeup_probe_pre(void *data, struct task_struct *task)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/* Nothing to do if we are already tracing */\n\tif (!this_cpu_read(tr->trace_buffer.data->ignore_pid))\n\t\treturn;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\n\tthis_cpu_write(tr->trace_buffer.data->ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, task));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tr->trace_buffer.data->ignore_pid",
            "trace_ignore_this_task(pid_list, task)"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ignore_this_task",
          "args": [
            "pid_list",
            "task"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ignore_this_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "353-364",
          "snippet": "bool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids, struct task_struct *task)\n{\n\t/*\n\t * Return false, because if filtered_pids does not exist,\n\t * all pids are good to trace.\n\t */\n\tif (!filtered_pids)\n\t\treturn false;\n\n\treturn !trace_find_filtered_pid(filtered_pids, task->pid);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids, struct task_struct *task)\n{\n\t/*\n\t * Return false, because if filtered_pids does not exist,\n\t * all pids are good to trace.\n\t */\n\tif (!filtered_pids)\n\t\treturn false;\n\n\treturn !trace_find_filtered_pid(filtered_pids, task->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_pids"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "tr->trace_buffer.data->ignore_pid"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void\nevent_filter_pid_sched_wakeup_probe_pre(void *data, struct task_struct *task)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/* Nothing to do if we are already tracing */\n\tif (!this_cpu_read(tr->trace_buffer.data->ignore_pid))\n\t\treturn;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\n\tthis_cpu_write(tr->trace_buffer.data->ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, task));\n}"
  },
  {
    "function_name": "event_filter_pid_sched_switch_probe_post",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "561-572",
    "snippet": "static void\nevent_filter_pid_sched_switch_probe_post(void *data, bool preempt,\n\t\t    struct task_struct *prev, struct task_struct *next)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\n\tthis_cpu_write(tr->trace_buffer.data->ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, next));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tr->trace_buffer.data->ignore_pid",
            "trace_ignore_this_task(pid_list, next)"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ignore_this_task",
          "args": [
            "pid_list",
            "next"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ignore_this_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "353-364",
          "snippet": "bool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids, struct task_struct *task)\n{\n\t/*\n\t * Return false, because if filtered_pids does not exist,\n\t * all pids are good to trace.\n\t */\n\tif (!filtered_pids)\n\t\treturn false;\n\n\treturn !trace_find_filtered_pid(filtered_pids, task->pid);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids, struct task_struct *task)\n{\n\t/*\n\t * Return false, because if filtered_pids does not exist,\n\t * all pids are good to trace.\n\t */\n\tif (!filtered_pids)\n\t\treturn false;\n\n\treturn !trace_find_filtered_pid(filtered_pids, task->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_pids"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void\nevent_filter_pid_sched_switch_probe_post(void *data, bool preempt,\n\t\t    struct task_struct *prev, struct task_struct *next)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\n\tthis_cpu_write(tr->trace_buffer.data->ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, next));\n}"
  },
  {
    "function_name": "event_filter_pid_sched_switch_probe_pre",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "547-559",
    "snippet": "static void\nevent_filter_pid_sched_switch_probe_pre(void *data, bool preempt,\n\t\t    struct task_struct *prev, struct task_struct *next)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\n\tthis_cpu_write(tr->trace_buffer.data->ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, prev) &&\n\t\t       trace_ignore_this_task(pid_list, next));\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tr->trace_buffer.data->ignore_pid",
            "trace_ignore_this_task(pid_list, prev) &&\n\t\t       trace_ignore_this_task(pid_list, next)"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ignore_this_task",
          "args": [
            "pid_list",
            "next"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "trace_ignore_this_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "353-364",
          "snippet": "bool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids, struct task_struct *task)\n{\n\t/*\n\t * Return false, because if filtered_pids does not exist,\n\t * all pids are good to trace.\n\t */\n\tif (!filtered_pids)\n\t\treturn false;\n\n\treturn !trace_find_filtered_pid(filtered_pids, task->pid);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nbool\ntrace_ignore_this_task(struct trace_pid_list *filtered_pids, struct task_struct *task)\n{\n\t/*\n\t * Return false, because if filtered_pids does not exist,\n\t * all pids are good to trace.\n\t */\n\tif (!filtered_pids)\n\t\treturn false;\n\n\treturn !trace_find_filtered_pid(filtered_pids, task->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_pids"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void\nevent_filter_pid_sched_switch_probe_pre(void *data, bool preempt,\n\t\t    struct task_struct *prev, struct task_struct *next)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\n\tthis_cpu_write(tr->trace_buffer.data->ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, prev) &&\n\t\t       trace_ignore_this_task(pid_list, next));\n}"
  },
  {
    "function_name": "trace_event_follow_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "532-545",
    "snippet": "void trace_event_follow_fork(struct trace_array *tr, bool enable)\n{\n\tif (enable) {\n\t\tregister_trace_prio_sched_process_fork(event_filter_pid_sched_process_fork,\n\t\t\t\t\t\t       tr, INT_MIN);\n\t\tregister_trace_prio_sched_process_exit(event_filter_pid_sched_process_exit,\n\t\t\t\t\t\t       tr, INT_MAX);\n\t} else {\n\t\tunregister_trace_sched_process_fork(event_filter_pid_sched_process_fork,\n\t\t\t\t\t\t    tr);\n\t\tunregister_trace_sched_process_exit(event_filter_pid_sched_process_exit,\n\t\t\t\t\t\t    tr);\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_sched_process_exit",
          "args": [
            "event_filter_pid_sched_process_exit",
            "tr"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_trace_sched_process_fork",
          "args": [
            "event_filter_pid_sched_process_fork",
            "tr"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_prio_sched_process_exit",
          "args": [
            "event_filter_pid_sched_process_exit",
            "tr",
            "INT_MAX"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_prio_sched_process_fork",
          "args": [
            "event_filter_pid_sched_process_fork",
            "tr",
            "INT_MIN"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nvoid trace_event_follow_fork(struct trace_array *tr, bool enable)\n{\n\tif (enable) {\n\t\tregister_trace_prio_sched_process_fork(event_filter_pid_sched_process_fork,\n\t\t\t\t\t\t       tr, INT_MIN);\n\t\tregister_trace_prio_sched_process_exit(event_filter_pid_sched_process_exit,\n\t\t\t\t\t\t       tr, INT_MAX);\n\t} else {\n\t\tunregister_trace_sched_process_fork(event_filter_pid_sched_process_fork,\n\t\t\t\t\t\t    tr);\n\t\tunregister_trace_sched_process_exit(event_filter_pid_sched_process_exit,\n\t\t\t\t\t\t    tr);\n\t}\n}"
  },
  {
    "function_name": "event_filter_pid_sched_process_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "520-530",
    "snippet": "static void\nevent_filter_pid_sched_process_fork(void *data,\n\t\t\t\t    struct task_struct *self,\n\t\t\t\t    struct task_struct *task)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = data;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\ttrace_filter_add_remove_task(pid_list, self, task);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_filter_add_remove_task",
          "args": [
            "pid_list",
            "self",
            "task"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "trace_filter_add_remove_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "378-400",
          "snippet": "void trace_filter_add_remove_task(struct trace_pid_list *pid_list,\n\t\t\t\t  struct task_struct *self,\n\t\t\t\t  struct task_struct *task)\n{\n\tif (!pid_list)\n\t\treturn;\n\n\t/* For forks, we only add if the forking task is listed */\n\tif (self) {\n\t\tif (!trace_find_filtered_pid(pid_list, self->pid))\n\t\t\treturn;\n\t}\n\n\t/* Sorry, but we don't support pid_max changing after setting */\n\tif (task->pid >= pid_list->pid_max)\n\t\treturn;\n\n\t/* \"self\" is set for forks, and NULL for exits */\n\tif (self)\n\t\tset_bit(task->pid, pid_list->pids);\n\telse\n\t\tclear_bit(task->pid, pid_list->pids);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nvoid trace_filter_add_remove_task(struct trace_pid_list *pid_list,\n\t\t\t\t  struct task_struct *self,\n\t\t\t\t  struct task_struct *task)\n{\n\tif (!pid_list)\n\t\treturn;\n\n\t/* For forks, we only add if the forking task is listed */\n\tif (self) {\n\t\tif (!trace_find_filtered_pid(pid_list, self->pid))\n\t\t\treturn;\n\t}\n\n\t/* Sorry, but we don't support pid_max changing after setting */\n\tif (task->pid >= pid_list->pid_max)\n\t\treturn;\n\n\t/* \"self\" is set for forks, and NULL for exits */\n\tif (self)\n\t\tset_bit(task->pid, pid_list->pids);\n\telse\n\t\tclear_bit(task->pid, pid_list->pids);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "tr->filtered_pids"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void\nevent_filter_pid_sched_process_fork(void *data,\n\t\t\t\t    struct task_struct *self,\n\t\t\t\t    struct task_struct *task)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = data;\n\n\tpid_list = rcu_dereference_sched(tr->filtered_pids);\n\ttrace_filter_add_remove_task(pid_list, self, task);\n}"
  },
  {
    "function_name": "event_filter_pid_sched_process_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "510-518",
    "snippet": "static void\nevent_filter_pid_sched_process_exit(void *data, struct task_struct *task)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = data;\n\n\tpid_list = rcu_dereference_raw(tr->filtered_pids);\n\ttrace_filter_add_remove_task(pid_list, NULL, task);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_filter_add_remove_task",
          "args": [
            "pid_list",
            "NULL",
            "task"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "trace_filter_add_remove_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "378-400",
          "snippet": "void trace_filter_add_remove_task(struct trace_pid_list *pid_list,\n\t\t\t\t  struct task_struct *self,\n\t\t\t\t  struct task_struct *task)\n{\n\tif (!pid_list)\n\t\treturn;\n\n\t/* For forks, we only add if the forking task is listed */\n\tif (self) {\n\t\tif (!trace_find_filtered_pid(pid_list, self->pid))\n\t\t\treturn;\n\t}\n\n\t/* Sorry, but we don't support pid_max changing after setting */\n\tif (task->pid >= pid_list->pid_max)\n\t\treturn;\n\n\t/* \"self\" is set for forks, and NULL for exits */\n\tif (self)\n\t\tset_bit(task->pid, pid_list->pids);\n\telse\n\t\tclear_bit(task->pid, pid_list->pids);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nvoid trace_filter_add_remove_task(struct trace_pid_list *pid_list,\n\t\t\t\t  struct task_struct *self,\n\t\t\t\t  struct task_struct *task)\n{\n\tif (!pid_list)\n\t\treturn;\n\n\t/* For forks, we only add if the forking task is listed */\n\tif (self) {\n\t\tif (!trace_find_filtered_pid(pid_list, self->pid))\n\t\t\treturn;\n\t}\n\n\t/* Sorry, but we don't support pid_max changing after setting */\n\tif (task->pid >= pid_list->pid_max)\n\t\treturn;\n\n\t/* \"self\" is set for forks, and NULL for exits */\n\tif (self)\n\t\tset_bit(task->pid, pid_list->pids);\n\telse\n\t\tclear_bit(task->pid, pid_list->pids);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "tr->filtered_pids"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void\nevent_filter_pid_sched_process_exit(void *data, struct task_struct *task)\n{\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_array *tr = data;\n\n\tpid_list = rcu_dereference_raw(tr->filtered_pids);\n\ttrace_filter_add_remove_task(pid_list, NULL, task);\n}"
  },
  {
    "function_name": "ftrace_clear_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "499-508",
    "snippet": "static void ftrace_clear_events(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tmutex_lock(&event_mutex);\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tftrace_event_enable_disable(file, 0);\n\t}\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_event_enable_disable",
          "args": [
            "file",
            "0"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "493-497",
          "snippet": "static int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "file",
            "&tr->events",
            "list"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic void ftrace_clear_events(struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tmutex_lock(&event_mutex);\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tftrace_event_enable_disable(file, 0);\n\t}\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "ftrace_event_enable_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "493-497",
    "snippet": "static int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_event_enable_disable",
          "args": [
            "file",
            "enable",
            "0"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_event_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "369-485",
          "snippet": "static int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstatic int ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int enable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, 0);\n}"
  },
  {
    "function_name": "trace_event_enable_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "487-491",
    "snippet": "int trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ftrace_event_enable_disable",
          "args": [
            "file",
            "enable",
            "soft_disable"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "__ftrace_event_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "369-485",
          "snippet": "static int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nint trace_event_enable_disable(struct trace_event_file *file,\n\t\t\t       int enable, int soft_disable)\n{\n\treturn __ftrace_event_enable_disable(file, enable, soft_disable);\n}"
  },
  {
    "function_name": "__ftrace_event_enable_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "369-485",
    "snippet": "static int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffered_event_disable",
          "args": [],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffered_event_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2234-2270",
          "snippet": "void trace_buffered_event_disable(void)\n{\n\tint cpu;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&event_mutex));\n\n\tif (WARN_ON_ONCE(!trace_buffered_event_ref))\n\t\treturn;\n\n\tif (--trace_buffered_event_ref)\n\t\treturn;\n\n\tpreempt_disable();\n\t/* For each CPU, set the buffer as used. */\n\tsmp_call_function_many(tracing_buffer_mask,\n\t\t\t       disable_trace_buffered_event, NULL, 1);\n\tpreempt_enable();\n\n\t/* Wait for all current users to finish */\n\tsynchronize_sched();\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tfree_page((unsigned long)per_cpu(trace_buffered_event, cpu));\n\t\tper_cpu(trace_buffered_event, cpu) = NULL;\n\t}\n\t/*\n\t * Make sure trace_buffered_event is NULL before clearing\n\t * trace_buffered_event_cnt.\n\t */\n\tsmp_wmb();\n\n\tpreempt_disable();\n\t/* Do the work on each cpu */\n\tsmp_call_function_many(tracing_buffer_mask,\n\t\t\t       enable_trace_buffered_event, NULL, 1);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int trace_buffered_event_ref;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int trace_buffered_event_ref;\n\nvoid trace_buffered_event_disable(void)\n{\n\tint cpu;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&event_mutex));\n\n\tif (WARN_ON_ONCE(!trace_buffered_event_ref))\n\t\treturn;\n\n\tif (--trace_buffered_event_ref)\n\t\treturn;\n\n\tpreempt_disable();\n\t/* For each CPU, set the buffer as used. */\n\tsmp_call_function_many(tracing_buffer_mask,\n\t\t\t       disable_trace_buffered_event, NULL, 1);\n\tpreempt_enable();\n\n\t/* Wait for all current users to finish */\n\tsynchronize_sched();\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tfree_page((unsigned long)per_cpu(trace_buffered_event, cpu));\n\t\tper_cpu(trace_buffered_event, cpu) = NULL;\n\t}\n\t/*\n\t * Make sure trace_buffered_event is NULL before clearing\n\t * trace_buffered_event_cnt.\n\t */\n\tsmp_wmb();\n\n\tpreempt_disable();\n\t/* Do the work on each cpu */\n\tsmp_call_function_many(tracing_buffer_mask,\n\t\t\t       enable_trace_buffered_event, NULL, 1);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffered_event_enable",
          "args": [],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffered_event_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2179-2212",
          "snippet": "void trace_buffered_event_enable(void)\n{\n\tstruct ring_buffer_event *event;\n\tstruct page *page;\n\tint cpu;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&event_mutex));\n\n\tif (trace_buffered_event_ref++)\n\t\treturn;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tpage = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\tGFP_KERNEL | __GFP_NORETRY, 0);\n\t\tif (!page)\n\t\t\tgoto failed;\n\n\t\tevent = page_address(page);\n\t\tmemset(event, 0, sizeof(*event));\n\n\t\tper_cpu(trace_buffered_event, cpu) = event;\n\n\t\tpreempt_disable();\n\t\tif (cpu == smp_processor_id() &&\n\t\t    this_cpu_read(trace_buffered_event) !=\n\t\t    per_cpu(trace_buffered_event, cpu))\n\t\t\tWARN_ON_ONCE(1);\n\t\tpreempt_enable();\n\t}\n\n\treturn;\n failed:\n\ttrace_buffered_event_disable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static int trace_buffered_event_ref;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic int trace_buffered_event_ref;\n\nvoid trace_buffered_event_enable(void)\n{\n\tstruct ring_buffer_event *event;\n\tstruct page *page;\n\tint cpu;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&event_mutex));\n\n\tif (trace_buffered_event_ref++)\n\t\treturn;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tpage = alloc_pages_node(cpu_to_node(cpu),\n\t\t\t\t\tGFP_KERNEL | __GFP_NORETRY, 0);\n\t\tif (!page)\n\t\t\tgoto failed;\n\n\t\tevent = page_address(page);\n\t\tmemset(event, 0, sizeof(*event));\n\n\t\tper_cpu(trace_buffered_event, cpu) = event;\n\n\t\tpreempt_disable();\n\t\tif (cpu == smp_processor_id() &&\n\t\t    this_cpu_read(trace_buffered_event) !=\n\t\t    per_cpu(trace_buffered_event, cpu))\n\t\t\tWARN_ON_ONCE(1);\n\t\tpreempt_enable();\n\t}\n\n\treturn;\n failed:\n\ttrace_buffered_event_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EVENT_FILE_FL_WAS_ENABLED_BIT",
            "&file->flags"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\"",
            "trace_event_name(call)"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_stop_tgid_record",
          "args": [],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop_tgid_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_switch.c",
          "lines": "144-147",
          "snippet": "void tracing_stop_tgid_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_TGID);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_TGID\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_TGID\t2\n\nvoid tracing_stop_tgid_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_TGID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop_cmdline_record",
          "args": [],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop_cmdline_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_switch.c",
          "lines": "134-137",
          "snippet": "void tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call->class->reg",
          "args": [
            "call",
            "TRACE_REG_REGISTER",
            "file"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_start_tgid_record",
          "args": [],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start_tgid_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_switch.c",
          "lines": "139-142",
          "snippet": "void tracing_start_tgid_record(void)\n{\n\ttracing_start_sched_switch(RECORD_TGID);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_TGID\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_TGID\t2\n\nvoid tracing_start_tgid_record(void)\n{\n\ttracing_start_sched_switch(RECORD_TGID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start_cmdline_record",
          "args": [],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start_cmdline_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_switch.c",
          "lines": "129-132",
          "snippet": "void tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&file->sm_ref"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EVENT_FILE_FL_SOFT_DISABLED_BIT",
            "&file->flags"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "792-801",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call->class->reg",
          "args": [
            "call",
            "TRACE_REG_UNREGISTER",
            "file"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&file->sm_ref"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic int __ftrace_event_enable_disable(struct trace_event_file *file,\n\t\t\t\t\t int enable, int soft_disable)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct trace_array *tr = file->tr;\n\tunsigned long file_flags = file->flags;\n\tint ret = 0;\n\tint disable;\n\n\tswitch (enable) {\n\tcase 0:\n\t\t/*\n\t\t * When soft_disable is set and enable is cleared, the sm_ref\n\t\t * reference counter is decremented. If it reaches 0, we want\n\t\t * to clear the SOFT_DISABLED flag but leave the event in the\n\t\t * state that it was. That is, if the event was enabled and\n\t\t * SOFT_DISABLED isn't set, then do nothing. But if SOFT_DISABLED\n\t\t * is set we do not want the event to be enabled before we\n\t\t * clear the bit.\n\t\t *\n\t\t * When soft_disable is not set but the SOFT_MODE flag is,\n\t\t * we do nothing. Do not disable the tracepoint, otherwise\n\t\t * \"soft enable\"s (clearing the SOFT_DISABLED bit) wont work.\n\t\t */\n\t\tif (soft_disable) {\n\t\t\tif (atomic_dec_return(&file->sm_ref) > 0)\n\t\t\t\tbreak;\n\t\t\tdisable = file->flags & EVENT_FILE_FL_SOFT_DISABLED;\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t} else\n\t\t\tdisable = !(file->flags & EVENT_FILE_FL_SOFT_MODE);\n\n\t\tif (disable && (file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tclear_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_CMD) {\n\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (file->flags & EVENT_FILE_FL_RECORDED_TGID) {\n\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tcall->class->reg(call, TRACE_REG_UNREGISTER, file);\n\t\t}\n\t\t/* If in SOFT_MODE, just set the SOFT_DISABLE_BIT, else clear it */\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_MODE)\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * When soft_disable is set and enable is set, we want to\n\t\t * register the tracepoint for the event, but leave the event\n\t\t * as is. That means, if the event was already enabled, we do\n\t\t * nothing (but set SOFT_MODE). If the event is disabled, we\n\t\t * set SOFT_DISABLED before enabling the event tracepoint, so\n\t\t * it still seems to be disabled.\n\t\t */\n\t\tif (!soft_disable)\n\t\t\tclear_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\t\telse {\n\t\t\tif (atomic_inc_return(&file->sm_ref) > 1)\n\t\t\t\tbreak;\n\t\t\tset_bit(EVENT_FILE_FL_SOFT_MODE_BIT, &file->flags);\n\t\t}\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED)) {\n\t\t\tbool cmd = false, tgid = false;\n\n\t\t\t/* Keep the event disabled, when going to SOFT_MODE. */\n\t\t\tif (soft_disable)\n\t\t\t\tset_bit(EVENT_FILE_FL_SOFT_DISABLED_BIT, &file->flags);\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_CMD) {\n\t\t\t\tcmd = true;\n\t\t\t\ttracing_start_cmdline_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tif (tr->trace_flags & TRACE_ITER_RECORD_TGID) {\n\t\t\t\ttgid = true;\n\t\t\t\ttracing_start_tgid_record();\n\t\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t\t}\n\n\t\t\tret = call->class->reg(call, TRACE_REG_REGISTER, file);\n\t\t\tif (ret) {\n\t\t\t\tif (cmd)\n\t\t\t\t\ttracing_stop_cmdline_record();\n\t\t\t\tif (tgid)\n\t\t\t\t\ttracing_stop_tgid_record();\n\t\t\t\tpr_info(\"event trace: Could not enable event \"\n\t\t\t\t\t\"%s\\n\", trace_event_name(call));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit(EVENT_FILE_FL_ENABLED_BIT, &file->flags);\n\n\t\t\t/* WAS_ENABLED gets set but never cleared. */\n\t\t\tset_bit(EVENT_FILE_FL_WAS_ENABLED_BIT, &file->flags);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Enable or disable use of trace_buffered_event */\n\tif ((file_flags & EVENT_FILE_FL_SOFT_DISABLED) !=\n\t    (file->flags & EVENT_FILE_FL_SOFT_DISABLED)) {\n\t\tif (file->flags & EVENT_FILE_FL_SOFT_DISABLED)\n\t\t\ttrace_buffered_event_enable();\n\t\telse\n\t\t\ttrace_buffered_event_disable();\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_event_enable_tgid_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "347-367",
    "snippet": "void trace_event_enable_tgid_record(bool enable)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr;\n\n\tmutex_lock(&event_mutex);\n\tdo_for_each_event_file(tr, file) {\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED))\n\t\t\tcontinue;\n\n\t\tif (enable) {\n\t\t\ttracing_start_tgid_record();\n\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t} else {\n\t\t\ttracing_stop_tgid_record();\n\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT,\n\t\t\t\t  &file->flags);\n\t\t}\n\t} while_for_each_event_file();\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_for_each_event_file",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EVENT_FILE_FL_RECORDED_TGID_BIT",
            "&file->flags"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "792-801",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop_tgid_record",
          "args": [],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop_tgid_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_switch.c",
          "lines": "144-147",
          "snippet": "void tracing_stop_tgid_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_TGID);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_TGID\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_TGID\t2\n\nvoid tracing_stop_tgid_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_TGID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EVENT_FILE_FL_RECORDED_TGID_BIT",
            "&file->flags"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start_tgid_record",
          "args": [],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start_tgid_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_switch.c",
          "lines": "139-142",
          "snippet": "void tracing_start_tgid_record(void)\n{\n\ttracing_start_sched_switch(RECORD_TGID);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_TGID\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_TGID\t2\n\nvoid tracing_start_tgid_record(void)\n{\n\ttracing_start_sched_switch(RECORD_TGID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_event_file",
          "args": [
            "tr",
            "file"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nvoid trace_event_enable_tgid_record(bool enable)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr;\n\n\tmutex_lock(&event_mutex);\n\tdo_for_each_event_file(tr, file) {\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED))\n\t\t\tcontinue;\n\n\t\tif (enable) {\n\t\t\ttracing_start_tgid_record();\n\t\t\tset_bit(EVENT_FILE_FL_RECORDED_TGID_BIT, &file->flags);\n\t\t} else {\n\t\t\ttracing_stop_tgid_record();\n\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_TGID_BIT,\n\t\t\t\t  &file->flags);\n\t\t}\n\t} while_for_each_event_file();\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "trace_event_enable_cmd_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "325-345",
    "snippet": "void trace_event_enable_cmd_record(bool enable)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr;\n\n\tmutex_lock(&event_mutex);\n\tdo_for_each_event_file(tr, file) {\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED))\n\t\t\tcontinue;\n\n\t\tif (enable) {\n\t\t\ttracing_start_cmdline_record();\n\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t} else {\n\t\t\ttracing_stop_cmdline_record();\n\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t}\n\t} while_for_each_event_file();\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_for_each_event_file",
          "args": [],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EVENT_FILE_FL_RECORDED_CMD_BIT",
            "&file->flags"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "792-801",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop_cmdline_record",
          "args": [],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop_cmdline_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_switch.c",
          "lines": "134-137",
          "snippet": "void tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EVENT_FILE_FL_RECORDED_CMD_BIT",
            "&file->flags"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start_cmdline_record",
          "args": [],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start_cmdline_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_switch.c",
          "lines": "129-132",
          "snippet": "void tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_for_each_event_file",
          "args": [
            "tr",
            "file"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nvoid trace_event_enable_cmd_record(bool enable)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_array *tr;\n\n\tmutex_lock(&event_mutex);\n\tdo_for_each_event_file(tr, file) {\n\n\t\tif (!(file->flags & EVENT_FILE_FL_ENABLED))\n\t\t\tcontinue;\n\n\t\tif (enable) {\n\t\t\ttracing_start_cmdline_record();\n\t\t\tset_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t} else {\n\t\t\ttracing_stop_cmdline_record();\n\t\t\tclear_bit(EVENT_FILE_FL_RECORDED_CMD_BIT, &file->flags);\n\t\t}\n\t} while_for_each_event_file();\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "trace_event_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "287-322",
    "snippet": "int trace_event_reg(struct trace_event_call *call,\n\t\t    enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tWARN_ON(!(call->flags & TRACE_EVENT_FL_TRACEPOINT));\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn tracepoint_probe_register(call->tp,\n\t\t\t\t\t\t call->class->probe,\n\t\t\t\t\t\t file);\n\tcase TRACE_REG_UNREGISTER:\n\t\ttracepoint_probe_unregister(call->tp,\n\t\t\t\t\t    call->class->probe,\n\t\t\t\t\t    file);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn tracepoint_probe_register(call->tp,\n\t\t\t\t\t\t call->class->perf_probe,\n\t\t\t\t\t\t call);\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\ttracepoint_probe_unregister(call->tp,\n\t\t\t\t\t    call->class->perf_probe,\n\t\t\t\t\t    call);\n\t\treturn 0;\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
      "static int ftrace_event_release(struct inode *inode, struct file *file);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracepoint_probe_unregister",
          "args": [
            "call->tp",
            "call->class->perf_probe",
            "call"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_probe_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "360-371",
          "snippet": "int tracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\tret = tracepoint_remove_func(tp, &tp_func);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(tracepoints_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nint tracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\tret = tracepoint_remove_func(tp, &tp_func);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_probe_register",
          "args": [
            "call->tp",
            "call->class->perf_probe",
            "call"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_probe_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "346-349",
          "snippet": "int tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data)\n{\n\treturn tracepoint_probe_register_prio(tp, probe, data, TRACEPOINT_DEFAULT_PRIO);\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data)\n{\n\treturn tracepoint_probe_register_prio(tp, probe, data, TRACEPOINT_DEFAULT_PRIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(call->flags & TRACE_EVENT_FL_TRACEPOINT)"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_event_reg(struct trace_event_call *call,\n\t\t    enum trace_reg type, void *data)\n{\n\tstruct trace_event_file *file = data;\n\n\tWARN_ON(!(call->flags & TRACE_EVENT_FL_TRACEPOINT));\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\t\treturn tracepoint_probe_register(call->tp,\n\t\t\t\t\t\t call->class->probe,\n\t\t\t\t\t\t file);\n\tcase TRACE_REG_UNREGISTER:\n\t\ttracepoint_probe_unregister(call->tp,\n\t\t\t\t\t    call->class->probe,\n\t\t\t\t\t    file);\n\t\treturn 0;\n\n#ifdef CONFIG_PERF_EVENTS\n\tcase TRACE_REG_PERF_REGISTER:\n\t\treturn tracepoint_probe_register(call->tp,\n\t\t\t\t\t\t call->class->perf_probe,\n\t\t\t\t\t\t call);\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\ttracepoint_probe_unregister(call->tp,\n\t\t\t\t\t    call->class->perf_probe,\n\t\t\t\t\t    call);\n\t\treturn 0;\n\tcase TRACE_REG_PERF_OPEN:\n\tcase TRACE_REG_PERF_CLOSE:\n\tcase TRACE_REG_PERF_ADD:\n\tcase TRACE_REG_PERF_DEL:\n\t\treturn 0;\n#endif\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_event_buffer_reserve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "253-284",
    "snippet": "void *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\tlocal_save_flags(fbuffer->flags);\n\tfbuffer->pc = preempt_count();\n\t/*\n\t * If CONFIG_PREEMPT is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT))\n\t\tfbuffer->pc--;\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->flags, fbuffer->pc);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "fbuffer->event"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "272-275",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_lock_reserve",
          "args": [
            "&fbuffer->buffer",
            "trace_file",
            "event_call->event.type",
            "len",
            "fbuffer->flags",
            "fbuffer->pc"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_lock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2274-2312",
          "snippet": "struct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct ring_buffer **current_rb,\n\t\t\t  struct trace_event_file *trace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\tstruct ring_buffer_event *entry;\n\tint val;\n\n\t*current_rb = trace_file->tr->trace_buffer.buffer;\n\n\tif (!ring_buffer_time_stamp_abs(*current_rb) && (trace_file->flags &\n\t     (EVENT_FILE_FL_SOFT_DISABLED | EVENT_FILE_FL_FILTERED)) &&\n\t    (entry = this_cpu_read(trace_buffered_event))) {\n\t\t/* Try to use the per cpu buffer first */\n\t\tval = this_cpu_inc_return(trace_buffered_event_cnt);\n\t\tif (val == 1) {\n\t\t\ttrace_event_setup(entry, type, flags, pc);\n\t\t\tentry->array[0] = len;\n\t\t\treturn entry;\n\t\t}\n\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t}\n\n\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t    type, len, flags, pc);\n\t/*\n\t * If tracing is off, but we have triggers enabled\n\t * we still need to look at the event data. Use the temp_buffer\n\t * to store the trace event for the tigger to use. It's recusive\n\t * safe and will not be recorded anywhere.\n\t */\n\tif (!entry && trace_file->flags & EVENT_FILE_FL_TRIGGER_COND) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t\t    type, len, flags, pc);\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static struct ring_buffer *temp_buffer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic struct ring_buffer *temp_buffer;\n\nstruct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct ring_buffer **current_rb,\n\t\t\t  struct trace_event_file *trace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\tstruct ring_buffer_event *entry;\n\tint val;\n\n\t*current_rb = trace_file->tr->trace_buffer.buffer;\n\n\tif (!ring_buffer_time_stamp_abs(*current_rb) && (trace_file->flags &\n\t     (EVENT_FILE_FL_SOFT_DISABLED | EVENT_FILE_FL_FILTERED)) &&\n\t    (entry = this_cpu_read(trace_buffered_event))) {\n\t\t/* Try to use the per cpu buffer first */\n\t\tval = this_cpu_inc_return(trace_buffered_event_cnt);\n\t\tif (val == 1) {\n\t\t\ttrace_event_setup(entry, type, flags, pc);\n\t\t\tentry->array[0] = len;\n\t\t\treturn entry;\n\t\t}\n\t\tthis_cpu_dec(trace_buffered_event_cnt);\n\t}\n\n\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t    type, len, flags, pc);\n\t/*\n\t * If tracing is off, but we have triggers enabled\n\t * we still need to look at the event data. Use the temp_buffer\n\t * to store the trace event for the tigger to use. It's recusive\n\t * safe and will not be recorded anywhere.\n\t */\n\tif (!entry && trace_file->flags & EVENT_FILE_FL_TRIGGER_COND) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = __trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t\t    type, len, flags, pc);\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_save_flags",
          "args": [
            "fbuffer->flags"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_ignore_this_pid",
          "args": [
            "trace_file"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_ignore_this_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "237-250",
          "snippet": "bool trace_event_ignore_this_pid(struct trace_event_file *trace_file)\n{\n\tstruct trace_array *tr = trace_file->tr;\n\tstruct trace_array_cpu *data;\n\tstruct trace_pid_list *pid_list;\n\n\tpid_list = rcu_dereference_raw(tr->filtered_pids);\n\tif (!pid_list)\n\t\treturn false;\n\n\tdata = this_cpu_ptr(tr->trace_buffer.data);\n\n\treturn data->ignore_pid;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nbool trace_event_ignore_this_pid(struct trace_event_file *trace_file)\n{\n\tstruct trace_array *tr = trace_file->tr;\n\tstruct trace_array_cpu *data;\n\tstruct trace_pid_list *pid_list;\n\n\tpid_list = rcu_dereference_raw(tr->filtered_pids);\n\tif (!pid_list)\n\t\treturn false;\n\n\tdata = this_cpu_ptr(tr->trace_buffer.data);\n\n\treturn data->ignore_pid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nvoid *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\tlocal_save_flags(fbuffer->flags);\n\tfbuffer->pc = preempt_count();\n\t/*\n\t * If CONFIG_PREEMPT is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT))\n\t\tfbuffer->pc--;\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->flags, fbuffer->pc);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}"
  },
  {
    "function_name": "trace_event_ignore_this_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "237-250",
    "snippet": "bool trace_event_ignore_this_pid(struct trace_event_file *trace_file)\n{\n\tstruct trace_array *tr = trace_file->tr;\n\tstruct trace_array_cpu *data;\n\tstruct trace_pid_list *pid_list;\n\n\tpid_list = rcu_dereference_raw(tr->filtered_pids);\n\tif (!pid_list)\n\t\treturn false;\n\n\tdata = this_cpu_ptr(tr->trace_buffer.data);\n\n\treturn data->ignore_pid;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "tr->trace_buffer.data"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "tr->filtered_pids"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nbool trace_event_ignore_this_pid(struct trace_event_file *trace_file)\n{\n\tstruct trace_array *tr = trace_file->tr;\n\tstruct trace_array_cpu *data;\n\tstruct trace_pid_list *pid_list;\n\n\tpid_list = rcu_dereference_raw(tr->filtered_pids);\n\tif (!pid_list)\n\t\treturn false;\n\n\tdata = this_cpu_ptr(tr->trace_buffer.data);\n\n\treturn data->ignore_pid;\n}"
  },
  {
    "function_name": "trace_event_raw_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "225-234",
    "snippet": "int trace_event_raw_init(struct trace_event_call *call)\n{\n\tint id;\n\n\tid = register_trace_event(&call->event);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_trace_event",
          "args": [
            "&call->event"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_output.c",
          "lines": "818-825",
          "snippet": "int unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_event_raw_init(struct trace_event_call *call)\n{\n\tint id;\n\n\tid = register_trace_event(&call->event);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_event_get_offsets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "211-223",
    "snippet": "int trace_event_get_offsets(struct trace_event_call *call)\n{\n\tstruct ftrace_event_field *tail;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\t/*\n\t * head->next points to the last field with the largest offset,\n\t * since it was added last by trace_define_field()\n\t */\n\ttail = list_first_entry(head, struct ftrace_event_field, link);\n\treturn tail->offset + tail->size;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "head",
            "structftrace_event_field",
            "link"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_get_fields",
          "args": [
            "call"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "73-79",
          "snippet": "static struct list_head *\ntrace_get_fields(struct trace_event_call *event_call)\n{\n\tif (!event_call->class->get_fields)\n\t\treturn &event_call->class->fields;\n\treturn event_call->class->get_fields(event_call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic struct list_head *\ntrace_get_fields(struct trace_event_call *event_call)\n{\n\tif (!event_call->class->get_fields)\n\t\treturn &event_call->class->fields;\n\treturn event_call->class->get_fields(event_call);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_event_get_offsets(struct trace_event_call *call)\n{\n\tstruct ftrace_event_field *tail;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\t/*\n\t * head->next points to the last field with the largest offset,\n\t * since it was added last by trace_define_field()\n\t */\n\ttail = list_first_entry(head, struct ftrace_event_field, link);\n\treturn tail->offset + tail->size;\n}"
  },
  {
    "function_name": "trace_destroy_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "195-205",
    "snippet": "static void trace_destroy_fields(struct trace_event_call *call)\n{\n\tstruct ftrace_event_field *field, *next;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tlist_for_each_entry_safe(field, next, head, link) {\n\t\tlist_del(&field->link);\n\t\tkmem_cache_free(field_cachep, field);\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *field_cachep;",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "field_cachep",
            "field"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&field->link"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "field",
            "next",
            "head",
            "link"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_get_fields",
          "args": [
            "call"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "73-79",
          "snippet": "static struct list_head *\ntrace_get_fields(struct trace_event_call *event_call)\n{\n\tif (!event_call->class->get_fields)\n\t\treturn &event_call->class->fields;\n\treturn event_call->class->get_fields(event_call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic struct list_head *\ntrace_get_fields(struct trace_event_call *event_call)\n{\n\tif (!event_call->class->get_fields)\n\t\treturn &event_call->class->fields;\n\treturn event_call->class->get_fields(event_call);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic struct kmem_cache *field_cachep;\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstatic void trace_destroy_fields(struct trace_event_call *call)\n{\n\tstruct ftrace_event_field *field, *next;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tlist_for_each_entry_safe(field, next, head, link) {\n\t\tlist_del(&field->link);\n\t\tkmem_cache_free(field_cachep, field);\n\t}\n}"
  },
  {
    "function_name": "trace_define_common_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "182-193",
    "snippet": "static int trace_define_common_fields(void)\n{\n\tint ret;\n\tstruct trace_entry ent;\n\n\t__common_field(unsigned short, type);\n\t__common_field(unsigned char, flags);\n\t__common_field(unsigned char, preempt_count);\n\t__common_field(int, pid);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__common_field",
          "args": [
            "int",
            "pid"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int trace_define_common_fields(void)\n{\n\tint ret;\n\tstruct trace_entry ent;\n\n\t__common_field(unsigned short, type);\n\t__common_field(unsigned char, flags);\n\t__common_field(unsigned char, preempt_count);\n\t__common_field(int, pid);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_define_generic_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "170-180",
    "snippet": "static int trace_define_generic_fields(void)\n{\n\tint ret;\n\n\t__generic_field(int, CPU, FILTER_CPU);\n\t__generic_field(int, cpu, FILTER_CPU);\n\t__generic_field(char *, COMM, FILTER_COMM);\n\t__generic_field(char *, comm, FILTER_COMM);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__generic_field",
          "args": [
            "int",
            "cpu",
            "FILTER_CPU"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__generic_field",
          "args": [
            "int",
            "CPU",
            "FILTER_CPU"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int trace_define_generic_fields(void)\n{\n\tint ret;\n\n\t__generic_field(int, CPU, FILTER_CPU);\n\t__generic_field(int, cpu, FILTER_CPU);\n\t__generic_field(char *, COMM, FILTER_COMM);\n\t__generic_field(char *, comm, FILTER_COMM);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_define_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "139-151",
    "snippet": "int trace_define_field(struct trace_event_call *call, const char *type,\n\t\t       const char *name, int offset, int size, int is_signed,\n\t\t       int filter_type)\n{\n\tstruct list_head *head;\n\n\tif (WARN_ON(!call->class))\n\t\treturn 0;\n\n\thead = trace_get_fields(call);\n\treturn __trace_define_field(head, type, name, offset, size,\n\t\t\t\t    is_signed, filter_type);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__trace_define_field",
          "args": [
            "head",
            "type",
            "name",
            "offset",
            "size",
            "is_signed",
            "filter_type"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_define_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "112-137",
          "snippet": "static int __trace_define_field(struct list_head *head, const char *type,\n\t\t\t\tconst char *name, int offset, int size,\n\t\t\t\tint is_signed, int filter_type)\n{\n\tstruct ftrace_event_field *field;\n\n\tfield = kmem_cache_alloc(field_cachep, GFP_TRACE);\n\tif (!field)\n\t\treturn -ENOMEM;\n\n\tfield->name = name;\n\tfield->type = type;\n\n\tif (filter_type == FILTER_OTHER)\n\t\tfield->filter_type = filter_assign_type(type);\n\telse\n\t\tfield->filter_type = filter_type;\n\n\tfield->offset = offset;\n\tfield->size = size;\n\tfield->is_signed = is_signed;\n\n\tlist_add(&field->link, head);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [
            "#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)"
          ],
          "globals_used": [
            "static struct kmem_cache *field_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)\n\nstatic struct kmem_cache *field_cachep;\n\nstatic int __trace_define_field(struct list_head *head, const char *type,\n\t\t\t\tconst char *name, int offset, int size,\n\t\t\t\tint is_signed, int filter_type)\n{\n\tstruct ftrace_event_field *field;\n\n\tfield = kmem_cache_alloc(field_cachep, GFP_TRACE);\n\tif (!field)\n\t\treturn -ENOMEM;\n\n\tfield->name = name;\n\tfield->type = type;\n\n\tif (filter_type == FILTER_OTHER)\n\t\tfield->filter_type = filter_assign_type(type);\n\telse\n\t\tfield->filter_type = filter_type;\n\n\tfield->offset = offset;\n\tfield->size = size;\n\tfield->is_signed = is_signed;\n\n\tlist_add(&field->link, head);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_get_fields",
          "args": [
            "call"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "73-79",
          "snippet": "static struct list_head *\ntrace_get_fields(struct trace_event_call *event_call)\n{\n\tif (!event_call->class->get_fields)\n\t\treturn &event_call->class->fields;\n\treturn event_call->class->get_fields(event_call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic struct list_head *\ntrace_get_fields(struct trace_event_call *event_call)\n{\n\tif (!event_call->class->get_fields)\n\t\treturn &event_call->class->fields;\n\treturn event_call->class->get_fields(event_call);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!call->class"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_define_field(struct trace_event_call *call, const char *type,\n\t\t       const char *name, int offset, int size, int is_signed,\n\t\t       int filter_type)\n{\n\tstruct list_head *head;\n\n\tif (WARN_ON(!call->class))\n\t\treturn 0;\n\n\thead = trace_get_fields(call);\n\treturn __trace_define_field(head, type, name, offset, size,\n\t\t\t\t    is_signed, filter_type);\n}"
  },
  {
    "function_name": "__trace_define_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "112-137",
    "snippet": "static int __trace_define_field(struct list_head *head, const char *type,\n\t\t\t\tconst char *name, int offset, int size,\n\t\t\t\tint is_signed, int filter_type)\n{\n\tstruct ftrace_event_field *field;\n\n\tfield = kmem_cache_alloc(field_cachep, GFP_TRACE);\n\tif (!field)\n\t\treturn -ENOMEM;\n\n\tfield->name = name;\n\tfield->type = type;\n\n\tif (filter_type == FILTER_OTHER)\n\t\tfield->filter_type = filter_assign_type(type);\n\telse\n\t\tfield->filter_type = filter_type;\n\n\tfield->offset = offset;\n\tfield->size = size;\n\tfield->is_signed = is_signed;\n\n\tlist_add(&field->link, head);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [
      "#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)"
    ],
    "globals_used": [
      "static struct kmem_cache *field_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&field->link",
            "head"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_assign_type",
          "args": [
            "type"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "filter_assign_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_filter.c",
          "lines": "1058-1067",
          "snippet": "int filter_assign_type(const char *type)\n{\n\tif (strstr(type, \"__data_loc\") && strstr(type, \"char\"))\n\t\treturn FILTER_DYN_STRING;\n\n\tif (strchr(type, '[') && strstr(type, \"char\"))\n\t\treturn FILTER_STATIC_STRING;\n\n\treturn FILTER_OTHER;\n}",
          "includes": [
            "#include \"trace_events_filter_test.h\"",
            "#include <linux/tracepoint.h>",
            "#include <linux/types.h>",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_events_filter_test.h\"\n#include <linux/tracepoint.h>\n#include <linux/types.h>\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint filter_assign_type(const char *type)\n{\n\tif (strstr(type, \"__data_loc\") && strstr(type, \"char\"))\n\t\treturn FILTER_DYN_STRING;\n\n\tif (strchr(type, '[') && strstr(type, \"char\"))\n\t\treturn FILTER_STATIC_STRING;\n\n\treturn FILTER_OTHER;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "field_cachep",
            "GFP_TRACE"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#define GFP_TRACE (GFP_KERNEL | __GFP_ZERO)\n\nstatic struct kmem_cache *field_cachep;\n\nstatic int __trace_define_field(struct list_head *head, const char *type,\n\t\t\t\tconst char *name, int offset, int size,\n\t\t\t\tint is_signed, int filter_type)\n{\n\tstruct ftrace_event_field *field;\n\n\tfield = kmem_cache_alloc(field_cachep, GFP_TRACE);\n\tif (!field)\n\t\treturn -ENOMEM;\n\n\tfield->name = name;\n\tfield->type = type;\n\n\tif (filter_type == FILTER_OTHER)\n\t\tfield->filter_type = filter_assign_type(type);\n\telse\n\t\tfield->filter_type = filter_type;\n\n\tfield->offset = offset;\n\tfield->size = size;\n\tfield->is_signed = is_signed;\n\n\tlist_add(&field->link, head);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_find_event_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "94-110",
    "snippet": "struct ftrace_event_field *\ntrace_find_event_field(struct trace_event_call *call, char *name)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tfield = __find_event_field(head, name);\n\tif (field)\n\t\treturn field;\n\n\tfield = __find_event_field(&ftrace_generic_fields, name);\n\tif (field)\n\t\treturn field;\n\n\treturn __find_event_field(&ftrace_common_fields, name);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(ftrace_generic_fields);",
      "static LIST_HEAD(ftrace_common_fields);",
      "static void __add_event_to_tracers(struct trace_event_call *call);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__find_event_field",
          "args": [
            "&ftrace_common_fields",
            "name"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "__find_event_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "81-92",
          "snippet": "static struct ftrace_event_field *\n__find_event_field(struct list_head *head, char *name)\n{\n\tstruct ftrace_event_field *field;\n\n\tlist_for_each_entry(field, head, link) {\n\t\tif (!strcmp(field->name, name))\n\t\t\treturn field;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic struct ftrace_event_field *\n__find_event_field(struct list_head *head, char *name)\n{\n\tstruct ftrace_event_field *field;\n\n\tlist_for_each_entry(field, head, link) {\n\t\tif (!strcmp(field->name, name))\n\t\t\treturn field;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_get_fields",
          "args": [
            "call"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "trace_get_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "73-79",
          "snippet": "static struct list_head *\ntrace_get_fields(struct trace_event_call *event_call)\n{\n\tif (!event_call->class->get_fields)\n\t\treturn &event_call->class->fields;\n\treturn event_call->class->get_fields(event_call);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic struct list_head *\ntrace_get_fields(struct trace_event_call *event_call)\n{\n\tif (!event_call->class->get_fields)\n\t\treturn &event_call->class->fields;\n\treturn event_call->class->get_fields(event_call);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic LIST_HEAD(ftrace_generic_fields);\nstatic LIST_HEAD(ftrace_common_fields);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstruct ftrace_event_field *\ntrace_find_event_field(struct trace_event_call *call, char *name)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tfield = __find_event_field(head, name);\n\tif (field)\n\t\treturn field;\n\n\tfield = __find_event_field(&ftrace_generic_fields, name);\n\tif (field)\n\t\treturn field;\n\n\treturn __find_event_field(&ftrace_common_fields, name);\n}"
  },
  {
    "function_name": "__find_event_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "81-92",
    "snippet": "static struct ftrace_event_field *\n__find_event_field(struct list_head *head, char *name)\n{\n\tstruct ftrace_event_field *field;\n\n\tlist_for_each_entry(field, head, link) {\n\t\tif (!strcmp(field->name, name))\n\t\t\treturn field;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field->name",
            "name"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "field",
            "head",
            "link"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic struct ftrace_event_field *\n__find_event_field(struct list_head *head, char *name)\n{\n\tstruct ftrace_event_field *field;\n\n\tlist_for_each_entry(field, head, link) {\n\t\tif (!strcmp(field->name, name))\n\t\t\treturn field;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "trace_get_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "73-79",
    "snippet": "static struct list_head *\ntrace_get_fields(struct trace_event_call *event_call)\n{\n\tif (!event_call->class->get_fields)\n\t\treturn &event_call->class->fields;\n\treturn event_call->class->get_fields(event_call);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_call->class->get_fields",
          "args": [
            "event_call"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic struct list_head *\ntrace_get_fields(struct trace_event_call *event_call)\n{\n\tif (!event_call->class->get_fields)\n\t\treturn &event_call->class->fields;\n\treturn event_call->class->get_fields(event_call);\n}"
  },
  {
    "function_name": "system_refcount_dec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "55-58",
    "snippet": "static int system_refcount_dec(struct event_subsystem *system)\n{\n\treturn --system->ref_count;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_dec(struct event_subsystem *system)\n{\n\treturn --system->ref_count;\n}"
  },
  {
    "function_name": "system_refcount_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "50-53",
    "snippet": "static int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int system_refcount_inc(struct event_subsystem *system)\n{\n\treturn system->ref_count++;\n}"
  },
  {
    "function_name": "system_refcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
    "lines": "45-48",
    "snippet": "static inline int system_refcount(struct event_subsystem *system)\n{\n\treturn system->ref_count;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include <asm/setup.h>",
      "#include <trace/events/sched.h>",
      "#include <linux/delay.h>",
      "#include <linux/slab.h>",
      "#include <linux/sort.h>",
      "#include <linux/ctype.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/tracefs.h>",
      "#include <linux/kthread.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/workqueue.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic inline int system_refcount(struct event_subsystem *system)\n{\n\treturn system->ref_count;\n}"
  }
]