[
  {
    "function_name": "klp_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "1049-1064",
    "snippet": "static int __init klp_init(void)\n{\n\tint ret;\n\n\tret = klp_check_compiler_support();\n\tif (ret) {\n\t\tpr_info(\"Your compiler is too old; turning off.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tklp_root_kobj = kobject_create_and_add(\"livepatch\", kernel_kobj);\n\tif (!klp_root_kobj)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kobject *klp_root_kobj;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_create_and_add",
          "args": [
            "\"livepatch\"",
            "kernel_kobj"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Your compiler is too old; turning off.\\n\""
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_check_compiler_support",
          "args": [],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct kobject *klp_root_kobj;\n\nstatic int __init klp_init(void)\n{\n\tint ret;\n\n\tret = klp_check_compiler_support();\n\tif (ret) {\n\t\tpr_info(\"Your compiler is too old; turning off.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tklp_root_kobj = kobject_create_and_add(\"livepatch\", kernel_kobj);\n\tif (!klp_root_kobj)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "klp_module_going",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "1030-1047",
    "snippet": "void klp_module_going(struct module *mod)\n{\n\tif (WARN_ON(mod->state != MODULE_STATE_GOING &&\n\t\t    mod->state != MODULE_STATE_COMING))\n\t\treturn;\n\n\tmutex_lock(&klp_mutex);\n\t/*\n\t * Each module has to know that klp_module_going()\n\t * has been called. We never know what module will\n\t * get patched by a new patch.\n\t */\n\tmod->klp_alive = false;\n\n\tklp_cleanup_module_patches_limited(mod, NULL);\n\n\tmutex_unlock(&klp_mutex);\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&klp_mutex"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_cleanup_module_patches_limited",
          "args": [
            "mod",
            "NULL"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "klp_cleanup_module_patches_limited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "912-946",
          "snippet": "static void klp_cleanup_module_patches_limited(struct module *mod,\n\t\t\t\t\t       struct klp_patch *limit)\n{\n\tstruct klp_patch *patch;\n\tstruct klp_object *obj;\n\n\tlist_for_each_entry(patch, &klp_patches, list) {\n\t\tif (patch == limit)\n\t\t\tbreak;\n\n\t\tklp_for_each_object(patch, obj) {\n\t\t\tif (!klp_is_module(obj) || strcmp(obj->name, mod->name))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Only unpatch the module if the patch is enabled or\n\t\t\t * is in transition.\n\t\t\t */\n\t\t\tif (patch->enabled || patch == klp_transition_patch) {\n\n\t\t\t\tif (patch != klp_transition_patch)\n\t\t\t\t\tklp_pre_unpatch_callback(obj);\n\n\t\t\t\tpr_notice(\"reverting patch '%s' on unloading module '%s'\\n\",\n\t\t\t\t\t  patch->mod->name, obj->mod->name);\n\t\t\t\tklp_unpatch_object(obj);\n\n\t\t\t\tklp_post_unpatch_callback(obj);\n\t\t\t}\n\n\t\t\tklp_free_object_loaded(obj);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_patches);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(klp_patches);\n\nstatic void klp_cleanup_module_patches_limited(struct module *mod,\n\t\t\t\t\t       struct klp_patch *limit)\n{\n\tstruct klp_patch *patch;\n\tstruct klp_object *obj;\n\n\tlist_for_each_entry(patch, &klp_patches, list) {\n\t\tif (patch == limit)\n\t\t\tbreak;\n\n\t\tklp_for_each_object(patch, obj) {\n\t\t\tif (!klp_is_module(obj) || strcmp(obj->name, mod->name))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Only unpatch the module if the patch is enabled or\n\t\t\t * is in transition.\n\t\t\t */\n\t\t\tif (patch->enabled || patch == klp_transition_patch) {\n\n\t\t\t\tif (patch != klp_transition_patch)\n\t\t\t\t\tklp_pre_unpatch_callback(obj);\n\n\t\t\t\tpr_notice(\"reverting patch '%s' on unloading module '%s'\\n\",\n\t\t\t\t\t  patch->mod->name, obj->mod->name);\n\t\t\t\tklp_unpatch_object(obj);\n\n\t\t\t\tklp_post_unpatch_callback(obj);\n\t\t\t}\n\n\t\t\tklp_free_object_loaded(obj);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&klp_mutex"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "mod->state != MODULE_STATE_GOING &&\n\t\t    mod->state != MODULE_STATE_COMING"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nvoid klp_module_going(struct module *mod)\n{\n\tif (WARN_ON(mod->state != MODULE_STATE_GOING &&\n\t\t    mod->state != MODULE_STATE_COMING))\n\t\treturn;\n\n\tmutex_lock(&klp_mutex);\n\t/*\n\t * Each module has to know that klp_module_going()\n\t * has been called. We never know what module will\n\t * get patched by a new patch.\n\t */\n\tmod->klp_alive = false;\n\n\tklp_cleanup_module_patches_limited(mod, NULL);\n\n\tmutex_unlock(&klp_mutex);\n}"
  },
  {
    "function_name": "klp_module_coming",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "948-1028",
    "snippet": "int klp_module_coming(struct module *mod)\n{\n\tint ret;\n\tstruct klp_patch *patch;\n\tstruct klp_object *obj;\n\n\tif (WARN_ON(mod->state != MODULE_STATE_COMING))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&klp_mutex);\n\t/*\n\t * Each module has to know that klp_module_coming()\n\t * has been called. We never know what module will\n\t * get patched by a new patch.\n\t */\n\tmod->klp_alive = true;\n\n\tlist_for_each_entry(patch, &klp_patches, list) {\n\t\tklp_for_each_object(patch, obj) {\n\t\t\tif (!klp_is_module(obj) || strcmp(obj->name, mod->name))\n\t\t\t\tcontinue;\n\n\t\t\tobj->mod = mod;\n\n\t\t\tret = klp_init_object_loaded(patch, obj);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"failed to initialize patch '%s' for module '%s' (%d)\\n\",\n\t\t\t\t\tpatch->mod->name, obj->mod->name, ret);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Only patch the module if the patch is enabled or is\n\t\t\t * in transition.\n\t\t\t */\n\t\t\tif (!patch->enabled && patch != klp_transition_patch)\n\t\t\t\tbreak;\n\n\t\t\tpr_notice(\"applying patch '%s' to loading module '%s'\\n\",\n\t\t\t\t  patch->mod->name, obj->mod->name);\n\n\t\t\tret = klp_pre_patch_callback(obj);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"pre-patch callback failed for object '%s'\\n\",\n\t\t\t\t\tobj->name);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tret = klp_patch_object(obj);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"failed to apply patch '%s' to module '%s' (%d)\\n\",\n\t\t\t\t\tpatch->mod->name, obj->mod->name, ret);\n\n\t\t\t\tklp_post_unpatch_callback(obj);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (patch != klp_transition_patch)\n\t\t\t\tklp_post_patch_callback(obj);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&klp_mutex);\n\n\treturn 0;\n\nerr:\n\t/*\n\t * If a patch is unsuccessfully applied, return\n\t * error to the module loader.\n\t */\n\tpr_warn(\"patch '%s' failed for module '%s', refusing to load module '%s'\\n\",\n\t\tpatch->mod->name, obj->mod->name, obj->mod->name);\n\tmod->klp_alive = false;\n\tklp_cleanup_module_patches_limited(mod, patch);\n\tmutex_unlock(&klp_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(klp_patches);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&klp_mutex"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_cleanup_module_patches_limited",
          "args": [
            "mod",
            "patch"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "klp_cleanup_module_patches_limited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "912-946",
          "snippet": "static void klp_cleanup_module_patches_limited(struct module *mod,\n\t\t\t\t\t       struct klp_patch *limit)\n{\n\tstruct klp_patch *patch;\n\tstruct klp_object *obj;\n\n\tlist_for_each_entry(patch, &klp_patches, list) {\n\t\tif (patch == limit)\n\t\t\tbreak;\n\n\t\tklp_for_each_object(patch, obj) {\n\t\t\tif (!klp_is_module(obj) || strcmp(obj->name, mod->name))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Only unpatch the module if the patch is enabled or\n\t\t\t * is in transition.\n\t\t\t */\n\t\t\tif (patch->enabled || patch == klp_transition_patch) {\n\n\t\t\t\tif (patch != klp_transition_patch)\n\t\t\t\t\tklp_pre_unpatch_callback(obj);\n\n\t\t\t\tpr_notice(\"reverting patch '%s' on unloading module '%s'\\n\",\n\t\t\t\t\t  patch->mod->name, obj->mod->name);\n\t\t\t\tklp_unpatch_object(obj);\n\n\t\t\t\tklp_post_unpatch_callback(obj);\n\t\t\t}\n\n\t\t\tklp_free_object_loaded(obj);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_patches);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(klp_patches);\n\nstatic void klp_cleanup_module_patches_limited(struct module *mod,\n\t\t\t\t\t       struct klp_patch *limit)\n{\n\tstruct klp_patch *patch;\n\tstruct klp_object *obj;\n\n\tlist_for_each_entry(patch, &klp_patches, list) {\n\t\tif (patch == limit)\n\t\t\tbreak;\n\n\t\tklp_for_each_object(patch, obj) {\n\t\t\tif (!klp_is_module(obj) || strcmp(obj->name, mod->name))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Only unpatch the module if the patch is enabled or\n\t\t\t * is in transition.\n\t\t\t */\n\t\t\tif (patch->enabled || patch == klp_transition_patch) {\n\n\t\t\t\tif (patch != klp_transition_patch)\n\t\t\t\t\tklp_pre_unpatch_callback(obj);\n\n\t\t\t\tpr_notice(\"reverting patch '%s' on unloading module '%s'\\n\",\n\t\t\t\t\t  patch->mod->name, obj->mod->name);\n\t\t\t\tklp_unpatch_object(obj);\n\n\t\t\t\tklp_post_unpatch_callback(obj);\n\t\t\t}\n\n\t\t\tklp_free_object_loaded(obj);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"patch '%s' failed for module '%s', refusing to load module '%s'\\n\"",
            "patch->mod->name",
            "obj->mod->name",
            "obj->mod->name"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_post_patch_callback",
          "args": [
            "obj"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "klp_post_patch_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.h",
          "lines": "26-30",
          "snippet": "static inline void klp_post_patch_callback(struct klp_object *obj)\n{\n\tif (obj->callbacks.post_patch)\n\t\t(*obj->callbacks.post_patch)(obj);\n}",
          "includes": [
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n\nstatic inline void klp_post_patch_callback(struct klp_object *obj)\n{\n\tif (obj->callbacks.post_patch)\n\t\t(*obj->callbacks.post_patch)(obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_post_unpatch_callback",
          "args": [
            "obj"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "klp_post_unpatch_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.h",
          "lines": "38-45",
          "snippet": "static inline void klp_post_unpatch_callback(struct klp_object *obj)\n{\n\tif (obj->callbacks.post_unpatch_enabled &&\n\t    obj->callbacks.post_unpatch)\n\t\t(*obj->callbacks.post_unpatch)(obj);\n\n\tobj->callbacks.post_unpatch_enabled = false;\n}",
          "includes": [
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n\nstatic inline void klp_post_unpatch_callback(struct klp_object *obj)\n{\n\tif (obj->callbacks.post_unpatch_enabled &&\n\t    obj->callbacks.post_unpatch)\n\t\t(*obj->callbacks.post_unpatch)(obj);\n\n\tobj->callbacks.post_unpatch_enabled = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"failed to apply patch '%s' to module '%s' (%d)\\n\"",
            "patch->mod->name",
            "obj->mod->name",
            "ret"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_patch_object",
          "args": [
            "obj"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "klp_patch_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
          "lines": "250-268",
          "snippet": "int klp_patch_object(struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\n\tif (WARN_ON(obj->patched))\n\t\treturn -EINVAL;\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_patch_func(func);\n\t\tif (ret) {\n\t\t\tklp_unpatch_object(obj);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tobj->patched = true;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nint klp_patch_object(struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\n\tif (WARN_ON(obj->patched))\n\t\treturn -EINVAL;\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_patch_func(func);\n\t\tif (ret) {\n\t\t\tklp_unpatch_object(obj);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tobj->patched = true;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"pre-patch callback failed for object '%s'\\n\"",
            "obj->name"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_pre_patch_callback",
          "args": [
            "obj"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "klp_pre_patch_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.h",
          "lines": "14-24",
          "snippet": "static inline int klp_pre_patch_callback(struct klp_object *obj)\n{\n\tint ret = 0;\n\n\tif (obj->callbacks.pre_patch)\n\t\tret = (*obj->callbacks.pre_patch)(obj);\n\n\tobj->callbacks.post_unpatch_enabled = !ret;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n\nstatic inline int klp_pre_patch_callback(struct klp_object *obj)\n{\n\tint ret = 0;\n\n\tif (obj->callbacks.pre_patch)\n\t\tret = (*obj->callbacks.pre_patch)(obj);\n\n\tobj->callbacks.post_unpatch_enabled = !ret;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"applying patch '%s' to loading module '%s'\\n\"",
            "patch->mod->name",
            "obj->mod->name"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"failed to initialize patch '%s' for module '%s' (%d)\\n\"",
            "patch->mod->name",
            "obj->mod->name",
            "ret"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_init_object_loaded",
          "args": [
            "patch",
            "obj"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "klp_init_object_loaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "705-746",
          "snippet": "static int klp_init_object_loaded(struct klp_patch *patch,\n\t\t\t\t  struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\n\tmodule_disable_ro(patch->mod);\n\tret = klp_write_object_relocations(patch->mod, obj);\n\tif (ret) {\n\t\tmodule_enable_ro(patch->mod, true);\n\t\treturn ret;\n\t}\n\n\tarch_klp_init_object_loaded(patch, obj);\n\tmodule_enable_ro(patch->mod, true);\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_find_object_symbol(obj->name, func->old_name,\n\t\t\t\t\t     func->old_sympos,\n\t\t\t\t\t     &func->old_addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = kallsyms_lookup_size_offset(func->old_addr,\n\t\t\t\t\t\t  &func->old_size, NULL);\n\t\tif (!ret) {\n\t\t\tpr_err(\"kallsyms size lookup failed for '%s'\\n\",\n\t\t\t       func->old_name);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tret = kallsyms_lookup_size_offset((unsigned long)func->new_func,\n\t\t\t\t\t\t  &func->new_size, NULL);\n\t\tif (!ret) {\n\t\t\tpr_err(\"kallsyms size lookup failed for '%s' replacement\\n\",\n\t\t\t       func->old_name);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int klp_init_object_loaded(struct klp_patch *patch,\n\t\t\t\t  struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\n\tmodule_disable_ro(patch->mod);\n\tret = klp_write_object_relocations(patch->mod, obj);\n\tif (ret) {\n\t\tmodule_enable_ro(patch->mod, true);\n\t\treturn ret;\n\t}\n\n\tarch_klp_init_object_loaded(patch, obj);\n\tmodule_enable_ro(patch->mod, true);\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_find_object_symbol(obj->name, func->old_name,\n\t\t\t\t\t     func->old_sympos,\n\t\t\t\t\t     &func->old_addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = kallsyms_lookup_size_offset(func->old_addr,\n\t\t\t\t\t\t  &func->old_size, NULL);\n\t\tif (!ret) {\n\t\t\tpr_err(\"kallsyms size lookup failed for '%s'\\n\",\n\t\t\t       func->old_name);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tret = kallsyms_lookup_size_offset((unsigned long)func->new_func,\n\t\t\t\t\t\t  &func->new_size, NULL);\n\t\tif (!ret) {\n\t\t\tpr_err(\"kallsyms size lookup failed for '%s' replacement\\n\",\n\t\t\t       func->old_name);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "obj->name",
            "mod->name"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_is_module",
          "args": [
            "obj"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "klp_is_module",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "52-55",
          "snippet": "static bool klp_is_module(struct klp_object *obj)\n{\n\treturn obj->name;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic bool klp_is_module(struct klp_object *obj)\n{\n\treturn obj->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_object",
          "args": [
            "patch",
            "obj"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "patch",
            "&klp_patches",
            "list"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&klp_mutex"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "mod->state != MODULE_STATE_COMING"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(klp_patches);\n\nint klp_module_coming(struct module *mod)\n{\n\tint ret;\n\tstruct klp_patch *patch;\n\tstruct klp_object *obj;\n\n\tif (WARN_ON(mod->state != MODULE_STATE_COMING))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&klp_mutex);\n\t/*\n\t * Each module has to know that klp_module_coming()\n\t * has been called. We never know what module will\n\t * get patched by a new patch.\n\t */\n\tmod->klp_alive = true;\n\n\tlist_for_each_entry(patch, &klp_patches, list) {\n\t\tklp_for_each_object(patch, obj) {\n\t\t\tif (!klp_is_module(obj) || strcmp(obj->name, mod->name))\n\t\t\t\tcontinue;\n\n\t\t\tobj->mod = mod;\n\n\t\t\tret = klp_init_object_loaded(patch, obj);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"failed to initialize patch '%s' for module '%s' (%d)\\n\",\n\t\t\t\t\tpatch->mod->name, obj->mod->name, ret);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Only patch the module if the patch is enabled or is\n\t\t\t * in transition.\n\t\t\t */\n\t\t\tif (!patch->enabled && patch != klp_transition_patch)\n\t\t\t\tbreak;\n\n\t\t\tpr_notice(\"applying patch '%s' to loading module '%s'\\n\",\n\t\t\t\t  patch->mod->name, obj->mod->name);\n\n\t\t\tret = klp_pre_patch_callback(obj);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"pre-patch callback failed for object '%s'\\n\",\n\t\t\t\t\tobj->name);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tret = klp_patch_object(obj);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"failed to apply patch '%s' to module '%s' (%d)\\n\",\n\t\t\t\t\tpatch->mod->name, obj->mod->name, ret);\n\n\t\t\t\tklp_post_unpatch_callback(obj);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (patch != klp_transition_patch)\n\t\t\t\tklp_post_patch_callback(obj);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&klp_mutex);\n\n\treturn 0;\n\nerr:\n\t/*\n\t * If a patch is unsuccessfully applied, return\n\t * error to the module loader.\n\t */\n\tpr_warn(\"patch '%s' failed for module '%s', refusing to load module '%s'\\n\",\n\t\tpatch->mod->name, obj->mod->name, obj->mod->name);\n\tmod->klp_alive = false;\n\tklp_cleanup_module_patches_limited(mod, patch);\n\tmutex_unlock(&klp_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "klp_cleanup_module_patches_limited",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "912-946",
    "snippet": "static void klp_cleanup_module_patches_limited(struct module *mod,\n\t\t\t\t\t       struct klp_patch *limit)\n{\n\tstruct klp_patch *patch;\n\tstruct klp_object *obj;\n\n\tlist_for_each_entry(patch, &klp_patches, list) {\n\t\tif (patch == limit)\n\t\t\tbreak;\n\n\t\tklp_for_each_object(patch, obj) {\n\t\t\tif (!klp_is_module(obj) || strcmp(obj->name, mod->name))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Only unpatch the module if the patch is enabled or\n\t\t\t * is in transition.\n\t\t\t */\n\t\t\tif (patch->enabled || patch == klp_transition_patch) {\n\n\t\t\t\tif (patch != klp_transition_patch)\n\t\t\t\t\tklp_pre_unpatch_callback(obj);\n\n\t\t\t\tpr_notice(\"reverting patch '%s' on unloading module '%s'\\n\",\n\t\t\t\t\t  patch->mod->name, obj->mod->name);\n\t\t\t\tklp_unpatch_object(obj);\n\n\t\t\t\tklp_post_unpatch_callback(obj);\n\t\t\t}\n\n\t\t\tklp_free_object_loaded(obj);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(klp_patches);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_free_object_loaded",
          "args": [
            "obj"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "klp_free_object_loaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "644-652",
          "snippet": "static void klp_free_object_loaded(struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\n\tobj->mod = NULL;\n\n\tklp_for_each_func(obj, func)\n\t\tfunc->old_addr = 0;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void klp_free_object_loaded(struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\n\tobj->mod = NULL;\n\n\tklp_for_each_func(obj, func)\n\t\tfunc->old_addr = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_post_unpatch_callback",
          "args": [
            "obj"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "klp_post_unpatch_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.h",
          "lines": "38-45",
          "snippet": "static inline void klp_post_unpatch_callback(struct klp_object *obj)\n{\n\tif (obj->callbacks.post_unpatch_enabled &&\n\t    obj->callbacks.post_unpatch)\n\t\t(*obj->callbacks.post_unpatch)(obj);\n\n\tobj->callbacks.post_unpatch_enabled = false;\n}",
          "includes": [
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n\nstatic inline void klp_post_unpatch_callback(struct klp_object *obj)\n{\n\tif (obj->callbacks.post_unpatch_enabled &&\n\t    obj->callbacks.post_unpatch)\n\t\t(*obj->callbacks.post_unpatch)(obj);\n\n\tobj->callbacks.post_unpatch_enabled = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_unpatch_object",
          "args": [
            "obj"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "klp_unpatch_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
          "lines": "270-277",
          "snippet": "void klp_unpatch_objects(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\tklp_unpatch_object(obj);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nvoid klp_unpatch_objects(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\tklp_unpatch_object(obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"reverting patch '%s' on unloading module '%s'\\n\"",
            "patch->mod->name",
            "obj->mod->name"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_pre_unpatch_callback",
          "args": [
            "obj"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "klp_pre_unpatch_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.h",
          "lines": "32-36",
          "snippet": "static inline void klp_pre_unpatch_callback(struct klp_object *obj)\n{\n\tif (obj->callbacks.pre_unpatch)\n\t\t(*obj->callbacks.pre_unpatch)(obj);\n}",
          "includes": [
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n\nstatic inline void klp_pre_unpatch_callback(struct klp_object *obj)\n{\n\tif (obj->callbacks.pre_unpatch)\n\t\t(*obj->callbacks.pre_unpatch)(obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "obj->name",
            "mod->name"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_is_module",
          "args": [
            "obj"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "klp_is_module",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "52-55",
          "snippet": "static bool klp_is_module(struct klp_object *obj)\n{\n\treturn obj->name;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic bool klp_is_module(struct klp_object *obj)\n{\n\treturn obj->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_object",
          "args": [
            "patch",
            "obj"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "patch",
            "&klp_patches",
            "list"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(klp_patches);\n\nstatic void klp_cleanup_module_patches_limited(struct module *mod,\n\t\t\t\t\t       struct klp_patch *limit)\n{\n\tstruct klp_patch *patch;\n\tstruct klp_object *obj;\n\n\tlist_for_each_entry(patch, &klp_patches, list) {\n\t\tif (patch == limit)\n\t\t\tbreak;\n\n\t\tklp_for_each_object(patch, obj) {\n\t\t\tif (!klp_is_module(obj) || strcmp(obj->name, mod->name))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Only unpatch the module if the patch is enabled or\n\t\t\t * is in transition.\n\t\t\t */\n\t\t\tif (patch->enabled || patch == klp_transition_patch) {\n\n\t\t\t\tif (patch != klp_transition_patch)\n\t\t\t\t\tklp_pre_unpatch_callback(obj);\n\n\t\t\t\tpr_notice(\"reverting patch '%s' on unloading module '%s'\\n\",\n\t\t\t\t\t  patch->mod->name, obj->mod->name);\n\t\t\t\tklp_unpatch_object(obj);\n\n\t\t\t\tklp_post_unpatch_callback(obj);\n\t\t\t}\n\n\t\t\tklp_free_object_loaded(obj);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "klp_register_patch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "884-904",
    "snippet": "int klp_register_patch(struct klp_patch *patch)\n{\n\tif (!patch || !patch->mod)\n\t\treturn -EINVAL;\n\n\tif (!is_livepatch_module(patch->mod)) {\n\t\tpr_err(\"module %s is not marked as a livepatch module\\n\",\n\t\t       patch->mod->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!klp_initialized())\n\t\treturn -ENODEV;\n\n\tif (!klp_have_reliable_stack()) {\n\t\tpr_err(\"This architecture doesn't have support for the livepatch consistency model.\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\treturn klp_init_patch(patch);\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_init_patch",
          "args": [
            "patch"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "klp_init_patch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "791-832",
          "snippet": "static int klp_init_patch(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\tint ret;\n\n\tif (!patch->objs)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&klp_mutex);\n\n\tpatch->enabled = false;\n\tinit_completion(&patch->finish);\n\n\tret = kobject_init_and_add(&patch->kobj, &klp_ktype_patch,\n\t\t\t\t   klp_root_kobj, \"%s\", patch->mod->name);\n\tif (ret) {\n\t\tmutex_unlock(&klp_mutex);\n\t\treturn ret;\n\t}\n\n\tklp_for_each_object(patch, obj) {\n\t\tret = klp_init_object(patch, obj);\n\t\tif (ret)\n\t\t\tgoto free;\n\t}\n\n\tlist_add_tail(&patch->list, &klp_patches);\n\n\tmutex_unlock(&klp_mutex);\n\n\treturn 0;\n\nfree:\n\tklp_free_objects_limited(patch, obj);\n\n\tmutex_unlock(&klp_mutex);\n\n\tkobject_put(&patch->kobj);\n\twait_for_completion(&patch->finish);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_patches);",
            "static struct kobject *klp_root_kobj;",
            "static struct kobj_type klp_ktype_patch = {\n\t.release = klp_kobj_release_patch,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_attrs = klp_patch_attrs,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(klp_patches);\nstatic struct kobject *klp_root_kobj;\nstatic struct kobj_type klp_ktype_patch = {\n\t.release = klp_kobj_release_patch,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_attrs = klp_patch_attrs,\n};\n\nstatic int klp_init_patch(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\tint ret;\n\n\tif (!patch->objs)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&klp_mutex);\n\n\tpatch->enabled = false;\n\tinit_completion(&patch->finish);\n\n\tret = kobject_init_and_add(&patch->kobj, &klp_ktype_patch,\n\t\t\t\t   klp_root_kobj, \"%s\", patch->mod->name);\n\tif (ret) {\n\t\tmutex_unlock(&klp_mutex);\n\t\treturn ret;\n\t}\n\n\tklp_for_each_object(patch, obj) {\n\t\tret = klp_init_object(patch, obj);\n\t\tif (ret)\n\t\t\tgoto free;\n\t}\n\n\tlist_add_tail(&patch->list, &klp_patches);\n\n\tmutex_unlock(&klp_mutex);\n\n\treturn 0;\n\nfree:\n\tklp_free_objects_limited(patch, obj);\n\n\tmutex_unlock(&klp_mutex);\n\n\tkobject_put(&patch->kobj);\n\twait_for_completion(&patch->finish);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"This architecture doesn't have support for the livepatch consistency model.\\n\""
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_have_reliable_stack",
          "args": [],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_initialized",
          "args": [],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "klp_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "96-99",
          "snippet": "static bool klp_initialized(void)\n{\n\treturn !!klp_root_kobj;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobject *klp_root_kobj;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct kobject *klp_root_kobj;\n\nstatic bool klp_initialized(void)\n{\n\treturn !!klp_root_kobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"module %s is not marked as a livepatch module\\n\"",
            "patch->mod->name"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_livepatch_module",
          "args": [
            "patch->mod"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nint klp_register_patch(struct klp_patch *patch)\n{\n\tif (!patch || !patch->mod)\n\t\treturn -EINVAL;\n\n\tif (!is_livepatch_module(patch->mod)) {\n\t\tpr_err(\"module %s is not marked as a livepatch module\\n\",\n\t\t       patch->mod->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!klp_initialized())\n\t\treturn -ENODEV;\n\n\tif (!klp_have_reliable_stack()) {\n\t\tpr_err(\"This architecture doesn't have support for the livepatch consistency model.\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\treturn klp_init_patch(patch);\n}"
  },
  {
    "function_name": "klp_unregister_patch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "842-869",
    "snippet": "int klp_unregister_patch(struct klp_patch *patch)\n{\n\tint ret;\n\n\tmutex_lock(&klp_mutex);\n\n\tif (!klp_is_patch_registered(patch)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (patch->enabled) {\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tklp_free_patch(patch);\n\n\tmutex_unlock(&klp_mutex);\n\n\tkobject_put(&patch->kobj);\n\twait_for_completion(&patch->finish);\n\n\treturn 0;\nerr:\n\tmutex_unlock(&klp_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&klp_mutex"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&patch->finish"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "&patch->kobj"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "mod_kobject_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1742-1748",
          "snippet": "static void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_free_patch",
          "args": [
            "patch"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "klp_free_patch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "669-674",
          "snippet": "static void klp_free_patch(struct klp_patch *patch)\n{\n\tklp_free_objects_limited(patch, NULL);\n\tif (!list_empty(&patch->list))\n\t\tlist_del(&patch->list);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void klp_free_patch(struct klp_patch *patch)\n{\n\tklp_free_objects_limited(patch, NULL);\n\tif (!list_empty(&patch->list))\n\t\tlist_del(&patch->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_is_patch_registered",
          "args": [
            "patch"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "klp_is_patch_registered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "85-94",
          "snippet": "static bool klp_is_patch_registered(struct klp_patch *patch)\n{\n\tstruct klp_patch *mypatch;\n\n\tlist_for_each_entry(mypatch, &klp_patches, list)\n\t\tif (mypatch == patch)\n\t\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_patches);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(klp_patches);\n\nstatic bool klp_is_patch_registered(struct klp_patch *patch)\n{\n\tstruct klp_patch *mypatch;\n\n\tlist_for_each_entry(mypatch, &klp_patches, list)\n\t\tif (mypatch == patch)\n\t\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&klp_mutex"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nint klp_unregister_patch(struct klp_patch *patch)\n{\n\tint ret;\n\n\tmutex_lock(&klp_mutex);\n\n\tif (!klp_is_patch_registered(patch)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (patch->enabled) {\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tklp_free_patch(patch);\n\n\tmutex_unlock(&klp_mutex);\n\n\tkobject_put(&patch->kobj);\n\twait_for_completion(&patch->finish);\n\n\treturn 0;\nerr:\n\tmutex_unlock(&klp_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "klp_init_patch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "791-832",
    "snippet": "static int klp_init_patch(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\tint ret;\n\n\tif (!patch->objs)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&klp_mutex);\n\n\tpatch->enabled = false;\n\tinit_completion(&patch->finish);\n\n\tret = kobject_init_and_add(&patch->kobj, &klp_ktype_patch,\n\t\t\t\t   klp_root_kobj, \"%s\", patch->mod->name);\n\tif (ret) {\n\t\tmutex_unlock(&klp_mutex);\n\t\treturn ret;\n\t}\n\n\tklp_for_each_object(patch, obj) {\n\t\tret = klp_init_object(patch, obj);\n\t\tif (ret)\n\t\t\tgoto free;\n\t}\n\n\tlist_add_tail(&patch->list, &klp_patches);\n\n\tmutex_unlock(&klp_mutex);\n\n\treturn 0;\n\nfree:\n\tklp_free_objects_limited(patch, obj);\n\n\tmutex_unlock(&klp_mutex);\n\n\tkobject_put(&patch->kobj);\n\twait_for_completion(&patch->finish);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(klp_patches);",
      "static struct kobject *klp_root_kobj;",
      "static struct kobj_type klp_ktype_patch = {\n\t.release = klp_kobj_release_patch,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_attrs = klp_patch_attrs,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&patch->finish"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "&patch->kobj"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "mod_kobject_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1742-1748",
          "snippet": "static void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&klp_mutex"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_free_objects_limited",
          "args": [
            "patch",
            "obj"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "klp_free_objects_limited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "658-667",
          "snippet": "static void klp_free_objects_limited(struct klp_patch *patch,\n\t\t\t\t     struct klp_object *limit)\n{\n\tstruct klp_object *obj;\n\n\tfor (obj = patch->objs; obj->funcs && obj != limit; obj++) {\n\t\tklp_free_funcs_limited(obj, NULL);\n\t\tkobject_put(&obj->kobj);\n\t}\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void klp_free_objects_limited(struct klp_patch *patch,\n\t\t\t\t     struct klp_object *limit)\n{\n\tstruct klp_object *obj;\n\n\tfor (obj = patch->objs; obj->funcs && obj != limit; obj++) {\n\t\tklp_free_funcs_limited(obj, NULL);\n\t\tkobject_put(&obj->kobj);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&patch->list",
            "&klp_patches"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_init_object",
          "args": [
            "patch",
            "obj"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "klp_init_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "748-789",
          "snippet": "static int klp_init_object(struct klp_patch *patch, struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\tconst char *name;\n\n\tif (!obj->funcs)\n\t\treturn -EINVAL;\n\n\tif (klp_is_module(obj) && strlen(obj->name) >= MODULE_NAME_LEN)\n\t\treturn -EINVAL;\n\n\tobj->patched = false;\n\tobj->mod = NULL;\n\n\tklp_find_object_module(obj);\n\n\tname = klp_is_module(obj) ? obj->name : \"vmlinux\";\n\tret = kobject_init_and_add(&obj->kobj, &klp_ktype_object,\n\t\t\t\t   &patch->kobj, \"%s\", name);\n\tif (ret)\n\t\treturn ret;\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_init_func(obj, func);\n\t\tif (ret)\n\t\t\tgoto free;\n\t}\n\n\tif (klp_is_object_loaded(obj)) {\n\t\tret = klp_init_object_loaded(patch, obj);\n\t\tif (ret)\n\t\t\tgoto free;\n\t}\n\n\treturn 0;\n\nfree:\n\tklp_free_funcs_limited(obj, func);\n\tkobject_put(&obj->kobj);\n\treturn ret;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobj_type klp_ktype_object = {\n\t.release = klp_kobj_release_object,\n\t.sysfs_ops = &kobj_sysfs_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct kobj_type klp_ktype_object = {\n\t.release = klp_kobj_release_object,\n\t.sysfs_ops = &kobj_sysfs_ops,\n};\n\nstatic int klp_init_object(struct klp_patch *patch, struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\tconst char *name;\n\n\tif (!obj->funcs)\n\t\treturn -EINVAL;\n\n\tif (klp_is_module(obj) && strlen(obj->name) >= MODULE_NAME_LEN)\n\t\treturn -EINVAL;\n\n\tobj->patched = false;\n\tobj->mod = NULL;\n\n\tklp_find_object_module(obj);\n\n\tname = klp_is_module(obj) ? obj->name : \"vmlinux\";\n\tret = kobject_init_and_add(&obj->kobj, &klp_ktype_object,\n\t\t\t\t   &patch->kobj, \"%s\", name);\n\tif (ret)\n\t\treturn ret;\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_init_func(obj, func);\n\t\tif (ret)\n\t\t\tgoto free;\n\t}\n\n\tif (klp_is_object_loaded(obj)) {\n\t\tret = klp_init_object_loaded(patch, obj);\n\t\tif (ret)\n\t\t\tgoto free;\n\t}\n\n\treturn 0;\n\nfree:\n\tklp_free_funcs_limited(obj, func);\n\tkobject_put(&obj->kobj);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_object",
          "args": [
            "patch",
            "obj"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_init_and_add",
          "args": [
            "&patch->kobj",
            "&klp_ktype_patch",
            "klp_root_kobj",
            "\"%s\"",
            "patch->mod->name"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&patch->finish"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&klp_mutex"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(klp_patches);\nstatic struct kobject *klp_root_kobj;\nstatic struct kobj_type klp_ktype_patch = {\n\t.release = klp_kobj_release_patch,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_attrs = klp_patch_attrs,\n};\n\nstatic int klp_init_patch(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\tint ret;\n\n\tif (!patch->objs)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&klp_mutex);\n\n\tpatch->enabled = false;\n\tinit_completion(&patch->finish);\n\n\tret = kobject_init_and_add(&patch->kobj, &klp_ktype_patch,\n\t\t\t\t   klp_root_kobj, \"%s\", patch->mod->name);\n\tif (ret) {\n\t\tmutex_unlock(&klp_mutex);\n\t\treturn ret;\n\t}\n\n\tklp_for_each_object(patch, obj) {\n\t\tret = klp_init_object(patch, obj);\n\t\tif (ret)\n\t\t\tgoto free;\n\t}\n\n\tlist_add_tail(&patch->list, &klp_patches);\n\n\tmutex_unlock(&klp_mutex);\n\n\treturn 0;\n\nfree:\n\tklp_free_objects_limited(patch, obj);\n\n\tmutex_unlock(&klp_mutex);\n\n\tkobject_put(&patch->kobj);\n\twait_for_completion(&patch->finish);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "klp_init_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "748-789",
    "snippet": "static int klp_init_object(struct klp_patch *patch, struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\tconst char *name;\n\n\tif (!obj->funcs)\n\t\treturn -EINVAL;\n\n\tif (klp_is_module(obj) && strlen(obj->name) >= MODULE_NAME_LEN)\n\t\treturn -EINVAL;\n\n\tobj->patched = false;\n\tobj->mod = NULL;\n\n\tklp_find_object_module(obj);\n\n\tname = klp_is_module(obj) ? obj->name : \"vmlinux\";\n\tret = kobject_init_and_add(&obj->kobj, &klp_ktype_object,\n\t\t\t\t   &patch->kobj, \"%s\", name);\n\tif (ret)\n\t\treturn ret;\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_init_func(obj, func);\n\t\tif (ret)\n\t\t\tgoto free;\n\t}\n\n\tif (klp_is_object_loaded(obj)) {\n\t\tret = klp_init_object_loaded(patch, obj);\n\t\tif (ret)\n\t\t\tgoto free;\n\t}\n\n\treturn 0;\n\nfree:\n\tklp_free_funcs_limited(obj, func);\n\tkobject_put(&obj->kobj);\n\treturn ret;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kobj_type klp_ktype_object = {\n\t.release = klp_kobj_release_object,\n\t.sysfs_ops = &kobj_sysfs_ops,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "&obj->kobj"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "mod_kobject_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1742-1748",
          "snippet": "static void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_free_funcs_limited",
          "args": [
            "obj",
            "func"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "klp_free_funcs_limited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "634-641",
          "snippet": "static void klp_free_funcs_limited(struct klp_object *obj,\n\t\t\t\t   struct klp_func *limit)\n{\n\tstruct klp_func *func;\n\n\tfor (func = obj->funcs; func->old_name && func != limit; func++)\n\t\tkobject_put(&func->kobj);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void klp_free_funcs_limited(struct klp_object *obj,\n\t\t\t\t   struct klp_func *limit)\n{\n\tstruct klp_func *func;\n\n\tfor (func = obj->funcs; func->old_name && func != limit; func++)\n\t\tkobject_put(&func->kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_init_object_loaded",
          "args": [
            "patch",
            "obj"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "klp_init_object_loaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "705-746",
          "snippet": "static int klp_init_object_loaded(struct klp_patch *patch,\n\t\t\t\t  struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\n\tmodule_disable_ro(patch->mod);\n\tret = klp_write_object_relocations(patch->mod, obj);\n\tif (ret) {\n\t\tmodule_enable_ro(patch->mod, true);\n\t\treturn ret;\n\t}\n\n\tarch_klp_init_object_loaded(patch, obj);\n\tmodule_enable_ro(patch->mod, true);\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_find_object_symbol(obj->name, func->old_name,\n\t\t\t\t\t     func->old_sympos,\n\t\t\t\t\t     &func->old_addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = kallsyms_lookup_size_offset(func->old_addr,\n\t\t\t\t\t\t  &func->old_size, NULL);\n\t\tif (!ret) {\n\t\t\tpr_err(\"kallsyms size lookup failed for '%s'\\n\",\n\t\t\t       func->old_name);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tret = kallsyms_lookup_size_offset((unsigned long)func->new_func,\n\t\t\t\t\t\t  &func->new_size, NULL);\n\t\tif (!ret) {\n\t\t\tpr_err(\"kallsyms size lookup failed for '%s' replacement\\n\",\n\t\t\t       func->old_name);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int klp_init_object_loaded(struct klp_patch *patch,\n\t\t\t\t  struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\n\tmodule_disable_ro(patch->mod);\n\tret = klp_write_object_relocations(patch->mod, obj);\n\tif (ret) {\n\t\tmodule_enable_ro(patch->mod, true);\n\t\treturn ret;\n\t}\n\n\tarch_klp_init_object_loaded(patch, obj);\n\tmodule_enable_ro(patch->mod, true);\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_find_object_symbol(obj->name, func->old_name,\n\t\t\t\t\t     func->old_sympos,\n\t\t\t\t\t     &func->old_addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = kallsyms_lookup_size_offset(func->old_addr,\n\t\t\t\t\t\t  &func->old_size, NULL);\n\t\tif (!ret) {\n\t\t\tpr_err(\"kallsyms size lookup failed for '%s'\\n\",\n\t\t\t       func->old_name);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tret = kallsyms_lookup_size_offset((unsigned long)func->new_func,\n\t\t\t\t\t\t  &func->new_size, NULL);\n\t\tif (!ret) {\n\t\t\tpr_err(\"kallsyms size lookup failed for '%s' replacement\\n\",\n\t\t\t       func->old_name);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_is_object_loaded",
          "args": [
            "obj"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "klp_is_object_loaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.h",
          "lines": "9-12",
          "snippet": "static inline bool klp_is_object_loaded(struct klp_object *obj)\n{\n\treturn !obj->name || obj->mod;\n}",
          "includes": [
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n\nstatic inline bool klp_is_object_loaded(struct klp_object *obj)\n{\n\treturn !obj->name || obj->mod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_init_func",
          "args": [
            "obj",
            "func"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "klp_init_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "676-696",
          "snippet": "static int klp_init_func(struct klp_object *obj, struct klp_func *func)\n{\n\tif (!func->old_name || !func->new_func)\n\t\treturn -EINVAL;\n\n\tif (strlen(func->old_name) >= KSYM_NAME_LEN)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&func->stack_node);\n\tfunc->patched = false;\n\tfunc->transition = false;\n\n\t/* The format for the sysfs directory is <function,sympos> where sympos\n\t * is the nth occurrence of this symbol in kallsyms for the patched\n\t * object. If the user selects 0 for old_sympos, then 1 will be used\n\t * since a unique symbol will be the first occurrence.\n\t */\n\treturn kobject_init_and_add(&func->kobj, &klp_ktype_func,\n\t\t\t\t    &obj->kobj, \"%s,%lu\", func->old_name,\n\t\t\t\t    func->old_sympos ? func->old_sympos : 1);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobj_type klp_ktype_func = {\n\t.release = klp_kobj_release_func,\n\t.sysfs_ops = &kobj_sysfs_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct kobj_type klp_ktype_func = {\n\t.release = klp_kobj_release_func,\n\t.sysfs_ops = &kobj_sysfs_ops,\n};\n\nstatic int klp_init_func(struct klp_object *obj, struct klp_func *func)\n{\n\tif (!func->old_name || !func->new_func)\n\t\treturn -EINVAL;\n\n\tif (strlen(func->old_name) >= KSYM_NAME_LEN)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&func->stack_node);\n\tfunc->patched = false;\n\tfunc->transition = false;\n\n\t/* The format for the sysfs directory is <function,sympos> where sympos\n\t * is the nth occurrence of this symbol in kallsyms for the patched\n\t * object. If the user selects 0 for old_sympos, then 1 will be used\n\t * since a unique symbol will be the first occurrence.\n\t */\n\treturn kobject_init_and_add(&func->kobj, &klp_ktype_func,\n\t\t\t\t    &obj->kobj, \"%s,%lu\", func->old_name,\n\t\t\t\t    func->old_sympos ? func->old_sympos : 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_func",
          "args": [
            "obj",
            "func"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_init_and_add",
          "args": [
            "&obj->kobj",
            "&klp_ktype_object",
            "&patch->kobj",
            "\"%s\"",
            "name"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_is_module",
          "args": [
            "obj"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "klp_is_module",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "52-55",
          "snippet": "static bool klp_is_module(struct klp_object *obj)\n{\n\treturn obj->name;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic bool klp_is_module(struct klp_object *obj)\n{\n\treturn obj->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_find_object_module",
          "args": [
            "obj"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "klp_find_object_module",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "58-83",
          "snippet": "static void klp_find_object_module(struct klp_object *obj)\n{\n\tstruct module *mod;\n\n\tif (!klp_is_module(obj))\n\t\treturn;\n\n\tmutex_lock(&module_mutex);\n\t/*\n\t * We do not want to block removal of patched modules and therefore\n\t * we do not take a reference here. The patches are removed by\n\t * klp_module_going() instead.\n\t */\n\tmod = find_module(obj->name);\n\t/*\n\t * Do not mess work of klp_module_coming() and klp_module_going().\n\t * Note that the patch might still be needed before klp_module_going()\n\t * is called. Module functions can be called even in the GOING state\n\t * until mod->exit() finishes. This is especially important for\n\t * patches that modify semantic of the functions.\n\t */\n\tif (mod && mod->klp_alive)\n\t\tobj->mod = mod;\n\n\tmutex_unlock(&module_mutex);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void klp_find_object_module(struct klp_object *obj)\n{\n\tstruct module *mod;\n\n\tif (!klp_is_module(obj))\n\t\treturn;\n\n\tmutex_lock(&module_mutex);\n\t/*\n\t * We do not want to block removal of patched modules and therefore\n\t * we do not take a reference here. The patches are removed by\n\t * klp_module_going() instead.\n\t */\n\tmod = find_module(obj->name);\n\t/*\n\t * Do not mess work of klp_module_coming() and klp_module_going().\n\t * Note that the patch might still be needed before klp_module_going()\n\t * is called. Module functions can be called even in the GOING state\n\t * until mod->exit() finishes. This is especially important for\n\t * patches that modify semantic of the functions.\n\t */\n\tif (mod && mod->klp_alive)\n\t\tobj->mod = mod;\n\n\tmutex_unlock(&module_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "obj->name"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct kobj_type klp_ktype_object = {\n\t.release = klp_kobj_release_object,\n\t.sysfs_ops = &kobj_sysfs_ops,\n};\n\nstatic int klp_init_object(struct klp_patch *patch, struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\tconst char *name;\n\n\tif (!obj->funcs)\n\t\treturn -EINVAL;\n\n\tif (klp_is_module(obj) && strlen(obj->name) >= MODULE_NAME_LEN)\n\t\treturn -EINVAL;\n\n\tobj->patched = false;\n\tobj->mod = NULL;\n\n\tklp_find_object_module(obj);\n\n\tname = klp_is_module(obj) ? obj->name : \"vmlinux\";\n\tret = kobject_init_and_add(&obj->kobj, &klp_ktype_object,\n\t\t\t\t   &patch->kobj, \"%s\", name);\n\tif (ret)\n\t\treturn ret;\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_init_func(obj, func);\n\t\tif (ret)\n\t\t\tgoto free;\n\t}\n\n\tif (klp_is_object_loaded(obj)) {\n\t\tret = klp_init_object_loaded(patch, obj);\n\t\tif (ret)\n\t\t\tgoto free;\n\t}\n\n\treturn 0;\n\nfree:\n\tklp_free_funcs_limited(obj, func);\n\tkobject_put(&obj->kobj);\n\treturn ret;\n}"
  },
  {
    "function_name": "klp_init_object_loaded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "705-746",
    "snippet": "static int klp_init_object_loaded(struct klp_patch *patch,\n\t\t\t\t  struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\n\tmodule_disable_ro(patch->mod);\n\tret = klp_write_object_relocations(patch->mod, obj);\n\tif (ret) {\n\t\tmodule_enable_ro(patch->mod, true);\n\t\treturn ret;\n\t}\n\n\tarch_klp_init_object_loaded(patch, obj);\n\tmodule_enable_ro(patch->mod, true);\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_find_object_symbol(obj->name, func->old_name,\n\t\t\t\t\t     func->old_sympos,\n\t\t\t\t\t     &func->old_addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = kallsyms_lookup_size_offset(func->old_addr,\n\t\t\t\t\t\t  &func->old_size, NULL);\n\t\tif (!ret) {\n\t\t\tpr_err(\"kallsyms size lookup failed for '%s'\\n\",\n\t\t\t       func->old_name);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tret = kallsyms_lookup_size_offset((unsigned long)func->new_func,\n\t\t\t\t\t\t  &func->new_size, NULL);\n\t\tif (!ret) {\n\t\t\tpr_err(\"kallsyms size lookup failed for '%s' replacement\\n\",\n\t\t\t       func->old_name);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"kallsyms size lookup failed for '%s' replacement\\n\"",
            "func->old_name"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup_size_offset",
          "args": [
            "(unsigned long)func->new_func",
            "&func->new_size",
            "NULL"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup_size_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "260-269",
          "snippet": "int kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr))\n\t\treturn !!get_symbol_pos(addr, symbolsize, offset);\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr))\n\t\treturn !!get_symbol_pos(addr, symbolsize, offset);\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"kallsyms size lookup failed for '%s'\\n\"",
            "func->old_name"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_find_object_symbol",
          "args": [
            "obj->name",
            "func->old_name",
            "func->old_sympos",
            "&func->old_addr"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "klp_find_object_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "137-174",
          "snippet": "static int klp_find_object_symbol(const char *objname, const char *name,\n\t\t\t\t  unsigned long sympos, unsigned long *addr)\n{\n\tstruct klp_find_arg args = {\n\t\t.objname = objname,\n\t\t.name = name,\n\t\t.addr = 0,\n\t\t.count = 0,\n\t\t.pos = sympos,\n\t};\n\n\tmutex_lock(&module_mutex);\n\tif (objname)\n\t\tmodule_kallsyms_on_each_symbol(klp_find_callback, &args);\n\telse\n\t\tkallsyms_on_each_symbol(klp_find_callback, &args);\n\tmutex_unlock(&module_mutex);\n\n\t/*\n\t * Ensure an address was found. If sympos is 0, ensure symbol is unique;\n\t * otherwise ensure the symbol position count matches sympos.\n\t */\n\tif (args.addr == 0)\n\t\tpr_err(\"symbol '%s' not found in symbol table\\n\", name);\n\telse if (args.count > 1 && sympos == 0) {\n\t\tpr_err(\"unresolvable ambiguity for symbol '%s' in object '%s'\\n\",\n\t\t       name, objname);\n\t} else if (sympos != args.count && sympos > 0) {\n\t\tpr_err(\"symbol position %lu for symbol '%s' in object '%s' not found\\n\",\n\t\t       sympos, name, objname ? objname : \"vmlinux\");\n\t} else {\n\t\t*addr = args.addr;\n\t\treturn 0;\n\t}\n\n\t*addr = 0;\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int klp_find_object_symbol(const char *objname, const char *name,\n\t\t\t\t  unsigned long sympos, unsigned long *addr)\n{\n\tstruct klp_find_arg args = {\n\t\t.objname = objname,\n\t\t.name = name,\n\t\t.addr = 0,\n\t\t.count = 0,\n\t\t.pos = sympos,\n\t};\n\n\tmutex_lock(&module_mutex);\n\tif (objname)\n\t\tmodule_kallsyms_on_each_symbol(klp_find_callback, &args);\n\telse\n\t\tkallsyms_on_each_symbol(klp_find_callback, &args);\n\tmutex_unlock(&module_mutex);\n\n\t/*\n\t * Ensure an address was found. If sympos is 0, ensure symbol is unique;\n\t * otherwise ensure the symbol position count matches sympos.\n\t */\n\tif (args.addr == 0)\n\t\tpr_err(\"symbol '%s' not found in symbol table\\n\", name);\n\telse if (args.count > 1 && sympos == 0) {\n\t\tpr_err(\"unresolvable ambiguity for symbol '%s' in object '%s'\\n\",\n\t\t       name, objname);\n\t} else if (sympos != args.count && sympos > 0) {\n\t\tpr_err(\"symbol position %lu for symbol '%s' in object '%s' not found\\n\",\n\t\t       sympos, name, objname ? objname : \"vmlinux\");\n\t} else {\n\t\t*addr = args.addr;\n\t\treturn 0;\n\t}\n\n\t*addr = 0;\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_func",
          "args": [
            "obj",
            "func"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_enable_ro",
          "args": [
            "patch->mod",
            "true"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "module_enable_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1944-1956",
          "snippet": "void module_enable_ro(const struct module *mod, bool after_init)\n{\n\tif (!rodata_enabled)\n\t\treturn;\n\n\tfrob_text(&mod->core_layout, set_memory_ro);\n\tfrob_rodata(&mod->core_layout, set_memory_ro);\n\tfrob_text(&mod->init_layout, set_memory_ro);\n\tfrob_rodata(&mod->init_layout, set_memory_ro);\n\n\tif (after_init)\n\t\tfrob_ro_after_init(&mod->core_layout, set_memory_ro);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_enable_ro(const struct module *mod, bool after_init)\n{\n\tif (!rodata_enabled)\n\t\treturn;\n\n\tfrob_text(&mod->core_layout, set_memory_ro);\n\tfrob_rodata(&mod->core_layout, set_memory_ro);\n\tfrob_text(&mod->init_layout, set_memory_ro);\n\tfrob_rodata(&mod->init_layout, set_memory_ro);\n\n\tif (after_init)\n\t\tfrob_ro_after_init(&mod->core_layout, set_memory_ro);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_klp_init_object_loaded",
          "args": [
            "patch",
            "obj"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "arch_klp_init_object_loaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "699-702",
          "snippet": "void __weak arch_klp_init_object_loaded(struct klp_patch *patch,\n\t\t\t\t\tstruct klp_object *obj)\n{\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nvoid __weak arch_klp_init_object_loaded(struct klp_patch *patch,\n\t\t\t\t\tstruct klp_object *obj)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_write_object_relocations",
          "args": [
            "patch->mod",
            "obj"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "klp_write_object_relocations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "231-279",
          "snippet": "static int klp_write_object_relocations(struct module *pmod,\n\t\t\t\t\tstruct klp_object *obj)\n{\n\tint i, cnt, ret = 0;\n\tconst char *objname, *secname;\n\tchar sec_objname[MODULE_NAME_LEN];\n\tElf_Shdr *sec;\n\n\tif (WARN_ON(!klp_is_object_loaded(obj)))\n\t\treturn -EINVAL;\n\n\tobjname = klp_is_module(obj) ? obj->name : \"vmlinux\";\n\n\t/* For each klp relocation section */\n\tfor (i = 1; i < pmod->klp_info->hdr.e_shnum; i++) {\n\t\tsec = pmod->klp_info->sechdrs + i;\n\t\tsecname = pmod->klp_info->secstrings + sec->sh_name;\n\t\tif (!(sec->sh_flags & SHF_RELA_LIVEPATCH))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Format: .klp.rela.sec_objname.section_name\n\t\t * See comment in klp_resolve_symbols() for an explanation\n\t\t * of the selected field width value.\n\t\t */\n\t\tcnt = sscanf(secname, \".klp.rela.%55[^.]\", sec_objname);\n\t\tif (cnt != 1) {\n\t\t\tpr_err(\"section %s has an incorrectly formatted name\\n\",\n\t\t\t       secname);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strcmp(objname, sec_objname))\n\t\t\tcontinue;\n\n\t\tret = klp_resolve_symbols(sec, pmod);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = apply_relocate_add(pmod->klp_info->sechdrs,\n\t\t\t\t\t pmod->core_kallsyms.strtab,\n\t\t\t\t\t pmod->klp_info->symndx, i, pmod);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int klp_write_object_relocations(struct module *pmod,\n\t\t\t\t\tstruct klp_object *obj)\n{\n\tint i, cnt, ret = 0;\n\tconst char *objname, *secname;\n\tchar sec_objname[MODULE_NAME_LEN];\n\tElf_Shdr *sec;\n\n\tif (WARN_ON(!klp_is_object_loaded(obj)))\n\t\treturn -EINVAL;\n\n\tobjname = klp_is_module(obj) ? obj->name : \"vmlinux\";\n\n\t/* For each klp relocation section */\n\tfor (i = 1; i < pmod->klp_info->hdr.e_shnum; i++) {\n\t\tsec = pmod->klp_info->sechdrs + i;\n\t\tsecname = pmod->klp_info->secstrings + sec->sh_name;\n\t\tif (!(sec->sh_flags & SHF_RELA_LIVEPATCH))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Format: .klp.rela.sec_objname.section_name\n\t\t * See comment in klp_resolve_symbols() for an explanation\n\t\t * of the selected field width value.\n\t\t */\n\t\tcnt = sscanf(secname, \".klp.rela.%55[^.]\", sec_objname);\n\t\tif (cnt != 1) {\n\t\t\tpr_err(\"section %s has an incorrectly formatted name\\n\",\n\t\t\t       secname);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strcmp(objname, sec_objname))\n\t\t\tcontinue;\n\n\t\tret = klp_resolve_symbols(sec, pmod);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = apply_relocate_add(pmod->klp_info->sechdrs,\n\t\t\t\t\t pmod->core_kallsyms.strtab,\n\t\t\t\t\t pmod->klp_info->symndx, i, pmod);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_disable_ro",
          "args": [
            "patch->mod"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "module_disable_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1932-1942",
          "snippet": "void module_disable_ro(const struct module *mod)\n{\n\tif (!rodata_enabled)\n\t\treturn;\n\n\tfrob_text(&mod->core_layout, set_memory_rw);\n\tfrob_rodata(&mod->core_layout, set_memory_rw);\n\tfrob_ro_after_init(&mod->core_layout, set_memory_rw);\n\tfrob_text(&mod->init_layout, set_memory_rw);\n\tfrob_rodata(&mod->init_layout, set_memory_rw);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_disable_ro(const struct module *mod)\n{\n\tif (!rodata_enabled)\n\t\treturn;\n\n\tfrob_text(&mod->core_layout, set_memory_rw);\n\tfrob_rodata(&mod->core_layout, set_memory_rw);\n\tfrob_ro_after_init(&mod->core_layout, set_memory_rw);\n\tfrob_text(&mod->init_layout, set_memory_rw);\n\tfrob_rodata(&mod->init_layout, set_memory_rw);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int klp_init_object_loaded(struct klp_patch *patch,\n\t\t\t\t  struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\n\tmodule_disable_ro(patch->mod);\n\tret = klp_write_object_relocations(patch->mod, obj);\n\tif (ret) {\n\t\tmodule_enable_ro(patch->mod, true);\n\t\treturn ret;\n\t}\n\n\tarch_klp_init_object_loaded(patch, obj);\n\tmodule_enable_ro(patch->mod, true);\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_find_object_symbol(obj->name, func->old_name,\n\t\t\t\t\t     func->old_sympos,\n\t\t\t\t\t     &func->old_addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = kallsyms_lookup_size_offset(func->old_addr,\n\t\t\t\t\t\t  &func->old_size, NULL);\n\t\tif (!ret) {\n\t\t\tpr_err(\"kallsyms size lookup failed for '%s'\\n\",\n\t\t\t       func->old_name);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tret = kallsyms_lookup_size_offset((unsigned long)func->new_func,\n\t\t\t\t\t\t  &func->new_size, NULL);\n\t\tif (!ret) {\n\t\t\tpr_err(\"kallsyms size lookup failed for '%s' replacement\\n\",\n\t\t\t       func->old_name);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_klp_init_object_loaded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "699-702",
    "snippet": "void __weak arch_klp_init_object_loaded(struct klp_patch *patch,\n\t\t\t\t\tstruct klp_object *obj)\n{\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nvoid __weak arch_klp_init_object_loaded(struct klp_patch *patch,\n\t\t\t\t\tstruct klp_object *obj)\n{\n}"
  },
  {
    "function_name": "klp_init_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "676-696",
    "snippet": "static int klp_init_func(struct klp_object *obj, struct klp_func *func)\n{\n\tif (!func->old_name || !func->new_func)\n\t\treturn -EINVAL;\n\n\tif (strlen(func->old_name) >= KSYM_NAME_LEN)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&func->stack_node);\n\tfunc->patched = false;\n\tfunc->transition = false;\n\n\t/* The format for the sysfs directory is <function,sympos> where sympos\n\t * is the nth occurrence of this symbol in kallsyms for the patched\n\t * object. If the user selects 0 for old_sympos, then 1 will be used\n\t * since a unique symbol will be the first occurrence.\n\t */\n\treturn kobject_init_and_add(&func->kobj, &klp_ktype_func,\n\t\t\t\t    &obj->kobj, \"%s,%lu\", func->old_name,\n\t\t\t\t    func->old_sympos ? func->old_sympos : 1);\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kobj_type klp_ktype_func = {\n\t.release = klp_kobj_release_func,\n\t.sysfs_ops = &kobj_sysfs_ops,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_init_and_add",
          "args": [
            "&func->kobj",
            "&klp_ktype_func",
            "&obj->kobj",
            "\"%s,%lu\"",
            "func->old_name",
            "func->old_sympos ? func->old_sympos : 1"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&func->stack_node"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func->old_name"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct kobj_type klp_ktype_func = {\n\t.release = klp_kobj_release_func,\n\t.sysfs_ops = &kobj_sysfs_ops,\n};\n\nstatic int klp_init_func(struct klp_object *obj, struct klp_func *func)\n{\n\tif (!func->old_name || !func->new_func)\n\t\treturn -EINVAL;\n\n\tif (strlen(func->old_name) >= KSYM_NAME_LEN)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&func->stack_node);\n\tfunc->patched = false;\n\tfunc->transition = false;\n\n\t/* The format for the sysfs directory is <function,sympos> where sympos\n\t * is the nth occurrence of this symbol in kallsyms for the patched\n\t * object. If the user selects 0 for old_sympos, then 1 will be used\n\t * since a unique symbol will be the first occurrence.\n\t */\n\treturn kobject_init_and_add(&func->kobj, &klp_ktype_func,\n\t\t\t\t    &obj->kobj, \"%s,%lu\", func->old_name,\n\t\t\t\t    func->old_sympos ? func->old_sympos : 1);\n}"
  },
  {
    "function_name": "klp_free_patch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "669-674",
    "snippet": "static void klp_free_patch(struct klp_patch *patch)\n{\n\tklp_free_objects_limited(patch, NULL);\n\tif (!list_empty(&patch->list))\n\t\tlist_del(&patch->list);\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&patch->list"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&patch->list"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_free_objects_limited",
          "args": [
            "patch",
            "NULL"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "klp_free_objects_limited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "658-667",
          "snippet": "static void klp_free_objects_limited(struct klp_patch *patch,\n\t\t\t\t     struct klp_object *limit)\n{\n\tstruct klp_object *obj;\n\n\tfor (obj = patch->objs; obj->funcs && obj != limit; obj++) {\n\t\tklp_free_funcs_limited(obj, NULL);\n\t\tkobject_put(&obj->kobj);\n\t}\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void klp_free_objects_limited(struct klp_patch *patch,\n\t\t\t\t     struct klp_object *limit)\n{\n\tstruct klp_object *obj;\n\n\tfor (obj = patch->objs; obj->funcs && obj != limit; obj++) {\n\t\tklp_free_funcs_limited(obj, NULL);\n\t\tkobject_put(&obj->kobj);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void klp_free_patch(struct klp_patch *patch)\n{\n\tklp_free_objects_limited(patch, NULL);\n\tif (!list_empty(&patch->list))\n\t\tlist_del(&patch->list);\n}"
  },
  {
    "function_name": "klp_free_objects_limited",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "658-667",
    "snippet": "static void klp_free_objects_limited(struct klp_patch *patch,\n\t\t\t\t     struct klp_object *limit)\n{\n\tstruct klp_object *obj;\n\n\tfor (obj = patch->objs; obj->funcs && obj != limit; obj++) {\n\t\tklp_free_funcs_limited(obj, NULL);\n\t\tkobject_put(&obj->kobj);\n\t}\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "&obj->kobj"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "mod_kobject_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1742-1748",
          "snippet": "static void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_free_funcs_limited",
          "args": [
            "obj",
            "NULL"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "klp_free_funcs_limited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "634-641",
          "snippet": "static void klp_free_funcs_limited(struct klp_object *obj,\n\t\t\t\t   struct klp_func *limit)\n{\n\tstruct klp_func *func;\n\n\tfor (func = obj->funcs; func->old_name && func != limit; func++)\n\t\tkobject_put(&func->kobj);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void klp_free_funcs_limited(struct klp_object *obj,\n\t\t\t\t   struct klp_func *limit)\n{\n\tstruct klp_func *func;\n\n\tfor (func = obj->funcs; func->old_name && func != limit; func++)\n\t\tkobject_put(&func->kobj);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void klp_free_objects_limited(struct klp_patch *patch,\n\t\t\t\t     struct klp_object *limit)\n{\n\tstruct klp_object *obj;\n\n\tfor (obj = patch->objs; obj->funcs && obj != limit; obj++) {\n\t\tklp_free_funcs_limited(obj, NULL);\n\t\tkobject_put(&obj->kobj);\n\t}\n}"
  },
  {
    "function_name": "klp_free_object_loaded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "644-652",
    "snippet": "static void klp_free_object_loaded(struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\n\tobj->mod = NULL;\n\n\tklp_for_each_func(obj, func)\n\t\tfunc->old_addr = 0;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_for_each_func",
          "args": [
            "obj",
            "func"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void klp_free_object_loaded(struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\n\tobj->mod = NULL;\n\n\tklp_for_each_func(obj, func)\n\t\tfunc->old_addr = 0;\n}"
  },
  {
    "function_name": "klp_free_funcs_limited",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "634-641",
    "snippet": "static void klp_free_funcs_limited(struct klp_object *obj,\n\t\t\t\t   struct klp_func *limit)\n{\n\tstruct klp_func *func;\n\n\tfor (func = obj->funcs; func->old_name && func != limit; func++)\n\t\tkobject_put(&func->kobj);\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "&func->kobj"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "mod_kobject_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1742-1748",
          "snippet": "static void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic void mod_kobject_put(struct module *mod)\n{\n\tDECLARE_COMPLETION_ONSTACK(c);\n\tmod->mkobj.kobj_completion = &c;\n\tkobject_put(&mod->mkobj.kobj);\n\twait_for_completion(&c);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void klp_free_funcs_limited(struct klp_object *obj,\n\t\t\t\t   struct klp_func *limit)\n{\n\tstruct klp_func *func;\n\n\tfor (func = obj->funcs; func->old_name && func != limit; func++)\n\t\tkobject_put(&func->kobj);\n}"
  },
  {
    "function_name": "klp_kobj_release_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "621-623",
    "snippet": "static void klp_kobj_release_func(struct kobject *kobj)\n{\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void klp_kobj_release_func(struct kobject *kobj)\n{\n}"
  },
  {
    "function_name": "klp_kobj_release_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "612-614",
    "snippet": "static void klp_kobj_release_object(struct kobject *kobj)\n{\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void klp_kobj_release_object(struct kobject *kobj)\n{\n}"
  },
  {
    "function_name": "klp_kobj_release_patch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "598-604",
    "snippet": "static void klp_kobj_release_patch(struct kobject *kobj)\n{\n\tstruct klp_patch *patch;\n\n\tpatch = container_of(kobj, struct klp_patch, kobj);\n\tcomplete(&patch->finish);\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&patch->finish"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1205-1216",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kobj",
            "structklp_patch",
            "kobj"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void klp_kobj_release_patch(struct kobject *kobj)\n{\n\tstruct klp_patch *patch;\n\n\tpatch = container_of(kobj, struct klp_patch, kobj);\n\tcomplete(&patch->finish);\n}"
  },
  {
    "function_name": "force_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "557-584",
    "snippet": "static ssize_t force_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct klp_patch *patch;\n\tint ret;\n\tbool val;\n\n\tret = kstrtobool(buf, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!val)\n\t\treturn count;\n\n\tmutex_lock(&klp_mutex);\n\n\tpatch = container_of(kobj, struct klp_patch, kobj);\n\tif (patch != klp_transition_patch) {\n\t\tmutex_unlock(&klp_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tklp_force_transition();\n\n\tmutex_unlock(&klp_mutex);\n\n\treturn count;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&klp_mutex"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_force_transition",
          "args": [],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "klp_force_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "621-637",
          "snippet": "void klp_force_transition(void)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tpr_warn(\"forcing remaining tasks to the patched state\\n\");\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tklp_update_patch_state(task);\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu)\n\t\tklp_update_patch_state(idle_task(cpu));\n\n\tklp_forced = true;\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool klp_forced = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic bool klp_forced = false;\n\nvoid klp_force_transition(void)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tpr_warn(\"forcing remaining tasks to the patched state\\n\");\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tklp_update_patch_state(task);\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu)\n\t\tklp_update_patch_state(idle_task(cpu));\n\n\tklp_forced = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kobj",
            "structklp_patch",
            "kobj"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&klp_mutex"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtobool",
          "args": [
            "buf",
            "&val"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t force_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct klp_patch *patch;\n\tint ret;\n\tbool val;\n\n\tret = kstrtobool(buf, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!val)\n\t\treturn count;\n\n\tmutex_lock(&klp_mutex);\n\n\tpatch = container_of(kobj, struct klp_patch, kobj);\n\tif (patch != klp_transition_patch) {\n\t\tmutex_unlock(&klp_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tklp_force_transition();\n\n\tmutex_unlock(&klp_mutex);\n\n\treturn count;\n}"
  },
  {
    "function_name": "signal_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "528-555",
    "snippet": "static ssize_t signal_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct klp_patch *patch;\n\tint ret;\n\tbool val;\n\n\tret = kstrtobool(buf, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!val)\n\t\treturn count;\n\n\tmutex_lock(&klp_mutex);\n\n\tpatch = container_of(kobj, struct klp_patch, kobj);\n\tif (patch != klp_transition_patch) {\n\t\tmutex_unlock(&klp_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tklp_send_signals();\n\n\tmutex_unlock(&klp_mutex);\n\n\treturn count;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&klp_mutex"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_send_signals",
          "args": [],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "klp_send_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "576-610",
          "snippet": "void klp_send_signals(void)\n{\n\tstruct task_struct *g, *task;\n\n\tpr_notice(\"signaling remaining tasks\\n\");\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tif (!klp_patch_pending(task))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * There is a small race here. We could see TIF_PATCH_PENDING\n\t\t * set and decide to wake up a kthread or send a fake signal.\n\t\t * Meanwhile the task could migrate itself and the action\n\t\t * would be meaningless. It is not serious though.\n\t\t */\n\t\tif (task->flags & PF_KTHREAD) {\n\t\t\t/*\n\t\t\t * Wake up a kthread which sleeps interruptedly and\n\t\t\t * still has not been migrated.\n\t\t\t */\n\t\t\twake_up_state(task, TASK_INTERRUPTIBLE);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Send fake signal to all non-kthread tasks which are\n\t\t\t * still not migrated.\n\t\t\t */\n\t\t\tspin_lock_irq(&task->sighand->siglock);\n\t\t\tsignal_wake_up(task, 0);\n\t\t\tspin_unlock_irq(&task->sighand->siglock);\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nvoid klp_send_signals(void)\n{\n\tstruct task_struct *g, *task;\n\n\tpr_notice(\"signaling remaining tasks\\n\");\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tif (!klp_patch_pending(task))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * There is a small race here. We could see TIF_PATCH_PENDING\n\t\t * set and decide to wake up a kthread or send a fake signal.\n\t\t * Meanwhile the task could migrate itself and the action\n\t\t * would be meaningless. It is not serious though.\n\t\t */\n\t\tif (task->flags & PF_KTHREAD) {\n\t\t\t/*\n\t\t\t * Wake up a kthread which sleeps interruptedly and\n\t\t\t * still has not been migrated.\n\t\t\t */\n\t\t\twake_up_state(task, TASK_INTERRUPTIBLE);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Send fake signal to all non-kthread tasks which are\n\t\t\t * still not migrated.\n\t\t\t */\n\t\t\tspin_lock_irq(&task->sighand->siglock);\n\t\t\tsignal_wake_up(task, 0);\n\t\t\tspin_unlock_irq(&task->sighand->siglock);\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kobj",
            "structklp_patch",
            "kobj"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&klp_mutex"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtobool",
          "args": [
            "buf",
            "&val"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t signal_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct klp_patch *patch;\n\tint ret;\n\tbool val;\n\n\tret = kstrtobool(buf, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!val)\n\t\treturn count;\n\n\tmutex_lock(&klp_mutex);\n\n\tpatch = container_of(kobj, struct klp_patch, kobj);\n\tif (patch != klp_transition_patch) {\n\t\tmutex_unlock(&klp_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tklp_send_signals();\n\n\tmutex_unlock(&klp_mutex);\n\n\treturn count;\n}"
  },
  {
    "function_name": "transition_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "518-526",
    "snippet": "static ssize_t transition_show(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\tstruct klp_patch *patch;\n\n\tpatch = container_of(kobj, struct klp_patch, kobj);\n\treturn snprintf(buf, PAGE_SIZE-1, \"%d\\n\",\n\t\t\tpatch == klp_transition_patch);\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE-1",
            "\"%d\\n\"",
            "patch == klp_transition_patch"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kobj",
            "structklp_patch",
            "kobj"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t transition_show(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\tstruct klp_patch *patch;\n\n\tpatch = container_of(kobj, struct klp_patch, kobj);\n\treturn snprintf(buf, PAGE_SIZE-1, \"%d\\n\",\n\t\t\tpatch == klp_transition_patch);\n}"
  },
  {
    "function_name": "enabled_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "509-516",
    "snippet": "static ssize_t enabled_show(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr, char *buf)\n{\n\tstruct klp_patch *patch;\n\n\tpatch = container_of(kobj, struct klp_patch, kobj);\n\treturn snprintf(buf, PAGE_SIZE-1, \"%d\\n\", patch->enabled);\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE-1",
            "\"%d\\n\"",
            "patch->enabled"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kobj",
            "structklp_patch",
            "kobj"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t enabled_show(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr, char *buf)\n{\n\tstruct klp_patch *patch;\n\n\tpatch = container_of(kobj, struct klp_patch, kobj);\n\treturn snprintf(buf, PAGE_SIZE-1, \"%d\\n\", patch->enabled);\n}"
  },
  {
    "function_name": "enabled_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "458-507",
    "snippet": "static ssize_t enabled_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct klp_patch *patch;\n\tint ret;\n\tbool enabled;\n\n\tret = kstrtobool(buf, &enabled);\n\tif (ret)\n\t\treturn ret;\n\n\tpatch = container_of(kobj, struct klp_patch, kobj);\n\n\tmutex_lock(&klp_mutex);\n\n\tif (!klp_is_patch_registered(patch)) {\n\t\t/*\n\t\t * Module with the patch could either disappear meanwhile or is\n\t\t * not properly initialized yet.\n\t\t */\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (patch->enabled == enabled) {\n\t\t/* already in requested state */\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (patch == klp_transition_patch) {\n\t\tklp_reverse_transition();\n\t} else if (enabled) {\n\t\tret = __klp_enable_patch(patch);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tret = __klp_disable_patch(patch);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tmutex_unlock(&klp_mutex);\n\n\treturn count;\n\nerr:\n\tmutex_unlock(&klp_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&klp_mutex"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__klp_disable_patch",
          "args": [
            "patch"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "__klp_disable_patch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "281-316",
          "snippet": "static int __klp_disable_patch(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\n\tif (WARN_ON(!patch->enabled))\n\t\treturn -EINVAL;\n\n\tif (klp_transition_patch)\n\t\treturn -EBUSY;\n\n\t/* enforce stacking: only the last enabled patch can be disabled */\n\tif (!list_is_last(&patch->list, &klp_patches) &&\n\t    list_next_entry(patch, list)->enabled)\n\t\treturn -EBUSY;\n\n\tklp_init_transition(patch, KLP_UNPATCHED);\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\tklp_pre_unpatch_callback(obj);\n\n\t/*\n\t * Enforce the order of the func->transition writes in\n\t * klp_init_transition() and the TIF_PATCH_PENDING writes in\n\t * klp_start_transition().  In the rare case where klp_ftrace_handler()\n\t * is called shortly after klp_update_patch_state() switches the task,\n\t * this ensures the handler sees that func->transition is set.\n\t */\n\tsmp_wmb();\n\n\tklp_start_transition();\n\tklp_try_complete_transition();\n\tpatch->enabled = false;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_patches);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(klp_patches);\n\nstatic int __klp_disable_patch(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\n\tif (WARN_ON(!patch->enabled))\n\t\treturn -EINVAL;\n\n\tif (klp_transition_patch)\n\t\treturn -EBUSY;\n\n\t/* enforce stacking: only the last enabled patch can be disabled */\n\tif (!list_is_last(&patch->list, &klp_patches) &&\n\t    list_next_entry(patch, list)->enabled)\n\t\treturn -EBUSY;\n\n\tklp_init_transition(patch, KLP_UNPATCHED);\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\tklp_pre_unpatch_callback(obj);\n\n\t/*\n\t * Enforce the order of the func->transition writes in\n\t * klp_init_transition() and the TIF_PATCH_PENDING writes in\n\t * klp_start_transition().  In the rare case where klp_ftrace_handler()\n\t * is called shortly after klp_update_patch_state() switches the task,\n\t * this ensures the handler sees that func->transition is set.\n\t */\n\tsmp_wmb();\n\n\tklp_start_transition();\n\tklp_try_complete_transition();\n\tpatch->enabled = false;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__klp_enable_patch",
          "args": [
            "patch"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "__klp_enable_patch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "350-415",
          "snippet": "static int __klp_enable_patch(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\tint ret;\n\n\tif (klp_transition_patch)\n\t\treturn -EBUSY;\n\n\tif (WARN_ON(patch->enabled))\n\t\treturn -EINVAL;\n\n\t/* enforce stacking: only the first disabled patch can be enabled */\n\tif (patch->list.prev != &klp_patches &&\n\t    !list_prev_entry(patch, list)->enabled)\n\t\treturn -EBUSY;\n\n\t/*\n\t * A reference is taken on the patch module to prevent it from being\n\t * unloaded.\n\t */\n\tif (!try_module_get(patch->mod))\n\t\treturn -ENODEV;\n\n\tpr_notice(\"enabling patch '%s'\\n\", patch->mod->name);\n\n\tklp_init_transition(patch, KLP_PATCHED);\n\n\t/*\n\t * Enforce the order of the func->transition writes in\n\t * klp_init_transition() and the ops->func_stack writes in\n\t * klp_patch_object(), so that klp_ftrace_handler() will see the\n\t * func->transition updates before the handler is registered and the\n\t * new funcs become visible to the handler.\n\t */\n\tsmp_wmb();\n\n\tklp_for_each_object(patch, obj) {\n\t\tif (!klp_is_object_loaded(obj))\n\t\t\tcontinue;\n\n\t\tret = klp_pre_patch_callback(obj);\n\t\tif (ret) {\n\t\t\tpr_warn(\"pre-patch callback failed for object '%s'\\n\",\n\t\t\t\tklp_is_module(obj) ? obj->name : \"vmlinux\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = klp_patch_object(obj);\n\t\tif (ret) {\n\t\t\tpr_warn(\"failed to patch object '%s'\\n\",\n\t\t\t\tklp_is_module(obj) ? obj->name : \"vmlinux\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tklp_start_transition();\n\tklp_try_complete_transition();\n\tpatch->enabled = true;\n\n\treturn 0;\nerr:\n\tpr_warn(\"failed to enable patch '%s'\\n\", patch->mod->name);\n\n\tklp_cancel_transition();\n\treturn ret;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_patches);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(klp_patches);\n\nstatic int __klp_enable_patch(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\tint ret;\n\n\tif (klp_transition_patch)\n\t\treturn -EBUSY;\n\n\tif (WARN_ON(patch->enabled))\n\t\treturn -EINVAL;\n\n\t/* enforce stacking: only the first disabled patch can be enabled */\n\tif (patch->list.prev != &klp_patches &&\n\t    !list_prev_entry(patch, list)->enabled)\n\t\treturn -EBUSY;\n\n\t/*\n\t * A reference is taken on the patch module to prevent it from being\n\t * unloaded.\n\t */\n\tif (!try_module_get(patch->mod))\n\t\treturn -ENODEV;\n\n\tpr_notice(\"enabling patch '%s'\\n\", patch->mod->name);\n\n\tklp_init_transition(patch, KLP_PATCHED);\n\n\t/*\n\t * Enforce the order of the func->transition writes in\n\t * klp_init_transition() and the ops->func_stack writes in\n\t * klp_patch_object(), so that klp_ftrace_handler() will see the\n\t * func->transition updates before the handler is registered and the\n\t * new funcs become visible to the handler.\n\t */\n\tsmp_wmb();\n\n\tklp_for_each_object(patch, obj) {\n\t\tif (!klp_is_object_loaded(obj))\n\t\t\tcontinue;\n\n\t\tret = klp_pre_patch_callback(obj);\n\t\tif (ret) {\n\t\t\tpr_warn(\"pre-patch callback failed for object '%s'\\n\",\n\t\t\t\tklp_is_module(obj) ? obj->name : \"vmlinux\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = klp_patch_object(obj);\n\t\tif (ret) {\n\t\t\tpr_warn(\"failed to patch object '%s'\\n\",\n\t\t\t\tklp_is_module(obj) ? obj->name : \"vmlinux\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tklp_start_transition();\n\tklp_try_complete_transition();\n\tpatch->enabled = true;\n\n\treturn 0;\nerr:\n\tpr_warn(\"failed to enable patch '%s'\\n\", patch->mod->name);\n\n\tklp_cancel_transition();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_reverse_transition",
          "args": [],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "klp_reverse_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "530-561",
          "snippet": "void klp_reverse_transition(void)\n{\n\tunsigned int cpu;\n\tstruct task_struct *g, *task;\n\n\tpr_debug(\"'%s': reversing transition from %s\\n\",\n\t\t klp_transition_patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching to unpatching\" :\n\t\t\t\t\t\t   \"unpatching to patching\");\n\n\tklp_transition_patch->enabled = !klp_transition_patch->enabled;\n\n\tklp_target_state = !klp_target_state;\n\n\t/*\n\t * Clear all TIF_PATCH_PENDING flags to prevent races caused by\n\t * klp_update_patch_state() running in parallel with\n\t * klp_start_transition().\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu)\n\t\tclear_tsk_thread_flag(idle_task(cpu), TIF_PATCH_PENDING);\n\n\t/* Let any remaining calls to klp_update_patch_state() complete */\n\tklp_synchronize_transition();\n\n\tklp_start_transition();\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct klp_patch *klp_transition_patch;",
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_reverse_transition(void)\n{\n\tunsigned int cpu;\n\tstruct task_struct *g, *task;\n\n\tpr_debug(\"'%s': reversing transition from %s\\n\",\n\t\t klp_transition_patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching to unpatching\" :\n\t\t\t\t\t\t   \"unpatching to patching\");\n\n\tklp_transition_patch->enabled = !klp_transition_patch->enabled;\n\n\tklp_target_state = !klp_target_state;\n\n\t/*\n\t * Clear all TIF_PATCH_PENDING flags to prevent races caused by\n\t * klp_update_patch_state() running in parallel with\n\t * klp_start_transition().\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu)\n\t\tclear_tsk_thread_flag(idle_task(cpu), TIF_PATCH_PENDING);\n\n\t/* Let any remaining calls to klp_update_patch_state() complete */\n\tklp_synchronize_transition();\n\n\tklp_start_transition();\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_is_patch_registered",
          "args": [
            "patch"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "klp_is_patch_registered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "85-94",
          "snippet": "static bool klp_is_patch_registered(struct klp_patch *patch)\n{\n\tstruct klp_patch *mypatch;\n\n\tlist_for_each_entry(mypatch, &klp_patches, list)\n\t\tif (mypatch == patch)\n\t\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_patches);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(klp_patches);\n\nstatic bool klp_is_patch_registered(struct klp_patch *patch)\n{\n\tstruct klp_patch *mypatch;\n\n\tlist_for_each_entry(mypatch, &klp_patches, list)\n\t\tif (mypatch == patch)\n\t\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&klp_mutex"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kobj",
            "structklp_patch",
            "kobj"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtobool",
          "args": [
            "buf",
            "&enabled"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t enabled_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct klp_patch *patch;\n\tint ret;\n\tbool enabled;\n\n\tret = kstrtobool(buf, &enabled);\n\tif (ret)\n\t\treturn ret;\n\n\tpatch = container_of(kobj, struct klp_patch, kobj);\n\n\tmutex_lock(&klp_mutex);\n\n\tif (!klp_is_patch_registered(patch)) {\n\t\t/*\n\t\t * Module with the patch could either disappear meanwhile or is\n\t\t * not properly initialized yet.\n\t\t */\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (patch->enabled == enabled) {\n\t\t/* already in requested state */\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (patch == klp_transition_patch) {\n\t\tklp_reverse_transition();\n\t} else if (enabled) {\n\t\tret = __klp_enable_patch(patch);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tret = __klp_disable_patch(patch);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tmutex_unlock(&klp_mutex);\n\n\treturn count;\n\nerr:\n\tmutex_unlock(&klp_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "klp_enable_patch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "426-442",
    "snippet": "int klp_enable_patch(struct klp_patch *patch)\n{\n\tint ret;\n\n\tmutex_lock(&klp_mutex);\n\n\tif (!klp_is_patch_registered(patch)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = __klp_enable_patch(patch);\n\nerr:\n\tmutex_unlock(&klp_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&klp_mutex"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__klp_enable_patch",
          "args": [
            "patch"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "__klp_enable_patch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "350-415",
          "snippet": "static int __klp_enable_patch(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\tint ret;\n\n\tif (klp_transition_patch)\n\t\treturn -EBUSY;\n\n\tif (WARN_ON(patch->enabled))\n\t\treturn -EINVAL;\n\n\t/* enforce stacking: only the first disabled patch can be enabled */\n\tif (patch->list.prev != &klp_patches &&\n\t    !list_prev_entry(patch, list)->enabled)\n\t\treturn -EBUSY;\n\n\t/*\n\t * A reference is taken on the patch module to prevent it from being\n\t * unloaded.\n\t */\n\tif (!try_module_get(patch->mod))\n\t\treturn -ENODEV;\n\n\tpr_notice(\"enabling patch '%s'\\n\", patch->mod->name);\n\n\tklp_init_transition(patch, KLP_PATCHED);\n\n\t/*\n\t * Enforce the order of the func->transition writes in\n\t * klp_init_transition() and the ops->func_stack writes in\n\t * klp_patch_object(), so that klp_ftrace_handler() will see the\n\t * func->transition updates before the handler is registered and the\n\t * new funcs become visible to the handler.\n\t */\n\tsmp_wmb();\n\n\tklp_for_each_object(patch, obj) {\n\t\tif (!klp_is_object_loaded(obj))\n\t\t\tcontinue;\n\n\t\tret = klp_pre_patch_callback(obj);\n\t\tif (ret) {\n\t\t\tpr_warn(\"pre-patch callback failed for object '%s'\\n\",\n\t\t\t\tklp_is_module(obj) ? obj->name : \"vmlinux\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = klp_patch_object(obj);\n\t\tif (ret) {\n\t\t\tpr_warn(\"failed to patch object '%s'\\n\",\n\t\t\t\tklp_is_module(obj) ? obj->name : \"vmlinux\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tklp_start_transition();\n\tklp_try_complete_transition();\n\tpatch->enabled = true;\n\n\treturn 0;\nerr:\n\tpr_warn(\"failed to enable patch '%s'\\n\", patch->mod->name);\n\n\tklp_cancel_transition();\n\treturn ret;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_patches);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(klp_patches);\n\nstatic int __klp_enable_patch(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\tint ret;\n\n\tif (klp_transition_patch)\n\t\treturn -EBUSY;\n\n\tif (WARN_ON(patch->enabled))\n\t\treturn -EINVAL;\n\n\t/* enforce stacking: only the first disabled patch can be enabled */\n\tif (patch->list.prev != &klp_patches &&\n\t    !list_prev_entry(patch, list)->enabled)\n\t\treturn -EBUSY;\n\n\t/*\n\t * A reference is taken on the patch module to prevent it from being\n\t * unloaded.\n\t */\n\tif (!try_module_get(patch->mod))\n\t\treturn -ENODEV;\n\n\tpr_notice(\"enabling patch '%s'\\n\", patch->mod->name);\n\n\tklp_init_transition(patch, KLP_PATCHED);\n\n\t/*\n\t * Enforce the order of the func->transition writes in\n\t * klp_init_transition() and the ops->func_stack writes in\n\t * klp_patch_object(), so that klp_ftrace_handler() will see the\n\t * func->transition updates before the handler is registered and the\n\t * new funcs become visible to the handler.\n\t */\n\tsmp_wmb();\n\n\tklp_for_each_object(patch, obj) {\n\t\tif (!klp_is_object_loaded(obj))\n\t\t\tcontinue;\n\n\t\tret = klp_pre_patch_callback(obj);\n\t\tif (ret) {\n\t\t\tpr_warn(\"pre-patch callback failed for object '%s'\\n\",\n\t\t\t\tklp_is_module(obj) ? obj->name : \"vmlinux\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = klp_patch_object(obj);\n\t\tif (ret) {\n\t\t\tpr_warn(\"failed to patch object '%s'\\n\",\n\t\t\t\tklp_is_module(obj) ? obj->name : \"vmlinux\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tklp_start_transition();\n\tklp_try_complete_transition();\n\tpatch->enabled = true;\n\n\treturn 0;\nerr:\n\tpr_warn(\"failed to enable patch '%s'\\n\", patch->mod->name);\n\n\tklp_cancel_transition();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_is_patch_registered",
          "args": [
            "patch"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "klp_is_patch_registered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "85-94",
          "snippet": "static bool klp_is_patch_registered(struct klp_patch *patch)\n{\n\tstruct klp_patch *mypatch;\n\n\tlist_for_each_entry(mypatch, &klp_patches, list)\n\t\tif (mypatch == patch)\n\t\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_patches);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(klp_patches);\n\nstatic bool klp_is_patch_registered(struct klp_patch *patch)\n{\n\tstruct klp_patch *mypatch;\n\n\tlist_for_each_entry(mypatch, &klp_patches, list)\n\t\tif (mypatch == patch)\n\t\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&klp_mutex"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nint klp_enable_patch(struct klp_patch *patch)\n{\n\tint ret;\n\n\tmutex_lock(&klp_mutex);\n\n\tif (!klp_is_patch_registered(patch)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = __klp_enable_patch(patch);\n\nerr:\n\tmutex_unlock(&klp_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "__klp_enable_patch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "350-415",
    "snippet": "static int __klp_enable_patch(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\tint ret;\n\n\tif (klp_transition_patch)\n\t\treturn -EBUSY;\n\n\tif (WARN_ON(patch->enabled))\n\t\treturn -EINVAL;\n\n\t/* enforce stacking: only the first disabled patch can be enabled */\n\tif (patch->list.prev != &klp_patches &&\n\t    !list_prev_entry(patch, list)->enabled)\n\t\treturn -EBUSY;\n\n\t/*\n\t * A reference is taken on the patch module to prevent it from being\n\t * unloaded.\n\t */\n\tif (!try_module_get(patch->mod))\n\t\treturn -ENODEV;\n\n\tpr_notice(\"enabling patch '%s'\\n\", patch->mod->name);\n\n\tklp_init_transition(patch, KLP_PATCHED);\n\n\t/*\n\t * Enforce the order of the func->transition writes in\n\t * klp_init_transition() and the ops->func_stack writes in\n\t * klp_patch_object(), so that klp_ftrace_handler() will see the\n\t * func->transition updates before the handler is registered and the\n\t * new funcs become visible to the handler.\n\t */\n\tsmp_wmb();\n\n\tklp_for_each_object(patch, obj) {\n\t\tif (!klp_is_object_loaded(obj))\n\t\t\tcontinue;\n\n\t\tret = klp_pre_patch_callback(obj);\n\t\tif (ret) {\n\t\t\tpr_warn(\"pre-patch callback failed for object '%s'\\n\",\n\t\t\t\tklp_is_module(obj) ? obj->name : \"vmlinux\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = klp_patch_object(obj);\n\t\tif (ret) {\n\t\t\tpr_warn(\"failed to patch object '%s'\\n\",\n\t\t\t\tklp_is_module(obj) ? obj->name : \"vmlinux\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tklp_start_transition();\n\tklp_try_complete_transition();\n\tpatch->enabled = true;\n\n\treturn 0;\nerr:\n\tpr_warn(\"failed to enable patch '%s'\\n\", patch->mod->name);\n\n\tklp_cancel_transition();\n\treturn ret;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(klp_patches);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_cancel_transition",
          "args": [],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "klp_cancel_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "156-166",
          "snippet": "void klp_cancel_transition(void)\n{\n\tif (WARN_ON_ONCE(klp_target_state != KLP_PATCHED))\n\t\treturn;\n\n\tpr_debug(\"'%s': canceling patching transition, going to unpatch\\n\",\n\t\t klp_transition_patch->mod->name);\n\n\tklp_target_state = KLP_UNPATCHED;\n\tklp_complete_transition();\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct klp_patch *klp_transition_patch;",
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_cancel_transition(void)\n{\n\tif (WARN_ON_ONCE(klp_target_state != KLP_PATCHED))\n\t\treturn;\n\n\tpr_debug(\"'%s': canceling patching transition, going to unpatch\\n\",\n\t\t klp_transition_patch->mod->name);\n\n\tklp_target_state = KLP_UNPATCHED;\n\tklp_complete_transition();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"failed to enable patch '%s'\\n\"",
            "patch->mod->name"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_try_complete_transition",
          "args": [],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "klp_try_complete_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "358-411",
          "snippet": "void klp_try_complete_transition(void)\n{\n\tunsigned int cpu;\n\tstruct task_struct *g, *task;\n\tbool complete = true;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\t/*\n\t * Try to switch the tasks to the target patch state by walking their\n\t * stacks and looking for any to-be-patched or to-be-unpatched\n\t * functions.  If such functions are found on a stack, or if the stack\n\t * is deemed unreliable, the task can't be switched yet.\n\t *\n\t * Usually this will transition most (or all) of the tasks on a system\n\t * unless the patch includes changes to a very common function.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (!klp_try_switch_task(task))\n\t\t\tcomplete = false;\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tget_online_cpus();\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (cpu_online(cpu)) {\n\t\t\tif (!klp_try_switch_task(task))\n\t\t\t\tcomplete = false;\n\t\t} else if (task->patch_state != klp_target_state) {\n\t\t\t/* offline idle tasks can be switched immediately */\n\t\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t\t\ttask->patch_state = klp_target_state;\n\t\t}\n\t}\n\tput_online_cpus();\n\n\tif (!complete) {\n\t\t/*\n\t\t * Some tasks weren't able to be switched over.  Try again\n\t\t * later and/or wait for other methods like kernel exit\n\t\t * switching.\n\t\t */\n\t\tschedule_delayed_work(&klp_transition_work,\n\t\t\t\t      round_jiffies_relative(HZ));\n\t\treturn;\n\t}\n\n\t/* we're done, now cleanup the data structures */\n\tklp_complete_transition();\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_try_complete_transition(void)\n{\n\tunsigned int cpu;\n\tstruct task_struct *g, *task;\n\tbool complete = true;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\t/*\n\t * Try to switch the tasks to the target patch state by walking their\n\t * stacks and looking for any to-be-patched or to-be-unpatched\n\t * functions.  If such functions are found on a stack, or if the stack\n\t * is deemed unreliable, the task can't be switched yet.\n\t *\n\t * Usually this will transition most (or all) of the tasks on a system\n\t * unless the patch includes changes to a very common function.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (!klp_try_switch_task(task))\n\t\t\tcomplete = false;\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tget_online_cpus();\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (cpu_online(cpu)) {\n\t\t\tif (!klp_try_switch_task(task))\n\t\t\t\tcomplete = false;\n\t\t} else if (task->patch_state != klp_target_state) {\n\t\t\t/* offline idle tasks can be switched immediately */\n\t\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t\t\ttask->patch_state = klp_target_state;\n\t\t}\n\t}\n\tput_online_cpus();\n\n\tif (!complete) {\n\t\t/*\n\t\t * Some tasks weren't able to be switched over.  Try again\n\t\t * later and/or wait for other methods like kernel exit\n\t\t * switching.\n\t\t */\n\t\tschedule_delayed_work(&klp_transition_work,\n\t\t\t\t      round_jiffies_relative(HZ));\n\t\treturn;\n\t}\n\n\t/* we're done, now cleanup the data structures */\n\tklp_complete_transition();\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_start_transition",
          "args": [],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "klp_start_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "417-449",
          "snippet": "void klp_start_transition(void)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\tpr_notice(\"'%s': starting %s transition\\n\",\n\t\t  klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Mark all normal tasks as needing a patch state update.  They'll\n\t * switch either in klp_try_complete_transition() or as they exit the\n\t * kernel.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Mark all idle tasks as needing a patch state update.  They'll switch\n\t * either in klp_try_complete_transition() or at the idle loop switch\n\t * point.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t}\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct klp_patch *klp_transition_patch;",
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_start_transition(void)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\tpr_notice(\"'%s': starting %s transition\\n\",\n\t\t  klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Mark all normal tasks as needing a patch state update.  They'll\n\t * switch either in klp_try_complete_transition() or as they exit the\n\t * kernel.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Mark all idle tasks as needing a patch state update.  They'll switch\n\t * either in klp_try_complete_transition() or at the idle loop switch\n\t * point.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"failed to patch object '%s'\\n\"",
            "klp_is_module(obj) ? obj->name : \"vmlinux\""
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_is_module",
          "args": [
            "obj"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "klp_is_module",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "52-55",
          "snippet": "static bool klp_is_module(struct klp_object *obj)\n{\n\treturn obj->name;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic bool klp_is_module(struct klp_object *obj)\n{\n\treturn obj->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_patch_object",
          "args": [
            "obj"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "klp_patch_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/patch.c",
          "lines": "250-268",
          "snippet": "int klp_patch_object(struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\n\tif (WARN_ON(obj->patched))\n\t\treturn -EINVAL;\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_patch_func(func);\n\t\tif (ret) {\n\t\t\tklp_unpatch_object(obj);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tobj->patched = true;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nint klp_patch_object(struct klp_object *obj)\n{\n\tstruct klp_func *func;\n\tint ret;\n\n\tif (WARN_ON(obj->patched))\n\t\treturn -EINVAL;\n\n\tklp_for_each_func(obj, func) {\n\t\tret = klp_patch_func(func);\n\t\tif (ret) {\n\t\t\tklp_unpatch_object(obj);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tobj->patched = true;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"pre-patch callback failed for object '%s'\\n\"",
            "klp_is_module(obj) ? obj->name : \"vmlinux\""
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_pre_patch_callback",
          "args": [
            "obj"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "klp_pre_patch_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.h",
          "lines": "14-24",
          "snippet": "static inline int klp_pre_patch_callback(struct klp_object *obj)\n{\n\tint ret = 0;\n\n\tif (obj->callbacks.pre_patch)\n\t\tret = (*obj->callbacks.pre_patch)(obj);\n\n\tobj->callbacks.post_unpatch_enabled = !ret;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n\nstatic inline int klp_pre_patch_callback(struct klp_object *obj)\n{\n\tint ret = 0;\n\n\tif (obj->callbacks.pre_patch)\n\t\tret = (*obj->callbacks.pre_patch)(obj);\n\n\tobj->callbacks.post_unpatch_enabled = !ret;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_is_object_loaded",
          "args": [
            "obj"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "klp_is_object_loaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.h",
          "lines": "9-12",
          "snippet": "static inline bool klp_is_object_loaded(struct klp_object *obj)\n{\n\treturn !obj->name || obj->mod;\n}",
          "includes": [
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n\nstatic inline bool klp_is_object_loaded(struct klp_object *obj)\n{\n\treturn !obj->name || obj->mod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_object",
          "args": [
            "patch",
            "obj"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_init_transition",
          "args": [
            "patch",
            "KLP_PATCHED"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "klp_init_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "456-522",
          "snippet": "void klp_init_transition(struct klp_patch *patch, int state)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tint initial_state = !state;\n\n\tWARN_ON_ONCE(klp_target_state != KLP_UNDEFINED);\n\n\tklp_transition_patch = patch;\n\n\t/*\n\t * Set the global target patch state which tasks will switch to.  This\n\t * has no effect until the TIF_PATCH_PENDING flags get set later.\n\t */\n\tklp_target_state = state;\n\n\tpr_debug(\"'%s': initializing %s transition\\n\", patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Initialize all tasks to the initial patch state to prepare them for\n\t * switching to the target state.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);\n\t\ttask->patch_state = initial_state;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);\n\t\ttask->patch_state = initial_state;\n\t}\n\n\t/*\n\t * Enforce the order of the task->patch_state initializations and the\n\t * func->transition updates to ensure that klp_ftrace_handler() doesn't\n\t * see a func in transition with a task->patch_state of KLP_UNDEFINED.\n\t *\n\t * Also enforce the order of the klp_target_state write and future\n\t * TIF_PATCH_PENDING writes to ensure klp_update_patch_state() doesn't\n\t * set a task->patch_state to KLP_UNDEFINED.\n\t */\n\tsmp_wmb();\n\n\t/*\n\t * Set the func transition states so klp_ftrace_handler() will know to\n\t * switch to the transition logic.\n\t *\n\t * When patching, the funcs aren't yet in the func_stack and will be\n\t * made visible to the ftrace handler shortly by the calls to\n\t * klp_patch_object().\n\t *\n\t * When unpatching, the funcs are already in the func_stack and so are\n\t * already visible to the ftrace handler.\n\t */\n\tklp_for_each_object(patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = true;\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct klp_patch *klp_transition_patch;",
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_init_transition(struct klp_patch *patch, int state)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tint initial_state = !state;\n\n\tWARN_ON_ONCE(klp_target_state != KLP_UNDEFINED);\n\n\tklp_transition_patch = patch;\n\n\t/*\n\t * Set the global target patch state which tasks will switch to.  This\n\t * has no effect until the TIF_PATCH_PENDING flags get set later.\n\t */\n\tklp_target_state = state;\n\n\tpr_debug(\"'%s': initializing %s transition\\n\", patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Initialize all tasks to the initial patch state to prepare them for\n\t * switching to the target state.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);\n\t\ttask->patch_state = initial_state;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);\n\t\ttask->patch_state = initial_state;\n\t}\n\n\t/*\n\t * Enforce the order of the task->patch_state initializations and the\n\t * func->transition updates to ensure that klp_ftrace_handler() doesn't\n\t * see a func in transition with a task->patch_state of KLP_UNDEFINED.\n\t *\n\t * Also enforce the order of the klp_target_state write and future\n\t * TIF_PATCH_PENDING writes to ensure klp_update_patch_state() doesn't\n\t * set a task->patch_state to KLP_UNDEFINED.\n\t */\n\tsmp_wmb();\n\n\t/*\n\t * Set the func transition states so klp_ftrace_handler() will know to\n\t * switch to the transition logic.\n\t *\n\t * When patching, the funcs aren't yet in the func_stack and will be\n\t * made visible to the ftrace handler shortly by the calls to\n\t * klp_patch_object().\n\t *\n\t * When unpatching, the funcs are already in the func_stack and so are\n\t * already visible to the ftrace handler.\n\t */\n\tklp_for_each_object(patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"enabling patch '%s'\\n\"",
            "patch->mod->name"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "patch->mod"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1113-1129",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_prev_entry",
          "args": [
            "patch",
            "list"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "patch->enabled"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(klp_patches);\n\nstatic int __klp_enable_patch(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\tint ret;\n\n\tif (klp_transition_patch)\n\t\treturn -EBUSY;\n\n\tif (WARN_ON(patch->enabled))\n\t\treturn -EINVAL;\n\n\t/* enforce stacking: only the first disabled patch can be enabled */\n\tif (patch->list.prev != &klp_patches &&\n\t    !list_prev_entry(patch, list)->enabled)\n\t\treturn -EBUSY;\n\n\t/*\n\t * A reference is taken on the patch module to prevent it from being\n\t * unloaded.\n\t */\n\tif (!try_module_get(patch->mod))\n\t\treturn -ENODEV;\n\n\tpr_notice(\"enabling patch '%s'\\n\", patch->mod->name);\n\n\tklp_init_transition(patch, KLP_PATCHED);\n\n\t/*\n\t * Enforce the order of the func->transition writes in\n\t * klp_init_transition() and the ops->func_stack writes in\n\t * klp_patch_object(), so that klp_ftrace_handler() will see the\n\t * func->transition updates before the handler is registered and the\n\t * new funcs become visible to the handler.\n\t */\n\tsmp_wmb();\n\n\tklp_for_each_object(patch, obj) {\n\t\tif (!klp_is_object_loaded(obj))\n\t\t\tcontinue;\n\n\t\tret = klp_pre_patch_callback(obj);\n\t\tif (ret) {\n\t\t\tpr_warn(\"pre-patch callback failed for object '%s'\\n\",\n\t\t\t\tklp_is_module(obj) ? obj->name : \"vmlinux\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = klp_patch_object(obj);\n\t\tif (ret) {\n\t\t\tpr_warn(\"failed to patch object '%s'\\n\",\n\t\t\t\tklp_is_module(obj) ? obj->name : \"vmlinux\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tklp_start_transition();\n\tklp_try_complete_transition();\n\tpatch->enabled = true;\n\n\treturn 0;\nerr:\n\tpr_warn(\"failed to enable patch '%s'\\n\", patch->mod->name);\n\n\tklp_cancel_transition();\n\treturn ret;\n}"
  },
  {
    "function_name": "klp_disable_patch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "326-347",
    "snippet": "int klp_disable_patch(struct klp_patch *patch)\n{\n\tint ret;\n\n\tmutex_lock(&klp_mutex);\n\n\tif (!klp_is_patch_registered(patch)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (!patch->enabled) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = __klp_disable_patch(patch);\n\nerr:\n\tmutex_unlock(&klp_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&klp_mutex"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__klp_disable_patch",
          "args": [
            "patch"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "__klp_disable_patch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "281-316",
          "snippet": "static int __klp_disable_patch(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\n\tif (WARN_ON(!patch->enabled))\n\t\treturn -EINVAL;\n\n\tif (klp_transition_patch)\n\t\treturn -EBUSY;\n\n\t/* enforce stacking: only the last enabled patch can be disabled */\n\tif (!list_is_last(&patch->list, &klp_patches) &&\n\t    list_next_entry(patch, list)->enabled)\n\t\treturn -EBUSY;\n\n\tklp_init_transition(patch, KLP_UNPATCHED);\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\tklp_pre_unpatch_callback(obj);\n\n\t/*\n\t * Enforce the order of the func->transition writes in\n\t * klp_init_transition() and the TIF_PATCH_PENDING writes in\n\t * klp_start_transition().  In the rare case where klp_ftrace_handler()\n\t * is called shortly after klp_update_patch_state() switches the task,\n\t * this ensures the handler sees that func->transition is set.\n\t */\n\tsmp_wmb();\n\n\tklp_start_transition();\n\tklp_try_complete_transition();\n\tpatch->enabled = false;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_patches);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(klp_patches);\n\nstatic int __klp_disable_patch(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\n\tif (WARN_ON(!patch->enabled))\n\t\treturn -EINVAL;\n\n\tif (klp_transition_patch)\n\t\treturn -EBUSY;\n\n\t/* enforce stacking: only the last enabled patch can be disabled */\n\tif (!list_is_last(&patch->list, &klp_patches) &&\n\t    list_next_entry(patch, list)->enabled)\n\t\treturn -EBUSY;\n\n\tklp_init_transition(patch, KLP_UNPATCHED);\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\tklp_pre_unpatch_callback(obj);\n\n\t/*\n\t * Enforce the order of the func->transition writes in\n\t * klp_init_transition() and the TIF_PATCH_PENDING writes in\n\t * klp_start_transition().  In the rare case where klp_ftrace_handler()\n\t * is called shortly after klp_update_patch_state() switches the task,\n\t * this ensures the handler sees that func->transition is set.\n\t */\n\tsmp_wmb();\n\n\tklp_start_transition();\n\tklp_try_complete_transition();\n\tpatch->enabled = false;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_is_patch_registered",
          "args": [
            "patch"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "klp_is_patch_registered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "85-94",
          "snippet": "static bool klp_is_patch_registered(struct klp_patch *patch)\n{\n\tstruct klp_patch *mypatch;\n\n\tlist_for_each_entry(mypatch, &klp_patches, list)\n\t\tif (mypatch == patch)\n\t\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_patches);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(klp_patches);\n\nstatic bool klp_is_patch_registered(struct klp_patch *patch)\n{\n\tstruct klp_patch *mypatch;\n\n\tlist_for_each_entry(mypatch, &klp_patches, list)\n\t\tif (mypatch == patch)\n\t\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&klp_mutex"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nint klp_disable_patch(struct klp_patch *patch)\n{\n\tint ret;\n\n\tmutex_lock(&klp_mutex);\n\n\tif (!klp_is_patch_registered(patch)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (!patch->enabled) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = __klp_disable_patch(patch);\n\nerr:\n\tmutex_unlock(&klp_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "__klp_disable_patch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "281-316",
    "snippet": "static int __klp_disable_patch(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\n\tif (WARN_ON(!patch->enabled))\n\t\treturn -EINVAL;\n\n\tif (klp_transition_patch)\n\t\treturn -EBUSY;\n\n\t/* enforce stacking: only the last enabled patch can be disabled */\n\tif (!list_is_last(&patch->list, &klp_patches) &&\n\t    list_next_entry(patch, list)->enabled)\n\t\treturn -EBUSY;\n\n\tklp_init_transition(patch, KLP_UNPATCHED);\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\tklp_pre_unpatch_callback(obj);\n\n\t/*\n\t * Enforce the order of the func->transition writes in\n\t * klp_init_transition() and the TIF_PATCH_PENDING writes in\n\t * klp_start_transition().  In the rare case where klp_ftrace_handler()\n\t * is called shortly after klp_update_patch_state() switches the task,\n\t * this ensures the handler sees that func->transition is set.\n\t */\n\tsmp_wmb();\n\n\tklp_start_transition();\n\tklp_try_complete_transition();\n\tpatch->enabled = false;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(klp_patches);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_try_complete_transition",
          "args": [],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "klp_try_complete_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "358-411",
          "snippet": "void klp_try_complete_transition(void)\n{\n\tunsigned int cpu;\n\tstruct task_struct *g, *task;\n\tbool complete = true;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\t/*\n\t * Try to switch the tasks to the target patch state by walking their\n\t * stacks and looking for any to-be-patched or to-be-unpatched\n\t * functions.  If such functions are found on a stack, or if the stack\n\t * is deemed unreliable, the task can't be switched yet.\n\t *\n\t * Usually this will transition most (or all) of the tasks on a system\n\t * unless the patch includes changes to a very common function.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (!klp_try_switch_task(task))\n\t\t\tcomplete = false;\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tget_online_cpus();\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (cpu_online(cpu)) {\n\t\t\tif (!klp_try_switch_task(task))\n\t\t\t\tcomplete = false;\n\t\t} else if (task->patch_state != klp_target_state) {\n\t\t\t/* offline idle tasks can be switched immediately */\n\t\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t\t\ttask->patch_state = klp_target_state;\n\t\t}\n\t}\n\tput_online_cpus();\n\n\tif (!complete) {\n\t\t/*\n\t\t * Some tasks weren't able to be switched over.  Try again\n\t\t * later and/or wait for other methods like kernel exit\n\t\t * switching.\n\t\t */\n\t\tschedule_delayed_work(&klp_transition_work,\n\t\t\t\t      round_jiffies_relative(HZ));\n\t\treturn;\n\t}\n\n\t/* we're done, now cleanup the data structures */\n\tklp_complete_transition();\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_try_complete_transition(void)\n{\n\tunsigned int cpu;\n\tstruct task_struct *g, *task;\n\tbool complete = true;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\t/*\n\t * Try to switch the tasks to the target patch state by walking their\n\t * stacks and looking for any to-be-patched or to-be-unpatched\n\t * functions.  If such functions are found on a stack, or if the stack\n\t * is deemed unreliable, the task can't be switched yet.\n\t *\n\t * Usually this will transition most (or all) of the tasks on a system\n\t * unless the patch includes changes to a very common function.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (!klp_try_switch_task(task))\n\t\t\tcomplete = false;\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tget_online_cpus();\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (cpu_online(cpu)) {\n\t\t\tif (!klp_try_switch_task(task))\n\t\t\t\tcomplete = false;\n\t\t} else if (task->patch_state != klp_target_state) {\n\t\t\t/* offline idle tasks can be switched immediately */\n\t\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t\t\ttask->patch_state = klp_target_state;\n\t\t}\n\t}\n\tput_online_cpus();\n\n\tif (!complete) {\n\t\t/*\n\t\t * Some tasks weren't able to be switched over.  Try again\n\t\t * later and/or wait for other methods like kernel exit\n\t\t * switching.\n\t\t */\n\t\tschedule_delayed_work(&klp_transition_work,\n\t\t\t\t      round_jiffies_relative(HZ));\n\t\treturn;\n\t}\n\n\t/* we're done, now cleanup the data structures */\n\tklp_complete_transition();\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_start_transition",
          "args": [],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "klp_start_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "417-449",
          "snippet": "void klp_start_transition(void)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\tpr_notice(\"'%s': starting %s transition\\n\",\n\t\t  klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Mark all normal tasks as needing a patch state update.  They'll\n\t * switch either in klp_try_complete_transition() or as they exit the\n\t * kernel.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Mark all idle tasks as needing a patch state update.  They'll switch\n\t * either in klp_try_complete_transition() or at the idle loop switch\n\t * point.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t}\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct klp_patch *klp_transition_patch;",
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_start_transition(void)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\tpr_notice(\"'%s': starting %s transition\\n\",\n\t\t  klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Mark all normal tasks as needing a patch state update.  They'll\n\t * switch either in klp_try_complete_transition() or as they exit the\n\t * kernel.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Mark all idle tasks as needing a patch state update.  They'll switch\n\t * either in klp_try_complete_transition() or at the idle loop switch\n\t * point.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_pre_unpatch_callback",
          "args": [
            "obj"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "klp_pre_unpatch_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.h",
          "lines": "32-36",
          "snippet": "static inline void klp_pre_unpatch_callback(struct klp_object *obj)\n{\n\tif (obj->callbacks.pre_unpatch)\n\t\t(*obj->callbacks.pre_unpatch)(obj);\n}",
          "includes": [
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n\nstatic inline void klp_pre_unpatch_callback(struct klp_object *obj)\n{\n\tif (obj->callbacks.pre_unpatch)\n\t\t(*obj->callbacks.pre_unpatch)(obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_object",
          "args": [
            "patch",
            "obj"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_init_transition",
          "args": [
            "patch",
            "KLP_UNPATCHED"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "klp_init_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/transition.c",
          "lines": "456-522",
          "snippet": "void klp_init_transition(struct klp_patch *patch, int state)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tint initial_state = !state;\n\n\tWARN_ON_ONCE(klp_target_state != KLP_UNDEFINED);\n\n\tklp_transition_patch = patch;\n\n\t/*\n\t * Set the global target patch state which tasks will switch to.  This\n\t * has no effect until the TIF_PATCH_PENDING flags get set later.\n\t */\n\tklp_target_state = state;\n\n\tpr_debug(\"'%s': initializing %s transition\\n\", patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Initialize all tasks to the initial patch state to prepare them for\n\t * switching to the target state.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);\n\t\ttask->patch_state = initial_state;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);\n\t\ttask->patch_state = initial_state;\n\t}\n\n\t/*\n\t * Enforce the order of the task->patch_state initializations and the\n\t * func->transition updates to ensure that klp_ftrace_handler() doesn't\n\t * see a func in transition with a task->patch_state of KLP_UNDEFINED.\n\t *\n\t * Also enforce the order of the klp_target_state write and future\n\t * TIF_PATCH_PENDING writes to ensure klp_update_patch_state() doesn't\n\t * set a task->patch_state to KLP_UNDEFINED.\n\t */\n\tsmp_wmb();\n\n\t/*\n\t * Set the func transition states so klp_ftrace_handler() will know to\n\t * switch to the transition logic.\n\t *\n\t * When patching, the funcs aren't yet in the func_stack and will be\n\t * made visible to the ftrace handler shortly by the calls to\n\t * klp_patch_object().\n\t *\n\t * When unpatching, the funcs are already in the func_stack and so are\n\t * already visible to the ftrace handler.\n\t */\n\tklp_for_each_object(patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = true;\n}",
          "includes": [
            "#include \"../sched/sched.h\"",
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct klp_patch *klp_transition_patch;",
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../sched/sched.h\"\n#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_init_transition(struct klp_patch *patch, int state)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tint initial_state = !state;\n\n\tWARN_ON_ONCE(klp_target_state != KLP_UNDEFINED);\n\n\tklp_transition_patch = patch;\n\n\t/*\n\t * Set the global target patch state which tasks will switch to.  This\n\t * has no effect until the TIF_PATCH_PENDING flags get set later.\n\t */\n\tklp_target_state = state;\n\n\tpr_debug(\"'%s': initializing %s transition\\n\", patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Initialize all tasks to the initial patch state to prepare them for\n\t * switching to the target state.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);\n\t\ttask->patch_state = initial_state;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);\n\t\ttask->patch_state = initial_state;\n\t}\n\n\t/*\n\t * Enforce the order of the task->patch_state initializations and the\n\t * func->transition updates to ensure that klp_ftrace_handler() doesn't\n\t * see a func in transition with a task->patch_state of KLP_UNDEFINED.\n\t *\n\t * Also enforce the order of the klp_target_state write and future\n\t * TIF_PATCH_PENDING writes to ensure klp_update_patch_state() doesn't\n\t * set a task->patch_state to KLP_UNDEFINED.\n\t */\n\tsmp_wmb();\n\n\t/*\n\t * Set the func transition states so klp_ftrace_handler() will know to\n\t * switch to the transition logic.\n\t *\n\t * When patching, the funcs aren't yet in the func_stack and will be\n\t * made visible to the ftrace handler shortly by the calls to\n\t * klp_patch_object().\n\t *\n\t * When unpatching, the funcs are already in the func_stack and so are\n\t * already visible to the ftrace handler.\n\t */\n\tklp_for_each_object(patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_next_entry",
          "args": [
            "patch",
            "list"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_is_last",
          "args": [
            "&patch->list",
            "&klp_patches"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!patch->enabled"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(klp_patches);\n\nstatic int __klp_disable_patch(struct klp_patch *patch)\n{\n\tstruct klp_object *obj;\n\n\tif (WARN_ON(!patch->enabled))\n\t\treturn -EINVAL;\n\n\tif (klp_transition_patch)\n\t\treturn -EBUSY;\n\n\t/* enforce stacking: only the last enabled patch can be disabled */\n\tif (!list_is_last(&patch->list, &klp_patches) &&\n\t    list_next_entry(patch, list)->enabled)\n\t\treturn -EBUSY;\n\n\tklp_init_transition(patch, KLP_UNPATCHED);\n\n\tklp_for_each_object(patch, obj)\n\t\tif (obj->patched)\n\t\t\tklp_pre_unpatch_callback(obj);\n\n\t/*\n\t * Enforce the order of the func->transition writes in\n\t * klp_init_transition() and the TIF_PATCH_PENDING writes in\n\t * klp_start_transition().  In the rare case where klp_ftrace_handler()\n\t * is called shortly after klp_update_patch_state() switches the task,\n\t * this ensures the handler sees that func->transition is set.\n\t */\n\tsmp_wmb();\n\n\tklp_start_transition();\n\tklp_try_complete_transition();\n\tpatch->enabled = false;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "klp_write_object_relocations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "231-279",
    "snippet": "static int klp_write_object_relocations(struct module *pmod,\n\t\t\t\t\tstruct klp_object *obj)\n{\n\tint i, cnt, ret = 0;\n\tconst char *objname, *secname;\n\tchar sec_objname[MODULE_NAME_LEN];\n\tElf_Shdr *sec;\n\n\tif (WARN_ON(!klp_is_object_loaded(obj)))\n\t\treturn -EINVAL;\n\n\tobjname = klp_is_module(obj) ? obj->name : \"vmlinux\";\n\n\t/* For each klp relocation section */\n\tfor (i = 1; i < pmod->klp_info->hdr.e_shnum; i++) {\n\t\tsec = pmod->klp_info->sechdrs + i;\n\t\tsecname = pmod->klp_info->secstrings + sec->sh_name;\n\t\tif (!(sec->sh_flags & SHF_RELA_LIVEPATCH))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Format: .klp.rela.sec_objname.section_name\n\t\t * See comment in klp_resolve_symbols() for an explanation\n\t\t * of the selected field width value.\n\t\t */\n\t\tcnt = sscanf(secname, \".klp.rela.%55[^.]\", sec_objname);\n\t\tif (cnt != 1) {\n\t\t\tpr_err(\"section %s has an incorrectly formatted name\\n\",\n\t\t\t       secname);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strcmp(objname, sec_objname))\n\t\t\tcontinue;\n\n\t\tret = klp_resolve_symbols(sec, pmod);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = apply_relocate_add(pmod->klp_info->sechdrs,\n\t\t\t\t\t pmod->core_kallsyms.strtab,\n\t\t\t\t\t pmod->klp_info->symndx, i, pmod);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply_relocate_add",
          "args": [
            "pmod->klp_info->sechdrs",
            "pmod->core_kallsyms.strtab",
            "pmod->klp_info->symndx",
            "i",
            "pmod"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_resolve_symbols",
          "args": [
            "sec",
            "pmod"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "klp_resolve_symbols",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "176-229",
          "snippet": "static int klp_resolve_symbols(Elf_Shdr *relasec, struct module *pmod)\n{\n\tint i, cnt, vmlinux, ret;\n\tchar objname[MODULE_NAME_LEN];\n\tchar symname[KSYM_NAME_LEN];\n\tchar *strtab = pmod->core_kallsyms.strtab;\n\tElf_Rela *relas;\n\tElf_Sym *sym;\n\tunsigned long sympos, addr;\n\n\t/*\n\t * Since the field widths for objname and symname in the sscanf()\n\t * call are hard-coded and correspond to MODULE_NAME_LEN and\n\t * KSYM_NAME_LEN respectively, we must make sure that MODULE_NAME_LEN\n\t * and KSYM_NAME_LEN have the values we expect them to have.\n\t *\n\t * Because the value of MODULE_NAME_LEN can differ among architectures,\n\t * we use the smallest/strictest upper bound possible (56, based on\n\t * the current definition of MODULE_NAME_LEN) to prevent overflows.\n\t */\n\tBUILD_BUG_ON(MODULE_NAME_LEN < 56 || KSYM_NAME_LEN != 128);\n\n\trelas = (Elf_Rela *) relasec->sh_addr;\n\t/* For each rela in this klp relocation section */\n\tfor (i = 0; i < relasec->sh_size / sizeof(Elf_Rela); i++) {\n\t\tsym = pmod->core_kallsyms.symtab + ELF_R_SYM(relas[i].r_info);\n\t\tif (sym->st_shndx != SHN_LIVEPATCH) {\n\t\t\tpr_err(\"symbol %s is not marked as a livepatch symbol\\n\",\n\t\t\t       strtab + sym->st_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Format: .klp.sym.objname.symname,sympos */\n\t\tcnt = sscanf(strtab + sym->st_name,\n\t\t\t     \".klp.sym.%55[^.].%127[^,],%lu\",\n\t\t\t     objname, symname, &sympos);\n\t\tif (cnt != 3) {\n\t\t\tpr_err(\"symbol %s has an incorrectly formatted name\\n\",\n\t\t\t       strtab + sym->st_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* klp_find_object_symbol() treats a NULL objname as vmlinux */\n\t\tvmlinux = !strcmp(objname, \"vmlinux\");\n\t\tret = klp_find_object_symbol(vmlinux ? NULL : objname,\n\t\t\t\t\t     symname, sympos, &addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsym->st_value = addr;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int klp_resolve_symbols(Elf_Shdr *relasec, struct module *pmod)\n{\n\tint i, cnt, vmlinux, ret;\n\tchar objname[MODULE_NAME_LEN];\n\tchar symname[KSYM_NAME_LEN];\n\tchar *strtab = pmod->core_kallsyms.strtab;\n\tElf_Rela *relas;\n\tElf_Sym *sym;\n\tunsigned long sympos, addr;\n\n\t/*\n\t * Since the field widths for objname and symname in the sscanf()\n\t * call are hard-coded and correspond to MODULE_NAME_LEN and\n\t * KSYM_NAME_LEN respectively, we must make sure that MODULE_NAME_LEN\n\t * and KSYM_NAME_LEN have the values we expect them to have.\n\t *\n\t * Because the value of MODULE_NAME_LEN can differ among architectures,\n\t * we use the smallest/strictest upper bound possible (56, based on\n\t * the current definition of MODULE_NAME_LEN) to prevent overflows.\n\t */\n\tBUILD_BUG_ON(MODULE_NAME_LEN < 56 || KSYM_NAME_LEN != 128);\n\n\trelas = (Elf_Rela *) relasec->sh_addr;\n\t/* For each rela in this klp relocation section */\n\tfor (i = 0; i < relasec->sh_size / sizeof(Elf_Rela); i++) {\n\t\tsym = pmod->core_kallsyms.symtab + ELF_R_SYM(relas[i].r_info);\n\t\tif (sym->st_shndx != SHN_LIVEPATCH) {\n\t\t\tpr_err(\"symbol %s is not marked as a livepatch symbol\\n\",\n\t\t\t       strtab + sym->st_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Format: .klp.sym.objname.symname,sympos */\n\t\tcnt = sscanf(strtab + sym->st_name,\n\t\t\t     \".klp.sym.%55[^.].%127[^,],%lu\",\n\t\t\t     objname, symname, &sympos);\n\t\tif (cnt != 3) {\n\t\t\tpr_err(\"symbol %s has an incorrectly formatted name\\n\",\n\t\t\t       strtab + sym->st_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* klp_find_object_symbol() treats a NULL objname as vmlinux */\n\t\tvmlinux = !strcmp(objname, \"vmlinux\");\n\t\tret = klp_find_object_symbol(vmlinux ? NULL : objname,\n\t\t\t\t\t     symname, sympos, &addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsym->st_value = addr;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "objname",
            "sec_objname"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"section %s has an incorrectly formatted name\\n\"",
            "secname"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "secname",
            "\".klp.rela.%55[^.]\"",
            "sec_objname"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_is_module",
          "args": [
            "obj"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "klp_is_module",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "52-55",
          "snippet": "static bool klp_is_module(struct klp_object *obj)\n{\n\treturn obj->name;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic bool klp_is_module(struct klp_object *obj)\n{\n\treturn obj->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!klp_is_object_loaded(obj)"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_is_object_loaded",
          "args": [
            "obj"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "klp_is_object_loaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.h",
          "lines": "9-12",
          "snippet": "static inline bool klp_is_object_loaded(struct klp_object *obj)\n{\n\treturn !obj->name || obj->mod;\n}",
          "includes": [
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n\nstatic inline bool klp_is_object_loaded(struct klp_object *obj)\n{\n\treturn !obj->name || obj->mod;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int klp_write_object_relocations(struct module *pmod,\n\t\t\t\t\tstruct klp_object *obj)\n{\n\tint i, cnt, ret = 0;\n\tconst char *objname, *secname;\n\tchar sec_objname[MODULE_NAME_LEN];\n\tElf_Shdr *sec;\n\n\tif (WARN_ON(!klp_is_object_loaded(obj)))\n\t\treturn -EINVAL;\n\n\tobjname = klp_is_module(obj) ? obj->name : \"vmlinux\";\n\n\t/* For each klp relocation section */\n\tfor (i = 1; i < pmod->klp_info->hdr.e_shnum; i++) {\n\t\tsec = pmod->klp_info->sechdrs + i;\n\t\tsecname = pmod->klp_info->secstrings + sec->sh_name;\n\t\tif (!(sec->sh_flags & SHF_RELA_LIVEPATCH))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Format: .klp.rela.sec_objname.section_name\n\t\t * See comment in klp_resolve_symbols() for an explanation\n\t\t * of the selected field width value.\n\t\t */\n\t\tcnt = sscanf(secname, \".klp.rela.%55[^.]\", sec_objname);\n\t\tif (cnt != 1) {\n\t\t\tpr_err(\"section %s has an incorrectly formatted name\\n\",\n\t\t\t       secname);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strcmp(objname, sec_objname))\n\t\t\tcontinue;\n\n\t\tret = klp_resolve_symbols(sec, pmod);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = apply_relocate_add(pmod->klp_info->sechdrs,\n\t\t\t\t\t pmod->core_kallsyms.strtab,\n\t\t\t\t\t pmod->klp_info->symndx, i, pmod);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "klp_resolve_symbols",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "176-229",
    "snippet": "static int klp_resolve_symbols(Elf_Shdr *relasec, struct module *pmod)\n{\n\tint i, cnt, vmlinux, ret;\n\tchar objname[MODULE_NAME_LEN];\n\tchar symname[KSYM_NAME_LEN];\n\tchar *strtab = pmod->core_kallsyms.strtab;\n\tElf_Rela *relas;\n\tElf_Sym *sym;\n\tunsigned long sympos, addr;\n\n\t/*\n\t * Since the field widths for objname and symname in the sscanf()\n\t * call are hard-coded and correspond to MODULE_NAME_LEN and\n\t * KSYM_NAME_LEN respectively, we must make sure that MODULE_NAME_LEN\n\t * and KSYM_NAME_LEN have the values we expect them to have.\n\t *\n\t * Because the value of MODULE_NAME_LEN can differ among architectures,\n\t * we use the smallest/strictest upper bound possible (56, based on\n\t * the current definition of MODULE_NAME_LEN) to prevent overflows.\n\t */\n\tBUILD_BUG_ON(MODULE_NAME_LEN < 56 || KSYM_NAME_LEN != 128);\n\n\trelas = (Elf_Rela *) relasec->sh_addr;\n\t/* For each rela in this klp relocation section */\n\tfor (i = 0; i < relasec->sh_size / sizeof(Elf_Rela); i++) {\n\t\tsym = pmod->core_kallsyms.symtab + ELF_R_SYM(relas[i].r_info);\n\t\tif (sym->st_shndx != SHN_LIVEPATCH) {\n\t\t\tpr_err(\"symbol %s is not marked as a livepatch symbol\\n\",\n\t\t\t       strtab + sym->st_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Format: .klp.sym.objname.symname,sympos */\n\t\tcnt = sscanf(strtab + sym->st_name,\n\t\t\t     \".klp.sym.%55[^.].%127[^,],%lu\",\n\t\t\t     objname, symname, &sympos);\n\t\tif (cnt != 3) {\n\t\t\tpr_err(\"symbol %s has an incorrectly formatted name\\n\",\n\t\t\t       strtab + sym->st_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* klp_find_object_symbol() treats a NULL objname as vmlinux */\n\t\tvmlinux = !strcmp(objname, \"vmlinux\");\n\t\tret = klp_find_object_symbol(vmlinux ? NULL : objname,\n\t\t\t\t\t     symname, sympos, &addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsym->st_value = addr;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_find_object_symbol",
          "args": [
            "vmlinux ? NULL : objname",
            "symname",
            "sympos",
            "&addr"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "klp_find_object_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "137-174",
          "snippet": "static int klp_find_object_symbol(const char *objname, const char *name,\n\t\t\t\t  unsigned long sympos, unsigned long *addr)\n{\n\tstruct klp_find_arg args = {\n\t\t.objname = objname,\n\t\t.name = name,\n\t\t.addr = 0,\n\t\t.count = 0,\n\t\t.pos = sympos,\n\t};\n\n\tmutex_lock(&module_mutex);\n\tif (objname)\n\t\tmodule_kallsyms_on_each_symbol(klp_find_callback, &args);\n\telse\n\t\tkallsyms_on_each_symbol(klp_find_callback, &args);\n\tmutex_unlock(&module_mutex);\n\n\t/*\n\t * Ensure an address was found. If sympos is 0, ensure symbol is unique;\n\t * otherwise ensure the symbol position count matches sympos.\n\t */\n\tif (args.addr == 0)\n\t\tpr_err(\"symbol '%s' not found in symbol table\\n\", name);\n\telse if (args.count > 1 && sympos == 0) {\n\t\tpr_err(\"unresolvable ambiguity for symbol '%s' in object '%s'\\n\",\n\t\t       name, objname);\n\t} else if (sympos != args.count && sympos > 0) {\n\t\tpr_err(\"symbol position %lu for symbol '%s' in object '%s' not found\\n\",\n\t\t       sympos, name, objname ? objname : \"vmlinux\");\n\t} else {\n\t\t*addr = args.addr;\n\t\treturn 0;\n\t}\n\n\t*addr = 0;\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int klp_find_object_symbol(const char *objname, const char *name,\n\t\t\t\t  unsigned long sympos, unsigned long *addr)\n{\n\tstruct klp_find_arg args = {\n\t\t.objname = objname,\n\t\t.name = name,\n\t\t.addr = 0,\n\t\t.count = 0,\n\t\t.pos = sympos,\n\t};\n\n\tmutex_lock(&module_mutex);\n\tif (objname)\n\t\tmodule_kallsyms_on_each_symbol(klp_find_callback, &args);\n\telse\n\t\tkallsyms_on_each_symbol(klp_find_callback, &args);\n\tmutex_unlock(&module_mutex);\n\n\t/*\n\t * Ensure an address was found. If sympos is 0, ensure symbol is unique;\n\t * otherwise ensure the symbol position count matches sympos.\n\t */\n\tif (args.addr == 0)\n\t\tpr_err(\"symbol '%s' not found in symbol table\\n\", name);\n\telse if (args.count > 1 && sympos == 0) {\n\t\tpr_err(\"unresolvable ambiguity for symbol '%s' in object '%s'\\n\",\n\t\t       name, objname);\n\t} else if (sympos != args.count && sympos > 0) {\n\t\tpr_err(\"symbol position %lu for symbol '%s' in object '%s' not found\\n\",\n\t\t       sympos, name, objname ? objname : \"vmlinux\");\n\t} else {\n\t\t*addr = args.addr;\n\t\treturn 0;\n\t}\n\n\t*addr = 0;\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "objname",
            "\"vmlinux\""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"symbol %s has an incorrectly formatted name\\n\"",
            "strtab + sym->st_name"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "strtab + sym->st_name",
            "\".klp.sym.%55[^.].%127[^,],%lu\"",
            "objname",
            "symname",
            "&sympos"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"symbol %s is not marked as a livepatch symbol\\n\"",
            "strtab + sym->st_name"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_R_SYM",
          "args": [
            "relas[i].r_info"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "MODULE_NAME_LEN < 56 || KSYM_NAME_LEN != 128"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int klp_resolve_symbols(Elf_Shdr *relasec, struct module *pmod)\n{\n\tint i, cnt, vmlinux, ret;\n\tchar objname[MODULE_NAME_LEN];\n\tchar symname[KSYM_NAME_LEN];\n\tchar *strtab = pmod->core_kallsyms.strtab;\n\tElf_Rela *relas;\n\tElf_Sym *sym;\n\tunsigned long sympos, addr;\n\n\t/*\n\t * Since the field widths for objname and symname in the sscanf()\n\t * call are hard-coded and correspond to MODULE_NAME_LEN and\n\t * KSYM_NAME_LEN respectively, we must make sure that MODULE_NAME_LEN\n\t * and KSYM_NAME_LEN have the values we expect them to have.\n\t *\n\t * Because the value of MODULE_NAME_LEN can differ among architectures,\n\t * we use the smallest/strictest upper bound possible (56, based on\n\t * the current definition of MODULE_NAME_LEN) to prevent overflows.\n\t */\n\tBUILD_BUG_ON(MODULE_NAME_LEN < 56 || KSYM_NAME_LEN != 128);\n\n\trelas = (Elf_Rela *) relasec->sh_addr;\n\t/* For each rela in this klp relocation section */\n\tfor (i = 0; i < relasec->sh_size / sizeof(Elf_Rela); i++) {\n\t\tsym = pmod->core_kallsyms.symtab + ELF_R_SYM(relas[i].r_info);\n\t\tif (sym->st_shndx != SHN_LIVEPATCH) {\n\t\t\tpr_err(\"symbol %s is not marked as a livepatch symbol\\n\",\n\t\t\t       strtab + sym->st_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Format: .klp.sym.objname.symname,sympos */\n\t\tcnt = sscanf(strtab + sym->st_name,\n\t\t\t     \".klp.sym.%55[^.].%127[^,],%lu\",\n\t\t\t     objname, symname, &sympos);\n\t\tif (cnt != 3) {\n\t\t\tpr_err(\"symbol %s has an incorrectly formatted name\\n\",\n\t\t\t       strtab + sym->st_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* klp_find_object_symbol() treats a NULL objname as vmlinux */\n\t\tvmlinux = !strcmp(objname, \"vmlinux\");\n\t\tret = klp_find_object_symbol(vmlinux ? NULL : objname,\n\t\t\t\t\t     symname, sympos, &addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsym->st_value = addr;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "klp_find_object_symbol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "137-174",
    "snippet": "static int klp_find_object_symbol(const char *objname, const char *name,\n\t\t\t\t  unsigned long sympos, unsigned long *addr)\n{\n\tstruct klp_find_arg args = {\n\t\t.objname = objname,\n\t\t.name = name,\n\t\t.addr = 0,\n\t\t.count = 0,\n\t\t.pos = sympos,\n\t};\n\n\tmutex_lock(&module_mutex);\n\tif (objname)\n\t\tmodule_kallsyms_on_each_symbol(klp_find_callback, &args);\n\telse\n\t\tkallsyms_on_each_symbol(klp_find_callback, &args);\n\tmutex_unlock(&module_mutex);\n\n\t/*\n\t * Ensure an address was found. If sympos is 0, ensure symbol is unique;\n\t * otherwise ensure the symbol position count matches sympos.\n\t */\n\tif (args.addr == 0)\n\t\tpr_err(\"symbol '%s' not found in symbol table\\n\", name);\n\telse if (args.count > 1 && sympos == 0) {\n\t\tpr_err(\"unresolvable ambiguity for symbol '%s' in object '%s'\\n\",\n\t\t       name, objname);\n\t} else if (sympos != args.count && sympos > 0) {\n\t\tpr_err(\"symbol position %lu for symbol '%s' in object '%s' not found\\n\",\n\t\t       sympos, name, objname ? objname : \"vmlinux\");\n\t} else {\n\t\t*addr = args.addr;\n\t\treturn 0;\n\t}\n\n\t*addr = 0;\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"symbol position %lu for symbol '%s' in object '%s' not found\\n\"",
            "sympos",
            "name",
            "objname ? objname : \"vmlinux\""
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unresolvable ambiguity for symbol '%s' in object '%s'\\n\"",
            "name",
            "objname"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"symbol '%s' not found in symbol table\\n\"",
            "name"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&module_mutex"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_on_each_symbol",
          "args": [
            "klp_find_callback",
            "&args"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "module_kallsyms_on_each_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "4113-4141",
          "snippet": "int module_kallsyms_on_each_symbol(int (*fn)(void *, const char *,\n\t\t\t\t\t     struct module *, unsigned long),\n\t\t\t\t   void *data)\n{\n\tstruct module *mod;\n\tunsigned int i;\n\tint ret;\n\n\tmodule_assert_mutex();\n\n\tlist_for_each_entry(mod, &modules, list) {\n\t\t/* We hold module_mutex: no need for rcu_dereference_sched */\n\t\tstruct mod_kallsyms *kallsyms = mod->kallsyms;\n\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < kallsyms->num_symtab; i++) {\n\n\t\t\tif (kallsyms->symtab[i].st_shndx == SHN_UNDEF)\n\t\t\t\tcontinue;\n\n\t\t\tret = fn(data, symname(kallsyms, i),\n\t\t\t\t mod, kallsyms->symtab[i].st_value);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\n\nint module_kallsyms_on_each_symbol(int (*fn)(void *, const char *,\n\t\t\t\t\t     struct module *, unsigned long),\n\t\t\t\t   void *data)\n{\n\tstruct module *mod;\n\tunsigned int i;\n\tint ret;\n\n\tmodule_assert_mutex();\n\n\tlist_for_each_entry(mod, &modules, list) {\n\t\t/* We hold module_mutex: no need for rcu_dereference_sched */\n\t\tstruct mod_kallsyms *kallsyms = mod->kallsyms;\n\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < kallsyms->num_symtab; i++) {\n\n\t\t\tif (kallsyms->symtab[i].st_shndx == SHN_UNDEF)\n\t\t\t\tcontinue;\n\n\t\t\tret = fn(data, symname(kallsyms, i),\n\t\t\t\t mod, kallsyms->symtab[i].st_value);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&module_mutex"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int klp_find_object_symbol(const char *objname, const char *name,\n\t\t\t\t  unsigned long sympos, unsigned long *addr)\n{\n\tstruct klp_find_arg args = {\n\t\t.objname = objname,\n\t\t.name = name,\n\t\t.addr = 0,\n\t\t.count = 0,\n\t\t.pos = sympos,\n\t};\n\n\tmutex_lock(&module_mutex);\n\tif (objname)\n\t\tmodule_kallsyms_on_each_symbol(klp_find_callback, &args);\n\telse\n\t\tkallsyms_on_each_symbol(klp_find_callback, &args);\n\tmutex_unlock(&module_mutex);\n\n\t/*\n\t * Ensure an address was found. If sympos is 0, ensure symbol is unique;\n\t * otherwise ensure the symbol position count matches sympos.\n\t */\n\tif (args.addr == 0)\n\t\tpr_err(\"symbol '%s' not found in symbol table\\n\", name);\n\telse if (args.count > 1 && sympos == 0) {\n\t\tpr_err(\"unresolvable ambiguity for symbol '%s' in object '%s'\\n\",\n\t\t       name, objname);\n\t} else if (sympos != args.count && sympos > 0) {\n\t\tpr_err(\"symbol position %lu for symbol '%s' in object '%s' not found\\n\",\n\t\t       sympos, name, objname ? objname : \"vmlinux\");\n\t} else {\n\t\t*addr = args.addr;\n\t\treturn 0;\n\t}\n\n\t*addr = 0;\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "klp_find_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "109-135",
    "snippet": "static int klp_find_callback(void *data, const char *name,\n\t\t\t     struct module *mod, unsigned long addr)\n{\n\tstruct klp_find_arg *args = data;\n\n\tif ((mod && !args->objname) || (!mod && args->objname))\n\t\treturn 0;\n\n\tif (strcmp(args->name, name))\n\t\treturn 0;\n\n\tif (args->objname && strcmp(args->objname, mod->name))\n\t\treturn 0;\n\n\targs->addr = addr;\n\targs->count++;\n\n\t/*\n\t * Finish the search when the symbol is found for the desired position\n\t * or the position is not defined for a non-unique symbol.\n\t */\n\tif ((args->pos && (args->count == args->pos)) ||\n\t    (!args->pos && (args->count > 1)))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args->objname",
            "mod->name"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args->name",
            "name"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int klp_find_callback(void *data, const char *name,\n\t\t\t     struct module *mod, unsigned long addr)\n{\n\tstruct klp_find_arg *args = data;\n\n\tif ((mod && !args->objname) || (!mod && args->objname))\n\t\treturn 0;\n\n\tif (strcmp(args->name, name))\n\t\treturn 0;\n\n\tif (args->objname && strcmp(args->objname, mod->name))\n\t\treturn 0;\n\n\targs->addr = addr;\n\targs->count++;\n\n\t/*\n\t * Finish the search when the symbol is found for the desired position\n\t * or the position is not defined for a non-unique symbol.\n\t */\n\tif ((args->pos && (args->count == args->pos)) ||\n\t    (!args->pos && (args->count > 1)))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "klp_initialized",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "96-99",
    "snippet": "static bool klp_initialized(void)\n{\n\treturn !!klp_root_kobj;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kobject *klp_root_kobj;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct kobject *klp_root_kobj;\n\nstatic bool klp_initialized(void)\n{\n\treturn !!klp_root_kobj;\n}"
  },
  {
    "function_name": "klp_is_patch_registered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "85-94",
    "snippet": "static bool klp_is_patch_registered(struct klp_patch *patch)\n{\n\tstruct klp_patch *mypatch;\n\n\tlist_for_each_entry(mypatch, &klp_patches, list)\n\t\tif (mypatch == patch)\n\t\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(klp_patches);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "mypatch",
            "&klp_patches",
            "list"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(klp_patches);\n\nstatic bool klp_is_patch_registered(struct klp_patch *patch)\n{\n\tstruct klp_patch *mypatch;\n\n\tlist_for_each_entry(mypatch, &klp_patches, list)\n\t\tif (mypatch == patch)\n\t\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "klp_find_object_module",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "58-83",
    "snippet": "static void klp_find_object_module(struct klp_object *obj)\n{\n\tstruct module *mod;\n\n\tif (!klp_is_module(obj))\n\t\treturn;\n\n\tmutex_lock(&module_mutex);\n\t/*\n\t * We do not want to block removal of patched modules and therefore\n\t * we do not take a reference here. The patches are removed by\n\t * klp_module_going() instead.\n\t */\n\tmod = find_module(obj->name);\n\t/*\n\t * Do not mess work of klp_module_coming() and klp_module_going().\n\t * Note that the patch might still be needed before klp_module_going()\n\t * is called. Module functions can be called even in the GOING state\n\t * until mod->exit() finishes. This is especially important for\n\t * patches that modify semantic of the functions.\n\t */\n\tif (mod && mod->klp_alive)\n\t\tobj->mod = mod;\n\n\tmutex_unlock(&module_mutex);\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&module_mutex"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_module",
          "args": [
            "obj->name"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "find_module",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "621-625",
          "snippet": "struct module *find_module(const char *name)\n{\n\tmodule_assert_mutex();\n\treturn find_module_all(name, strlen(name), false);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstruct module *find_module(const char *name)\n{\n\tmodule_assert_mutex();\n\treturn find_module_all(name, strlen(name), false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&module_mutex"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_is_module",
          "args": [
            "obj"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "klp_is_module",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
          "lines": "52-55",
          "snippet": "static bool klp_is_module(struct klp_object *obj)\n{\n\treturn obj->name;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic bool klp_is_module(struct klp_object *obj)\n{\n\treturn obj->name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void klp_find_object_module(struct klp_object *obj)\n{\n\tstruct module *mod;\n\n\tif (!klp_is_module(obj))\n\t\treturn;\n\n\tmutex_lock(&module_mutex);\n\t/*\n\t * We do not want to block removal of patched modules and therefore\n\t * we do not take a reference here. The patches are removed by\n\t * klp_module_going() instead.\n\t */\n\tmod = find_module(obj->name);\n\t/*\n\t * Do not mess work of klp_module_coming() and klp_module_going().\n\t * Note that the patch might still be needed before klp_module_going()\n\t * is called. Module functions can be called even in the GOING state\n\t * until mod->exit() finishes. This is especially important for\n\t * patches that modify semantic of the functions.\n\t */\n\tif (mod && mod->klp_alive)\n\t\tobj->mod = mod;\n\n\tmutex_unlock(&module_mutex);\n}"
  },
  {
    "function_name": "klp_is_module",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/livepatch/core.c",
    "lines": "52-55",
    "snippet": "static bool klp_is_module(struct klp_object *obj)\n{\n\treturn obj->name;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <asm/cacheflush.h>",
      "#include <linux/completion.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/list.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic bool klp_is_module(struct klp_object *obj)\n{\n\treturn obj->name;\n}"
  }
]