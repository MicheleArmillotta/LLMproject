[
  {
    "function_name": "fei_debugfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "330-353",
    "snippet": "static int __init fei_debugfs_init(void)\n{\n\tstruct dentry *dir;\n\n\tdir = fault_create_debugfs_attr(\"fail_function\", NULL,\n\t\t\t\t\t&fei_fault_attr);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\n\t/* injectable attribute is just a symlink of error_inject/list */\n\tif (!debugfs_create_symlink(\"injectable\", dir,\n\t\t\t\t    \"../error_injection/list\"))\n\t\tgoto error;\n\n\tif (!debugfs_create_file(\"inject\", 0600, dir, NULL, &fei_ops))\n\t\tgoto error;\n\n\tfei_debugfs_dir = dir;\n\n\treturn 0;\nerror:\n\tdebugfs_remove_recursive(dir);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_FAULT_ATTR(fei_fault_attr);",
      "static struct dentry *fei_debugfs_dir;",
      "static const struct file_operations fei_ops = {\n\t.open =\t\tfei_open,\n\t.read =\t\tseq_read,\n\t.write =\tfei_write,\n\t.llseek =\tseq_lseek,\n\t.release =\tseq_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove_recursive",
          "args": [
            "dir"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"inject\"",
            "0600",
            "dir",
            "NULL",
            "&fei_ops"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_symlink",
          "args": [
            "\"injectable\"",
            "dir",
            "\"../error_injection/list\""
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dir"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dir"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fault_create_debugfs_attr",
          "args": [
            "\"fail_function\"",
            "NULL",
            "&fei_fault_attr"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic DECLARE_FAULT_ATTR(fei_fault_attr);\nstatic struct dentry *fei_debugfs_dir;\nstatic const struct file_operations fei_ops = {\n\t.open =\t\tfei_open,\n\t.read =\t\tseq_read,\n\t.write =\tfei_write,\n\t.llseek =\tseq_lseek,\n\t.release =\tseq_release,\n};\n\nstatic int __init fei_debugfs_init(void)\n{\n\tstruct dentry *dir;\n\n\tdir = fault_create_debugfs_attr(\"fail_function\", NULL,\n\t\t\t\t\t&fei_fault_attr);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\n\t/* injectable attribute is just a symlink of error_inject/list */\n\tif (!debugfs_create_symlink(\"injectable\", dir,\n\t\t\t\t    \"../error_injection/list\"))\n\t\tgoto error;\n\n\tif (!debugfs_create_file(\"inject\", 0600, dir, NULL, &fei_ops))\n\t\tgoto error;\n\n\tfei_debugfs_dir = dir;\n\n\treturn 0;\nerror:\n\tdebugfs_remove_recursive(dir);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "fei_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "246-320",
    "snippet": "static ssize_t fei_write(struct file *file, const char __user *buffer,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct fei_attr *attr;\n\tunsigned long addr;\n\tchar *buf, *sym;\n\tint ret;\n\n\t/* cut off if it is too long */\n\tif (count > KSYM_NAME_LEN)\n\t\tcount = KSYM_NAME_LEN;\n\tbuf = kmalloc(count + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(buf, buffer, count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tbuf[count] = '\\0';\n\tsym = strstrip(buf);\n\n\tmutex_lock(&fei_lock);\n\n\t/* Writing just spaces will remove all injection points */\n\tif (sym[0] == '\\0') {\n\t\tfei_attr_remove_all();\n\t\tret = count;\n\t\tgoto out;\n\t}\n\t/* Writing !function will remove one injection point */\n\tif (sym[0] == '!') {\n\t\tattr = fei_attr_lookup(sym + 1);\n\t\tif (!attr) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tfei_attr_remove(attr);\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\taddr = kallsyms_lookup_name(sym);\n\tif (!addr) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!within_error_injection_list(addr)) {\n\t\tret = -ERANGE;\n\t\tgoto out;\n\t}\n\tif (fei_attr_lookup(sym)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\tattr = fei_attr_new(sym, addr);\n\tif (!attr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = register_kprobe(&attr->kp);\n\tif (!ret)\n\t\tret = fei_debugfs_add_attr(attr);\n\tif (ret < 0)\n\t\tfei_attr_remove(attr);\n\telse {\n\t\tlist_add_tail(&attr->list, &fei_attr_list);\n\t\tret = count;\n\t}\nout:\n\tkfree(buf);\n\tmutex_unlock(&fei_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(fei_lock);",
      "static LIST_HEAD(fei_attr_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fei_lock"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&attr->list",
            "&fei_attr_list"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fei_attr_remove",
          "args": [
            "attr"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "fei_attr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
          "lines": "229-235",
          "snippet": "static void fei_attr_remove(struct fei_attr *attr)\n{\n\tfei_debugfs_remove_attr(attr);\n\tunregister_kprobe(&attr->kp);\n\tlist_del(&attr->list);\n\tfei_attr_free(attr);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic void fei_attr_remove(struct fei_attr *attr)\n{\n\tfei_debugfs_remove_attr(attr);\n\tunregister_kprobe(&attr->kp);\n\tlist_del(&attr->list);\n\tfei_attr_free(attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fei_debugfs_add_attr",
          "args": [
            "attr"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "fei_debugfs_add_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
          "lines": "155-169",
          "snippet": "static int fei_debugfs_add_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(attr->kp.symbol_name, fei_debugfs_dir);\n\tif (!dir)\n\t\treturn -ENOMEM;\n\n\tif (!debugfs_create_file(\"retval\", 0600, dir, attr, &fei_retval_ops)) {\n\t\tdebugfs_remove_recursive(dir);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *fei_debugfs_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic int fei_debugfs_add_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(attr->kp.symbol_name, fei_debugfs_dir);\n\tif (!dir)\n\t\treturn -ENOMEM;\n\n\tif (!debugfs_create_file(\"retval\", 0600, dir, attr, &fei_retval_ops)) {\n\t\tdebugfs_remove_recursive(dir);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_kprobe",
          "args": [
            "&attr->kp"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1761-1764",
          "snippet": "void unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fei_attr_new",
          "args": [
            "sym",
            "addr"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "fei_attr_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
          "lines": "56-73",
          "snippet": "static struct fei_attr *fei_attr_new(const char *sym, unsigned long addr)\n{\n\tstruct fei_attr *attr;\n\n\tattr = kzalloc(sizeof(*attr), GFP_KERNEL);\n\tif (attr) {\n\t\tattr->kp.symbol_name = kstrdup(sym, GFP_KERNEL);\n\t\tif (!attr->kp.symbol_name) {\n\t\t\tkfree(attr);\n\t\t\treturn NULL;\n\t\t}\n\t\tattr->kp.pre_handler = fei_kprobe_handler;\n\t\tattr->kp.post_handler = fei_post_handler;\n\t\tattr->retval = adjust_error_retval(addr, 0);\n\t\tINIT_LIST_HEAD(&attr->list);\n\t}\n\treturn attr;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct fei_attr *fei_attr_new(const char *sym, unsigned long addr)\n{\n\tstruct fei_attr *attr;\n\n\tattr = kzalloc(sizeof(*attr), GFP_KERNEL);\n\tif (attr) {\n\t\tattr->kp.symbol_name = kstrdup(sym, GFP_KERNEL);\n\t\tif (!attr->kp.symbol_name) {\n\t\t\tkfree(attr);\n\t\t\treturn NULL;\n\t\t}\n\t\tattr->kp.pre_handler = fei_kprobe_handler;\n\t\tattr->kp.post_handler = fei_post_handler;\n\t\tattr->retval = adjust_error_retval(addr, 0);\n\t\tINIT_LIST_HEAD(&attr->list);\n\t}\n\treturn attr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fei_attr_lookup",
          "args": [
            "sym"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "fei_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
          "lines": "83-93",
          "snippet": "static struct fei_attr *fei_attr_lookup(const char *sym)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (!strcmp(attr->kp.symbol_name, sym))\n\t\t\treturn attr;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fei_attr_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic LIST_HEAD(fei_attr_list);\n\nstatic struct fei_attr *fei_attr_lookup(const char *sym)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (!strcmp(attr->kp.symbol_name, sym))\n\t\t\treturn attr;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "within_error_injection_list",
          "args": [
            "addr"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup_name",
          "args": [
            "sym"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "module_kallsyms_lookup_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "4090-4111",
          "snippet": "unsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = mod_find_symname(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = mod_find_symname(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\n\nunsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = mod_find_symname(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = mod_find_symname(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fei_attr_remove_all",
          "args": [],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "fei_attr_remove_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
          "lines": "237-244",
          "snippet": "static void fei_attr_remove_all(void)\n{\n\tstruct fei_attr *attr, *n;\n\n\tlist_for_each_entry_safe(attr, n, &fei_attr_list, list) {\n\t\tfei_attr_remove(attr);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fei_attr_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic LIST_HEAD(fei_attr_list);\n\nstatic void fei_attr_remove_all(void)\n{\n\tstruct fei_attr *attr, *n;\n\n\tlist_for_each_entry_safe(attr, n, &fei_attr_list, list) {\n\t\tfei_attr_remove(attr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fei_lock"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buf",
            "buffer",
            "count"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "count + 1",
            "GFP_KERNEL"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic DEFINE_MUTEX(fei_lock);\nstatic LIST_HEAD(fei_attr_list);\n\nstatic ssize_t fei_write(struct file *file, const char __user *buffer,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct fei_attr *attr;\n\tunsigned long addr;\n\tchar *buf, *sym;\n\tint ret;\n\n\t/* cut off if it is too long */\n\tif (count > KSYM_NAME_LEN)\n\t\tcount = KSYM_NAME_LEN;\n\tbuf = kmalloc(count + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(buf, buffer, count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tbuf[count] = '\\0';\n\tsym = strstrip(buf);\n\n\tmutex_lock(&fei_lock);\n\n\t/* Writing just spaces will remove all injection points */\n\tif (sym[0] == '\\0') {\n\t\tfei_attr_remove_all();\n\t\tret = count;\n\t\tgoto out;\n\t}\n\t/* Writing !function will remove one injection point */\n\tif (sym[0] == '!') {\n\t\tattr = fei_attr_lookup(sym + 1);\n\t\tif (!attr) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tfei_attr_remove(attr);\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\taddr = kallsyms_lookup_name(sym);\n\tif (!addr) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!within_error_injection_list(addr)) {\n\t\tret = -ERANGE;\n\t\tgoto out;\n\t}\n\tif (fei_attr_lookup(sym)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\tattr = fei_attr_new(sym, addr);\n\tif (!attr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = register_kprobe(&attr->kp);\n\tif (!ret)\n\t\tret = fei_debugfs_add_attr(attr);\n\tif (ret < 0)\n\t\tfei_attr_remove(attr);\n\telse {\n\t\tlist_add_tail(&attr->list, &fei_attr_list);\n\t\tret = count;\n\t}\nout:\n\tkfree(buf);\n\tmutex_unlock(&fei_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "fei_attr_remove_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "237-244",
    "snippet": "static void fei_attr_remove_all(void)\n{\n\tstruct fei_attr *attr, *n;\n\n\tlist_for_each_entry_safe(attr, n, &fei_attr_list, list) {\n\t\tfei_attr_remove(attr);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(fei_attr_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fei_attr_remove",
          "args": [
            "attr"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "fei_attr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
          "lines": "229-235",
          "snippet": "static void fei_attr_remove(struct fei_attr *attr)\n{\n\tfei_debugfs_remove_attr(attr);\n\tunregister_kprobe(&attr->kp);\n\tlist_del(&attr->list);\n\tfei_attr_free(attr);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic void fei_attr_remove(struct fei_attr *attr)\n{\n\tfei_debugfs_remove_attr(attr);\n\tunregister_kprobe(&attr->kp);\n\tlist_del(&attr->list);\n\tfei_attr_free(attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "attr",
            "n",
            "&fei_attr_list",
            "list"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic LIST_HEAD(fei_attr_list);\n\nstatic void fei_attr_remove_all(void)\n{\n\tstruct fei_attr *attr, *n;\n\n\tlist_for_each_entry_safe(attr, n, &fei_attr_list, list) {\n\t\tfei_attr_remove(attr);\n\t}\n}"
  },
  {
    "function_name": "fei_attr_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "229-235",
    "snippet": "static void fei_attr_remove(struct fei_attr *attr)\n{\n\tfei_debugfs_remove_attr(attr);\n\tunregister_kprobe(&attr->kp);\n\tlist_del(&attr->list);\n\tfei_attr_free(attr);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fei_attr_free",
          "args": [
            "attr"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "fei_attr_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
          "lines": "75-81",
          "snippet": "static void fei_attr_free(struct fei_attr *attr)\n{\n\tif (attr) {\n\t\tkfree(attr->kp.symbol_name);\n\t\tkfree(attr);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic void fei_attr_free(struct fei_attr *attr)\n{\n\tif (attr) {\n\t\tkfree(attr->kp.symbol_name);\n\t\tkfree(attr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&attr->list"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_kprobe",
          "args": [
            "&attr->kp"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kprobes.c",
          "lines": "1761-1764",
          "snippet": "void unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fei_debugfs_remove_attr",
          "args": [
            "attr"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "fei_debugfs_remove_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
          "lines": "171-177",
          "snippet": "static void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *fei_debugfs_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic void fei_attr_remove(struct fei_attr *attr)\n{\n\tfei_debugfs_remove_attr(attr);\n\tunregister_kprobe(&attr->kp);\n\tlist_del(&attr->list);\n\tfei_attr_free(attr);\n}"
  },
  {
    "function_name": "fei_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "224-227",
    "snippet": "static int fei_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &fei_seq_ops);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations fei_seq_ops = {\n\t.start\t= fei_seq_start,\n\t.next\t= fei_seq_next,\n\t.stop\t= fei_seq_stop,\n\t.show\t= fei_seq_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&fei_seq_ops"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "179-213",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic const struct seq_operations fei_seq_ops = {\n\t.start\t= fei_seq_start,\n\t.next\t= fei_seq_next,\n\t.stop\t= fei_seq_stop,\n\t.show\t= fei_seq_show,\n};\n\nstatic int fei_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &fei_seq_ops);\n}"
  },
  {
    "function_name": "fei_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "209-215",
    "snippet": "static int fei_seq_show(struct seq_file *m, void *v)\n{\n\tstruct fei_attr *attr = list_entry(v, struct fei_attr, list);\n\n\tseq_printf(m, \"%pf\\n\", attr->kp.addr);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%pf\\n\"",
            "attr->kp.addr"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "v",
            "structfei_attr",
            "list"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic int fei_seq_show(struct seq_file *m, void *v)\n{\n\tstruct fei_attr *attr = list_entry(v, struct fei_attr, list);\n\n\tseq_printf(m, \"%pf\\n\", attr->kp.addr);\n\treturn 0;\n}"
  },
  {
    "function_name": "fei_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "204-207",
    "snippet": "static void *fei_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &fei_attr_list, pos);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(fei_attr_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "v",
            "&fei_attr_list",
            "pos"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic LIST_HEAD(fei_attr_list);\n\nstatic void *fei_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &fei_attr_list, pos);\n}"
  },
  {
    "function_name": "fei_seq_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "199-202",
    "snippet": "static void fei_seq_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&fei_lock);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(fei_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fei_lock"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic DEFINE_MUTEX(fei_lock);\n\nstatic void fei_seq_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&fei_lock);\n}"
  },
  {
    "function_name": "fei_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "191-197",
    "snippet": "NOKPROBE_SYMBOL(fei_kprobe_handler)\n\nstatic void *fei_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&fei_lock);\n\treturn seq_list_start(&fei_attr_list, *pos);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(fei_lock);",
      "static LIST_HEAD(fei_attr_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start",
          "args": [
            "&fei_attr_list",
            "*pos"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fei_lock"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic DEFINE_MUTEX(fei_lock);\nstatic LIST_HEAD(fei_attr_list);\n\nNOKPROBE_SYMBOL(fei_kprobe_handler)\n\nstatic void *fei_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&fei_lock);\n\treturn seq_list_start(&fei_attr_list, *pos);\n}"
  },
  {
    "function_name": "fei_kprobe_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "179-190",
    "snippet": "static int fei_kprobe_handler(struct kprobe *kp, struct pt_regs *regs)\n{\n\tstruct fei_attr *attr = container_of(kp, struct fei_attr, kp);\n\n\tif (should_fail(&fei_fault_attr, 1)) {\n\t\tregs_set_return_value(regs, attr->retval);\n\t\toverride_function_with_return(regs);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fei_kprobe_handler(struct kprobe *kp, struct pt_regs *regs);",
      "static DECLARE_FAULT_ATTR(fei_fault_attr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "override_function_with_return",
          "args": [
            "regs"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regs_set_return_value",
          "args": [
            "regs",
            "attr->retval"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_fail",
          "args": [
            "&fei_fault_attr",
            "1"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kp",
            "structfei_attr",
            "kp"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic int fei_kprobe_handler(struct kprobe *kp, struct pt_regs *regs);\nstatic DECLARE_FAULT_ATTR(fei_fault_attr);\n\nstatic int fei_kprobe_handler(struct kprobe *kp, struct pt_regs *regs)\n{\n\tstruct fei_attr *attr = container_of(kp, struct fei_attr, kp);\n\n\tif (should_fail(&fei_fault_attr, 1)) {\n\t\tregs_set_return_value(regs, attr->retval);\n\t\toverride_function_with_return(regs);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fei_debugfs_remove_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "171-177",
    "snippet": "static void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *fei_debugfs_dir;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove_recursive",
          "args": [
            "dir"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_lookup",
          "args": [
            "attr->kp.symbol_name",
            "fei_debugfs_dir"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic void fei_debugfs_remove_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_lookup(attr->kp.symbol_name, fei_debugfs_dir);\n\tdebugfs_remove_recursive(dir);\n}"
  },
  {
    "function_name": "fei_debugfs_add_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "155-169",
    "snippet": "static int fei_debugfs_add_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(attr->kp.symbol_name, fei_debugfs_dir);\n\tif (!dir)\n\t\treturn -ENOMEM;\n\n\tif (!debugfs_create_file(\"retval\", 0600, dir, attr, &fei_retval_ops)) {\n\t\tdebugfs_remove_recursive(dir);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *fei_debugfs_dir;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove_recursive",
          "args": [
            "dir"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"retval\"",
            "0600",
            "dir",
            "attr",
            "&fei_retval_ops"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "attr->kp.symbol_name",
            "fei_debugfs_dir"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct dentry *fei_debugfs_dir;\n\nstatic int fei_debugfs_add_attr(struct fei_attr *attr)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(attr->kp.symbol_name, fei_debugfs_dir);\n\tif (!dir)\n\t\treturn -ENOMEM;\n\n\tif (!debugfs_create_file(\"retval\", 0600, dir, attr, &fei_retval_ops)) {\n\t\tdebugfs_remove_recursive(dir);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fei_retval_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "137-151",
    "snippet": "static int fei_retval_get(void *data, u64 *val)\n{\n\tstruct fei_attr *attr = data;\n\tint err = 0;\n\n\tmutex_lock(&fei_lock);\n\t/* Here we also validate @attr to ensure it still exists. */\n\tif (!fei_attr_is_valid(attr))\n\t\terr = -ENOENT;\n\telse\n\t\t*val = attr->retval;\n\tmutex_unlock(&fei_lock);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(fei_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fei_lock"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fei_attr_is_valid",
          "args": [
            "attr"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "fei_attr_is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
          "lines": "95-105",
          "snippet": "static bool fei_attr_is_valid(struct fei_attr *_attr)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (attr == _attr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fei_attr_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic LIST_HEAD(fei_attr_list);\n\nstatic bool fei_attr_is_valid(struct fei_attr *_attr)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (attr == _attr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fei_lock"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic DEFINE_MUTEX(fei_lock);\n\nstatic int fei_retval_get(void *data, u64 *val)\n{\n\tstruct fei_attr *attr = data;\n\tint err = 0;\n\n\tmutex_lock(&fei_lock);\n\t/* Here we also validate @attr to ensure it still exists. */\n\tif (!fei_attr_is_valid(attr))\n\t\terr = -ENOENT;\n\telse\n\t\t*val = attr->retval;\n\tmutex_unlock(&fei_lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "fei_retval_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "107-135",
    "snippet": "static int fei_retval_set(void *data, u64 val)\n{\n\tstruct fei_attr *attr = data;\n\tunsigned long retv = (unsigned long)val;\n\tint err = 0;\n\n\tmutex_lock(&fei_lock);\n\t/*\n\t * Since this operation can be done after retval file is removed,\n\t * It is safer to check the attr is still valid before accessing\n\t * its member.\n\t */\n\tif (!fei_attr_is_valid(attr)) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (attr->kp.addr) {\n\t\tif (adjust_error_retval((unsigned long)attr->kp.addr,\n\t\t\t\t\tval) != retv)\n\t\t\terr = -EINVAL;\n\t}\n\tif (!err)\n\t\tattr->retval = val;\nout:\n\tmutex_unlock(&fei_lock);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(fei_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fei_lock"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "adjust_error_retval",
          "args": [
            "(unsigned long)attr->kp.addr",
            "val"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_error_retval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
          "lines": "36-54",
          "snippet": "static unsigned long adjust_error_retval(unsigned long addr, unsigned long retv)\n{\n\tswitch (get_injectable_error_type(addr)) {\n\tcase EI_ETYPE_NULL:\n\t\tif (retv != 0)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase EI_ETYPE_ERRNO:\n\t\tif (retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_ERRNO_NULL:\n\t\tif (retv != 0 && retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\t}\n\n\treturn retv;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic unsigned long adjust_error_retval(unsigned long addr, unsigned long retv)\n{\n\tswitch (get_injectable_error_type(addr)) {\n\tcase EI_ETYPE_NULL:\n\t\tif (retv != 0)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase EI_ETYPE_ERRNO:\n\t\tif (retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_ERRNO_NULL:\n\t\tif (retv != 0 && retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\t}\n\n\treturn retv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fei_attr_is_valid",
          "args": [
            "attr"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "fei_attr_is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
          "lines": "95-105",
          "snippet": "static bool fei_attr_is_valid(struct fei_attr *_attr)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (attr == _attr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fei_attr_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic LIST_HEAD(fei_attr_list);\n\nstatic bool fei_attr_is_valid(struct fei_attr *_attr)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (attr == _attr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fei_lock"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic DEFINE_MUTEX(fei_lock);\n\nstatic int fei_retval_set(void *data, u64 val)\n{\n\tstruct fei_attr *attr = data;\n\tunsigned long retv = (unsigned long)val;\n\tint err = 0;\n\n\tmutex_lock(&fei_lock);\n\t/*\n\t * Since this operation can be done after retval file is removed,\n\t * It is safer to check the attr is still valid before accessing\n\t * its member.\n\t */\n\tif (!fei_attr_is_valid(attr)) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (attr->kp.addr) {\n\t\tif (adjust_error_retval((unsigned long)attr->kp.addr,\n\t\t\t\t\tval) != retv)\n\t\t\terr = -EINVAL;\n\t}\n\tif (!err)\n\t\tattr->retval = val;\nout:\n\tmutex_unlock(&fei_lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "fei_attr_is_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "95-105",
    "snippet": "static bool fei_attr_is_valid(struct fei_attr *_attr)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (attr == _attr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(fei_attr_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "attr",
            "&fei_attr_list",
            "list"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic LIST_HEAD(fei_attr_list);\n\nstatic bool fei_attr_is_valid(struct fei_attr *_attr)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (attr == _attr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "fei_attr_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "83-93",
    "snippet": "static struct fei_attr *fei_attr_lookup(const char *sym)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (!strcmp(attr->kp.symbol_name, sym))\n\t\t\treturn attr;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(fei_attr_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "attr->kp.symbol_name",
            "sym"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "attr",
            "&fei_attr_list",
            "list"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic LIST_HEAD(fei_attr_list);\n\nstatic struct fei_attr *fei_attr_lookup(const char *sym)\n{\n\tstruct fei_attr *attr;\n\n\tlist_for_each_entry(attr, &fei_attr_list, list) {\n\t\tif (!strcmp(attr->kp.symbol_name, sym))\n\t\t\treturn attr;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "fei_attr_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "75-81",
    "snippet": "static void fei_attr_free(struct fei_attr *attr)\n{\n\tif (attr) {\n\t\tkfree(attr->kp.symbol_name);\n\t\tkfree(attr);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "attr"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic void fei_attr_free(struct fei_attr *attr)\n{\n\tif (attr) {\n\t\tkfree(attr->kp.symbol_name);\n\t\tkfree(attr);\n\t}\n}"
  },
  {
    "function_name": "fei_attr_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "56-73",
    "snippet": "static struct fei_attr *fei_attr_new(const char *sym, unsigned long addr)\n{\n\tstruct fei_attr *attr;\n\n\tattr = kzalloc(sizeof(*attr), GFP_KERNEL);\n\tif (attr) {\n\t\tattr->kp.symbol_name = kstrdup(sym, GFP_KERNEL);\n\t\tif (!attr->kp.symbol_name) {\n\t\t\tkfree(attr);\n\t\t\treturn NULL;\n\t\t}\n\t\tattr->kp.pre_handler = fei_kprobe_handler;\n\t\tattr->kp.post_handler = fei_post_handler;\n\t\tattr->retval = adjust_error_retval(addr, 0);\n\t\tINIT_LIST_HEAD(&attr->list);\n\t}\n\treturn attr;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&attr->list"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adjust_error_retval",
          "args": [
            "addr",
            "0"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_error_retval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
          "lines": "36-54",
          "snippet": "static unsigned long adjust_error_retval(unsigned long addr, unsigned long retv)\n{\n\tswitch (get_injectable_error_type(addr)) {\n\tcase EI_ETYPE_NULL:\n\t\tif (retv != 0)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase EI_ETYPE_ERRNO:\n\t\tif (retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_ERRNO_NULL:\n\t\tif (retv != 0 && retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\t}\n\n\treturn retv;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic unsigned long adjust_error_retval(unsigned long addr, unsigned long retv)\n{\n\tswitch (get_injectable_error_type(addr)) {\n\tcase EI_ETYPE_NULL:\n\t\tif (retv != 0)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase EI_ETYPE_ERRNO:\n\t\tif (retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_ERRNO_NULL:\n\t\tif (retv != 0 && retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\t}\n\n\treturn retv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "attr"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "sym",
            "GFP_KERNEL"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*attr)",
            "GFP_KERNEL"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic struct fei_attr *fei_attr_new(const char *sym, unsigned long addr)\n{\n\tstruct fei_attr *attr;\n\n\tattr = kzalloc(sizeof(*attr), GFP_KERNEL);\n\tif (attr) {\n\t\tattr->kp.symbol_name = kstrdup(sym, GFP_KERNEL);\n\t\tif (!attr->kp.symbol_name) {\n\t\t\tkfree(attr);\n\t\t\treturn NULL;\n\t\t}\n\t\tattr->kp.pre_handler = fei_kprobe_handler;\n\t\tattr->kp.post_handler = fei_post_handler;\n\t\tattr->retval = adjust_error_retval(addr, 0);\n\t\tINIT_LIST_HEAD(&attr->list);\n\t}\n\treturn attr;\n}"
  },
  {
    "function_name": "adjust_error_retval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "36-54",
    "snippet": "static unsigned long adjust_error_retval(unsigned long addr, unsigned long retv)\n{\n\tswitch (get_injectable_error_type(addr)) {\n\tcase EI_ETYPE_NULL:\n\t\tif (retv != 0)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase EI_ETYPE_ERRNO:\n\t\tif (retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_ERRNO_NULL:\n\t\tif (retv != 0 && retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\t}\n\n\treturn retv;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_injectable_error_type",
          "args": [
            "addr"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic unsigned long adjust_error_retval(unsigned long addr, unsigned long retv)\n{\n\tswitch (get_injectable_error_type(addr)) {\n\tcase EI_ETYPE_NULL:\n\t\tif (retv != 0)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase EI_ETYPE_ERRNO:\n\t\tif (retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\tcase EI_ETYPE_ERRNO_NULL:\n\t\tif (retv != 0 && retv < (unsigned long)-MAX_ERRNO)\n\t\t\treturn (unsigned long)-EINVAL;\n\t\tbreak;\n\t}\n\n\treturn retv;\n}"
  },
  {
    "function_name": "fei_post_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fail_function.c",
    "lines": "17-24",
    "snippet": "static void fei_post_handler(struct kprobe *kp, struct pt_regs *regs,\n\t\t\t     unsigned long flags)\n{\n\t/*\n\t * A dummy post handler is required to prohibit optimizing, because\n\t * jump optimization does not support execution path overriding.\n\t */\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/fault-inject.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/error-injection.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int fei_kprobe_handler(struct kprobe *kp, struct pt_regs *regs);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic int fei_kprobe_handler(struct kprobe *kp, struct pt_regs *regs);\n\nstatic void fei_post_handler(struct kprobe *kp, struct pt_regs *regs,\n\t\t\t     unsigned long flags)\n{\n\t/*\n\t * A dummy post handler is required to prohibit optimizing, because\n\t * jump optimization does not support execution path overriding.\n\t */\n}"
  }
]