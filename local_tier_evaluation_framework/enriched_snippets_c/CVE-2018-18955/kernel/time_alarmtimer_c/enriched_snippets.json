[
  {
    "function_name": "alarmtimer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "865-903",
    "snippet": "static int __init alarmtimer_init(void)\n{\n\tstruct platform_device *pdev;\n\tint error = 0;\n\tint i;\n\n\talarmtimer_rtc_timer_init();\n\n\t/* Initialize alarm bases */\n\talarm_bases[ALARM_REALTIME].base_clockid = CLOCK_REALTIME;\n\talarm_bases[ALARM_REALTIME].gettime = &ktime_get_real;\n\talarm_bases[ALARM_BOOTTIME].base_clockid = CLOCK_BOOTTIME;\n\talarm_bases[ALARM_BOOTTIME].gettime = &ktime_get_boottime;\n\tfor (i = 0; i < ALARM_NUMTYPE; i++) {\n\t\ttimerqueue_init_head(&alarm_bases[i].timerqueue);\n\t\tspin_lock_init(&alarm_bases[i].lock);\n\t}\n\n\terror = alarmtimer_rtc_interface_setup();\n\tif (error)\n\t\treturn error;\n\n\terror = platform_driver_register(&alarmtimer_driver);\n\tif (error)\n\t\tgoto out_if;\n\n\tpdev = platform_device_register_simple(\"alarmtimer\", -1, NULL, 0);\n\tif (IS_ERR(pdev)) {\n\t\terror = PTR_ERR(pdev);\n\t\tgoto out_drv;\n\t}\n\treturn 0;\n\nout_drv:\n\tplatform_driver_unregister(&alarmtimer_driver);\nout_if:\n\talarmtimer_rtc_interface_remove();\n\treturn error;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];",
      "static struct platform_driver alarmtimer_driver = {\n\t.driver = {\n\t\t.name = \"alarmtimer\",\n\t\t.pm = &alarmtimer_pm_ops,\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarmtimer_rtc_interface_remove",
          "args": [],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_rtc_interface_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "150-150",
          "snippet": "static inline void alarmtimer_rtc_interface_remove(void) { }",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic inline void alarmtimer_rtc_interface_remove(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "platform_driver_unregister",
          "args": [
            "&alarmtimer_driver"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pdev"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pdev"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "platform_device_register_simple",
          "args": [
            "\"alarmtimer\"",
            "-1",
            "NULL",
            "0"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "platform_driver_register",
          "args": [
            "&alarmtimer_driver"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarmtimer_rtc_interface_setup",
          "args": [],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_rtc_interface_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "149-149",
          "snippet": "static inline int alarmtimer_rtc_interface_setup(void) { return 0; }",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic inline int alarmtimer_rtc_interface_setup(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&alarm_bases[i].lock"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_init_head",
          "args": [
            "&alarm_bases[i].timerqueue"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarmtimer_rtc_timer_init",
          "args": [],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_rtc_timer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "151-151",
          "snippet": "static inline void alarmtimer_rtc_timer_init(void) { }",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic inline void alarmtimer_rtc_timer_init(void) { }"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\nstatic struct platform_driver alarmtimer_driver = {\n\t.driver = {\n\t\t.name = \"alarmtimer\",\n\t\t.pm = &alarmtimer_pm_ops,\n\t}\n};\n\nstatic int __init alarmtimer_init(void)\n{\n\tstruct platform_device *pdev;\n\tint error = 0;\n\tint i;\n\n\talarmtimer_rtc_timer_init();\n\n\t/* Initialize alarm bases */\n\talarm_bases[ALARM_REALTIME].base_clockid = CLOCK_REALTIME;\n\talarm_bases[ALARM_REALTIME].gettime = &ktime_get_real;\n\talarm_bases[ALARM_BOOTTIME].base_clockid = CLOCK_BOOTTIME;\n\talarm_bases[ALARM_BOOTTIME].gettime = &ktime_get_boottime;\n\tfor (i = 0; i < ALARM_NUMTYPE; i++) {\n\t\ttimerqueue_init_head(&alarm_bases[i].timerqueue);\n\t\tspin_lock_init(&alarm_bases[i].lock);\n\t}\n\n\terror = alarmtimer_rtc_interface_setup();\n\tif (error)\n\t\treturn error;\n\n\terror = platform_driver_register(&alarmtimer_driver);\n\tif (error)\n\t\tgoto out_if;\n\n\tpdev = platform_device_register_simple(\"alarmtimer\", -1, NULL, 0);\n\tif (IS_ERR(pdev)) {\n\t\terror = PTR_ERR(pdev);\n\t\tgoto out_drv;\n\t}\n\treturn 0;\n\nout_drv:\n\tplatform_driver_unregister(&alarmtimer_driver);\nout_if:\n\talarmtimer_rtc_interface_remove();\n\treturn error;\n}"
  },
  {
    "function_name": "alarm_timer_nsleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "787-827",
    "snippet": "static int alarm_timer_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *tsreq)\n{\n\tenum  alarmtimer_type type = clock2alarm(which_clock);\n\tstruct restart_block *restart = &current->restart_block;\n\tstruct alarm alarm;\n\tktime_t exp;\n\tint ret = 0;\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -ENOTSUPP;\n\n\tif (flags & ~TIMER_ABSTIME)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\n\texp = timespec64_to_ktime(*tsreq);\n\t/* Convert (if necessary) to absolute time */\n\tif (flags != TIMER_ABSTIME) {\n\t\tktime_t now = alarm_bases[type].gettime();\n\n\t\texp = ktime_add_safe(now, exp);\n\t}\n\n\tret = alarmtimer_do_nsleep(&alarm, exp, type);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\treturn ret;\n\n\t/* abs timers don't set remaining time or restart */\n\tif (flags == TIMER_ABSTIME)\n\t\treturn -ERESTARTNOHAND;\n\n\trestart->fn = alarm_timer_nsleep_restart;\n\trestart->nanosleep.clockid = type;\n\trestart->nanosleep.expires = exp;\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarmtimer_do_nsleep",
          "args": [
            "&alarm",
            "exp",
            "type"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_do_nsleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "713-750",
          "snippet": "static int alarmtimer_do_nsleep(struct alarm *alarm, ktime_t absexp,\n\t\t\t\tenum alarmtimer_type type)\n{\n\tstruct restart_block *restart;\n\talarm->data = (void *)current;\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\talarm_start(alarm, absexp);\n\t\tif (likely(alarm->data))\n\t\t\tschedule();\n\n\t\talarm_cancel(alarm);\n\t} while (alarm->data && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tdestroy_hrtimer_on_stack(&alarm->timer);\n\n\tif (!alarm->data)\n\t\treturn 0;\n\n\tif (freezing(current))\n\t\talarmtimer_freezerset(absexp, type);\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tstruct timespec64 rmt;\n\t\tktime_t rem;\n\n\t\trem = ktime_sub(absexp, alarm_bases[type].gettime());\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic int alarmtimer_do_nsleep(struct alarm *alarm, ktime_t absexp,\n\t\t\t\tenum alarmtimer_type type)\n{\n\tstruct restart_block *restart;\n\talarm->data = (void *)current;\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\talarm_start(alarm, absexp);\n\t\tif (likely(alarm->data))\n\t\t\tschedule();\n\n\t\talarm_cancel(alarm);\n\t} while (alarm->data && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tdestroy_hrtimer_on_stack(&alarm->timer);\n\n\tif (!alarm->data)\n\t\treturn 0;\n\n\tif (freezing(current))\n\t\talarmtimer_freezerset(absexp, type);\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tstruct timespec64 rmt;\n\t\tktime_t rem;\n\n\t\trem = ktime_sub(absexp, alarm_bases[type].gettime());\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add_safe",
          "args": [
            "now",
            "exp"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarm_bases[type].gettime",
          "args": [],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "*tsreq"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarm_init_on_stack",
          "args": [
            "&alarm",
            "type",
            "alarmtimer_nsleep_wakeup"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_init_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "752-759",
          "snippet": "static void\nalarm_init_on_stack(struct alarm *alarm, enum alarmtimer_type type,\n\t\t    enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init_on_stack(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t\t      HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic void\nalarm_init_on_stack(struct alarm *alarm, enum alarmtimer_type type,\n\t\t    enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init_on_stack(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t\t      HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_WAKE_ALARM"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarmtimer_get_rtcdev",
          "args": [],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_get_rtcdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "144-147",
          "snippet": "struct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstruct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clock2alarm",
          "args": [
            "which_clock"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "clock2alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "522-529",
          "snippet": "static enum alarmtimer_type clock2alarm(clockid_t clockid)\n{\n\tif (clockid == CLOCK_REALTIME_ALARM)\n\t\treturn ALARM_REALTIME;\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\treturn ALARM_BOOTTIME;\n\treturn -1;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic enum alarmtimer_type clock2alarm(clockid_t clockid)\n{\n\tif (clockid == CLOCK_REALTIME_ALARM)\n\t\treturn ALARM_REALTIME;\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\treturn ALARM_BOOTTIME;\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic int alarm_timer_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *tsreq)\n{\n\tenum  alarmtimer_type type = clock2alarm(which_clock);\n\tstruct restart_block *restart = &current->restart_block;\n\tstruct alarm alarm;\n\tktime_t exp;\n\tint ret = 0;\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -ENOTSUPP;\n\n\tif (flags & ~TIMER_ABSTIME)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\n\texp = timespec64_to_ktime(*tsreq);\n\t/* Convert (if necessary) to absolute time */\n\tif (flags != TIMER_ABSTIME) {\n\t\tktime_t now = alarm_bases[type].gettime();\n\n\t\texp = ktime_add_safe(now, exp);\n\t}\n\n\tret = alarmtimer_do_nsleep(&alarm, exp, type);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\treturn ret;\n\n\t/* abs timers don't set remaining time or restart */\n\tif (flags == TIMER_ABSTIME)\n\t\treturn -ERESTARTNOHAND;\n\n\trestart->fn = alarm_timer_nsleep_restart;\n\trestart->nanosleep.clockid = type;\n\trestart->nanosleep.expires = exp;\n\treturn ret;\n}"
  },
  {
    "function_name": "alarm_timer_nsleep_restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "767-776",
    "snippet": "static long __sched alarm_timer_nsleep_restart(struct restart_block *restart)\n{\n\tenum  alarmtimer_type type = restart->nanosleep.clockid;\n\tktime_t exp = restart->nanosleep.expires;\n\tstruct alarm alarm;\n\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\n\treturn alarmtimer_do_nsleep(&alarm, exp, type);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarmtimer_do_nsleep",
          "args": [
            "&alarm",
            "exp",
            "type"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_do_nsleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "713-750",
          "snippet": "static int alarmtimer_do_nsleep(struct alarm *alarm, ktime_t absexp,\n\t\t\t\tenum alarmtimer_type type)\n{\n\tstruct restart_block *restart;\n\talarm->data = (void *)current;\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\talarm_start(alarm, absexp);\n\t\tif (likely(alarm->data))\n\t\t\tschedule();\n\n\t\talarm_cancel(alarm);\n\t} while (alarm->data && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tdestroy_hrtimer_on_stack(&alarm->timer);\n\n\tif (!alarm->data)\n\t\treturn 0;\n\n\tif (freezing(current))\n\t\talarmtimer_freezerset(absexp, type);\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tstruct timespec64 rmt;\n\t\tktime_t rem;\n\n\t\trem = ktime_sub(absexp, alarm_bases[type].gettime());\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic int alarmtimer_do_nsleep(struct alarm *alarm, ktime_t absexp,\n\t\t\t\tenum alarmtimer_type type)\n{\n\tstruct restart_block *restart;\n\talarm->data = (void *)current;\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\talarm_start(alarm, absexp);\n\t\tif (likely(alarm->data))\n\t\t\tschedule();\n\n\t\talarm_cancel(alarm);\n\t} while (alarm->data && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tdestroy_hrtimer_on_stack(&alarm->timer);\n\n\tif (!alarm->data)\n\t\treturn 0;\n\n\tif (freezing(current))\n\t\talarmtimer_freezerset(absexp, type);\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tstruct timespec64 rmt;\n\t\tktime_t rem;\n\n\t\trem = ktime_sub(absexp, alarm_bases[type].gettime());\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarm_init_on_stack",
          "args": [
            "&alarm",
            "type",
            "alarmtimer_nsleep_wakeup"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_init_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "752-759",
          "snippet": "static void\nalarm_init_on_stack(struct alarm *alarm, enum alarmtimer_type type,\n\t\t    enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init_on_stack(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t\t      HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic void\nalarm_init_on_stack(struct alarm *alarm, enum alarmtimer_type type,\n\t\t    enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init_on_stack(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t\t      HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic long __sched alarm_timer_nsleep_restart(struct restart_block *restart)\n{\n\tenum  alarmtimer_type type = restart->nanosleep.clockid;\n\tktime_t exp = restart->nanosleep.expires;\n\tstruct alarm alarm;\n\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\n\treturn alarmtimer_do_nsleep(&alarm, exp, type);\n}"
  },
  {
    "function_name": "alarm_init_on_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "752-759",
    "snippet": "static void\nalarm_init_on_stack(struct alarm *alarm, enum alarmtimer_type type,\n\t\t    enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init_on_stack(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t\t      HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__alarm_init",
          "args": [
            "alarm",
            "type",
            "function"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "__alarm_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "329-338",
          "snippet": "static void\n__alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t     enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\ttimerqueue_init(&alarm->node);\n\talarm->timer.function = alarmtimer_fired;\n\talarm->function = function;\n\talarm->type = type;\n\talarm->state = ALARMTIMER_STATE_INACTIVE;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void\n__alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t     enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\ttimerqueue_init(&alarm->node);\n\talarm->timer.function = alarmtimer_fired;\n\talarm->function = function;\n\talarm->type = type;\n\talarm->state = ALARMTIMER_STATE_INACTIVE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_init_on_stack",
          "args": [
            "&alarm->timer",
            "alarm_bases[type].base_clockid",
            "HRTIMER_MODE_ABS"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "432-437",
          "snippet": "void hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic void\nalarm_init_on_stack(struct alarm *alarm, enum alarmtimer_type type,\n\t\t    enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init_on_stack(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t\t      HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}"
  },
  {
    "function_name": "alarmtimer_do_nsleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "713-750",
    "snippet": "static int alarmtimer_do_nsleep(struct alarm *alarm, ktime_t absexp,\n\t\t\t\tenum alarmtimer_type type)\n{\n\tstruct restart_block *restart;\n\talarm->data = (void *)current;\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\talarm_start(alarm, absexp);\n\t\tif (likely(alarm->data))\n\t\t\tschedule();\n\n\t\talarm_cancel(alarm);\n\t} while (alarm->data && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tdestroy_hrtimer_on_stack(&alarm->timer);\n\n\tif (!alarm->data)\n\t\treturn 0;\n\n\tif (freezing(current))\n\t\talarmtimer_freezerset(absexp, type);\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tstruct timespec64 rmt;\n\t\tktime_t rem;\n\n\t\trem = ktime_sub(absexp, alarm_bases[type].gettime());\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nanosleep_copyout",
          "args": [
            "restart",
            "&rmt"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "nanosleep_copyout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1658-1675",
          "snippet": "int nanosleep_copyout(struct restart_block *restart, struct timespec64 *ts)\n{\n\tswitch(restart->nanosleep.type) {\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase TT_COMPAT:\n\t\tif (put_old_timespec32(ts, restart->nanosleep.compat_rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#endif\n\tcase TT_NATIVE:\n\t\tif (put_timespec64(ts, restart->nanosleep.rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint nanosleep_copyout(struct restart_block *restart, struct timespec64 *ts)\n{\n\tswitch(restart->nanosleep.type) {\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase TT_COMPAT:\n\t\tif (put_old_timespec32(ts, restart->nanosleep.compat_rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#endif\n\tcase TT_NATIVE:\n\t\tif (put_timespec64(ts, restart->nanosleep.rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_timespec64",
          "args": [
            "rem"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "absexp",
            "alarm_bases[type].gettime()"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarm_bases[type].gettime",
          "args": [],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarmtimer_freezerset",
          "args": [
            "absexp",
            "type"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_freezerset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "487-516",
          "snippet": "static void alarmtimer_freezerset(ktime_t absexp, enum alarmtimer_type type)\n{\n\tstruct alarm_base *base;\n\tunsigned long flags;\n\tktime_t delta;\n\n\tswitch(type) {\n\tcase ALARM_REALTIME:\n\t\tbase = &alarm_bases[ALARM_REALTIME];\n\t\ttype = ALARM_REALTIME_FREEZER;\n\t\tbreak;\n\tcase ALARM_BOOTTIME:\n\t\tbase = &alarm_bases[ALARM_BOOTTIME];\n\t\ttype = ALARM_BOOTTIME_FREEZER;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Invalid alarm type: %d\\n\", type);\n\t\treturn;\n\t}\n\n\tdelta = ktime_sub(absexp, base->gettime());\n\n\tspin_lock_irqsave(&freezer_delta_lock, flags);\n\tif (!freezer_delta || (delta < freezer_delta)) {\n\t\tfreezer_delta = delta;\n\t\tfreezer_expires = absexp;\n\t\tfreezer_alarmtype = type;\n\t}\n\tspin_unlock_irqrestore(&freezer_delta_lock, flags);\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic void alarmtimer_freezerset(ktime_t absexp, enum alarmtimer_type type)\n{\n\tstruct alarm_base *base;\n\tunsigned long flags;\n\tktime_t delta;\n\n\tswitch(type) {\n\tcase ALARM_REALTIME:\n\t\tbase = &alarm_bases[ALARM_REALTIME];\n\t\ttype = ALARM_REALTIME_FREEZER;\n\t\tbreak;\n\tcase ALARM_BOOTTIME:\n\t\tbase = &alarm_bases[ALARM_BOOTTIME];\n\t\ttype = ALARM_BOOTTIME_FREEZER;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Invalid alarm type: %d\\n\", type);\n\t\treturn;\n\t}\n\n\tdelta = ktime_sub(absexp, base->gettime());\n\n\tspin_lock_irqsave(&freezer_delta_lock, flags);\n\tif (!freezer_delta || (delta < freezer_delta)) {\n\t\tfreezer_delta = delta;\n\t\tfreezer_expires = absexp;\n\t\tfreezer_alarmtype = type;\n\t}\n\tspin_unlock_irqrestore(&freezer_delta_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezing",
          "args": [
            "current"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "freezing_slow_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/freezer.c",
          "lines": "42-57",
          "snippet": "bool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool pm_freezing;",
            "bool pm_nosig_freezing;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nbool pm_freezing;\nbool pm_nosig_freezing;\n\nbool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_hrtimer_on_stack",
          "args": [
            "&alarm->timer"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hrtimer_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "440-443",
          "snippet": "void destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarm_cancel",
          "args": [
            "alarm"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "433-441",
          "snippet": "int alarm_cancel(struct alarm *alarm)\n{\n\tfor (;;) {\n\t\tint ret = alarm_try_to_cancel(alarm);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nint alarm_cancel(struct alarm *alarm)\n{\n\tfor (;;) {\n\t\tint ret = alarm_try_to_cancel(alarm);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "alarm->data"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarm_start",
          "args": [
            "alarm",
            "absexp"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_start_relative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "380-386",
          "snippet": "void alarm_start_relative(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tstart = ktime_add_safe(start, base->gettime());\n\talarm_start(alarm, start);\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nvoid alarm_start_relative(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tstart = ktime_add_safe(start, base->gettime());\n\talarm_start(alarm, start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic int alarmtimer_do_nsleep(struct alarm *alarm, ktime_t absexp,\n\t\t\t\tenum alarmtimer_type type)\n{\n\tstruct restart_block *restart;\n\talarm->data = (void *)current;\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\talarm_start(alarm, absexp);\n\t\tif (likely(alarm->data))\n\t\t\tschedule();\n\n\t\talarm_cancel(alarm);\n\t} while (alarm->data && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tdestroy_hrtimer_on_stack(&alarm->timer);\n\n\tif (!alarm->data)\n\t\treturn 0;\n\n\tif (freezing(current))\n\t\talarmtimer_freezerset(absexp, type);\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tstruct timespec64 rmt;\n\t\tktime_t rem;\n\n\t\trem = ktime_sub(absexp, alarm_bases[type].gettime());\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
  },
  {
    "function_name": "alarmtimer_nsleep_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "695-704",
    "snippet": "static enum alarmtimer_restart alarmtimer_nsleep_wakeup(struct alarm *alarm,\n\t\t\t\t\t\t\t\tktime_t now)\n{\n\tstruct task_struct *task = (struct task_struct *)alarm->data;\n\n\talarm->data = NULL;\n\tif (task)\n\t\twake_up_process(task);\n\treturn ALARMTIMER_NORESTART;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "task"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic enum alarmtimer_restart alarmtimer_nsleep_wakeup(struct alarm *alarm,\n\t\t\t\t\t\t\t\tktime_t now)\n{\n\tstruct task_struct *task = (struct task_struct *)alarm->data;\n\n\talarm->data = NULL;\n\tif (task)\n\t\twake_up_process(task);\n\treturn ALARMTIMER_NORESTART;\n}"
  },
  {
    "function_name": "alarm_timer_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "674-687",
    "snippet": "static int alarm_timer_create(struct k_itimer *new_timer)\n{\n\tenum  alarmtimer_type type;\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -ENOTSUPP;\n\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\n\ttype = clock2alarm(new_timer->it_clock);\n\talarm_init(&new_timer->it.alarm.alarmtimer, type, alarm_handle_timer);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarm_init",
          "args": [
            "&new_timer->it.alarm.alarmtimer",
            "type",
            "alarm_handle_timer"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_init_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "752-759",
          "snippet": "static void\nalarm_init_on_stack(struct alarm *alarm, enum alarmtimer_type type,\n\t\t    enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init_on_stack(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t\t      HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic void\nalarm_init_on_stack(struct alarm *alarm, enum alarmtimer_type type,\n\t\t    enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init_on_stack(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t\t      HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clock2alarm",
          "args": [
            "new_timer->it_clock"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "clock2alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "522-529",
          "snippet": "static enum alarmtimer_type clock2alarm(clockid_t clockid)\n{\n\tif (clockid == CLOCK_REALTIME_ALARM)\n\t\treturn ALARM_REALTIME;\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\treturn ALARM_BOOTTIME;\n\treturn -1;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic enum alarmtimer_type clock2alarm(clockid_t clockid)\n{\n\tif (clockid == CLOCK_REALTIME_ALARM)\n\t\treturn ALARM_REALTIME;\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\treturn ALARM_BOOTTIME;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_WAKE_ALARM"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarmtimer_get_rtcdev",
          "args": [],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_get_rtcdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "144-147",
          "snippet": "struct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstruct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic int alarm_timer_create(struct k_itimer *new_timer)\n{\n\tenum  alarmtimer_type type;\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -ENOTSUPP;\n\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\n\ttype = clock2alarm(new_timer->it_clock);\n\talarm_init(&new_timer->it.alarm.alarmtimer, type, alarm_handle_timer);\n\treturn 0;\n}"
  },
  {
    "function_name": "alarm_clock_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "657-666",
    "snippet": "static int alarm_clock_get(clockid_t which_clock, struct timespec64 *tp)\n{\n\tstruct alarm_base *base = &alarm_bases[clock2alarm(which_clock)];\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -EINVAL;\n\n\t*tp = ktime_to_timespec64(base->gettime());\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_timespec64",
          "args": [
            "base->gettime()"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base->gettime",
          "args": [],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarmtimer_get_rtcdev",
          "args": [],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_get_rtcdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "144-147",
          "snippet": "struct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstruct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clock2alarm",
          "args": [
            "which_clock"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "clock2alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "522-529",
          "snippet": "static enum alarmtimer_type clock2alarm(clockid_t clockid)\n{\n\tif (clockid == CLOCK_REALTIME_ALARM)\n\t\treturn ALARM_REALTIME;\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\treturn ALARM_BOOTTIME;\n\treturn -1;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic enum alarmtimer_type clock2alarm(clockid_t clockid)\n{\n\tif (clockid == CLOCK_REALTIME_ALARM)\n\t\treturn ALARM_REALTIME;\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\treturn ALARM_BOOTTIME;\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic int alarm_clock_get(clockid_t which_clock, struct timespec64 *tp)\n{\n\tstruct alarm_base *base = &alarm_bases[clock2alarm(which_clock)];\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -EINVAL;\n\n\t*tp = ktime_to_timespec64(base->gettime());\n\treturn 0;\n}"
  },
  {
    "function_name": "alarm_clock_getres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "640-648",
    "snippet": "static int alarm_clock_getres(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -EINVAL;\n\n\ttp->tv_sec = 0;\n\ttp->tv_nsec = hrtimer_resolution;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarmtimer_get_rtcdev",
          "args": [],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_get_rtcdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "144-147",
          "snippet": "struct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstruct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic int alarm_clock_getres(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -EINVAL;\n\n\ttp->tv_sec = 0;\n\ttp->tv_nsec = hrtimer_resolution;\n\treturn 0;\n}"
  },
  {
    "function_name": "alarm_timer_arm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "619-631",
    "snippet": "static void alarm_timer_arm(struct k_itimer *timr, ktime_t expires,\n\t\t\t    bool absolute, bool sigev_none)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tif (!absolute)\n\t\texpires = ktime_add_safe(expires, base->gettime());\n\tif (sigev_none)\n\t\talarm->node.expires = expires;\n\telse\n\t\talarm_start(&timr->it.alarm.alarmtimer, expires);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarm_start",
          "args": [
            "&timr->it.alarm.alarmtimer",
            "expires"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_start_relative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "380-386",
          "snippet": "void alarm_start_relative(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tstart = ktime_add_safe(start, base->gettime());\n\talarm_start(alarm, start);\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nvoid alarm_start_relative(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tstart = ktime_add_safe(start, base->gettime());\n\talarm_start(alarm, start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add_safe",
          "args": [
            "expires",
            "base->gettime()"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "base->gettime",
          "args": [],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic void alarm_timer_arm(struct k_itimer *timr, ktime_t expires,\n\t\t\t    bool absolute, bool sigev_none)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tif (!absolute)\n\t\texpires = ktime_add_safe(expires, base->gettime());\n\tif (sigev_none)\n\t\talarm->node.expires = expires;\n\telse\n\t\talarm_start(&timr->it.alarm.alarmtimer, expires);\n}"
  },
  {
    "function_name": "alarm_timer_try_to_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "607-610",
    "snippet": "static int alarm_timer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn alarm_try_to_cancel(&timr->it.alarm.alarmtimer);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarm_try_to_cancel",
          "args": [
            "&timr->it.alarm.alarmtimer"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_try_to_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "409-423",
          "snippet": "int alarm_try_to_cancel(struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tret = hrtimer_try_to_cancel(&alarm->timer);\n\tif (ret >= 0)\n\t\talarmtimer_dequeue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_cancel(alarm, base->gettime());\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nint alarm_try_to_cancel(struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tret = hrtimer_try_to_cancel(&alarm->timer);\n\tif (ret >= 0)\n\t\talarmtimer_dequeue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_cancel(alarm, base->gettime());\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic int alarm_timer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn alarm_try_to_cancel(&timr->it.alarm.alarmtimer);\n}"
  },
  {
    "function_name": "alarm_timer_remaining",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "596-601",
    "snippet": "static ktime_t alarm_timer_remaining(struct k_itimer *timr, ktime_t now)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\n\treturn ktime_sub(now, alarm->node.expires);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "now",
            "alarm->node.expires"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic ktime_t alarm_timer_remaining(struct k_itimer *timr, ktime_t now)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\n\treturn ktime_sub(now, alarm->node.expires);\n}"
  },
  {
    "function_name": "alarm_timer_forward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "584-589",
    "snippet": "static s64 alarm_timer_forward(struct k_itimer *timr, ktime_t now)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\n\treturn alarm_forward(alarm, timr->it_interval, now);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarm_forward",
          "args": [
            "alarm",
            "timr->it_interval",
            "now"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "445-474",
          "snippet": "u64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval)\n{\n\tu64 overrun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, alarm->node.expires);\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\toverrun = ktime_divns(delta, incr);\n\n\t\talarm->node.expires = ktime_add_ns(alarm->node.expires,\n\t\t\t\t\t\t\tincr*overrun);\n\n\t\tif (alarm->node.expires > now)\n\t\t\treturn overrun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\toverrun++;\n\t}\n\n\talarm->node.expires = ktime_add_safe(alarm->node.expires, interval);\n\treturn overrun;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nu64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval)\n{\n\tu64 overrun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, alarm->node.expires);\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\toverrun = ktime_divns(delta, incr);\n\n\t\talarm->node.expires = ktime_add_ns(alarm->node.expires,\n\t\t\t\t\t\t\tincr*overrun);\n\n\t\tif (alarm->node.expires > now)\n\t\t\treturn overrun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\toverrun++;\n\t}\n\n\talarm->node.expires = ktime_add_safe(alarm->node.expires, interval);\n\treturn overrun;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic s64 alarm_timer_forward(struct k_itimer *timr, ktime_t now)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\n\treturn alarm_forward(alarm, timr->it_interval, now);\n}"
  },
  {
    "function_name": "alarm_timer_rearm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "571-577",
    "snippet": "static void alarm_timer_rearm(struct k_itimer *timr)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\n\ttimr->it_overrun += alarm_forward_now(alarm, timr->it_interval);\n\talarm_start(alarm, alarm->node.expires);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarm_start",
          "args": [
            "alarm",
            "alarm->node.expires"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_start_relative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "380-386",
          "snippet": "void alarm_start_relative(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tstart = ktime_add_safe(start, base->gettime());\n\talarm_start(alarm, start);\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nvoid alarm_start_relative(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tstart = ktime_add_safe(start, base->gettime());\n\talarm_start(alarm, start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarm_forward_now",
          "args": [
            "alarm",
            "timr->it_interval"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_forward_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "477-482",
          "snippet": "u64 alarm_forward_now(struct alarm *alarm, ktime_t interval)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\treturn alarm_forward(alarm, base->gettime(), interval);\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nu64 alarm_forward_now(struct alarm *alarm, ktime_t interval)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\treturn alarm_forward(alarm, base->gettime(), interval);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void alarm_timer_rearm(struct k_itimer *timr)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\n\ttimr->it_overrun += alarm_forward_now(alarm, timr->it_interval);\n\talarm_start(alarm, alarm->node.expires);\n}"
  },
  {
    "function_name": "alarm_handle_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "537-565",
    "snippet": "static enum alarmtimer_restart alarm_handle_timer(struct alarm *alarm,\n\t\t\t\t\t\t\tktime_t now)\n{\n\tstruct k_itimer *ptr = container_of(alarm, struct k_itimer,\n\t\t\t\t\t    it.alarm.alarmtimer);\n\tenum alarmtimer_restart result = ALARMTIMER_NORESTART;\n\tunsigned long flags;\n\tint si_private = 0;\n\n\tspin_lock_irqsave(&ptr->it_lock, flags);\n\n\tptr->it_active = 0;\n\tif (ptr->it_interval)\n\t\tsi_private = ++ptr->it_requeue_pending;\n\n\tif (posix_timer_event(ptr, si_private) && ptr->it_interval) {\n\t\t/*\n\t\t * Handle ignored signals and rearm the timer. This will go\n\t\t * away once we handle ignored signals proper.\n\t\t */\n\t\tptr->it_overrun += alarm_forward_now(alarm, ptr->it_interval);\n\t\t++ptr->it_requeue_pending;\n\t\tptr->it_active = 1;\n\t\tresult = ALARMTIMER_RESTART;\n\t}\n\tspin_unlock_irqrestore(&ptr->it_lock, flags);\n\n\treturn result;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ptr->it_lock",
            "flags"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarm_forward_now",
          "args": [
            "alarm",
            "ptr->it_interval"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_forward_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "477-482",
          "snippet": "u64 alarm_forward_now(struct alarm *alarm, ktime_t interval)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\treturn alarm_forward(alarm, base->gettime(), interval);\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nu64 alarm_forward_now(struct alarm *alarm, ktime_t interval)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\treturn alarm_forward(alarm, base->gettime(), interval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_timer_event",
          "args": [
            "ptr",
            "si_private"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "posix_timer_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "334-355",
          "snippet": "int posix_timer_event(struct k_itimer *timr, int si_private)\n{\n\tenum pid_type type;\n\tint ret = -1;\n\t/*\n\t * FIXME: if ->sigq is queued we can race with\n\t * dequeue_signal()->posixtimer_rearm().\n\t *\n\t * If dequeue_signal() sees the \"right\" value of\n\t * si_sys_private it calls posixtimer_rearm().\n\t * We re-queue ->sigq and drop ->it_lock().\n\t * posixtimer_rearm() locks the timer\n\t * and re-schedules it while ->sigq is pending.\n\t * Not really bad, but not that we want.\n\t */\n\ttimr->sigq->info.si_sys_private = si_private;\n\n\ttype = !(timr->it_sigev_notify & SIGEV_THREAD_ID) ? PIDTYPE_TGID : PIDTYPE_PID;\n\tret = send_sigqueue(timr->sigq, timr->it_pid, type);\n\t/* If we failed to send the signal the timer stops. */\n\treturn ret > 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nint posix_timer_event(struct k_itimer *timr, int si_private)\n{\n\tenum pid_type type;\n\tint ret = -1;\n\t/*\n\t * FIXME: if ->sigq is queued we can race with\n\t * dequeue_signal()->posixtimer_rearm().\n\t *\n\t * If dequeue_signal() sees the \"right\" value of\n\t * si_sys_private it calls posixtimer_rearm().\n\t * We re-queue ->sigq and drop ->it_lock().\n\t * posixtimer_rearm() locks the timer\n\t * and re-schedules it while ->sigq is pending.\n\t * Not really bad, but not that we want.\n\t */\n\ttimr->sigq->info.si_sys_private = si_private;\n\n\ttype = !(timr->it_sigev_notify & SIGEV_THREAD_ID) ? PIDTYPE_TGID : PIDTYPE_PID;\n\tret = send_sigqueue(timr->sigq, timr->it_pid, type);\n\t/* If we failed to send the signal the timer stops. */\n\treturn ret > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ptr->it_lock",
            "flags"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "alarm",
            "structk_itimer",
            "it.alarm.alarmtimer"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic enum alarmtimer_restart alarm_handle_timer(struct alarm *alarm,\n\t\t\t\t\t\t\tktime_t now)\n{\n\tstruct k_itimer *ptr = container_of(alarm, struct k_itimer,\n\t\t\t\t\t    it.alarm.alarmtimer);\n\tenum alarmtimer_restart result = ALARMTIMER_NORESTART;\n\tunsigned long flags;\n\tint si_private = 0;\n\n\tspin_lock_irqsave(&ptr->it_lock, flags);\n\n\tptr->it_active = 0;\n\tif (ptr->it_interval)\n\t\tsi_private = ++ptr->it_requeue_pending;\n\n\tif (posix_timer_event(ptr, si_private) && ptr->it_interval) {\n\t\t/*\n\t\t * Handle ignored signals and rearm the timer. This will go\n\t\t * away once we handle ignored signals proper.\n\t\t */\n\t\tptr->it_overrun += alarm_forward_now(alarm, ptr->it_interval);\n\t\t++ptr->it_requeue_pending;\n\t\tptr->it_active = 1;\n\t\tresult = ALARMTIMER_RESTART;\n\t}\n\tspin_unlock_irqrestore(&ptr->it_lock, flags);\n\n\treturn result;\n}"
  },
  {
    "function_name": "clock2alarm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "522-529",
    "snippet": "static enum alarmtimer_type clock2alarm(clockid_t clockid)\n{\n\tif (clockid == CLOCK_REALTIME_ALARM)\n\t\treturn ALARM_REALTIME;\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\treturn ALARM_BOOTTIME;\n\treturn -1;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic enum alarmtimer_type clock2alarm(clockid_t clockid)\n{\n\tif (clockid == CLOCK_REALTIME_ALARM)\n\t\treturn ALARM_REALTIME;\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\treturn ALARM_BOOTTIME;\n\treturn -1;\n}"
  },
  {
    "function_name": "alarmtimer_freezerset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "487-516",
    "snippet": "static void alarmtimer_freezerset(ktime_t absexp, enum alarmtimer_type type)\n{\n\tstruct alarm_base *base;\n\tunsigned long flags;\n\tktime_t delta;\n\n\tswitch(type) {\n\tcase ALARM_REALTIME:\n\t\tbase = &alarm_bases[ALARM_REALTIME];\n\t\ttype = ALARM_REALTIME_FREEZER;\n\t\tbreak;\n\tcase ALARM_BOOTTIME:\n\t\tbase = &alarm_bases[ALARM_BOOTTIME];\n\t\ttype = ALARM_BOOTTIME_FREEZER;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Invalid alarm type: %d\\n\", type);\n\t\treturn;\n\t}\n\n\tdelta = ktime_sub(absexp, base->gettime());\n\n\tspin_lock_irqsave(&freezer_delta_lock, flags);\n\tif (!freezer_delta || (delta < freezer_delta)) {\n\t\tfreezer_delta = delta;\n\t\tfreezer_expires = absexp;\n\t\tfreezer_alarmtype = type;\n\t}\n\tspin_unlock_irqrestore(&freezer_delta_lock, flags);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&freezer_delta_lock",
            "flags"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&freezer_delta_lock",
            "flags"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "absexp",
            "base->gettime()"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base->gettime",
          "args": [],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"Invalid alarm type: %d\\n\"",
            "type"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic void alarmtimer_freezerset(ktime_t absexp, enum alarmtimer_type type)\n{\n\tstruct alarm_base *base;\n\tunsigned long flags;\n\tktime_t delta;\n\n\tswitch(type) {\n\tcase ALARM_REALTIME:\n\t\tbase = &alarm_bases[ALARM_REALTIME];\n\t\ttype = ALARM_REALTIME_FREEZER;\n\t\tbreak;\n\tcase ALARM_BOOTTIME:\n\t\tbase = &alarm_bases[ALARM_BOOTTIME];\n\t\ttype = ALARM_BOOTTIME_FREEZER;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Invalid alarm type: %d\\n\", type);\n\t\treturn;\n\t}\n\n\tdelta = ktime_sub(absexp, base->gettime());\n\n\tspin_lock_irqsave(&freezer_delta_lock, flags);\n\tif (!freezer_delta || (delta < freezer_delta)) {\n\t\tfreezer_delta = delta;\n\t\tfreezer_expires = absexp;\n\t\tfreezer_alarmtype = type;\n\t}\n\tspin_unlock_irqrestore(&freezer_delta_lock, flags);\n}"
  },
  {
    "function_name": "alarm_forward_now",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "477-482",
    "snippet": "u64 alarm_forward_now(struct alarm *alarm, ktime_t interval)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\treturn alarm_forward(alarm, base->gettime(), interval);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarm_forward",
          "args": [
            "alarm",
            "base->gettime()",
            "interval"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "445-474",
          "snippet": "u64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval)\n{\n\tu64 overrun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, alarm->node.expires);\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\toverrun = ktime_divns(delta, incr);\n\n\t\talarm->node.expires = ktime_add_ns(alarm->node.expires,\n\t\t\t\t\t\t\tincr*overrun);\n\n\t\tif (alarm->node.expires > now)\n\t\t\treturn overrun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\toverrun++;\n\t}\n\n\talarm->node.expires = ktime_add_safe(alarm->node.expires, interval);\n\treturn overrun;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nu64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval)\n{\n\tu64 overrun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, alarm->node.expires);\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\toverrun = ktime_divns(delta, incr);\n\n\t\talarm->node.expires = ktime_add_ns(alarm->node.expires,\n\t\t\t\t\t\t\tincr*overrun);\n\n\t\tif (alarm->node.expires > now)\n\t\t\treturn overrun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\toverrun++;\n\t}\n\n\talarm->node.expires = ktime_add_safe(alarm->node.expires, interval);\n\treturn overrun;\n}"
        }
      },
      {
        "call_info": {
          "callee": "base->gettime",
          "args": [],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nu64 alarm_forward_now(struct alarm *alarm, ktime_t interval)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\treturn alarm_forward(alarm, base->gettime(), interval);\n}"
  },
  {
    "function_name": "alarm_forward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "445-474",
    "snippet": "u64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval)\n{\n\tu64 overrun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, alarm->node.expires);\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\toverrun = ktime_divns(delta, incr);\n\n\t\talarm->node.expires = ktime_add_ns(alarm->node.expires,\n\t\t\t\t\t\t\tincr*overrun);\n\n\t\tif (alarm->node.expires > now)\n\t\t\treturn overrun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\toverrun++;\n\t}\n\n\talarm->node.expires = ktime_add_safe(alarm->node.expires, interval);\n\treturn overrun;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add_safe",
          "args": [
            "alarm->node.expires",
            "interval"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "alarm->node.expires",
            "incr*overrun"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_divns",
          "args": [
            "delta",
            "incr"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_divns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "299-316",
          "snippet": "s64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (unsigned long) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\ns64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (unsigned long) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "interval"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "delta >= interval"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "now",
            "alarm->node.expires"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nu64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval)\n{\n\tu64 overrun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, alarm->node.expires);\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\toverrun = ktime_divns(delta, incr);\n\n\t\talarm->node.expires = ktime_add_ns(alarm->node.expires,\n\t\t\t\t\t\t\tincr*overrun);\n\n\t\tif (alarm->node.expires > now)\n\t\t\treturn overrun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\toverrun++;\n\t}\n\n\talarm->node.expires = ktime_add_safe(alarm->node.expires, interval);\n\treturn overrun;\n}"
  },
  {
    "function_name": "alarm_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "433-441",
    "snippet": "int alarm_cancel(struct alarm *alarm)\n{\n\tfor (;;) {\n\t\tint ret = alarm_try_to_cancel(alarm);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarm_try_to_cancel",
          "args": [
            "alarm"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_try_to_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "409-423",
          "snippet": "int alarm_try_to_cancel(struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tret = hrtimer_try_to_cancel(&alarm->timer);\n\tif (ret >= 0)\n\t\talarmtimer_dequeue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_cancel(alarm, base->gettime());\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nint alarm_try_to_cancel(struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tret = hrtimer_try_to_cancel(&alarm->timer);\n\tif (ret >= 0)\n\t\talarmtimer_dequeue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_cancel(alarm, base->gettime());\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nint alarm_cancel(struct alarm *alarm)\n{\n\tfor (;;) {\n\t\tint ret = alarm_try_to_cancel(alarm);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
  },
  {
    "function_name": "alarm_try_to_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "409-423",
    "snippet": "int alarm_try_to_cancel(struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tret = hrtimer_try_to_cancel(&alarm->timer);\n\tif (ret >= 0)\n\t\talarmtimer_dequeue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_cancel(alarm, base->gettime());\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_alarmtimer_cancel",
          "args": [
            "alarm",
            "base->gettime()"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base->gettime",
          "args": [],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarmtimer_dequeue",
          "args": [
            "base",
            "alarm"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_dequeue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "181-188",
          "snippet": "static void alarmtimer_dequeue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (!(alarm->state & ALARMTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\talarm->state &= ~ALARMTIMER_STATE_ENQUEUED;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void alarmtimer_dequeue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (!(alarm->state & ALARMTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\talarm->state &= ~ALARMTIMER_STATE_ENQUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "&alarm->timer"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "common_hrtimer_try_to_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "827-830",
          "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nint alarm_try_to_cancel(struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tret = hrtimer_try_to_cancel(&alarm->timer);\n\tif (ret >= 0)\n\t\talarmtimer_dequeue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_cancel(alarm, base->gettime());\n\treturn ret;\n}"
  },
  {
    "function_name": "alarm_restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "389-399",
    "snippet": "void alarm_restart(struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\thrtimer_set_expires(&alarm->timer, alarm->node.expires);\n\thrtimer_restart(&alarm->timer);\n\talarmtimer_enqueue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarmtimer_enqueue",
          "args": [
            "base",
            "alarm"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_enqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "163-170",
          "snippet": "static void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (alarm->state & ALARMTIMER_STATE_ENQUEUED)\n\t\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\n\ttimerqueue_add(&base->timerqueue, &alarm->node);\n\talarm->state |= ALARMTIMER_STATE_ENQUEUED;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (alarm->state & ALARMTIMER_STATE_ENQUEUED)\n\t\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\n\ttimerqueue_add(&base->timerqueue, &alarm->node);\n\talarm->state |= ALARMTIMER_STATE_ENQUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_restart",
          "args": [
            "&alarm->timer"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "perf_mux_hrtimer_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1109-1128",
          "snippet": "static int perf_mux_hrtimer_restart(struct perf_cpu_context *cpuctx)\n{\n\tstruct hrtimer *timer = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\tunsigned long flags;\n\n\t/* not for SW PMU */\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn 0;\n\n\traw_spin_lock_irqsave(&cpuctx->hrtimer_lock, flags);\n\tif (!cpuctx->hrtimer_active) {\n\t\tcpuctx->hrtimer_active = 1;\n\t\thrtimer_forward_now(timer, cpuctx->hrtimer_interval);\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED);\n\t}\n\traw_spin_unlock_irqrestore(&cpuctx->hrtimer_lock, flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool perf_rotate_context(struct perf_cpu_context *cpuctx);",
            "static void update_context_time(struct perf_event_context *ctx);",
            "static __must_check struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic bool perf_rotate_context(struct perf_cpu_context *cpuctx);\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic __must_check struct;\n\nstatic int perf_mux_hrtimer_restart(struct perf_cpu_context *cpuctx)\n{\n\tstruct hrtimer *timer = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\tunsigned long flags;\n\n\t/* not for SW PMU */\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn 0;\n\n\traw_spin_lock_irqsave(&cpuctx->hrtimer_lock, flags);\n\tif (!cpuctx->hrtimer_active) {\n\t\tcpuctx->hrtimer_active = 1;\n\t\thrtimer_forward_now(timer, cpuctx->hrtimer_interval);\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED);\n\t}\n\traw_spin_unlock_irqrestore(&cpuctx->hrtimer_lock, flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires",
          "args": [
            "&alarm->timer",
            "alarm->node.expires"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nvoid alarm_restart(struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\thrtimer_set_expires(&alarm->timer, alarm->node.expires);\n\thrtimer_restart(&alarm->timer);\n\talarmtimer_enqueue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n}"
  },
  {
    "function_name": "alarm_start_relative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "380-386",
    "snippet": "void alarm_start_relative(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tstart = ktime_add_safe(start, base->gettime());\n\talarm_start(alarm, start);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarm_start",
          "args": [
            "alarm",
            "start"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_start_relative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "380-386",
          "snippet": "void alarm_start_relative(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tstart = ktime_add_safe(start, base->gettime());\n\talarm_start(alarm, start);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add_safe",
          "args": [
            "start",
            "base->gettime()"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "base->gettime",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nvoid alarm_start_relative(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tstart = ktime_add_safe(start, base->gettime());\n\talarm_start(alarm, start);\n}"
  },
  {
    "function_name": "alarm_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "360-372",
    "snippet": "void alarm_start(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\talarm->node.expires = start;\n\talarmtimer_enqueue(base, alarm);\n\thrtimer_start(&alarm->timer, alarm->node.expires, HRTIMER_MODE_ABS);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_start(alarm, base->gettime());\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_alarmtimer_start",
          "args": [
            "alarm",
            "base->gettime()"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base->gettime",
          "args": [],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&alarm->timer",
            "alarm->node.expires",
            "HRTIMER_MODE_ABS"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarmtimer_enqueue",
          "args": [
            "base",
            "alarm"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_enqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "163-170",
          "snippet": "static void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (alarm->state & ALARMTIMER_STATE_ENQUEUED)\n\t\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\n\ttimerqueue_add(&base->timerqueue, &alarm->node);\n\talarm->state |= ALARMTIMER_STATE_ENQUEUED;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (alarm->state & ALARMTIMER_STATE_ENQUEUED)\n\t\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\n\ttimerqueue_add(&base->timerqueue, &alarm->node);\n\talarm->state |= ALARMTIMER_STATE_ENQUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nvoid alarm_start(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\talarm->node.expires = start;\n\talarmtimer_enqueue(base, alarm);\n\thrtimer_start(&alarm->timer, alarm->node.expires, HRTIMER_MODE_ABS);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_start(alarm, base->gettime());\n}"
  },
  {
    "function_name": "alarm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "346-352",
    "snippet": "void alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t\tenum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t     HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__alarm_init",
          "args": [
            "alarm",
            "type",
            "function"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "__alarm_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "329-338",
          "snippet": "static void\n__alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t     enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\ttimerqueue_init(&alarm->node);\n\talarm->timer.function = alarmtimer_fired;\n\talarm->function = function;\n\talarm->type = type;\n\talarm->state = ALARMTIMER_STATE_INACTIVE;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void\n__alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t     enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\ttimerqueue_init(&alarm->node);\n\talarm->timer.function = alarmtimer_fired;\n\talarm->function = function;\n\talarm->type = type;\n\talarm->state = ALARMTIMER_STATE_INACTIVE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&alarm->timer",
            "alarm_bases[type].base_clockid",
            "HRTIMER_MODE_ABS"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1305-1310",
          "snippet": "void hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nvoid alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t\tenum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t     HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}"
  },
  {
    "function_name": "__alarm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "329-338",
    "snippet": "static void\n__alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t     enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\ttimerqueue_init(&alarm->node);\n\talarm->timer.function = alarmtimer_fired;\n\talarm->function = function;\n\talarm->type = type;\n\talarm->state = ALARMTIMER_STATE_INACTIVE;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timerqueue_init",
          "args": [
            "&alarm->node"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void\n__alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t     enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\ttimerqueue_init(&alarm->node);\n\talarm->timer.function = alarmtimer_fired;\n\talarm->function = function;\n\talarm->type = type;\n\talarm->state = ALARMTIMER_STATE_INACTIVE;\n}"
  },
  {
    "function_name": "alarmtimer_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "323-326",
    "snippet": "static int alarmtimer_resume(struct device *dev)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic int alarmtimer_resume(struct device *dev)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "alarmtimer_suspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "318-321",
    "snippet": "static int alarmtimer_suspend(struct device *dev)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic int alarmtimer_suspend(struct device *dev)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "alarmtimer_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "307-315",
    "snippet": "static int alarmtimer_resume(struct device *dev)\n{\n\tstruct rtc_device *rtc;\n\n\trtc = alarmtimer_get_rtcdev();\n\tif (rtc)\n\t\trtc_timer_cancel(rtc, &rtctimer);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtc_timer_cancel",
          "args": [
            "rtc",
            "&rtctimer"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarmtimer_get_rtcdev",
          "args": [],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_get_rtcdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "144-147",
          "snippet": "struct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstruct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic int alarmtimer_resume(struct device *dev)\n{\n\tstruct rtc_device *rtc;\n\n\trtc = alarmtimer_get_rtcdev();\n\tif (rtc)\n\t\trtc_timer_cancel(rtc, &rtctimer);\n\treturn 0;\n}"
  },
  {
    "function_name": "alarmtimer_suspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "246-305",
    "snippet": "static int alarmtimer_suspend(struct device *dev)\n{\n\tktime_t min, now, expires;\n\tint i, ret, type;\n\tstruct rtc_device *rtc;\n\tunsigned long flags;\n\tstruct rtc_time tm;\n\n\tspin_lock_irqsave(&freezer_delta_lock, flags);\n\tmin = freezer_delta;\n\texpires = freezer_expires;\n\ttype = freezer_alarmtype;\n\tfreezer_delta = 0;\n\tspin_unlock_irqrestore(&freezer_delta_lock, flags);\n\n\trtc = alarmtimer_get_rtcdev();\n\t/* If we have no rtcdev, just return */\n\tif (!rtc)\n\t\treturn 0;\n\n\t/* Find the soonest timer to expire*/\n\tfor (i = 0; i < ALARM_NUMTYPE; i++) {\n\t\tstruct alarm_base *base = &alarm_bases[i];\n\t\tstruct timerqueue_node *next;\n\t\tktime_t delta;\n\n\t\tspin_lock_irqsave(&base->lock, flags);\n\t\tnext = timerqueue_getnext(&base->timerqueue);\n\t\tspin_unlock_irqrestore(&base->lock, flags);\n\t\tif (!next)\n\t\t\tcontinue;\n\t\tdelta = ktime_sub(next->expires, base->gettime());\n\t\tif (!min || (delta < min)) {\n\t\t\texpires = next->expires;\n\t\t\tmin = delta;\n\t\t\ttype = i;\n\t\t}\n\t}\n\tif (min == 0)\n\t\treturn 0;\n\n\tif (ktime_to_ns(min) < 2 * NSEC_PER_SEC) {\n\t\t__pm_wakeup_event(ws, 2 * MSEC_PER_SEC);\n\t\treturn -EBUSY;\n\t}\n\n\ttrace_alarmtimer_suspend(expires, type);\n\n\t/* Setup an rtc timer to fire that far in the future */\n\trtc_timer_cancel(rtc, &rtctimer);\n\trtc_read_time(rtc, &tm);\n\tnow = rtc_tm_to_ktime(tm);\n\tnow = ktime_add(now, min);\n\n\t/* Set alarm, if in the past reject suspend briefly to handle */\n\tret = rtc_timer_start(rtc, &rtctimer, now, 0);\n\tif (ret < 0)\n\t\t__pm_wakeup_event(ws, MSEC_PER_SEC);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define rtcdev (NULL)"
    ],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pm_wakeup_event",
          "args": [
            "ws",
            "MSEC_PER_SEC"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtc_timer_start",
          "args": [
            "rtc",
            "&rtctimer",
            "now",
            "0"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "now",
            "min"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtc_tm_to_ktime",
          "args": [
            "tm"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtc_read_time",
          "args": [
            "rtc",
            "&tm"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtc_timer_cancel",
          "args": [
            "rtc",
            "&rtctimer"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_alarmtimer_suspend",
          "args": [
            "expires",
            "type"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pm_wakeup_event",
          "args": [
            "ws",
            "2 * MSEC_PER_SEC"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "min"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "next->expires",
            "base->gettime()"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base->gettime",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timerqueue_getnext",
          "args": [
            "&base->timerqueue"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarmtimer_get_rtcdev",
          "args": [],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_get_rtcdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "144-147",
          "snippet": "struct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstruct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\n#define rtcdev (NULL)\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic int alarmtimer_suspend(struct device *dev)\n{\n\tktime_t min, now, expires;\n\tint i, ret, type;\n\tstruct rtc_device *rtc;\n\tunsigned long flags;\n\tstruct rtc_time tm;\n\n\tspin_lock_irqsave(&freezer_delta_lock, flags);\n\tmin = freezer_delta;\n\texpires = freezer_expires;\n\ttype = freezer_alarmtype;\n\tfreezer_delta = 0;\n\tspin_unlock_irqrestore(&freezer_delta_lock, flags);\n\n\trtc = alarmtimer_get_rtcdev();\n\t/* If we have no rtcdev, just return */\n\tif (!rtc)\n\t\treturn 0;\n\n\t/* Find the soonest timer to expire*/\n\tfor (i = 0; i < ALARM_NUMTYPE; i++) {\n\t\tstruct alarm_base *base = &alarm_bases[i];\n\t\tstruct timerqueue_node *next;\n\t\tktime_t delta;\n\n\t\tspin_lock_irqsave(&base->lock, flags);\n\t\tnext = timerqueue_getnext(&base->timerqueue);\n\t\tspin_unlock_irqrestore(&base->lock, flags);\n\t\tif (!next)\n\t\t\tcontinue;\n\t\tdelta = ktime_sub(next->expires, base->gettime());\n\t\tif (!min || (delta < min)) {\n\t\t\texpires = next->expires;\n\t\t\tmin = delta;\n\t\t\ttype = i;\n\t\t}\n\t}\n\tif (min == 0)\n\t\treturn 0;\n\n\tif (ktime_to_ns(min) < 2 * NSEC_PER_SEC) {\n\t\t__pm_wakeup_event(ws, 2 * MSEC_PER_SEC);\n\t\treturn -EBUSY;\n\t}\n\n\ttrace_alarmtimer_suspend(expires, type);\n\n\t/* Setup an rtc timer to fire that far in the future */\n\trtc_timer_cancel(rtc, &rtctimer);\n\trtc_read_time(rtc, &tm);\n\tnow = rtc_tm_to_ktime(tm);\n\tnow = ktime_add(now, min);\n\n\t/* Set alarm, if in the past reject suspend briefly to handle */\n\tret = rtc_timer_start(rtc, &rtctimer, now, 0);\n\tif (ret < 0)\n\t\t__pm_wakeup_event(ws, MSEC_PER_SEC);\n\treturn ret;\n}"
  },
  {
    "function_name": "alarm_expires_remaining",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "228-232",
    "snippet": "ktime_t alarm_expires_remaining(const struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\treturn ktime_sub(alarm->node.expires, base->gettime());\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "alarm->node.expires",
            "base->gettime()"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base->gettime",
          "args": [],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nktime_t alarm_expires_remaining(const struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\treturn ktime_sub(alarm->node.expires, base->gettime());\n}"
  },
  {
    "function_name": "alarmtimer_fired",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "200-226",
    "snippet": "static enum hrtimer_restart alarmtimer_fired(struct hrtimer *timer)\n{\n\tstruct alarm *alarm = container_of(timer, struct alarm, timer);\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\tint ret = HRTIMER_NORESTART;\n\tint restart = ALARMTIMER_NORESTART;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\talarmtimer_dequeue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\tif (alarm->function)\n\t\trestart = alarm->function(alarm, base->gettime());\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tif (restart != ALARMTIMER_NORESTART) {\n\t\thrtimer_set_expires(&alarm->timer, alarm->node.expires);\n\t\talarmtimer_enqueue(base, alarm);\n\t\tret = HRTIMER_RESTART;\n\t}\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_fired(alarm, base->gettime());\n\treturn ret;\n\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_alarmtimer_fired",
          "args": [
            "alarm",
            "base->gettime()"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base->gettime",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarmtimer_enqueue",
          "args": [
            "base",
            "alarm"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_enqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "163-170",
          "snippet": "static void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (alarm->state & ALARMTIMER_STATE_ENQUEUED)\n\t\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\n\ttimerqueue_add(&base->timerqueue, &alarm->node);\n\talarm->state |= ALARMTIMER_STATE_ENQUEUED;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (alarm->state & ALARMTIMER_STATE_ENQUEUED)\n\t\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\n\ttimerqueue_add(&base->timerqueue, &alarm->node);\n\talarm->state |= ALARMTIMER_STATE_ENQUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires",
          "args": [
            "&alarm->timer",
            "alarm->node.expires"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarm->function",
          "args": [
            "alarm",
            "base->gettime()"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base->gettime",
          "args": [],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarmtimer_dequeue",
          "args": [
            "base",
            "alarm"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_dequeue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
          "lines": "181-188",
          "snippet": "static void alarmtimer_dequeue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (!(alarm->state & ALARMTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\talarm->state &= ~ALARMTIMER_STATE_ENQUEUED;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void alarmtimer_dequeue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (!(alarm->state & ALARMTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\talarm->state &= ~ALARMTIMER_STATE_ENQUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structalarm",
            "timer"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*gettime)(void);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic enum hrtimer_restart alarmtimer_fired(struct hrtimer *timer)\n{\n\tstruct alarm *alarm = container_of(timer, struct alarm, timer);\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\tint ret = HRTIMER_NORESTART;\n\tint restart = ALARMTIMER_NORESTART;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\talarmtimer_dequeue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\tif (alarm->function)\n\t\trestart = alarm->function(alarm, base->gettime());\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tif (restart != ALARMTIMER_NORESTART) {\n\t\thrtimer_set_expires(&alarm->timer, alarm->node.expires);\n\t\talarmtimer_enqueue(base, alarm);\n\t\tret = HRTIMER_RESTART;\n\t}\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_fired(alarm, base->gettime());\n\treturn ret;\n\n}"
  },
  {
    "function_name": "alarmtimer_dequeue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "181-188",
    "snippet": "static void alarmtimer_dequeue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (!(alarm->state & ALARMTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\talarm->state &= ~ALARMTIMER_STATE_ENQUEUED;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timerqueue_del",
          "args": [
            "&base->timerqueue",
            "&alarm->node"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void alarmtimer_dequeue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (!(alarm->state & ALARMTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\talarm->state &= ~ALARMTIMER_STATE_ENQUEUED;\n}"
  },
  {
    "function_name": "alarmtimer_enqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "163-170",
    "snippet": "static void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (alarm->state & ALARMTIMER_STATE_ENQUEUED)\n\t\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\n\ttimerqueue_add(&base->timerqueue, &alarm->node);\n\talarm->state |= ALARMTIMER_STATE_ENQUEUED;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timerqueue_add",
          "args": [
            "&base->timerqueue",
            "&alarm->node"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_del",
          "args": [
            "&base->timerqueue",
            "&alarm->node"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (alarm->state & ALARMTIMER_STATE_ENQUEUED)\n\t\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\n\ttimerqueue_add(&base->timerqueue, &alarm->node);\n\talarm->state |= ALARMTIMER_STATE_ENQUEUED;\n}"
  },
  {
    "function_name": "alarmtimer_rtc_timer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "151-151",
    "snippet": "static inline void alarmtimer_rtc_timer_init(void) { }",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic inline void alarmtimer_rtc_timer_init(void) { }"
  },
  {
    "function_name": "alarmtimer_rtc_interface_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "150-150",
    "snippet": "static inline void alarmtimer_rtc_interface_remove(void) { }",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic inline void alarmtimer_rtc_interface_remove(void) { }"
  },
  {
    "function_name": "alarmtimer_rtc_interface_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "149-149",
    "snippet": "static inline int alarmtimer_rtc_interface_setup(void) { return 0; }",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic inline int alarmtimer_rtc_interface_setup(void) { return 0; }"
  },
  {
    "function_name": "alarmtimer_get_rtcdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "144-147",
    "snippet": "struct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstruct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "alarmtimer_rtc_interface_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "139-142",
    "snippet": "static void alarmtimer_rtc_interface_remove(void)\n{\n\tclass_interface_unregister(&alarmtimer_rtc_interface);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "class_interface_unregister",
          "args": [
            "&alarmtimer_rtc_interface"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void alarmtimer_rtc_interface_remove(void)\n{\n\tclass_interface_unregister(&alarmtimer_rtc_interface);\n}"
  },
  {
    "function_name": "alarmtimer_rtc_interface_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "134-138",
    "snippet": "static int alarmtimer_rtc_interface_setup(void)\n{\n\talarmtimer_rtc_interface.class = rtc_class;\n\treturn class_interface_register(&alarmtimer_rtc_interface);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "class_interface_register",
          "args": [
            "&alarmtimer_rtc_interface"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic int alarmtimer_rtc_interface_setup(void)\n{\n\talarmtimer_rtc_interface.class = rtc_class;\n\treturn class_interface_register(&alarmtimer_rtc_interface);\n}"
  },
  {
    "function_name": "alarmtimer_rtc_timer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "125-128",
    "snippet": "static inline void alarmtimer_rtc_timer_init(void)\n{\n\trtc_timer_init(&rtctimer, NULL, NULL);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtc_timer_init",
          "args": [
            "&rtctimer",
            "NULL",
            "NULL"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic inline void alarmtimer_rtc_timer_init(void)\n{\n\trtc_timer_init(&rtctimer, NULL, NULL);\n}"
  },
  {
    "function_name": "alarmtimer_rtc_add_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "88-123",
    "snippet": "static int alarmtimer_rtc_add_device(struct device *dev,\n\t\t\t\tstruct class_interface *class_intf)\n{\n\tunsigned long flags;\n\tstruct rtc_device *rtc = to_rtc_device(dev);\n\tstruct wakeup_source *__ws;\n\n\tif (rtcdev)\n\t\treturn -EBUSY;\n\n\tif (!rtc->ops->set_alarm)\n\t\treturn -1;\n\tif (!device_may_wakeup(rtc->dev.parent))\n\t\treturn -1;\n\n\t__ws = wakeup_source_register(\"alarmtimer\");\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tif (!rtcdev) {\n\t\tif (!try_module_get(rtc->owner)) {\n\t\t\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\t\t\treturn -1;\n\t\t}\n\n\t\trtcdev = rtc;\n\t\t/* hold a reference so it doesn't go away */\n\t\tget_device(dev);\n\t\tws = __ws;\n\t\t__ws = NULL;\n\t}\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\twakeup_source_unregister(__ws);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define rtcdev (NULL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup_source_unregister",
          "args": [
            "__ws"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtcdev_lock",
            "flags"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_device",
          "args": [
            "dev"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-common.c",
          "lines": "57-60",
          "snippet": "struct tick_device *tick_get_device(int cpu)\n{\n\treturn &per_cpu(tick_cpu_device, cpu);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstruct tick_device *tick_get_device(int cpu)\n{\n\treturn &per_cpu(tick_cpu_device, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "rtc->owner"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1113-1129",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&rtcdev_lock",
            "flags"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup_source_register",
          "args": [
            "\"alarmtimer\""
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_may_wakeup",
          "args": [
            "rtc->dev.parent"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_rtc_device",
          "args": [
            "dev"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\n#define rtcdev (NULL)\n\nstatic int alarmtimer_rtc_add_device(struct device *dev,\n\t\t\t\tstruct class_interface *class_intf)\n{\n\tunsigned long flags;\n\tstruct rtc_device *rtc = to_rtc_device(dev);\n\tstruct wakeup_source *__ws;\n\n\tif (rtcdev)\n\t\treturn -EBUSY;\n\n\tif (!rtc->ops->set_alarm)\n\t\treturn -1;\n\tif (!device_may_wakeup(rtc->dev.parent))\n\t\treturn -1;\n\n\t__ws = wakeup_source_register(\"alarmtimer\");\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tif (!rtcdev) {\n\t\tif (!try_module_get(rtc->owner)) {\n\t\t\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\t\t\treturn -1;\n\t\t}\n\n\t\trtcdev = rtc;\n\t\t/* hold a reference so it doesn't go away */\n\t\tget_device(dev);\n\t\tws = __ws;\n\t\t__ws = NULL;\n\t}\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\twakeup_source_unregister(__ws);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "alarmtimer_get_rtcdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/alarmtimer.c",
    "lines": "75-85",
    "snippet": "struct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\tunsigned long flags;\n\tstruct rtc_device *ret;\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tret = rtcdev;\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define rtcdev (NULL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtcdev_lock",
            "flags"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&rtcdev_lock",
            "flags"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\n#define rtcdev (NULL)\n\nstruct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\tunsigned long flags;\n\tstruct rtc_device *ret;\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tret = rtcdev;\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\treturn ret;\n}"
  }
]