[
  {
    "function_name": "pids_events_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
    "lines": "309-315",
    "snippet": "static int pids_events_show(struct seq_file *sf, void *v)\n{\n\tstruct pids_cgroup *pids = css_pids(seq_css(sf));\n\n\tseq_printf(sf, \"max %lld\\n\", (s64)atomic64_read(&pids->events_limit));\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\"max %lld\\n\"",
            "(s64)atomic64_read(&pids->events_limit)"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&pids->events_limit"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "seq_css(sf)"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "60-63",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "sf"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int pids_events_show(struct seq_file *sf, void *v)\n{\n\tstruct pids_cgroup *pids = css_pids(seq_css(sf));\n\n\tseq_printf(sf, \"max %lld\\n\", (s64)atomic64_read(&pids->events_limit));\n\treturn 0;\n}"
  },
  {
    "function_name": "pids_current_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
    "lines": "301-307",
    "snippet": "static s64 pids_current_read(struct cgroup_subsys_state *css,\n\t\t\t     struct cftype *cft)\n{\n\tstruct pids_cgroup *pids = css_pids(css);\n\n\treturn atomic64_read(&pids->counter);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&pids->counter"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "css"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "60-63",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic s64 pids_current_read(struct cgroup_subsys_state *css,\n\t\t\t     struct cftype *cft)\n{\n\tstruct pids_cgroup *pids = css_pids(css);\n\n\treturn atomic64_read(&pids->counter);\n}"
  },
  {
    "function_name": "pids_max_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
    "lines": "287-299",
    "snippet": "static int pids_max_show(struct seq_file *sf, void *v)\n{\n\tstruct cgroup_subsys_state *css = seq_css(sf);\n\tstruct pids_cgroup *pids = css_pids(css);\n\tint64_t limit = pids->limit;\n\n\tif (limit >= PIDS_MAX)\n\t\tseq_printf(sf, \"%s\\n\", PIDS_MAX_STR);\n\telse\n\t\tseq_printf(sf, \"%lld\\n\", limit);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PIDS_MAX_STR \"max\"",
      "#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\"%lld\\n\"",
            "limit"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "css"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "60-63",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "sf"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\n#define PIDS_MAX_STR \"max\"\n#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)\n\nstatic int pids_max_show(struct seq_file *sf, void *v)\n{\n\tstruct cgroup_subsys_state *css = seq_css(sf);\n\tstruct pids_cgroup *pids = css_pids(css);\n\tint64_t limit = pids->limit;\n\n\tif (limit >= PIDS_MAX)\n\t\tseq_printf(sf, \"%s\\n\", PIDS_MAX_STR);\n\telse\n\t\tseq_printf(sf, \"%lld\\n\", limit);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pids_max_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
    "lines": "257-285",
    "snippet": "static ssize_t pids_max_write(struct kernfs_open_file *of, char *buf,\n\t\t\t      size_t nbytes, loff_t off)\n{\n\tstruct cgroup_subsys_state *css = of_css(of);\n\tstruct pids_cgroup *pids = css_pids(css);\n\tint64_t limit;\n\tint err;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, PIDS_MAX_STR)) {\n\t\tlimit = PIDS_MAX;\n\t\tgoto set_limit;\n\t}\n\n\terr = kstrtoll(buf, 0, &limit);\n\tif (err)\n\t\treturn err;\n\n\tif (limit < 0 || limit >= PIDS_MAX)\n\t\treturn -EINVAL;\n\nset_limit:\n\t/*\n\t * Limit updates don't need to be mutex'd, since it isn't\n\t * critical that any racing fork()s follow the new limit.\n\t */\n\tpids->limit = limit;\n\treturn nbytes;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PIDS_MAX_STR \"max\"",
      "#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoll",
          "args": [
            "buf",
            "0",
            "&limit"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "PIDS_MAX_STR"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "css"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "60-63",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "of_css",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "565-582",
          "snippet": "struct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\n#define PIDS_MAX_STR \"max\"\n#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)\n\nstatic ssize_t pids_max_write(struct kernfs_open_file *of, char *buf,\n\t\t\t      size_t nbytes, loff_t off)\n{\n\tstruct cgroup_subsys_state *css = of_css(of);\n\tstruct pids_cgroup *pids = css_pids(css);\n\tint64_t limit;\n\tint err;\n\n\tbuf = strstrip(buf);\n\tif (!strcmp(buf, PIDS_MAX_STR)) {\n\t\tlimit = PIDS_MAX;\n\t\tgoto set_limit;\n\t}\n\n\terr = kstrtoll(buf, 0, &limit);\n\tif (err)\n\t\treturn err;\n\n\tif (limit < 0 || limit >= PIDS_MAX)\n\t\treturn -EINVAL;\n\nset_limit:\n\t/*\n\t * Limit updates don't need to be mutex'd, since it isn't\n\t * critical that any racing fork()s follow the new limit.\n\t */\n\tpids->limit = limit;\n\treturn nbytes;\n}"
  },
  {
    "function_name": "pids_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
    "lines": "250-255",
    "snippet": "static void pids_free(struct task_struct *task)\n{\n\tstruct pids_cgroup *pids = css_pids(task_css(task, pids_cgrp_id));\n\n\tpids_uncharge(pids, 1);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pids_uncharge",
          "args": [
            "pids",
            "1"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "pids_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "112-118",
          "snippet": "static void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "task_css(task, pids_cgrp_id)"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "60-63",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css",
          "args": [
            "task",
            "pids_cgrp_id"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_free(struct task_struct *task)\n{\n\tstruct pids_cgroup *pids = css_pids(task_css(task, pids_cgrp_id));\n\n\tpids_uncharge(pids, 1);\n}"
  },
  {
    "function_name": "pids_cancel_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
    "lines": "240-248",
    "snippet": "static void pids_cancel_fork(struct task_struct *task)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct pids_cgroup *pids;\n\n\tcss = task_css_check(current, pids_cgrp_id, true);\n\tpids = css_pids(css);\n\tpids_uncharge(pids, 1);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pids_uncharge",
          "args": [
            "pids",
            "1"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "pids_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "112-118",
          "snippet": "static void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "css"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "60-63",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css_check",
          "args": [
            "current",
            "pids_cgrp_id",
            "true"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_cancel_fork(struct task_struct *task)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct pids_cgroup *pids;\n\n\tcss = task_css_check(current, pids_cgrp_id, true);\n\tpids = css_pids(css);\n\tpids_uncharge(pids, 1);\n}"
  },
  {
    "function_name": "pids_can_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
    "lines": "219-238",
    "snippet": "static int pids_can_fork(struct task_struct *task)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct pids_cgroup *pids;\n\tint err;\n\n\tcss = task_css_check(current, pids_cgrp_id, true);\n\tpids = css_pids(css);\n\terr = pids_try_charge(pids, 1);\n\tif (err) {\n\t\t/* Only log the first time events_limit is incremented. */\n\t\tif (atomic64_inc_return(&pids->events_limit) == 1) {\n\t\t\tpr_info(\"cgroup: fork rejected by pids controller in \");\n\t\t\tpr_cont_cgroup_path(css->cgroup);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tcgroup_file_notify(&pids->events_file);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_file_notify",
          "args": [
            "&pids->events_file"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont_cgroup_path",
          "args": [
            "css->cgroup"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"cgroup: fork rejected by pids controller in \""
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_inc_return",
          "args": [
            "&pids->events_limit"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pids_try_charge",
          "args": [
            "pids",
            "1"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "pids_try_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "146-170",
          "snippet": "static int pids_try_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p, *q;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p)) {\n\t\tint64_t new = atomic64_add_return(num, &p->counter);\n\n\t\t/*\n\t\t * Since new is capped to the maximum number of pid_t, if\n\t\t * p->limit is %PIDS_MAX then we know that this test will never\n\t\t * fail.\n\t\t */\n\t\tif (new > p->limit)\n\t\t\tgoto revert;\n\t}\n\n\treturn 0;\n\nrevert:\n\tfor (q = pids; q != p; q = parent_pids(q))\n\t\tpids_cancel(q, num);\n\tpids_cancel(p, num);\n\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\n#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)\n\nstatic int pids_try_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p, *q;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p)) {\n\t\tint64_t new = atomic64_add_return(num, &p->counter);\n\n\t\t/*\n\t\t * Since new is capped to the maximum number of pid_t, if\n\t\t * p->limit is %PIDS_MAX then we know that this test will never\n\t\t * fail.\n\t\t */\n\t\tif (new > p->limit)\n\t\t\tgoto revert;\n\t}\n\n\treturn 0;\n\nrevert:\n\tfor (q = pids; q != p; q = parent_pids(q))\n\t\tpids_cancel(q, num);\n\tpids_cancel(p, num);\n\n\treturn -EAGAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "css"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "60-63",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css_check",
          "args": [
            "current",
            "pids_cgrp_id",
            "true"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int pids_can_fork(struct task_struct *task)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct pids_cgroup *pids;\n\tint err;\n\n\tcss = task_css_check(current, pids_cgrp_id, true);\n\tpids = css_pids(css);\n\terr = pids_try_charge(pids, 1);\n\tif (err) {\n\t\t/* Only log the first time events_limit is incremented. */\n\t\tif (atomic64_inc_return(&pids->events_limit) == 1) {\n\t\t\tpr_info(\"cgroup: fork rejected by pids controller in \");\n\t\t\tpr_cont_cgroup_path(css->cgroup);\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tcgroup_file_notify(&pids->events_file);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "pids_cancel_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
    "lines": "197-213",
    "snippet": "static void pids_cancel_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *dst_css;\n\n\tcgroup_taskset_for_each(task, dst_css, tset) {\n\t\tstruct pids_cgroup *pids = css_pids(dst_css);\n\t\tstruct cgroup_subsys_state *old_css;\n\t\tstruct pids_cgroup *old_pids;\n\n\t\told_css = task_css(task, pids_cgrp_id);\n\t\told_pids = css_pids(old_css);\n\n\t\tpids_charge(old_pids, 1);\n\t\tpids_uncharge(pids, 1);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pids_uncharge",
          "args": [
            "pids",
            "1"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "pids_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "112-118",
          "snippet": "static void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pids_charge",
          "args": [
            "old_pids",
            "1"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "pids_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "129-135",
          "snippet": "static void pids_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tatomic64_add(num, &p->counter);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tatomic64_add(num, &p->counter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "old_css"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "60-63",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css",
          "args": [
            "task",
            "pids_cgrp_id"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_taskset_for_each",
          "args": [
            "task",
            "dst_css",
            "tset"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_cancel_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *dst_css;\n\n\tcgroup_taskset_for_each(task, dst_css, tset) {\n\t\tstruct pids_cgroup *pids = css_pids(dst_css);\n\t\tstruct cgroup_subsys_state *old_css;\n\t\tstruct pids_cgroup *old_pids;\n\n\t\told_css = task_css(task, pids_cgrp_id);\n\t\told_pids = css_pids(old_css);\n\n\t\tpids_charge(old_pids, 1);\n\t\tpids_uncharge(pids, 1);\n\t}\n}"
  },
  {
    "function_name": "pids_can_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
    "lines": "172-195",
    "snippet": "static int pids_can_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *dst_css;\n\n\tcgroup_taskset_for_each(task, dst_css, tset) {\n\t\tstruct pids_cgroup *pids = css_pids(dst_css);\n\t\tstruct cgroup_subsys_state *old_css;\n\t\tstruct pids_cgroup *old_pids;\n\n\t\t/*\n\t\t * No need to pin @old_css between here and cancel_attach()\n\t\t * because cgroup core protects it from being freed before\n\t\t * the migration completes or fails.\n\t\t */\n\t\told_css = task_css(task, pids_cgrp_id);\n\t\told_pids = css_pids(old_css);\n\n\t\tpids_charge(pids, 1);\n\t\tpids_uncharge(old_pids, 1);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pids_uncharge",
          "args": [
            "old_pids",
            "1"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "pids_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "112-118",
          "snippet": "static void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pids_charge",
          "args": [
            "pids",
            "1"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "pids_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "129-135",
          "snippet": "static void pids_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tatomic64_add(num, &p->counter);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tatomic64_add(num, &p->counter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "old_css"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "60-63",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css",
          "args": [
            "task",
            "pids_cgrp_id"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_taskset_for_each",
          "args": [
            "task",
            "dst_css",
            "tset"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic int pids_can_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *dst_css;\n\n\tcgroup_taskset_for_each(task, dst_css, tset) {\n\t\tstruct pids_cgroup *pids = css_pids(dst_css);\n\t\tstruct cgroup_subsys_state *old_css;\n\t\tstruct pids_cgroup *old_pids;\n\n\t\t/*\n\t\t * No need to pin @old_css between here and cancel_attach()\n\t\t * because cgroup core protects it from being freed before\n\t\t * the migration completes or fails.\n\t\t */\n\t\told_css = task_css(task, pids_cgrp_id);\n\t\told_pids = css_pids(old_css);\n\n\t\tpids_charge(pids, 1);\n\t\tpids_uncharge(old_pids, 1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pids_try_charge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
    "lines": "146-170",
    "snippet": "static int pids_try_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p, *q;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p)) {\n\t\tint64_t new = atomic64_add_return(num, &p->counter);\n\n\t\t/*\n\t\t * Since new is capped to the maximum number of pid_t, if\n\t\t * p->limit is %PIDS_MAX then we know that this test will never\n\t\t * fail.\n\t\t */\n\t\tif (new > p->limit)\n\t\t\tgoto revert;\n\t}\n\n\treturn 0;\n\nrevert:\n\tfor (q = pids; q != p; q = parent_pids(q))\n\t\tpids_cancel(q, num);\n\tpids_cancel(p, num);\n\n\treturn -EAGAIN;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pids_cancel",
          "args": [
            "p",
            "num"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "pids_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "98-105",
          "snippet": "static void pids_cancel(struct pids_cgroup *pids, int num)\n{\n\t/*\n\t * A negative count (or overflow for that matter) is invalid,\n\t * and indicates a bug in the `pids` controller proper.\n\t */\n\tWARN_ON_ONCE(atomic64_add_negative(-num, &pids->counter));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_cancel(struct pids_cgroup *pids, int num)\n{\n\t/*\n\t * A negative count (or overflow for that matter) is invalid,\n\t * and indicates a bug in the `pids` controller proper.\n\t */\n\tWARN_ON_ONCE(atomic64_add_negative(-num, &pids->counter));\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_pids",
          "args": [
            "q"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "parent_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "65-68",
          "snippet": "static struct pids_cgroup *parent_pids(struct pids_cgroup *pids)\n{\n\treturn css_pids(pids->css.parent);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *parent_pids(struct pids_cgroup *pids)\n{\n\treturn css_pids(pids->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_add_return",
          "args": [
            "num",
            "&p->counter"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\n#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)\n\nstatic int pids_try_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p, *q;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p)) {\n\t\tint64_t new = atomic64_add_return(num, &p->counter);\n\n\t\t/*\n\t\t * Since new is capped to the maximum number of pid_t, if\n\t\t * p->limit is %PIDS_MAX then we know that this test will never\n\t\t * fail.\n\t\t */\n\t\tif (new > p->limit)\n\t\t\tgoto revert;\n\t}\n\n\treturn 0;\n\nrevert:\n\tfor (q = pids; q != p; q = parent_pids(q))\n\t\tpids_cancel(q, num);\n\tpids_cancel(p, num);\n\n\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "pids_charge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
    "lines": "129-135",
    "snippet": "static void pids_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tatomic64_add(num, &p->counter);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_add",
          "args": [
            "num",
            "&p->counter"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_pids",
          "args": [
            "p"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "parent_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "65-68",
          "snippet": "static struct pids_cgroup *parent_pids(struct pids_cgroup *pids)\n{\n\treturn css_pids(pids->css.parent);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *parent_pids(struct pids_cgroup *pids)\n{\n\treturn css_pids(pids->css.parent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_charge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tatomic64_add(num, &p->counter);\n}"
  },
  {
    "function_name": "pids_uncharge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
    "lines": "112-118",
    "snippet": "static void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pids_cancel",
          "args": [
            "p",
            "num"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "pids_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "98-105",
          "snippet": "static void pids_cancel(struct pids_cgroup *pids, int num)\n{\n\t/*\n\t * A negative count (or overflow for that matter) is invalid,\n\t * and indicates a bug in the `pids` controller proper.\n\t */\n\tWARN_ON_ONCE(atomic64_add_negative(-num, &pids->counter));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_cancel(struct pids_cgroup *pids, int num)\n{\n\t/*\n\t * A negative count (or overflow for that matter) is invalid,\n\t * and indicates a bug in the `pids` controller proper.\n\t */\n\tWARN_ON_ONCE(atomic64_add_negative(-num, &pids->counter));\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_pids",
          "args": [
            "p"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "parent_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "65-68",
          "snippet": "static struct pids_cgroup *parent_pids(struct pids_cgroup *pids)\n{\n\treturn css_pids(pids->css.parent);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *parent_pids(struct pids_cgroup *pids)\n{\n\treturn css_pids(pids->css.parent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_uncharge(struct pids_cgroup *pids, int num)\n{\n\tstruct pids_cgroup *p;\n\n\tfor (p = pids; parent_pids(p); p = parent_pids(p))\n\t\tpids_cancel(p, num);\n}"
  },
  {
    "function_name": "pids_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
    "lines": "98-105",
    "snippet": "static void pids_cancel(struct pids_cgroup *pids, int num)\n{\n\t/*\n\t * A negative count (or overflow for that matter) is invalid,\n\t * and indicates a bug in the `pids` controller proper.\n\t */\n\tWARN_ON_ONCE(atomic64_add_negative(-num, &pids->counter));\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "atomic64_add_negative(-num, &pids->counter)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_add_negative",
          "args": [
            "-num",
            "&pids->counter"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_cancel(struct pids_cgroup *pids, int num)\n{\n\t/*\n\t * A negative count (or overflow for that matter) is invalid,\n\t * and indicates a bug in the `pids` controller proper.\n\t */\n\tWARN_ON_ONCE(atomic64_add_negative(-num, &pids->counter));\n}"
  },
  {
    "function_name": "pids_css_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
    "lines": "85-88",
    "snippet": "static void pids_css_free(struct cgroup_subsys_state *css)\n{\n\tkfree(css_pids(css));\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "css_pids(css)"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "css"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "60-63",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic void pids_css_free(struct cgroup_subsys_state *css)\n{\n\tkfree(css_pids(css));\n}"
  },
  {
    "function_name": "pids_css_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
    "lines": "70-83",
    "snippet": "static struct cgroup_subsys_state *\npids_css_alloc(struct cgroup_subsys_state *parent)\n{\n\tstruct pids_cgroup *pids;\n\n\tpids = kzalloc(sizeof(struct pids_cgroup), GFP_KERNEL);\n\tif (!pids)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpids->limit = PIDS_MAX;\n\tatomic64_set(&pids->counter, 0);\n\tatomic64_set(&pids->events_limit, 0);\n\treturn &pids->css;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&pids->events_limit",
            "0"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&pids->counter",
            "0"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct pids_cgroup)",
            "GFP_KERNEL"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\n#define PIDS_MAX (PID_MAX_LIMIT + 1ULL)\n\nstatic struct cgroup_subsys_state *\npids_css_alloc(struct cgroup_subsys_state *parent)\n{\n\tstruct pids_cgroup *pids;\n\n\tpids = kzalloc(sizeof(struct pids_cgroup), GFP_KERNEL);\n\tif (!pids)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpids->limit = PIDS_MAX;\n\tatomic64_set(&pids->counter, 0);\n\tatomic64_set(&pids->events_limit, 0);\n\treturn &pids->css;\n}"
  },
  {
    "function_name": "parent_pids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
    "lines": "65-68",
    "snippet": "static struct pids_cgroup *parent_pids(struct pids_cgroup *pids)\n{\n\treturn css_pids(pids->css.parent);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_pids",
          "args": [
            "pids->css.parent"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "css_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
          "lines": "60-63",
          "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/threads.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *parent_pids(struct pids_cgroup *pids)\n{\n\treturn css_pids(pids->css.parent);\n}"
  },
  {
    "function_name": "css_pids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/pids.c",
    "lines": "60-63",
    "snippet": "static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/atomic.h>",
      "#include <linux/threads.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "css",
            "structpids_cgroup",
            "css"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/threads.h>\n#include <linux/kernel.h>\n\nstatic struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\n{\n\treturn container_of(css, struct pids_cgroup, css);\n}"
  }
]