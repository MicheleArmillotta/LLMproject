[
  {
    "function_name": "xtime_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "2392-2398",
    "snippet": "void xtime_update(unsigned long ticks)\n{\n\twrite_seqlock(&jiffies_lock);\n\tdo_timer(ticks);\n\twrite_sequnlock(&jiffies_lock);\n\tupdate_wall_time();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_wall_time",
          "args": [],
          "line": 2397
        },
        "resolved": true,
        "details": {
          "function_name": "update_wall_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "2136-2139",
          "snippet": "void update_wall_time(void)\n{\n\ttimekeeping_advance(TK_ADV_TICK);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid update_wall_time(void)\n{\n\ttimekeeping_advance(TK_ADV_TICK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_sequnlock",
          "args": [
            "&jiffies_lock"
          ],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_timer",
          "args": [
            "ticks"
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "do_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "2195-2199",
          "snippet": "void do_timer(unsigned long ticks)\n{\n\tjiffies_64 += ticks;\n\tcalc_global_load(ticks);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid do_timer(unsigned long ticks)\n{\n\tjiffies_64 += ticks;\n\tcalc_global_load(ticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqlock",
          "args": [
            "&jiffies_lock"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid xtime_update(unsigned long ticks)\n{\n\twrite_seqlock(&jiffies_lock);\n\tdo_timer(ticks);\n\twrite_sequnlock(&jiffies_lock);\n\tupdate_wall_time();\n}"
  },
  {
    "function_name": "hardpps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "2371-2382",
    "snippet": "void hardpps(const struct timespec64 *phase_ts, const struct timespec64 *raw_ts)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\t__hardpps(phase_ts, raw_ts);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(timekeeper_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hardpps",
          "args": [
            "phase_ts",
            "raw_ts"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "__hardpps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "971-1018",
          "snippet": "void __hardpps(const struct timespec64 *phase_ts, const struct timespec64 *raw_ts)\n{\n\tstruct pps_normtime pts_norm, freq_norm;\n\n\tpts_norm = pps_normalize_ts(*phase_ts);\n\n\t/* clear the error bits, they will be set again if needed */\n\ttime_status &= ~(STA_PPSJITTER | STA_PPSWANDER | STA_PPSERROR);\n\n\t/* indicate signal presence */\n\ttime_status |= STA_PPSSIGNAL;\n\tpps_valid = PPS_VALID;\n\n\t/* when called for the first time,\n\t * just start the frequency interval */\n\tif (unlikely(pps_fbase.tv_sec == 0)) {\n\t\tpps_fbase = *raw_ts;\n\t\treturn;\n\t}\n\n\t/* ok, now we have a base for frequency calculation */\n\tfreq_norm = pps_normalize_ts(timespec64_sub(*raw_ts, pps_fbase));\n\n\t/* check that the signal is in the range\n\t * [1s - MAXFREQ us, 1s + MAXFREQ us], otherwise reject it */\n\tif ((freq_norm.sec == 0) ||\n\t\t\t(freq_norm.nsec > MAXFREQ * freq_norm.sec) ||\n\t\t\t(freq_norm.nsec < -MAXFREQ * freq_norm.sec)) {\n\t\ttime_status |= STA_PPSJITTER;\n\t\t/* restart the frequency calibration interval */\n\t\tpps_fbase = *raw_ts;\n\t\tprintk_deferred(KERN_ERR \"hardpps: PPSJITTER: bad pulse\\n\");\n\t\treturn;\n\t}\n\n\t/* signal is ok */\n\n\t/* check if the current frequency interval is finished */\n\tif (freq_norm.sec >= (1 << pps_shift)) {\n\t\tpps_calcnt++;\n\t\t/* restart the frequency calibration interval */\n\t\tpps_fbase = *raw_ts;\n\t\thardpps_update_freq(freq_norm);\n\t}\n\n\thardpps_update_phase(pts_norm.nsec);\n\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define PPS_VALID\t10\t/* PPS signal watchdog max (s) */"
          ],
          "globals_used": [
            "static int\t\t\ttime_status = STA_UNSYNC;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_VALID\t10\t/* PPS signal watchdog max (s) */\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\n\nvoid __hardpps(const struct timespec64 *phase_ts, const struct timespec64 *raw_ts)\n{\n\tstruct pps_normtime pts_norm, freq_norm;\n\n\tpts_norm = pps_normalize_ts(*phase_ts);\n\n\t/* clear the error bits, they will be set again if needed */\n\ttime_status &= ~(STA_PPSJITTER | STA_PPSWANDER | STA_PPSERROR);\n\n\t/* indicate signal presence */\n\ttime_status |= STA_PPSSIGNAL;\n\tpps_valid = PPS_VALID;\n\n\t/* when called for the first time,\n\t * just start the frequency interval */\n\tif (unlikely(pps_fbase.tv_sec == 0)) {\n\t\tpps_fbase = *raw_ts;\n\t\treturn;\n\t}\n\n\t/* ok, now we have a base for frequency calculation */\n\tfreq_norm = pps_normalize_ts(timespec64_sub(*raw_ts, pps_fbase));\n\n\t/* check that the signal is in the range\n\t * [1s - MAXFREQ us, 1s + MAXFREQ us], otherwise reject it */\n\tif ((freq_norm.sec == 0) ||\n\t\t\t(freq_norm.nsec > MAXFREQ * freq_norm.sec) ||\n\t\t\t(freq_norm.nsec < -MAXFREQ * freq_norm.sec)) {\n\t\ttime_status |= STA_PPSJITTER;\n\t\t/* restart the frequency calibration interval */\n\t\tpps_fbase = *raw_ts;\n\t\tprintk_deferred(KERN_ERR \"hardpps: PPSJITTER: bad pulse\\n\");\n\t\treturn;\n\t}\n\n\t/* signal is ok */\n\n\t/* check if the current frequency interval is finished */\n\tif (freq_norm.sec >= (1 << pps_shift)) {\n\t\tpps_calcnt++;\n\t\t/* restart the frequency calibration interval */\n\t\tpps_fbase = *raw_ts;\n\t\thardpps_update_freq(freq_norm);\n\t}\n\n\thardpps_update_phase(pts_norm.nsec);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic DEFINE_RAW_SPINLOCK(timekeeper_lock);\n\nvoid hardpps(const struct timespec64 *phase_ts, const struct timespec64 *raw_ts)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\t__hardpps(phase_ts, raw_ts);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n}"
  },
  {
    "function_name": "do_adjtimex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "2314-2365",
    "snippet": "int do_adjtimex(struct timex *txc)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64 ts;\n\ts32 orig_tai, tai;\n\tint ret;\n\n\t/* Validate the data before disabling interrupts */\n\tret = timekeeping_validate_timex(txc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (txc->modes & ADJ_SETOFFSET) {\n\t\tstruct timespec64 delta;\n\t\tdelta.tv_sec  = txc->time.tv_sec;\n\t\tdelta.tv_nsec = txc->time.tv_usec;\n\t\tif (!(txc->modes & ADJ_NANO))\n\t\t\tdelta.tv_nsec *= 1000;\n\t\tret = timekeeping_inject_offset(&delta);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tktime_get_real_ts64(&ts);\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\torig_tai = tai = tk->tai_offset;\n\tret = __do_adjtimex(txc, &ts, &tai);\n\n\tif (tai != orig_tai) {\n\t\t__timekeeping_set_tai_offset(tk, tai);\n\t\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\t}\n\ttk_update_leap_state(tk);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* Update the multiplier immediately if frequency was set directly */\n\tif (txc->modes & (ADJ_FREQUENCY | ADJ_TICK))\n\t\ttimekeeping_advance(TK_ADV_FREQ);\n\n\tif (tai != orig_tai)\n\t\tclock_was_set();\n\n\tntp_notify_cmos_timer();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_CLOCK_WAS_SET\t(1 << 2)",
      "#define TK_MIRROR\t\t(1 << 1)"
    ],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(timekeeper_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntp_notify_cmos_timer",
          "args": [],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_notify_cmos_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "632-640",
          "snippet": "void ntp_notify_cmos_timer(void)\n{\n\tif (!ntp_synced())\n\t\treturn;\n\n\tif (IS_ENABLED(CONFIG_GENERIC_CMOS_UPDATE) ||\n\t    IS_ENABLED(CONFIG_RTC_SYSTOHC))\n\t\tqueue_delayed_work(system_power_efficient_wq, &sync_work, 0);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nvoid ntp_notify_cmos_timer(void)\n{\n\tif (!ntp_synced())\n\t\treturn;\n\n\tif (IS_ENABLED(CONFIG_GENERIC_CMOS_UPDATE) ||\n\t    IS_ENABLED(CONFIG_RTC_SYSTOHC))\n\t\tqueue_delayed_work(system_power_efficient_wq, &sync_work, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clock_was_set",
          "args": [],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "clock_was_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "857-864",
          "snippet": "void clock_was_set(void)\n{\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t/* Retrigger the CPU local events everywhere */\n\ton_each_cpu(retrigger_next_event, NULL, 1);\n#endif\n\ttimerfd_clock_was_set();\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid clock_was_set(void)\n{\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t/* Retrigger the CPU local events everywhere */\n\ton_each_cpu(retrigger_next_event, NULL, 1);\n#endif\n\ttimerfd_clock_was_set();\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_advance",
          "args": [
            "TK_ADV_FREQ"
          ],
          "line": 2357
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_advance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "2049-2130",
          "snippet": "static void timekeeping_advance(enum timekeeping_adv_mode mode)\n{\n\tstruct timekeeper *real_tk = &tk_core.timekeeper;\n\tstruct timekeeper *tk = &shadow_timekeeper;\n\tu64 offset;\n\tint shift = 0, maxshift;\n\tunsigned int clock_set = 0;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\n\t/* Make sure we're fully resumed: */\n\tif (unlikely(timekeeping_suspended))\n\t\tgoto out;\n\n#ifdef CONFIG_ARCH_USES_GETTIMEOFFSET\n\toffset = real_tk->cycle_interval;\n\n\tif (mode != TK_ADV_TICK)\n\t\tgoto out;\n#else\n\toffset = clocksource_delta(tk_clock_read(&tk->tkr_mono),\n\t\t\t\t   tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\n\t/* Check if there's really nothing to do */\n\tif (offset < real_tk->cycle_interval && mode == TK_ADV_TICK)\n\t\tgoto out;\n#endif\n\n\t/* Do some additional sanity checking */\n\ttimekeeping_check_update(tk, offset);\n\n\t/*\n\t * With NO_HZ we may have to accumulate many cycle_intervals\n\t * (think \"ticks\") worth of time at once. To do this efficiently,\n\t * we calculate the largest doubling multiple of cycle_intervals\n\t * that is smaller than the offset.  We then accumulate that\n\t * chunk in one go, and then try to consume the next smaller\n\t * doubled multiple.\n\t */\n\tshift = ilog2(offset) - ilog2(tk->cycle_interval);\n\tshift = max(0, shift);\n\t/* Bound shift to one less than what overflows tick_length */\n\tmaxshift = (64 - (ilog2(ntp_tick_length())+1)) - 1;\n\tshift = min(shift, maxshift);\n\twhile (offset >= tk->cycle_interval) {\n\t\toffset = logarithmic_accumulation(tk, offset, shift,\n\t\t\t\t\t\t\t&clock_set);\n\t\tif (offset < tk->cycle_interval<<shift)\n\t\t\tshift--;\n\t}\n\n\t/* Adjust the multiplier to correct NTP error */\n\ttimekeeping_adjust(tk, offset);\n\n\t/*\n\t * Finally, make sure that after the rounding\n\t * xtime_nsec isn't larger than NSEC_PER_SEC\n\t */\n\tclock_set |= accumulate_nsecs_to_secs(tk);\n\n\twrite_seqcount_begin(&tk_core.seq);\n\t/*\n\t * Update the real timekeeper.\n\t *\n\t * We could avoid this memcpy by switching pointers, but that\n\t * requires changes to all other timekeeper usage sites as\n\t * well, i.e. move the timekeeper pointer getter into the\n\t * spinlocked/seqcount protected sections. And we trade this\n\t * memcpy under the tk_core.seq against one before we start\n\t * updating.\n\t */\n\ttimekeeping_update(tk, clock_set);\n\tmemcpy(real_tk, tk, sizeof(*tk));\n\t/* The memcpy must come last. Do not put anything here! */\n\twrite_seqcount_end(&tk_core.seq);\nout:\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\tif (clock_set)\n\t\t/* Have to call _delayed version, since in irq context*/\n\t\tclock_was_set_delayed();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RAW_SPINLOCK(timekeeper_lock);",
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic DEFINE_RAW_SPINLOCK(timekeeper_lock);\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_advance(enum timekeeping_adv_mode mode)\n{\n\tstruct timekeeper *real_tk = &tk_core.timekeeper;\n\tstruct timekeeper *tk = &shadow_timekeeper;\n\tu64 offset;\n\tint shift = 0, maxshift;\n\tunsigned int clock_set = 0;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\n\t/* Make sure we're fully resumed: */\n\tif (unlikely(timekeeping_suspended))\n\t\tgoto out;\n\n#ifdef CONFIG_ARCH_USES_GETTIMEOFFSET\n\toffset = real_tk->cycle_interval;\n\n\tif (mode != TK_ADV_TICK)\n\t\tgoto out;\n#else\n\toffset = clocksource_delta(tk_clock_read(&tk->tkr_mono),\n\t\t\t\t   tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\n\t/* Check if there's really nothing to do */\n\tif (offset < real_tk->cycle_interval && mode == TK_ADV_TICK)\n\t\tgoto out;\n#endif\n\n\t/* Do some additional sanity checking */\n\ttimekeeping_check_update(tk, offset);\n\n\t/*\n\t * With NO_HZ we may have to accumulate many cycle_intervals\n\t * (think \"ticks\") worth of time at once. To do this efficiently,\n\t * we calculate the largest doubling multiple of cycle_intervals\n\t * that is smaller than the offset.  We then accumulate that\n\t * chunk in one go, and then try to consume the next smaller\n\t * doubled multiple.\n\t */\n\tshift = ilog2(offset) - ilog2(tk->cycle_interval);\n\tshift = max(0, shift);\n\t/* Bound shift to one less than what overflows tick_length */\n\tmaxshift = (64 - (ilog2(ntp_tick_length())+1)) - 1;\n\tshift = min(shift, maxshift);\n\twhile (offset >= tk->cycle_interval) {\n\t\toffset = logarithmic_accumulation(tk, offset, shift,\n\t\t\t\t\t\t\t&clock_set);\n\t\tif (offset < tk->cycle_interval<<shift)\n\t\t\tshift--;\n\t}\n\n\t/* Adjust the multiplier to correct NTP error */\n\ttimekeeping_adjust(tk, offset);\n\n\t/*\n\t * Finally, make sure that after the rounding\n\t * xtime_nsec isn't larger than NSEC_PER_SEC\n\t */\n\tclock_set |= accumulate_nsecs_to_secs(tk);\n\n\twrite_seqcount_begin(&tk_core.seq);\n\t/*\n\t * Update the real timekeeper.\n\t *\n\t * We could avoid this memcpy by switching pointers, but that\n\t * requires changes to all other timekeeper usage sites as\n\t * well, i.e. move the timekeeper pointer getter into the\n\t * spinlocked/seqcount protected sections. And we trade this\n\t * memcpy under the tk_core.seq against one before we start\n\t * updating.\n\t */\n\ttimekeeping_update(tk, clock_set);\n\tmemcpy(real_tk, tk, sizeof(*tk));\n\t/* The memcpy must come last. Do not put anything here! */\n\twrite_seqcount_end(&tk_core.seq);\nout:\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\tif (clock_set)\n\t\t/* Have to call _delayed version, since in irq context*/\n\t\tclock_was_set_delayed();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_update_leap_state",
          "args": [
            "tk"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "tk_update_leap_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "616-622",
          "snippet": "static inline void tk_update_leap_state(struct timekeeper *tk)\n{\n\ttk->next_leap_ktime = ntp_get_next_leap();\n\tif (tk->next_leap_ktime != KTIME_MAX)\n\t\t/* Convert to monotonic time */\n\t\ttk->next_leap_ktime = ktime_sub(tk->next_leap_ktime, tk->offs_real);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_update_leap_state(struct timekeeper *tk)\n{\n\ttk->next_leap_ktime = ntp_get_next_leap();\n\tif (tk->next_leap_ktime != KTIME_MAX)\n\t\t/* Convert to monotonic time */\n\t\ttk->next_leap_ktime = ktime_sub(tk->next_leap_ktime, tk->offs_real);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_update",
          "args": [
            "tk",
            "TK_MIRROR | TK_CLOCK_WAS_SET"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "658-685",
          "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__timekeeping_set_tai_offset",
          "args": [
            "tk",
            "tai"
          ],
          "line": 2347
        },
        "resolved": true,
        "details": {
          "function_name": "__timekeeping_set_tai_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1342-1346",
          "snippet": "static void __timekeeping_set_tai_offset(struct timekeeper *tk, s32 tai_offset)\n{\n\ttk->tai_offset = tai_offset;\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tai_offset, 0));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void __timekeeping_set_tai_offset(struct timekeeper *tk, s32 tai_offset)\n{\n\ttk->tai_offset = tai_offset;\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tai_offset, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__do_adjtimex",
          "args": [
            "txc",
            "&ts",
            "&tai"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "__do_adjtimex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "719-787",
          "snippet": "int __do_adjtimex(struct timex *txc, const struct timespec64 *ts, s32 *time_tai)\n{\n\tint result;\n\n\tif (txc->modes & ADJ_ADJTIME) {\n\t\tlong save_adjust = time_adjust;\n\n\t\tif (!(txc->modes & ADJ_OFFSET_READONLY)) {\n\t\t\t/* adjtime() is independent from ntp_adjtime() */\n\t\t\ttime_adjust = txc->offset;\n\t\t\tntp_update_frequency();\n\t\t}\n\t\ttxc->offset = save_adjust;\n\t} else {\n\n\t\t/* If there are input parameters, then process them: */\n\t\tif (txc->modes)\n\t\t\tprocess_adjtimex_modes(txc, time_tai);\n\n\t\ttxc->offset = shift_right(time_offset * NTP_INTERVAL_FREQ,\n\t\t\t\t  NTP_SCALE_SHIFT);\n\t\tif (!(time_status & STA_NANO))\n\t\t\ttxc->offset /= NSEC_PER_USEC;\n\t}\n\n\tresult = time_state;\t/* mostly `TIME_OK' */\n\t/* check for errors */\n\tif (is_error_status(time_status))\n\t\tresult = TIME_ERROR;\n\n\ttxc->freq\t   = shift_right((time_freq >> PPM_SCALE_INV_SHIFT) *\n\t\t\t\t\t PPM_SCALE_INV, NTP_SCALE_SHIFT);\n\ttxc->maxerror\t   = time_maxerror;\n\ttxc->esterror\t   = time_esterror;\n\ttxc->status\t   = time_status;\n\ttxc->constant\t   = time_constant;\n\ttxc->precision\t   = 1;\n\ttxc->tolerance\t   = MAXFREQ_SCALED / PPM_SCALE;\n\ttxc->tick\t   = tick_usec;\n\ttxc->tai\t   = *time_tai;\n\n\t/* fill PPS status fields */\n\tpps_fill_timex(txc);\n\n\ttxc->time.tv_sec = (time_t)ts->tv_sec;\n\ttxc->time.tv_usec = ts->tv_nsec;\n\tif (!(time_status & STA_NANO))\n\t\ttxc->time.tv_usec /= NSEC_PER_USEC;\n\n\t/* Handle leapsec adjustments */\n\tif (unlikely(ts->tv_sec >= ntp_next_leap_sec)) {\n\t\tif ((time_state == TIME_INS) && (time_status & STA_INS)) {\n\t\t\tresult = TIME_OOP;\n\t\t\ttxc->tai++;\n\t\t\ttxc->time.tv_sec--;\n\t\t}\n\t\tif ((time_state == TIME_DEL) && (time_status & STA_DEL)) {\n\t\t\tresult = TIME_WAIT;\n\t\t\ttxc->tai--;\n\t\t\ttxc->time.tv_sec++;\n\t\t}\n\t\tif ((time_state == TIME_OOP) &&\n\t\t\t\t\t(ts->tv_sec == ntp_next_leap_sec)) {\n\t\t\tresult = TIME_WAIT;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long\t\t\ttick_usec = USER_TICK_USEC;",
            "static int\t\t\ttime_state = TIME_OK;",
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static s64\t\t\ttime_offset;",
            "static long\t\t\ttime_constant = 2;",
            "static long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;",
            "static long\t\t\ttime_esterror = NTP_PHASE_LIMIT;",
            "static s64\t\t\ttime_freq;",
            "static long\t\t\ttime_adjust;",
            "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nunsigned long\t\t\ttick_usec = USER_TICK_USEC;\nstatic int\t\t\ttime_state = TIME_OK;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_constant = 2;\nstatic long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_esterror = NTP_PHASE_LIMIT;\nstatic s64\t\t\ttime_freq;\nstatic long\t\t\ttime_adjust;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nint __do_adjtimex(struct timex *txc, const struct timespec64 *ts, s32 *time_tai)\n{\n\tint result;\n\n\tif (txc->modes & ADJ_ADJTIME) {\n\t\tlong save_adjust = time_adjust;\n\n\t\tif (!(txc->modes & ADJ_OFFSET_READONLY)) {\n\t\t\t/* adjtime() is independent from ntp_adjtime() */\n\t\t\ttime_adjust = txc->offset;\n\t\t\tntp_update_frequency();\n\t\t}\n\t\ttxc->offset = save_adjust;\n\t} else {\n\n\t\t/* If there are input parameters, then process them: */\n\t\tif (txc->modes)\n\t\t\tprocess_adjtimex_modes(txc, time_tai);\n\n\t\ttxc->offset = shift_right(time_offset * NTP_INTERVAL_FREQ,\n\t\t\t\t  NTP_SCALE_SHIFT);\n\t\tif (!(time_status & STA_NANO))\n\t\t\ttxc->offset /= NSEC_PER_USEC;\n\t}\n\n\tresult = time_state;\t/* mostly `TIME_OK' */\n\t/* check for errors */\n\tif (is_error_status(time_status))\n\t\tresult = TIME_ERROR;\n\n\ttxc->freq\t   = shift_right((time_freq >> PPM_SCALE_INV_SHIFT) *\n\t\t\t\t\t PPM_SCALE_INV, NTP_SCALE_SHIFT);\n\ttxc->maxerror\t   = time_maxerror;\n\ttxc->esterror\t   = time_esterror;\n\ttxc->status\t   = time_status;\n\ttxc->constant\t   = time_constant;\n\ttxc->precision\t   = 1;\n\ttxc->tolerance\t   = MAXFREQ_SCALED / PPM_SCALE;\n\ttxc->tick\t   = tick_usec;\n\ttxc->tai\t   = *time_tai;\n\n\t/* fill PPS status fields */\n\tpps_fill_timex(txc);\n\n\ttxc->time.tv_sec = (time_t)ts->tv_sec;\n\ttxc->time.tv_usec = ts->tv_nsec;\n\tif (!(time_status & STA_NANO))\n\t\ttxc->time.tv_usec /= NSEC_PER_USEC;\n\n\t/* Handle leapsec adjustments */\n\tif (unlikely(ts->tv_sec >= ntp_next_leap_sec)) {\n\t\tif ((time_state == TIME_INS) && (time_status & STA_INS)) {\n\t\t\tresult = TIME_OOP;\n\t\t\ttxc->tai++;\n\t\t\ttxc->time.tv_sec--;\n\t\t}\n\t\tif ((time_state == TIME_DEL) && (time_status & STA_DEL)) {\n\t\t\tresult = TIME_WAIT;\n\t\t\ttxc->tai--;\n\t\t\ttxc->time.tv_sec++;\n\t\t}\n\t\tif ((time_state == TIME_OOP) &&\n\t\t\t\t\t(ts->tv_sec == ntp_next_leap_sec)) {\n\t\t\tresult = TIME_WAIT;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_real_ts64",
          "args": [
            "&ts"
          ],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_real_ts64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "723-741",
          "snippet": "void ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_inject_offset",
          "args": [
            "&delta"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_inject_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1266-1302",
          "snippet": "static int timekeeping_inject_offset(const struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64 tmp;\n\tint ret = 0;\n\n\tif (ts->tv_nsec < 0 || ts->tv_nsec >= NSEC_PER_SEC)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\t/* Make sure the proposed value is valid */\n\ttmp = timespec64_add(tk_xtime(tk), *ts);\n\tif (timespec64_compare(&tk->wall_to_monotonic, ts) > 0 ||\n\t    !timespec64_valid_strict(&tmp)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk_xtime_add(tk, ts);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *ts));\n\nerror: /* even if we error out, we forwarded the time, so call update */\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* signal hrtimers about time change */\n\tclock_was_set();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static DEFINE_RAW_SPINLOCK(timekeeper_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic DEFINE_RAW_SPINLOCK(timekeeper_lock);\n\nstatic int timekeeping_inject_offset(const struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64 tmp;\n\tint ret = 0;\n\n\tif (ts->tv_nsec < 0 || ts->tv_nsec >= NSEC_PER_SEC)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\t/* Make sure the proposed value is valid */\n\ttmp = timespec64_add(tk_xtime(tk), *ts);\n\tif (timespec64_compare(&tk->wall_to_monotonic, ts) > 0 ||\n\t    !timespec64_valid_strict(&tmp)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk_xtime_add(tk, ts);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *ts));\n\nerror: /* even if we error out, we forwarded the time, so call update */\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* signal hrtimers about time change */\n\tclock_was_set();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_validate_timex",
          "args": [
            "txc"
          ],
          "line": 2323
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_validate_timex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "2248-2308",
          "snippet": "static int timekeeping_validate_timex(const struct timex *txc)\n{\n\tif (txc->modes & ADJ_ADJTIME) {\n\t\t/* singleshot must not be used with any other mode bits */\n\t\tif (!(txc->modes & ADJ_OFFSET_SINGLESHOT))\n\t\t\treturn -EINVAL;\n\t\tif (!(txc->modes & ADJ_OFFSET_READONLY) &&\n\t\t    !capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\t} else {\n\t\t/* In order to modify anything, you gotta be super-user! */\n\t\tif (txc->modes && !capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * if the quartz is off by more than 10% then\n\t\t * something is VERY wrong!\n\t\t */\n\t\tif (txc->modes & ADJ_TICK &&\n\t\t    (txc->tick <  900000/USER_HZ ||\n\t\t     txc->tick > 1100000/USER_HZ))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (txc->modes & ADJ_SETOFFSET) {\n\t\t/* In order to inject time, you gotta be super-user! */\n\t\tif (!capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Validate if a timespec/timeval used to inject a time\n\t\t * offset is valid.  Offsets can be postive or negative, so\n\t\t * we don't check tv_sec. The value of the timeval/timespec\n\t\t * is the sum of its fields,but *NOTE*:\n\t\t * The field tv_usec/tv_nsec must always be non-negative and\n\t\t * we can't have more nanoseconds/microseconds than a second.\n\t\t */\n\t\tif (txc->time.tv_usec < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (txc->modes & ADJ_NANO) {\n\t\t\tif (txc->time.tv_usec >= NSEC_PER_SEC)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (txc->time.tv_usec >= USEC_PER_SEC)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Check for potential multiplication overflows that can\n\t * only happen on 64-bit systems:\n\t */\n\tif ((txc->modes & ADJ_FREQUENCY) && (BITS_PER_LONG == 64)) {\n\t\tif (LLONG_MIN / PPM_SCALE > txc->freq)\n\t\t\treturn -EINVAL;\n\t\tif (LLONG_MAX / PPM_SCALE < txc->freq)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic int timekeeping_validate_timex(const struct timex *txc)\n{\n\tif (txc->modes & ADJ_ADJTIME) {\n\t\t/* singleshot must not be used with any other mode bits */\n\t\tif (!(txc->modes & ADJ_OFFSET_SINGLESHOT))\n\t\t\treturn -EINVAL;\n\t\tif (!(txc->modes & ADJ_OFFSET_READONLY) &&\n\t\t    !capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\t} else {\n\t\t/* In order to modify anything, you gotta be super-user! */\n\t\tif (txc->modes && !capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * if the quartz is off by more than 10% then\n\t\t * something is VERY wrong!\n\t\t */\n\t\tif (txc->modes & ADJ_TICK &&\n\t\t    (txc->tick <  900000/USER_HZ ||\n\t\t     txc->tick > 1100000/USER_HZ))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (txc->modes & ADJ_SETOFFSET) {\n\t\t/* In order to inject time, you gotta be super-user! */\n\t\tif (!capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Validate if a timespec/timeval used to inject a time\n\t\t * offset is valid.  Offsets can be postive or negative, so\n\t\t * we don't check tv_sec. The value of the timeval/timespec\n\t\t * is the sum of its fields,but *NOTE*:\n\t\t * The field tv_usec/tv_nsec must always be non-negative and\n\t\t * we can't have more nanoseconds/microseconds than a second.\n\t\t */\n\t\tif (txc->time.tv_usec < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (txc->modes & ADJ_NANO) {\n\t\t\tif (txc->time.tv_usec >= NSEC_PER_SEC)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (txc->time.tv_usec >= USEC_PER_SEC)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Check for potential multiplication overflows that can\n\t * only happen on 64-bit systems:\n\t */\n\tif ((txc->modes & ADJ_FREQUENCY) && (BITS_PER_LONG == 64)) {\n\t\tif (LLONG_MIN / PPM_SCALE > txc->freq)\n\t\t\treturn -EINVAL;\n\t\tif (LLONG_MAX / PPM_SCALE < txc->freq)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n\nstatic DEFINE_RAW_SPINLOCK(timekeeper_lock);\n\nint do_adjtimex(struct timex *txc)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64 ts;\n\ts32 orig_tai, tai;\n\tint ret;\n\n\t/* Validate the data before disabling interrupts */\n\tret = timekeeping_validate_timex(txc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (txc->modes & ADJ_SETOFFSET) {\n\t\tstruct timespec64 delta;\n\t\tdelta.tv_sec  = txc->time.tv_sec;\n\t\tdelta.tv_nsec = txc->time.tv_usec;\n\t\tif (!(txc->modes & ADJ_NANO))\n\t\t\tdelta.tv_nsec *= 1000;\n\t\tret = timekeeping_inject_offset(&delta);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tktime_get_real_ts64(&ts);\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\torig_tai = tai = tk->tai_offset;\n\tret = __do_adjtimex(txc, &ts, &tai);\n\n\tif (tai != orig_tai) {\n\t\t__timekeeping_set_tai_offset(tk, tai);\n\t\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\t}\n\ttk_update_leap_state(tk);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* Update the multiplier immediately if frequency was set directly */\n\tif (txc->modes & (ADJ_FREQUENCY | ADJ_TICK))\n\t\ttimekeeping_advance(TK_ADV_FREQ);\n\n\tif (tai != orig_tai)\n\t\tclock_was_set();\n\n\tntp_notify_cmos_timer();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "timekeeping_validate_timex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "2248-2308",
    "snippet": "static int timekeeping_validate_timex(const struct timex *txc)\n{\n\tif (txc->modes & ADJ_ADJTIME) {\n\t\t/* singleshot must not be used with any other mode bits */\n\t\tif (!(txc->modes & ADJ_OFFSET_SINGLESHOT))\n\t\t\treturn -EINVAL;\n\t\tif (!(txc->modes & ADJ_OFFSET_READONLY) &&\n\t\t    !capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\t} else {\n\t\t/* In order to modify anything, you gotta be super-user! */\n\t\tif (txc->modes && !capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * if the quartz is off by more than 10% then\n\t\t * something is VERY wrong!\n\t\t */\n\t\tif (txc->modes & ADJ_TICK &&\n\t\t    (txc->tick <  900000/USER_HZ ||\n\t\t     txc->tick > 1100000/USER_HZ))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (txc->modes & ADJ_SETOFFSET) {\n\t\t/* In order to inject time, you gotta be super-user! */\n\t\tif (!capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Validate if a timespec/timeval used to inject a time\n\t\t * offset is valid.  Offsets can be postive or negative, so\n\t\t * we don't check tv_sec. The value of the timeval/timespec\n\t\t * is the sum of its fields,but *NOTE*:\n\t\t * The field tv_usec/tv_nsec must always be non-negative and\n\t\t * we can't have more nanoseconds/microseconds than a second.\n\t\t */\n\t\tif (txc->time.tv_usec < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (txc->modes & ADJ_NANO) {\n\t\t\tif (txc->time.tv_usec >= NSEC_PER_SEC)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (txc->time.tv_usec >= USEC_PER_SEC)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Check for potential multiplication overflows that can\n\t * only happen on 64-bit systems:\n\t */\n\tif ((txc->modes & ADJ_FREQUENCY) && (BITS_PER_LONG == 64)) {\n\t\tif (LLONG_MIN / PPM_SCALE > txc->freq)\n\t\t\treturn -EINVAL;\n\t\tif (LLONG_MAX / PPM_SCALE < txc->freq)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_TIME"
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic int timekeeping_validate_timex(const struct timex *txc)\n{\n\tif (txc->modes & ADJ_ADJTIME) {\n\t\t/* singleshot must not be used with any other mode bits */\n\t\tif (!(txc->modes & ADJ_OFFSET_SINGLESHOT))\n\t\t\treturn -EINVAL;\n\t\tif (!(txc->modes & ADJ_OFFSET_READONLY) &&\n\t\t    !capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\t} else {\n\t\t/* In order to modify anything, you gotta be super-user! */\n\t\tif (txc->modes && !capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * if the quartz is off by more than 10% then\n\t\t * something is VERY wrong!\n\t\t */\n\t\tif (txc->modes & ADJ_TICK &&\n\t\t    (txc->tick <  900000/USER_HZ ||\n\t\t     txc->tick > 1100000/USER_HZ))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (txc->modes & ADJ_SETOFFSET) {\n\t\t/* In order to inject time, you gotta be super-user! */\n\t\tif (!capable(CAP_SYS_TIME))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Validate if a timespec/timeval used to inject a time\n\t\t * offset is valid.  Offsets can be postive or negative, so\n\t\t * we don't check tv_sec. The value of the timeval/timespec\n\t\t * is the sum of its fields,but *NOTE*:\n\t\t * The field tv_usec/tv_nsec must always be non-negative and\n\t\t * we can't have more nanoseconds/microseconds than a second.\n\t\t */\n\t\tif (txc->time.tv_usec < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (txc->modes & ADJ_NANO) {\n\t\t\tif (txc->time.tv_usec >= NSEC_PER_SEC)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (txc->time.tv_usec >= USEC_PER_SEC)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Check for potential multiplication overflows that can\n\t * only happen on 64-bit systems:\n\t */\n\tif ((txc->modes & ADJ_FREQUENCY) && (BITS_PER_LONG == 64)) {\n\t\tif (LLONG_MIN / PPM_SCALE > txc->freq)\n\t\t\treturn -EINVAL;\n\t\tif (LLONG_MAX / PPM_SCALE < txc->freq)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ktime_get_update_offsets_now",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "2214-2243",
    "snippet": "ktime_t ktime_get_update_offsets_now(unsigned int *cwsseq, ktime_t *offs_real,\n\t\t\t\t     ktime_t *offs_boot, ktime_t *offs_tai)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tbase = tk->tkr_mono.base;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\t\tbase = ktime_add_ns(base, nsecs);\n\n\t\tif (*cwsseq != tk->clock_was_set_seq) {\n\t\t\t*cwsseq = tk->clock_was_set_seq;\n\t\t\t*offs_real = tk->offs_real;\n\t\t\t*offs_boot = tk->offs_boot;\n\t\t\t*offs_tai = tk->offs_tai;\n\t\t}\n\n\t\t/* Handle leapsecond insertion adjustments */\n\t\tif (unlikely(base >= tk->next_leap_ktime))\n\t\t\t*offs_real = ktime_sub(tk->offs_real, ktime_set(1, 0));\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn base;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "tk->offs_real",
            "ktime_set(1, 0)"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_set",
          "args": [
            "1",
            "0"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "base >= tk->next_leap_ktime"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "base",
            "nsecs"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_get_ns",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 2226
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_get_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "367-373",
          "snippet": "static inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nktime_t ktime_get_update_offsets_now(unsigned int *cwsseq, ktime_t *offs_real,\n\t\t\t\t     ktime_t *offs_boot, ktime_t *offs_tai)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tbase = tk->tkr_mono.base;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\t\tbase = ktime_add_ns(base, nsecs);\n\n\t\tif (*cwsseq != tk->clock_was_set_seq) {\n\t\t\t*cwsseq = tk->clock_was_set_seq;\n\t\t\t*offs_real = tk->offs_real;\n\t\t\t*offs_boot = tk->offs_boot;\n\t\t\t*offs_tai = tk->offs_tai;\n\t\t}\n\n\t\t/* Handle leapsecond insertion adjustments */\n\t\tif (unlikely(base >= tk->next_leap_ktime))\n\t\t\t*offs_real = ktime_sub(tk->offs_real, ktime_set(1, 0));\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn base;\n}"
  },
  {
    "function_name": "do_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "2195-2199",
    "snippet": "void do_timer(unsigned long ticks)\n{\n\tjiffies_64 += ticks;\n\tcalc_global_load(ticks);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calc_global_load",
          "args": [
            "ticks"
          ],
          "line": 2198
        },
        "resolved": true,
        "details": {
          "function_name": "calc_global_load_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/loadavg.c",
          "lines": "373-385",
          "snippet": "void calc_global_load_tick(struct rq *this_rq)\n{\n\tlong delta;\n\n\tif (time_before(jiffies, this_rq->calc_load_update))\n\t\treturn;\n\n\tdelta  = calc_load_fold_active(this_rq, 0);\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n\n\tthis_rq->calc_load_update += LOAD_FREQ;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_long_t calc_load_tasks;",
            "unsigned long calc_load_update;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\natomic_long_t calc_load_tasks;\nunsigned long calc_load_update;\n\nvoid calc_global_load_tick(struct rq *this_rq)\n{\n\tlong delta;\n\n\tif (time_before(jiffies, this_rq->calc_load_update))\n\t\treturn;\n\n\tdelta  = calc_load_fold_active(this_rq, 0);\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n\n\tthis_rq->calc_load_update += LOAD_FREQ;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid do_timer(unsigned long ticks)\n{\n\tjiffies_64 += ticks;\n\tcalc_global_load(ticks);\n}"
  },
  {
    "function_name": "ktime_get_coarse_ts64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "2174-2189",
    "snippet": "void ktime_get_coarse_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 now, mono;\n\tunsigned long seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tnow = tk_xtime(tk);\n\t\tmono = tk->wall_to_monotonic;\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tset_normalized_timespec64(ts, now.tv_sec + mono.tv_sec,\n\t\t\t\tnow.tv_nsec + mono.tv_nsec);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_normalized_timespec64",
          "args": [
            "ts",
            "now.tv_sec + mono.tv_sec",
            "now.tv_nsec + mono.tv_nsec"
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "set_normalized_timespec64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "494-513",
          "snippet": "void set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)\n{\n\twhile (nsec >= NSEC_PER_SEC) {\n\t\t/*\n\t\t * The following asm() prevents the compiler from\n\t\t * optimising this loop into a modulo operation. See\n\t\t * also __iter_div_u64_rem() in include/linux/time.h\n\t\t */\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec -= NSEC_PER_SEC;\n\t\t++sec;\n\t}\n\twhile (nsec < 0) {\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec += NSEC_PER_SEC;\n\t\t--sec;\n\t}\n\tts->tv_sec = sec;\n\tts->tv_nsec = nsec;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)\n{\n\twhile (nsec >= NSEC_PER_SEC) {\n\t\t/*\n\t\t * The following asm() prevents the compiler from\n\t\t * optimising this loop into a modulo operation. See\n\t\t * also __iter_div_u64_rem() in include/linux/time.h\n\t\t */\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec -= NSEC_PER_SEC;\n\t\t++sec;\n\t}\n\twhile (nsec < 0) {\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec += NSEC_PER_SEC;\n\t\t--sec;\n\t}\n\tts->tv_sec = sec;\n\tts->tv_nsec = nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_xtime",
          "args": [
            "tk"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "tk_xtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "109-116",
          "snippet": "static inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_coarse_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 now, mono;\n\tunsigned long seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tnow = tk_xtime(tk);\n\t\tmono = tk->wall_to_monotonic;\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tset_normalized_timespec64(ts, now.tv_sec + mono.tv_sec,\n\t\t\t\tnow.tv_nsec + mono.tv_nsec);\n}"
  },
  {
    "function_name": "ktime_get_coarse_real_ts64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "2161-2171",
    "snippet": "void ktime_get_coarse_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\t*ts = tk_xtime(tk);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_xtime",
          "args": [
            "tk"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "tk_xtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "109-116",
          "snippet": "static inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_coarse_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\t*ts = tk_xtime(tk);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n}"
  },
  {
    "function_name": "getboottime64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "2152-2158",
    "snippet": "void getboottime64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tktime_t t = ktime_sub(tk->offs_real, tk->offs_boot);\n\n\t*ts = ktime_to_timespec64(t);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_timespec64",
          "args": [
            "t"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "tk->offs_real",
            "tk->offs_boot"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid getboottime64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tktime_t t = ktime_sub(tk->offs_real, tk->offs_boot);\n\n\t*ts = ktime_to_timespec64(t);\n}"
  },
  {
    "function_name": "update_wall_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "2136-2139",
    "snippet": "void update_wall_time(void)\n{\n\ttimekeeping_advance(TK_ADV_TICK);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timekeeping_advance",
          "args": [
            "TK_ADV_TICK"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_advance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "2049-2130",
          "snippet": "static void timekeeping_advance(enum timekeeping_adv_mode mode)\n{\n\tstruct timekeeper *real_tk = &tk_core.timekeeper;\n\tstruct timekeeper *tk = &shadow_timekeeper;\n\tu64 offset;\n\tint shift = 0, maxshift;\n\tunsigned int clock_set = 0;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\n\t/* Make sure we're fully resumed: */\n\tif (unlikely(timekeeping_suspended))\n\t\tgoto out;\n\n#ifdef CONFIG_ARCH_USES_GETTIMEOFFSET\n\toffset = real_tk->cycle_interval;\n\n\tif (mode != TK_ADV_TICK)\n\t\tgoto out;\n#else\n\toffset = clocksource_delta(tk_clock_read(&tk->tkr_mono),\n\t\t\t\t   tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\n\t/* Check if there's really nothing to do */\n\tif (offset < real_tk->cycle_interval && mode == TK_ADV_TICK)\n\t\tgoto out;\n#endif\n\n\t/* Do some additional sanity checking */\n\ttimekeeping_check_update(tk, offset);\n\n\t/*\n\t * With NO_HZ we may have to accumulate many cycle_intervals\n\t * (think \"ticks\") worth of time at once. To do this efficiently,\n\t * we calculate the largest doubling multiple of cycle_intervals\n\t * that is smaller than the offset.  We then accumulate that\n\t * chunk in one go, and then try to consume the next smaller\n\t * doubled multiple.\n\t */\n\tshift = ilog2(offset) - ilog2(tk->cycle_interval);\n\tshift = max(0, shift);\n\t/* Bound shift to one less than what overflows tick_length */\n\tmaxshift = (64 - (ilog2(ntp_tick_length())+1)) - 1;\n\tshift = min(shift, maxshift);\n\twhile (offset >= tk->cycle_interval) {\n\t\toffset = logarithmic_accumulation(tk, offset, shift,\n\t\t\t\t\t\t\t&clock_set);\n\t\tif (offset < tk->cycle_interval<<shift)\n\t\t\tshift--;\n\t}\n\n\t/* Adjust the multiplier to correct NTP error */\n\ttimekeeping_adjust(tk, offset);\n\n\t/*\n\t * Finally, make sure that after the rounding\n\t * xtime_nsec isn't larger than NSEC_PER_SEC\n\t */\n\tclock_set |= accumulate_nsecs_to_secs(tk);\n\n\twrite_seqcount_begin(&tk_core.seq);\n\t/*\n\t * Update the real timekeeper.\n\t *\n\t * We could avoid this memcpy by switching pointers, but that\n\t * requires changes to all other timekeeper usage sites as\n\t * well, i.e. move the timekeeper pointer getter into the\n\t * spinlocked/seqcount protected sections. And we trade this\n\t * memcpy under the tk_core.seq against one before we start\n\t * updating.\n\t */\n\ttimekeeping_update(tk, clock_set);\n\tmemcpy(real_tk, tk, sizeof(*tk));\n\t/* The memcpy must come last. Do not put anything here! */\n\twrite_seqcount_end(&tk_core.seq);\nout:\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\tif (clock_set)\n\t\t/* Have to call _delayed version, since in irq context*/\n\t\tclock_was_set_delayed();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RAW_SPINLOCK(timekeeper_lock);",
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic DEFINE_RAW_SPINLOCK(timekeeper_lock);\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_advance(enum timekeeping_adv_mode mode)\n{\n\tstruct timekeeper *real_tk = &tk_core.timekeeper;\n\tstruct timekeeper *tk = &shadow_timekeeper;\n\tu64 offset;\n\tint shift = 0, maxshift;\n\tunsigned int clock_set = 0;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\n\t/* Make sure we're fully resumed: */\n\tif (unlikely(timekeeping_suspended))\n\t\tgoto out;\n\n#ifdef CONFIG_ARCH_USES_GETTIMEOFFSET\n\toffset = real_tk->cycle_interval;\n\n\tif (mode != TK_ADV_TICK)\n\t\tgoto out;\n#else\n\toffset = clocksource_delta(tk_clock_read(&tk->tkr_mono),\n\t\t\t\t   tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\n\t/* Check if there's really nothing to do */\n\tif (offset < real_tk->cycle_interval && mode == TK_ADV_TICK)\n\t\tgoto out;\n#endif\n\n\t/* Do some additional sanity checking */\n\ttimekeeping_check_update(tk, offset);\n\n\t/*\n\t * With NO_HZ we may have to accumulate many cycle_intervals\n\t * (think \"ticks\") worth of time at once. To do this efficiently,\n\t * we calculate the largest doubling multiple of cycle_intervals\n\t * that is smaller than the offset.  We then accumulate that\n\t * chunk in one go, and then try to consume the next smaller\n\t * doubled multiple.\n\t */\n\tshift = ilog2(offset) - ilog2(tk->cycle_interval);\n\tshift = max(0, shift);\n\t/* Bound shift to one less than what overflows tick_length */\n\tmaxshift = (64 - (ilog2(ntp_tick_length())+1)) - 1;\n\tshift = min(shift, maxshift);\n\twhile (offset >= tk->cycle_interval) {\n\t\toffset = logarithmic_accumulation(tk, offset, shift,\n\t\t\t\t\t\t\t&clock_set);\n\t\tif (offset < tk->cycle_interval<<shift)\n\t\t\tshift--;\n\t}\n\n\t/* Adjust the multiplier to correct NTP error */\n\ttimekeeping_adjust(tk, offset);\n\n\t/*\n\t * Finally, make sure that after the rounding\n\t * xtime_nsec isn't larger than NSEC_PER_SEC\n\t */\n\tclock_set |= accumulate_nsecs_to_secs(tk);\n\n\twrite_seqcount_begin(&tk_core.seq);\n\t/*\n\t * Update the real timekeeper.\n\t *\n\t * We could avoid this memcpy by switching pointers, but that\n\t * requires changes to all other timekeeper usage sites as\n\t * well, i.e. move the timekeeper pointer getter into the\n\t * spinlocked/seqcount protected sections. And we trade this\n\t * memcpy under the tk_core.seq against one before we start\n\t * updating.\n\t */\n\ttimekeeping_update(tk, clock_set);\n\tmemcpy(real_tk, tk, sizeof(*tk));\n\t/* The memcpy must come last. Do not put anything here! */\n\twrite_seqcount_end(&tk_core.seq);\nout:\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\tif (clock_set)\n\t\t/* Have to call _delayed version, since in irq context*/\n\t\tclock_was_set_delayed();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid update_wall_time(void)\n{\n\ttimekeeping_advance(TK_ADV_TICK);\n}"
  },
  {
    "function_name": "timekeeping_advance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "2049-2130",
    "snippet": "static void timekeeping_advance(enum timekeeping_adv_mode mode)\n{\n\tstruct timekeeper *real_tk = &tk_core.timekeeper;\n\tstruct timekeeper *tk = &shadow_timekeeper;\n\tu64 offset;\n\tint shift = 0, maxshift;\n\tunsigned int clock_set = 0;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\n\t/* Make sure we're fully resumed: */\n\tif (unlikely(timekeeping_suspended))\n\t\tgoto out;\n\n#ifdef CONFIG_ARCH_USES_GETTIMEOFFSET\n\toffset = real_tk->cycle_interval;\n\n\tif (mode != TK_ADV_TICK)\n\t\tgoto out;\n#else\n\toffset = clocksource_delta(tk_clock_read(&tk->tkr_mono),\n\t\t\t\t   tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\n\t/* Check if there's really nothing to do */\n\tif (offset < real_tk->cycle_interval && mode == TK_ADV_TICK)\n\t\tgoto out;\n#endif\n\n\t/* Do some additional sanity checking */\n\ttimekeeping_check_update(tk, offset);\n\n\t/*\n\t * With NO_HZ we may have to accumulate many cycle_intervals\n\t * (think \"ticks\") worth of time at once. To do this efficiently,\n\t * we calculate the largest doubling multiple of cycle_intervals\n\t * that is smaller than the offset.  We then accumulate that\n\t * chunk in one go, and then try to consume the next smaller\n\t * doubled multiple.\n\t */\n\tshift = ilog2(offset) - ilog2(tk->cycle_interval);\n\tshift = max(0, shift);\n\t/* Bound shift to one less than what overflows tick_length */\n\tmaxshift = (64 - (ilog2(ntp_tick_length())+1)) - 1;\n\tshift = min(shift, maxshift);\n\twhile (offset >= tk->cycle_interval) {\n\t\toffset = logarithmic_accumulation(tk, offset, shift,\n\t\t\t\t\t\t\t&clock_set);\n\t\tif (offset < tk->cycle_interval<<shift)\n\t\t\tshift--;\n\t}\n\n\t/* Adjust the multiplier to correct NTP error */\n\ttimekeeping_adjust(tk, offset);\n\n\t/*\n\t * Finally, make sure that after the rounding\n\t * xtime_nsec isn't larger than NSEC_PER_SEC\n\t */\n\tclock_set |= accumulate_nsecs_to_secs(tk);\n\n\twrite_seqcount_begin(&tk_core.seq);\n\t/*\n\t * Update the real timekeeper.\n\t *\n\t * We could avoid this memcpy by switching pointers, but that\n\t * requires changes to all other timekeeper usage sites as\n\t * well, i.e. move the timekeeper pointer getter into the\n\t * spinlocked/seqcount protected sections. And we trade this\n\t * memcpy under the tk_core.seq against one before we start\n\t * updating.\n\t */\n\ttimekeeping_update(tk, clock_set);\n\tmemcpy(real_tk, tk, sizeof(*tk));\n\t/* The memcpy must come last. Do not put anything here! */\n\twrite_seqcount_end(&tk_core.seq);\nout:\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\tif (clock_set)\n\t\t/* Have to call _delayed version, since in irq context*/\n\t\tclock_was_set_delayed();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(timekeeper_lock);",
      "static struct timekeeper shadow_timekeeper;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clock_was_set_delayed",
          "args": [],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "clock_was_set_delayed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "744-747",
          "snippet": "void clock_was_set_delayed(void)\n{\n\tschedule_work(&hrtimer_work);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid clock_was_set_delayed(void)\n{\n\tschedule_work(&hrtimer_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "real_tk",
            "tk",
            "sizeof(*tk)"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_update",
          "args": [
            "tk",
            "clock_set"
          ],
          "line": 2121
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "658-685",
          "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accumulate_nsecs_to_secs",
          "args": [
            "tk"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "accumulate_nsecs_to_secs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1962-2000",
          "snippet": "static inline unsigned int accumulate_nsecs_to_secs(struct timekeeper *tk)\n{\n\tu64 nsecps = (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\tunsigned int clock_set = 0;\n\n\twhile (tk->tkr_mono.xtime_nsec >= nsecps) {\n\t\tint leap;\n\n\t\ttk->tkr_mono.xtime_nsec -= nsecps;\n\t\ttk->xtime_sec++;\n\n\t\t/*\n\t\t * Skip NTP update if this second was accumulated before,\n\t\t * i.e. xtime_nsec underflowed in timekeeping_adjust()\n\t\t */\n\t\tif (unlikely(tk->skip_second_overflow)) {\n\t\t\ttk->skip_second_overflow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Figure out if its a leap sec and apply if needed */\n\t\tleap = second_overflow(tk->xtime_sec);\n\t\tif (unlikely(leap)) {\n\t\t\tstruct timespec64 ts;\n\n\t\t\ttk->xtime_sec += leap;\n\n\t\t\tts.tv_sec = leap;\n\t\t\tts.tv_nsec = 0;\n\t\t\ttk_set_wall_to_mono(tk,\n\t\t\t\ttimespec64_sub(tk->wall_to_monotonic, ts));\n\n\t\t\t__timekeeping_set_tai_offset(tk, tk->tai_offset - leap);\n\n\t\t\tclock_set = TK_CLOCK_WAS_SET;\n\t\t}\n\t}\n\treturn clock_set;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n\nstatic inline unsigned int accumulate_nsecs_to_secs(struct timekeeper *tk)\n{\n\tu64 nsecps = (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\tunsigned int clock_set = 0;\n\n\twhile (tk->tkr_mono.xtime_nsec >= nsecps) {\n\t\tint leap;\n\n\t\ttk->tkr_mono.xtime_nsec -= nsecps;\n\t\ttk->xtime_sec++;\n\n\t\t/*\n\t\t * Skip NTP update if this second was accumulated before,\n\t\t * i.e. xtime_nsec underflowed in timekeeping_adjust()\n\t\t */\n\t\tif (unlikely(tk->skip_second_overflow)) {\n\t\t\ttk->skip_second_overflow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Figure out if its a leap sec and apply if needed */\n\t\tleap = second_overflow(tk->xtime_sec);\n\t\tif (unlikely(leap)) {\n\t\t\tstruct timespec64 ts;\n\n\t\t\ttk->xtime_sec += leap;\n\n\t\t\tts.tv_sec = leap;\n\t\t\tts.tv_nsec = 0;\n\t\t\ttk_set_wall_to_mono(tk,\n\t\t\t\ttimespec64_sub(tk->wall_to_monotonic, ts));\n\n\t\t\t__timekeeping_set_tai_offset(tk, tk->tai_offset - leap);\n\n\t\t\tclock_set = TK_CLOCK_WAS_SET;\n\t\t}\n\t}\n\treturn clock_set;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_adjust",
          "args": [
            "tk",
            "offset"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_adjust",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1900-1952",
          "snippet": "static void timekeeping_adjust(struct timekeeper *tk, s64 offset)\n{\n\tu32 mult;\n\n\t/*\n\t * Determine the multiplier from the current NTP tick length.\n\t * Avoid expensive division when the tick length doesn't change.\n\t */\n\tif (likely(tk->ntp_tick == ntp_tick_length())) {\n\t\tmult = tk->tkr_mono.mult - tk->ntp_err_mult;\n\t} else {\n\t\ttk->ntp_tick = ntp_tick_length();\n\t\tmult = div64_u64((tk->ntp_tick >> tk->ntp_error_shift) -\n\t\t\t\t tk->xtime_remainder, tk->cycle_interval);\n\t}\n\n\t/*\n\t * If the clock is behind the NTP time, increase the multiplier by 1\n\t * to catch up with it. If it's ahead and there was a remainder in the\n\t * tick division, the clock will slow down. Otherwise it will stay\n\t * ahead until the tick length changes to a non-divisible value.\n\t */\n\ttk->ntp_err_mult = tk->ntp_error > 0 ? 1 : 0;\n\tmult += tk->ntp_err_mult;\n\n\ttimekeeping_apply_adjustment(tk, offset, mult - tk->tkr_mono.mult);\n\n\tif (unlikely(tk->tkr_mono.clock->maxadj &&\n\t\t(abs(tk->tkr_mono.mult - tk->tkr_mono.clock->mult)\n\t\t\t> tk->tkr_mono.clock->maxadj))) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\"Adjusting %s more than 11%% (%ld vs %ld)\\n\",\n\t\t\ttk->tkr_mono.clock->name, (long)tk->tkr_mono.mult,\n\t\t\t(long)tk->tkr_mono.clock->mult + tk->tkr_mono.clock->maxadj);\n\t}\n\n\t/*\n\t * It may be possible that when we entered this function, xtime_nsec\n\t * was very small.  Further, if we're slightly speeding the clocksource\n\t * in the code above, its possible the required corrective factor to\n\t * xtime_nsec could cause it to underflow.\n\t *\n\t * Now, since we have already accumulated the second and the NTP\n\t * subsystem has been notified via second_overflow(), we need to skip\n\t * the next update.\n\t */\n\tif (unlikely((s64)tk->tkr_mono.xtime_nsec < 0)) {\n\t\ttk->tkr_mono.xtime_nsec += (u64)NSEC_PER_SEC <<\n\t\t\t\t\t\t\ttk->tkr_mono.shift;\n\t\ttk->xtime_sec--;\n\t\ttk->skip_second_overflow = 1;\n\t}\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void timekeeping_adjust(struct timekeeper *tk, s64 offset)\n{\n\tu32 mult;\n\n\t/*\n\t * Determine the multiplier from the current NTP tick length.\n\t * Avoid expensive division when the tick length doesn't change.\n\t */\n\tif (likely(tk->ntp_tick == ntp_tick_length())) {\n\t\tmult = tk->tkr_mono.mult - tk->ntp_err_mult;\n\t} else {\n\t\ttk->ntp_tick = ntp_tick_length();\n\t\tmult = div64_u64((tk->ntp_tick >> tk->ntp_error_shift) -\n\t\t\t\t tk->xtime_remainder, tk->cycle_interval);\n\t}\n\n\t/*\n\t * If the clock is behind the NTP time, increase the multiplier by 1\n\t * to catch up with it. If it's ahead and there was a remainder in the\n\t * tick division, the clock will slow down. Otherwise it will stay\n\t * ahead until the tick length changes to a non-divisible value.\n\t */\n\ttk->ntp_err_mult = tk->ntp_error > 0 ? 1 : 0;\n\tmult += tk->ntp_err_mult;\n\n\ttimekeeping_apply_adjustment(tk, offset, mult - tk->tkr_mono.mult);\n\n\tif (unlikely(tk->tkr_mono.clock->maxadj &&\n\t\t(abs(tk->tkr_mono.mult - tk->tkr_mono.clock->mult)\n\t\t\t> tk->tkr_mono.clock->maxadj))) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\"Adjusting %s more than 11%% (%ld vs %ld)\\n\",\n\t\t\ttk->tkr_mono.clock->name, (long)tk->tkr_mono.mult,\n\t\t\t(long)tk->tkr_mono.clock->mult + tk->tkr_mono.clock->maxadj);\n\t}\n\n\t/*\n\t * It may be possible that when we entered this function, xtime_nsec\n\t * was very small.  Further, if we're slightly speeding the clocksource\n\t * in the code above, its possible the required corrective factor to\n\t * xtime_nsec could cause it to underflow.\n\t *\n\t * Now, since we have already accumulated the second and the NTP\n\t * subsystem has been notified via second_overflow(), we need to skip\n\t * the next update.\n\t */\n\tif (unlikely((s64)tk->tkr_mono.xtime_nsec < 0)) {\n\t\ttk->tkr_mono.xtime_nsec += (u64)NSEC_PER_SEC <<\n\t\t\t\t\t\t\ttk->tkr_mono.shift;\n\t\ttk->xtime_sec--;\n\t\ttk->skip_second_overflow = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logarithmic_accumulation",
          "args": [
            "tk",
            "offset",
            "shift",
            "&clock_set"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "logarithmic_accumulation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "2011-2043",
          "snippet": "static u64 logarithmic_accumulation(struct timekeeper *tk, u64 offset,\n\t\t\t\t    u32 shift, unsigned int *clock_set)\n{\n\tu64 interval = tk->cycle_interval << shift;\n\tu64 snsec_per_sec;\n\n\t/* If the offset is smaller than a shifted interval, do nothing */\n\tif (offset < interval)\n\t\treturn offset;\n\n\t/* Accumulate one shifted interval */\n\toffset -= interval;\n\ttk->tkr_mono.cycle_last += interval;\n\ttk->tkr_raw.cycle_last  += interval;\n\n\ttk->tkr_mono.xtime_nsec += tk->xtime_interval << shift;\n\t*clock_set |= accumulate_nsecs_to_secs(tk);\n\n\t/* Accumulate raw time */\n\ttk->tkr_raw.xtime_nsec += tk->raw_interval << shift;\n\tsnsec_per_sec = (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\twhile (tk->tkr_raw.xtime_nsec >= snsec_per_sec) {\n\t\ttk->tkr_raw.xtime_nsec -= snsec_per_sec;\n\t\ttk->raw_sec++;\n\t}\n\n\t/* Accumulate error between NTP and clock interval */\n\ttk->ntp_error += tk->ntp_tick << shift;\n\ttk->ntp_error -= (tk->xtime_interval + tk->xtime_remainder) <<\n\t\t\t\t\t\t(tk->ntp_error_shift + shift);\n\n\treturn offset;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic u64 logarithmic_accumulation(struct timekeeper *tk, u64 offset,\n\t\t\t\t    u32 shift, unsigned int *clock_set)\n{\n\tu64 interval = tk->cycle_interval << shift;\n\tu64 snsec_per_sec;\n\n\t/* If the offset is smaller than a shifted interval, do nothing */\n\tif (offset < interval)\n\t\treturn offset;\n\n\t/* Accumulate one shifted interval */\n\toffset -= interval;\n\ttk->tkr_mono.cycle_last += interval;\n\ttk->tkr_raw.cycle_last  += interval;\n\n\ttk->tkr_mono.xtime_nsec += tk->xtime_interval << shift;\n\t*clock_set |= accumulate_nsecs_to_secs(tk);\n\n\t/* Accumulate raw time */\n\ttk->tkr_raw.xtime_nsec += tk->raw_interval << shift;\n\tsnsec_per_sec = (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\twhile (tk->tkr_raw.xtime_nsec >= snsec_per_sec) {\n\t\ttk->tkr_raw.xtime_nsec -= snsec_per_sec;\n\t\ttk->raw_sec++;\n\t}\n\n\t/* Accumulate error between NTP and clock interval */\n\ttk->ntp_error += tk->ntp_tick << shift;\n\ttk->ntp_error -= (tk->xtime_interval + tk->xtime_remainder) <<\n\t\t\t\t\t\t(tk->ntp_error_shift + shift);\n\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "shift",
            "maxshift"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_stop_suspend_timing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "574-606",
          "snippet": "u64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;",
            "static u64 suspend_start;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic u64 suspend_start;\n\nu64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "ntp_tick_length()"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntp_tick_length",
          "args": [],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_tick_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "368-371",
          "snippet": "u64 ntp_tick_length(void)\n{\n\treturn tick_length;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64\t\t\ttick_length;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic u64\t\t\ttick_length;\n\nu64 ntp_tick_length(void)\n{\n\treturn tick_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "0",
            "shift"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4232-4251",
          "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "tk->cycle_interval"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "offset"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_check_update",
          "args": [
            "tk",
            "offset"
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_check_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "256-258",
          "snippet": "static inline void timekeeping_check_update(struct timekeeper *tk, u64 offset)\n{\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void timekeeping_check_update(struct timekeeper *tk, u64 offset)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "tk_clock_read(&tk->tkr_mono)",
            "tk->tkr_mono.cycle_last",
            "tk->tkr_mono.mask"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping_internal.h",
          "lines": "28-31",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "166-171",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic DEFINE_RAW_SPINLOCK(timekeeper_lock);\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_advance(enum timekeeping_adv_mode mode)\n{\n\tstruct timekeeper *real_tk = &tk_core.timekeeper;\n\tstruct timekeeper *tk = &shadow_timekeeper;\n\tu64 offset;\n\tint shift = 0, maxshift;\n\tunsigned int clock_set = 0;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\n\t/* Make sure we're fully resumed: */\n\tif (unlikely(timekeeping_suspended))\n\t\tgoto out;\n\n#ifdef CONFIG_ARCH_USES_GETTIMEOFFSET\n\toffset = real_tk->cycle_interval;\n\n\tif (mode != TK_ADV_TICK)\n\t\tgoto out;\n#else\n\toffset = clocksource_delta(tk_clock_read(&tk->tkr_mono),\n\t\t\t\t   tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\n\t/* Check if there's really nothing to do */\n\tif (offset < real_tk->cycle_interval && mode == TK_ADV_TICK)\n\t\tgoto out;\n#endif\n\n\t/* Do some additional sanity checking */\n\ttimekeeping_check_update(tk, offset);\n\n\t/*\n\t * With NO_HZ we may have to accumulate many cycle_intervals\n\t * (think \"ticks\") worth of time at once. To do this efficiently,\n\t * we calculate the largest doubling multiple of cycle_intervals\n\t * that is smaller than the offset.  We then accumulate that\n\t * chunk in one go, and then try to consume the next smaller\n\t * doubled multiple.\n\t */\n\tshift = ilog2(offset) - ilog2(tk->cycle_interval);\n\tshift = max(0, shift);\n\t/* Bound shift to one less than what overflows tick_length */\n\tmaxshift = (64 - (ilog2(ntp_tick_length())+1)) - 1;\n\tshift = min(shift, maxshift);\n\twhile (offset >= tk->cycle_interval) {\n\t\toffset = logarithmic_accumulation(tk, offset, shift,\n\t\t\t\t\t\t\t&clock_set);\n\t\tif (offset < tk->cycle_interval<<shift)\n\t\t\tshift--;\n\t}\n\n\t/* Adjust the multiplier to correct NTP error */\n\ttimekeeping_adjust(tk, offset);\n\n\t/*\n\t * Finally, make sure that after the rounding\n\t * xtime_nsec isn't larger than NSEC_PER_SEC\n\t */\n\tclock_set |= accumulate_nsecs_to_secs(tk);\n\n\twrite_seqcount_begin(&tk_core.seq);\n\t/*\n\t * Update the real timekeeper.\n\t *\n\t * We could avoid this memcpy by switching pointers, but that\n\t * requires changes to all other timekeeper usage sites as\n\t * well, i.e. move the timekeeper pointer getter into the\n\t * spinlocked/seqcount protected sections. And we trade this\n\t * memcpy under the tk_core.seq against one before we start\n\t * updating.\n\t */\n\ttimekeeping_update(tk, clock_set);\n\tmemcpy(real_tk, tk, sizeof(*tk));\n\t/* The memcpy must come last. Do not put anything here! */\n\twrite_seqcount_end(&tk_core.seq);\nout:\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\tif (clock_set)\n\t\t/* Have to call _delayed version, since in irq context*/\n\t\tclock_was_set_delayed();\n}"
  },
  {
    "function_name": "logarithmic_accumulation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "2011-2043",
    "snippet": "static u64 logarithmic_accumulation(struct timekeeper *tk, u64 offset,\n\t\t\t\t    u32 shift, unsigned int *clock_set)\n{\n\tu64 interval = tk->cycle_interval << shift;\n\tu64 snsec_per_sec;\n\n\t/* If the offset is smaller than a shifted interval, do nothing */\n\tif (offset < interval)\n\t\treturn offset;\n\n\t/* Accumulate one shifted interval */\n\toffset -= interval;\n\ttk->tkr_mono.cycle_last += interval;\n\ttk->tkr_raw.cycle_last  += interval;\n\n\ttk->tkr_mono.xtime_nsec += tk->xtime_interval << shift;\n\t*clock_set |= accumulate_nsecs_to_secs(tk);\n\n\t/* Accumulate raw time */\n\ttk->tkr_raw.xtime_nsec += tk->raw_interval << shift;\n\tsnsec_per_sec = (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\twhile (tk->tkr_raw.xtime_nsec >= snsec_per_sec) {\n\t\ttk->tkr_raw.xtime_nsec -= snsec_per_sec;\n\t\ttk->raw_sec++;\n\t}\n\n\t/* Accumulate error between NTP and clock interval */\n\ttk->ntp_error += tk->ntp_tick << shift;\n\ttk->ntp_error -= (tk->xtime_interval + tk->xtime_remainder) <<\n\t\t\t\t\t\t(tk->ntp_error_shift + shift);\n\n\treturn offset;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "accumulate_nsecs_to_secs",
          "args": [
            "tk"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "accumulate_nsecs_to_secs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1962-2000",
          "snippet": "static inline unsigned int accumulate_nsecs_to_secs(struct timekeeper *tk)\n{\n\tu64 nsecps = (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\tunsigned int clock_set = 0;\n\n\twhile (tk->tkr_mono.xtime_nsec >= nsecps) {\n\t\tint leap;\n\n\t\ttk->tkr_mono.xtime_nsec -= nsecps;\n\t\ttk->xtime_sec++;\n\n\t\t/*\n\t\t * Skip NTP update if this second was accumulated before,\n\t\t * i.e. xtime_nsec underflowed in timekeeping_adjust()\n\t\t */\n\t\tif (unlikely(tk->skip_second_overflow)) {\n\t\t\ttk->skip_second_overflow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Figure out if its a leap sec and apply if needed */\n\t\tleap = second_overflow(tk->xtime_sec);\n\t\tif (unlikely(leap)) {\n\t\t\tstruct timespec64 ts;\n\n\t\t\ttk->xtime_sec += leap;\n\n\t\t\tts.tv_sec = leap;\n\t\t\tts.tv_nsec = 0;\n\t\t\ttk_set_wall_to_mono(tk,\n\t\t\t\ttimespec64_sub(tk->wall_to_monotonic, ts));\n\n\t\t\t__timekeeping_set_tai_offset(tk, tk->tai_offset - leap);\n\n\t\t\tclock_set = TK_CLOCK_WAS_SET;\n\t\t}\n\t}\n\treturn clock_set;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n\nstatic inline unsigned int accumulate_nsecs_to_secs(struct timekeeper *tk)\n{\n\tu64 nsecps = (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\tunsigned int clock_set = 0;\n\n\twhile (tk->tkr_mono.xtime_nsec >= nsecps) {\n\t\tint leap;\n\n\t\ttk->tkr_mono.xtime_nsec -= nsecps;\n\t\ttk->xtime_sec++;\n\n\t\t/*\n\t\t * Skip NTP update if this second was accumulated before,\n\t\t * i.e. xtime_nsec underflowed in timekeeping_adjust()\n\t\t */\n\t\tif (unlikely(tk->skip_second_overflow)) {\n\t\t\ttk->skip_second_overflow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Figure out if its a leap sec and apply if needed */\n\t\tleap = second_overflow(tk->xtime_sec);\n\t\tif (unlikely(leap)) {\n\t\t\tstruct timespec64 ts;\n\n\t\t\ttk->xtime_sec += leap;\n\n\t\t\tts.tv_sec = leap;\n\t\t\tts.tv_nsec = 0;\n\t\t\ttk_set_wall_to_mono(tk,\n\t\t\t\ttimespec64_sub(tk->wall_to_monotonic, ts));\n\n\t\t\t__timekeeping_set_tai_offset(tk, tk->tai_offset - leap);\n\n\t\t\tclock_set = TK_CLOCK_WAS_SET;\n\t\t}\n\t}\n\treturn clock_set;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic u64 logarithmic_accumulation(struct timekeeper *tk, u64 offset,\n\t\t\t\t    u32 shift, unsigned int *clock_set)\n{\n\tu64 interval = tk->cycle_interval << shift;\n\tu64 snsec_per_sec;\n\n\t/* If the offset is smaller than a shifted interval, do nothing */\n\tif (offset < interval)\n\t\treturn offset;\n\n\t/* Accumulate one shifted interval */\n\toffset -= interval;\n\ttk->tkr_mono.cycle_last += interval;\n\ttk->tkr_raw.cycle_last  += interval;\n\n\ttk->tkr_mono.xtime_nsec += tk->xtime_interval << shift;\n\t*clock_set |= accumulate_nsecs_to_secs(tk);\n\n\t/* Accumulate raw time */\n\ttk->tkr_raw.xtime_nsec += tk->raw_interval << shift;\n\tsnsec_per_sec = (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\twhile (tk->tkr_raw.xtime_nsec >= snsec_per_sec) {\n\t\ttk->tkr_raw.xtime_nsec -= snsec_per_sec;\n\t\ttk->raw_sec++;\n\t}\n\n\t/* Accumulate error between NTP and clock interval */\n\ttk->ntp_error += tk->ntp_tick << shift;\n\ttk->ntp_error -= (tk->xtime_interval + tk->xtime_remainder) <<\n\t\t\t\t\t\t(tk->ntp_error_shift + shift);\n\n\treturn offset;\n}"
  },
  {
    "function_name": "accumulate_nsecs_to_secs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1962-2000",
    "snippet": "static inline unsigned int accumulate_nsecs_to_secs(struct timekeeper *tk)\n{\n\tu64 nsecps = (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\tunsigned int clock_set = 0;\n\n\twhile (tk->tkr_mono.xtime_nsec >= nsecps) {\n\t\tint leap;\n\n\t\ttk->tkr_mono.xtime_nsec -= nsecps;\n\t\ttk->xtime_sec++;\n\n\t\t/*\n\t\t * Skip NTP update if this second was accumulated before,\n\t\t * i.e. xtime_nsec underflowed in timekeeping_adjust()\n\t\t */\n\t\tif (unlikely(tk->skip_second_overflow)) {\n\t\t\ttk->skip_second_overflow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Figure out if its a leap sec and apply if needed */\n\t\tleap = second_overflow(tk->xtime_sec);\n\t\tif (unlikely(leap)) {\n\t\t\tstruct timespec64 ts;\n\n\t\t\ttk->xtime_sec += leap;\n\n\t\t\tts.tv_sec = leap;\n\t\t\tts.tv_nsec = 0;\n\t\t\ttk_set_wall_to_mono(tk,\n\t\t\t\ttimespec64_sub(tk->wall_to_monotonic, ts));\n\n\t\t\t__timekeeping_set_tai_offset(tk, tk->tai_offset - leap);\n\n\t\t\tclock_set = TK_CLOCK_WAS_SET;\n\t\t}\n\t}\n\treturn clock_set;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_CLOCK_WAS_SET\t(1 << 2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__timekeeping_set_tai_offset",
          "args": [
            "tk",
            "tk->tai_offset - leap"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "__timekeeping_set_tai_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1342-1346",
          "snippet": "static void __timekeeping_set_tai_offset(struct timekeeper *tk, s32 tai_offset)\n{\n\ttk->tai_offset = tai_offset;\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tai_offset, 0));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void __timekeeping_set_tai_offset(struct timekeeper *tk, s32 tai_offset)\n{\n\ttk->tai_offset = tai_offset;\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tai_offset, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_set_wall_to_mono",
          "args": [
            "tk",
            "timespec64_sub(tk->wall_to_monotonic, ts)"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "tk_set_wall_to_mono",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "131-146",
          "snippet": "static void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "tk->wall_to_monotonic",
            "ts"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "leap"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "second_overflow",
          "args": [
            "tk->xtime_sec"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "second_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "399-494",
          "snippet": "int second_overflow(time64_t secs)\n{\n\ts64 delta;\n\tint leap = 0;\n\ts32 rem;\n\n\t/*\n\t * Leap second processing. If in leap-insert state at the end of the\n\t * day, the system clock is set back one second; if in leap-delete\n\t * state, the system clock is set ahead one second.\n\t */\n\tswitch (time_state) {\n\tcase TIME_OK:\n\t\tif (time_status & STA_INS) {\n\t\t\ttime_state = TIME_INS;\n\t\t\tdiv_s64_rem(secs, SECS_PER_DAY, &rem);\n\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;\n\t\t} else if (time_status & STA_DEL) {\n\t\t\ttime_state = TIME_DEL;\n\t\t\tdiv_s64_rem(secs + 1, SECS_PER_DAY, &rem);\n\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;\n\t\t}\n\t\tbreak;\n\tcase TIME_INS:\n\t\tif (!(time_status & STA_INS)) {\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_OK;\n\t\t} else if (secs == ntp_next_leap_sec) {\n\t\t\tleap = -1;\n\t\t\ttime_state = TIME_OOP;\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"Clock: inserting leap second 23:59:60 UTC\\n\");\n\t\t}\n\t\tbreak;\n\tcase TIME_DEL:\n\t\tif (!(time_status & STA_DEL)) {\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_OK;\n\t\t} else if (secs == ntp_next_leap_sec) {\n\t\t\tleap = 1;\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_WAIT;\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"Clock: deleting leap second 23:59:59 UTC\\n\");\n\t\t}\n\t\tbreak;\n\tcase TIME_OOP:\n\t\tntp_next_leap_sec = TIME64_MAX;\n\t\ttime_state = TIME_WAIT;\n\t\tbreak;\n\tcase TIME_WAIT:\n\t\tif (!(time_status & (STA_INS | STA_DEL)))\n\t\t\ttime_state = TIME_OK;\n\t\tbreak;\n\t}\n\n\n\t/* Bump the maxerror field */\n\ttime_maxerror += MAXFREQ / NSEC_PER_USEC;\n\tif (time_maxerror > NTP_PHASE_LIMIT) {\n\t\ttime_maxerror = NTP_PHASE_LIMIT;\n\t\ttime_status |= STA_UNSYNC;\n\t}\n\n\t/* Compute the phase adjustment for the next second */\n\ttick_length\t = tick_length_base;\n\n\tdelta\t\t = ntp_offset_chunk(time_offset);\n\ttime_offset\t-= delta;\n\ttick_length\t+= delta;\n\n\t/* Check PPS signal */\n\tpps_dec_valid();\n\n\tif (!time_adjust)\n\t\tgoto out;\n\n\tif (time_adjust > MAX_TICKADJ) {\n\t\ttime_adjust -= MAX_TICKADJ;\n\t\ttick_length += MAX_TICKADJ_SCALED;\n\t\tgoto out;\n\t}\n\n\tif (time_adjust < -MAX_TICKADJ) {\n\t\ttime_adjust += MAX_TICKADJ;\n\t\ttick_length -= MAX_TICKADJ_SCALED;\n\t\tgoto out;\n\t}\n\n\ttick_length += (s64)(time_adjust * NSEC_PER_USEC / NTP_INTERVAL_FREQ)\n\t\t\t\t\t\t\t << NTP_SCALE_SHIFT;\n\ttime_adjust = 0;\n\nout:\n\treturn leap;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define MAX_TICKADJ_SCALED \\\n\t(((MAX_TICKADJ * NSEC_PER_USEC) << NTP_SCALE_SHIFT) / NTP_INTERVAL_FREQ)",
            "#define MAX_TICKADJ\t\t500LL\t\t/* usecs */",
            "#define SECS_PER_DAY\t\t86400"
          ],
          "globals_used": [
            "static u64\t\t\ttick_length;",
            "static u64\t\t\ttick_length_base;",
            "static int\t\t\ttime_state = TIME_OK;",
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static s64\t\t\ttime_offset;",
            "static long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;",
            "static long\t\t\ttime_adjust;",
            "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define MAX_TICKADJ_SCALED \\\n\t(((MAX_TICKADJ * NSEC_PER_USEC) << NTP_SCALE_SHIFT) / NTP_INTERVAL_FREQ)\n#define MAX_TICKADJ\t\t500LL\t\t/* usecs */\n#define SECS_PER_DAY\t\t86400\n\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic int\t\t\ttime_state = TIME_OK;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_adjust;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nint second_overflow(time64_t secs)\n{\n\ts64 delta;\n\tint leap = 0;\n\ts32 rem;\n\n\t/*\n\t * Leap second processing. If in leap-insert state at the end of the\n\t * day, the system clock is set back one second; if in leap-delete\n\t * state, the system clock is set ahead one second.\n\t */\n\tswitch (time_state) {\n\tcase TIME_OK:\n\t\tif (time_status & STA_INS) {\n\t\t\ttime_state = TIME_INS;\n\t\t\tdiv_s64_rem(secs, SECS_PER_DAY, &rem);\n\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;\n\t\t} else if (time_status & STA_DEL) {\n\t\t\ttime_state = TIME_DEL;\n\t\t\tdiv_s64_rem(secs + 1, SECS_PER_DAY, &rem);\n\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;\n\t\t}\n\t\tbreak;\n\tcase TIME_INS:\n\t\tif (!(time_status & STA_INS)) {\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_OK;\n\t\t} else if (secs == ntp_next_leap_sec) {\n\t\t\tleap = -1;\n\t\t\ttime_state = TIME_OOP;\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"Clock: inserting leap second 23:59:60 UTC\\n\");\n\t\t}\n\t\tbreak;\n\tcase TIME_DEL:\n\t\tif (!(time_status & STA_DEL)) {\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_OK;\n\t\t} else if (secs == ntp_next_leap_sec) {\n\t\t\tleap = 1;\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_WAIT;\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"Clock: deleting leap second 23:59:59 UTC\\n\");\n\t\t}\n\t\tbreak;\n\tcase TIME_OOP:\n\t\tntp_next_leap_sec = TIME64_MAX;\n\t\ttime_state = TIME_WAIT;\n\t\tbreak;\n\tcase TIME_WAIT:\n\t\tif (!(time_status & (STA_INS | STA_DEL)))\n\t\t\ttime_state = TIME_OK;\n\t\tbreak;\n\t}\n\n\n\t/* Bump the maxerror field */\n\ttime_maxerror += MAXFREQ / NSEC_PER_USEC;\n\tif (time_maxerror > NTP_PHASE_LIMIT) {\n\t\ttime_maxerror = NTP_PHASE_LIMIT;\n\t\ttime_status |= STA_UNSYNC;\n\t}\n\n\t/* Compute the phase adjustment for the next second */\n\ttick_length\t = tick_length_base;\n\n\tdelta\t\t = ntp_offset_chunk(time_offset);\n\ttime_offset\t-= delta;\n\ttick_length\t+= delta;\n\n\t/* Check PPS signal */\n\tpps_dec_valid();\n\n\tif (!time_adjust)\n\t\tgoto out;\n\n\tif (time_adjust > MAX_TICKADJ) {\n\t\ttime_adjust -= MAX_TICKADJ;\n\t\ttick_length += MAX_TICKADJ_SCALED;\n\t\tgoto out;\n\t}\n\n\tif (time_adjust < -MAX_TICKADJ) {\n\t\ttime_adjust += MAX_TICKADJ;\n\t\ttick_length -= MAX_TICKADJ_SCALED;\n\t\tgoto out;\n\t}\n\n\ttick_length += (s64)(time_adjust * NSEC_PER_USEC / NTP_INTERVAL_FREQ)\n\t\t\t\t\t\t\t << NTP_SCALE_SHIFT;\n\ttime_adjust = 0;\n\nout:\n\treturn leap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tk->skip_second_overflow"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n\nstatic inline unsigned int accumulate_nsecs_to_secs(struct timekeeper *tk)\n{\n\tu64 nsecps = (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\tunsigned int clock_set = 0;\n\n\twhile (tk->tkr_mono.xtime_nsec >= nsecps) {\n\t\tint leap;\n\n\t\ttk->tkr_mono.xtime_nsec -= nsecps;\n\t\ttk->xtime_sec++;\n\n\t\t/*\n\t\t * Skip NTP update if this second was accumulated before,\n\t\t * i.e. xtime_nsec underflowed in timekeeping_adjust()\n\t\t */\n\t\tif (unlikely(tk->skip_second_overflow)) {\n\t\t\ttk->skip_second_overflow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Figure out if its a leap sec and apply if needed */\n\t\tleap = second_overflow(tk->xtime_sec);\n\t\tif (unlikely(leap)) {\n\t\t\tstruct timespec64 ts;\n\n\t\t\ttk->xtime_sec += leap;\n\n\t\t\tts.tv_sec = leap;\n\t\t\tts.tv_nsec = 0;\n\t\t\ttk_set_wall_to_mono(tk,\n\t\t\t\ttimespec64_sub(tk->wall_to_monotonic, ts));\n\n\t\t\t__timekeeping_set_tai_offset(tk, tk->tai_offset - leap);\n\n\t\t\tclock_set = TK_CLOCK_WAS_SET;\n\t\t}\n\t}\n\treturn clock_set;\n}"
  },
  {
    "function_name": "timekeeping_adjust",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1900-1952",
    "snippet": "static void timekeeping_adjust(struct timekeeper *tk, s64 offset)\n{\n\tu32 mult;\n\n\t/*\n\t * Determine the multiplier from the current NTP tick length.\n\t * Avoid expensive division when the tick length doesn't change.\n\t */\n\tif (likely(tk->ntp_tick == ntp_tick_length())) {\n\t\tmult = tk->tkr_mono.mult - tk->ntp_err_mult;\n\t} else {\n\t\ttk->ntp_tick = ntp_tick_length();\n\t\tmult = div64_u64((tk->ntp_tick >> tk->ntp_error_shift) -\n\t\t\t\t tk->xtime_remainder, tk->cycle_interval);\n\t}\n\n\t/*\n\t * If the clock is behind the NTP time, increase the multiplier by 1\n\t * to catch up with it. If it's ahead and there was a remainder in the\n\t * tick division, the clock will slow down. Otherwise it will stay\n\t * ahead until the tick length changes to a non-divisible value.\n\t */\n\ttk->ntp_err_mult = tk->ntp_error > 0 ? 1 : 0;\n\tmult += tk->ntp_err_mult;\n\n\ttimekeeping_apply_adjustment(tk, offset, mult - tk->tkr_mono.mult);\n\n\tif (unlikely(tk->tkr_mono.clock->maxadj &&\n\t\t(abs(tk->tkr_mono.mult - tk->tkr_mono.clock->mult)\n\t\t\t> tk->tkr_mono.clock->maxadj))) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\"Adjusting %s more than 11%% (%ld vs %ld)\\n\",\n\t\t\ttk->tkr_mono.clock->name, (long)tk->tkr_mono.mult,\n\t\t\t(long)tk->tkr_mono.clock->mult + tk->tkr_mono.clock->maxadj);\n\t}\n\n\t/*\n\t * It may be possible that when we entered this function, xtime_nsec\n\t * was very small.  Further, if we're slightly speeding the clocksource\n\t * in the code above, its possible the required corrective factor to\n\t * xtime_nsec could cause it to underflow.\n\t *\n\t * Now, since we have already accumulated the second and the NTP\n\t * subsystem has been notified via second_overflow(), we need to skip\n\t * the next update.\n\t */\n\tif (unlikely((s64)tk->tkr_mono.xtime_nsec < 0)) {\n\t\ttk->tkr_mono.xtime_nsec += (u64)NSEC_PER_SEC <<\n\t\t\t\t\t\t\ttk->tkr_mono.shift;\n\t\ttk->xtime_sec--;\n\t\ttk->skip_second_overflow = 1;\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(s64)tk->tkr_mono.xtime_nsec < 0"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "KERN_WARNING\n\t\t\t\"Adjusting %s more than 11%% (%ld vs %ld)\\n\"",
            "tk->tkr_mono.clock->name",
            "(long)tk->tkr_mono.mult",
            "(long)tk->tkr_mono.clock->mult + tk->tkr_mono.clock->maxadj"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tk->tkr_mono.clock->maxadj &&\n\t\t(abs(tk->tkr_mono.mult - tk->tkr_mono.clock->mult)\n\t\t\t> tk->tkr_mono.clock->maxadj)"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "tk->tkr_mono.mult - tk->tkr_mono.clock->mult"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "462-469",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_apply_adjustment",
          "args": [
            "tk",
            "offset",
            "mult - tk->tkr_mono.mult"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_apply_adjustment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1822-1894",
          "snippet": "static __always_inline void timekeeping_apply_adjustment(struct timekeeper *tk,\n\t\t\t\t\t\t\t s64 offset,\n\t\t\t\t\t\t\t s32 mult_adj)\n{\n\ts64 interval = tk->cycle_interval;\n\n\tif (mult_adj == 0) {\n\t\treturn;\n\t} else if (mult_adj == -1) {\n\t\tinterval = -interval;\n\t\toffset = -offset;\n\t} else if (mult_adj != 1) {\n\t\tinterval *= mult_adj;\n\t\toffset *= mult_adj;\n\t}\n\n\t/*\n\t * So the following can be confusing.\n\t *\n\t * To keep things simple, lets assume mult_adj == 1 for now.\n\t *\n\t * When mult_adj != 1, remember that the interval and offset values\n\t * have been appropriately scaled so the math is the same.\n\t *\n\t * The basic idea here is that we're increasing the multiplier\n\t * by one, this causes the xtime_interval to be incremented by\n\t * one cycle_interval. This is because:\n\t *\txtime_interval = cycle_interval * mult\n\t * So if mult is being incremented by one:\n\t *\txtime_interval = cycle_interval * (mult + 1)\n\t * Its the same as:\n\t *\txtime_interval = (cycle_interval * mult) + cycle_interval\n\t * Which can be shortened to:\n\t *\txtime_interval += cycle_interval\n\t *\n\t * So offset stores the non-accumulated cycles. Thus the current\n\t * time (in shifted nanoseconds) is:\n\t *\tnow = (offset * adj) + xtime_nsec\n\t * Now, even though we're adjusting the clock frequency, we have\n\t * to keep time consistent. In other words, we can't jump back\n\t * in time, and we also want to avoid jumping forward in time.\n\t *\n\t * So given the same offset value, we need the time to be the same\n\t * both before and after the freq adjustment.\n\t *\tnow = (offset * adj_1) + xtime_nsec_1\n\t *\tnow = (offset * adj_2) + xtime_nsec_2\n\t * So:\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * adj_2) + xtime_nsec_2\n\t * And we know:\n\t *\tadj_2 = adj_1 + 1\n\t * So:\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * (adj_1+1)) + xtime_nsec_2\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * adj_1) + offset + xtime_nsec_2\n\t * Canceling the sides:\n\t *\txtime_nsec_1 = offset + xtime_nsec_2\n\t * Which gives us:\n\t *\txtime_nsec_2 = xtime_nsec_1 - offset\n\t * Which simplfies to:\n\t *\txtime_nsec -= offset\n\t */\n\tif ((mult_adj > 0) && (tk->tkr_mono.mult + mult_adj < mult_adj)) {\n\t\t/* NTP adjustment caused clocksource mult overflow */\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\ttk->tkr_mono.mult += mult_adj;\n\ttk->xtime_interval += interval;\n\ttk->tkr_mono.xtime_nsec -= offset;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic __always_inline void timekeeping_apply_adjustment(struct timekeeper *tk,\n\t\t\t\t\t\t\t s64 offset,\n\t\t\t\t\t\t\t s32 mult_adj)\n{\n\ts64 interval = tk->cycle_interval;\n\n\tif (mult_adj == 0) {\n\t\treturn;\n\t} else if (mult_adj == -1) {\n\t\tinterval = -interval;\n\t\toffset = -offset;\n\t} else if (mult_adj != 1) {\n\t\tinterval *= mult_adj;\n\t\toffset *= mult_adj;\n\t}\n\n\t/*\n\t * So the following can be confusing.\n\t *\n\t * To keep things simple, lets assume mult_adj == 1 for now.\n\t *\n\t * When mult_adj != 1, remember that the interval and offset values\n\t * have been appropriately scaled so the math is the same.\n\t *\n\t * The basic idea here is that we're increasing the multiplier\n\t * by one, this causes the xtime_interval to be incremented by\n\t * one cycle_interval. This is because:\n\t *\txtime_interval = cycle_interval * mult\n\t * So if mult is being incremented by one:\n\t *\txtime_interval = cycle_interval * (mult + 1)\n\t * Its the same as:\n\t *\txtime_interval = (cycle_interval * mult) + cycle_interval\n\t * Which can be shortened to:\n\t *\txtime_interval += cycle_interval\n\t *\n\t * So offset stores the non-accumulated cycles. Thus the current\n\t * time (in shifted nanoseconds) is:\n\t *\tnow = (offset * adj) + xtime_nsec\n\t * Now, even though we're adjusting the clock frequency, we have\n\t * to keep time consistent. In other words, we can't jump back\n\t * in time, and we also want to avoid jumping forward in time.\n\t *\n\t * So given the same offset value, we need the time to be the same\n\t * both before and after the freq adjustment.\n\t *\tnow = (offset * adj_1) + xtime_nsec_1\n\t *\tnow = (offset * adj_2) + xtime_nsec_2\n\t * So:\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * adj_2) + xtime_nsec_2\n\t * And we know:\n\t *\tadj_2 = adj_1 + 1\n\t * So:\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * (adj_1+1)) + xtime_nsec_2\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * adj_1) + offset + xtime_nsec_2\n\t * Canceling the sides:\n\t *\txtime_nsec_1 = offset + xtime_nsec_2\n\t * Which gives us:\n\t *\txtime_nsec_2 = xtime_nsec_1 - offset\n\t * Which simplfies to:\n\t *\txtime_nsec -= offset\n\t */\n\tif ((mult_adj > 0) && (tk->tkr_mono.mult + mult_adj < mult_adj)) {\n\t\t/* NTP adjustment caused clocksource mult overflow */\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\ttk->tkr_mono.mult += mult_adj;\n\ttk->xtime_interval += interval;\n\ttk->tkr_mono.xtime_nsec -= offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "(tk->ntp_tick >> tk->ntp_error_shift) -\n\t\t\t\t tk->xtime_remainder",
            "tk->cycle_interval"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntp_tick_length",
          "args": [],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_tick_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "368-371",
          "snippet": "u64 ntp_tick_length(void)\n{\n\treturn tick_length;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64\t\t\ttick_length;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic u64\t\t\ttick_length;\n\nu64 ntp_tick_length(void)\n{\n\treturn tick_length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "tk->ntp_tick == ntp_tick_length()"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void timekeeping_adjust(struct timekeeper *tk, s64 offset)\n{\n\tu32 mult;\n\n\t/*\n\t * Determine the multiplier from the current NTP tick length.\n\t * Avoid expensive division when the tick length doesn't change.\n\t */\n\tif (likely(tk->ntp_tick == ntp_tick_length())) {\n\t\tmult = tk->tkr_mono.mult - tk->ntp_err_mult;\n\t} else {\n\t\ttk->ntp_tick = ntp_tick_length();\n\t\tmult = div64_u64((tk->ntp_tick >> tk->ntp_error_shift) -\n\t\t\t\t tk->xtime_remainder, tk->cycle_interval);\n\t}\n\n\t/*\n\t * If the clock is behind the NTP time, increase the multiplier by 1\n\t * to catch up with it. If it's ahead and there was a remainder in the\n\t * tick division, the clock will slow down. Otherwise it will stay\n\t * ahead until the tick length changes to a non-divisible value.\n\t */\n\ttk->ntp_err_mult = tk->ntp_error > 0 ? 1 : 0;\n\tmult += tk->ntp_err_mult;\n\n\ttimekeeping_apply_adjustment(tk, offset, mult - tk->tkr_mono.mult);\n\n\tif (unlikely(tk->tkr_mono.clock->maxadj &&\n\t\t(abs(tk->tkr_mono.mult - tk->tkr_mono.clock->mult)\n\t\t\t> tk->tkr_mono.clock->maxadj))) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\"Adjusting %s more than 11%% (%ld vs %ld)\\n\",\n\t\t\ttk->tkr_mono.clock->name, (long)tk->tkr_mono.mult,\n\t\t\t(long)tk->tkr_mono.clock->mult + tk->tkr_mono.clock->maxadj);\n\t}\n\n\t/*\n\t * It may be possible that when we entered this function, xtime_nsec\n\t * was very small.  Further, if we're slightly speeding the clocksource\n\t * in the code above, its possible the required corrective factor to\n\t * xtime_nsec could cause it to underflow.\n\t *\n\t * Now, since we have already accumulated the second and the NTP\n\t * subsystem has been notified via second_overflow(), we need to skip\n\t * the next update.\n\t */\n\tif (unlikely((s64)tk->tkr_mono.xtime_nsec < 0)) {\n\t\ttk->tkr_mono.xtime_nsec += (u64)NSEC_PER_SEC <<\n\t\t\t\t\t\t\ttk->tkr_mono.shift;\n\t\ttk->xtime_sec--;\n\t\ttk->skip_second_overflow = 1;\n\t}\n}"
  },
  {
    "function_name": "timekeeping_apply_adjustment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1822-1894",
    "snippet": "static __always_inline void timekeeping_apply_adjustment(struct timekeeper *tk,\n\t\t\t\t\t\t\t s64 offset,\n\t\t\t\t\t\t\t s32 mult_adj)\n{\n\ts64 interval = tk->cycle_interval;\n\n\tif (mult_adj == 0) {\n\t\treturn;\n\t} else if (mult_adj == -1) {\n\t\tinterval = -interval;\n\t\toffset = -offset;\n\t} else if (mult_adj != 1) {\n\t\tinterval *= mult_adj;\n\t\toffset *= mult_adj;\n\t}\n\n\t/*\n\t * So the following can be confusing.\n\t *\n\t * To keep things simple, lets assume mult_adj == 1 for now.\n\t *\n\t * When mult_adj != 1, remember that the interval and offset values\n\t * have been appropriately scaled so the math is the same.\n\t *\n\t * The basic idea here is that we're increasing the multiplier\n\t * by one, this causes the xtime_interval to be incremented by\n\t * one cycle_interval. This is because:\n\t *\txtime_interval = cycle_interval * mult\n\t * So if mult is being incremented by one:\n\t *\txtime_interval = cycle_interval * (mult + 1)\n\t * Its the same as:\n\t *\txtime_interval = (cycle_interval * mult) + cycle_interval\n\t * Which can be shortened to:\n\t *\txtime_interval += cycle_interval\n\t *\n\t * So offset stores the non-accumulated cycles. Thus the current\n\t * time (in shifted nanoseconds) is:\n\t *\tnow = (offset * adj) + xtime_nsec\n\t * Now, even though we're adjusting the clock frequency, we have\n\t * to keep time consistent. In other words, we can't jump back\n\t * in time, and we also want to avoid jumping forward in time.\n\t *\n\t * So given the same offset value, we need the time to be the same\n\t * both before and after the freq adjustment.\n\t *\tnow = (offset * adj_1) + xtime_nsec_1\n\t *\tnow = (offset * adj_2) + xtime_nsec_2\n\t * So:\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * adj_2) + xtime_nsec_2\n\t * And we know:\n\t *\tadj_2 = adj_1 + 1\n\t * So:\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * (adj_1+1)) + xtime_nsec_2\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * adj_1) + offset + xtime_nsec_2\n\t * Canceling the sides:\n\t *\txtime_nsec_1 = offset + xtime_nsec_2\n\t * Which gives us:\n\t *\txtime_nsec_2 = xtime_nsec_1 - offset\n\t * Which simplfies to:\n\t *\txtime_nsec -= offset\n\t */\n\tif ((mult_adj > 0) && (tk->tkr_mono.mult + mult_adj < mult_adj)) {\n\t\t/* NTP adjustment caused clocksource mult overflow */\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\ttk->tkr_mono.mult += mult_adj;\n\ttk->xtime_interval += interval;\n\ttk->tkr_mono.xtime_nsec -= offset;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic __always_inline void timekeeping_apply_adjustment(struct timekeeper *tk,\n\t\t\t\t\t\t\t s64 offset,\n\t\t\t\t\t\t\t s32 mult_adj)\n{\n\ts64 interval = tk->cycle_interval;\n\n\tif (mult_adj == 0) {\n\t\treturn;\n\t} else if (mult_adj == -1) {\n\t\tinterval = -interval;\n\t\toffset = -offset;\n\t} else if (mult_adj != 1) {\n\t\tinterval *= mult_adj;\n\t\toffset *= mult_adj;\n\t}\n\n\t/*\n\t * So the following can be confusing.\n\t *\n\t * To keep things simple, lets assume mult_adj == 1 for now.\n\t *\n\t * When mult_adj != 1, remember that the interval and offset values\n\t * have been appropriately scaled so the math is the same.\n\t *\n\t * The basic idea here is that we're increasing the multiplier\n\t * by one, this causes the xtime_interval to be incremented by\n\t * one cycle_interval. This is because:\n\t *\txtime_interval = cycle_interval * mult\n\t * So if mult is being incremented by one:\n\t *\txtime_interval = cycle_interval * (mult + 1)\n\t * Its the same as:\n\t *\txtime_interval = (cycle_interval * mult) + cycle_interval\n\t * Which can be shortened to:\n\t *\txtime_interval += cycle_interval\n\t *\n\t * So offset stores the non-accumulated cycles. Thus the current\n\t * time (in shifted nanoseconds) is:\n\t *\tnow = (offset * adj) + xtime_nsec\n\t * Now, even though we're adjusting the clock frequency, we have\n\t * to keep time consistent. In other words, we can't jump back\n\t * in time, and we also want to avoid jumping forward in time.\n\t *\n\t * So given the same offset value, we need the time to be the same\n\t * both before and after the freq adjustment.\n\t *\tnow = (offset * adj_1) + xtime_nsec_1\n\t *\tnow = (offset * adj_2) + xtime_nsec_2\n\t * So:\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * adj_2) + xtime_nsec_2\n\t * And we know:\n\t *\tadj_2 = adj_1 + 1\n\t * So:\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * (adj_1+1)) + xtime_nsec_2\n\t *\t(offset * adj_1) + xtime_nsec_1 =\n\t *\t\t(offset * adj_1) + offset + xtime_nsec_2\n\t * Canceling the sides:\n\t *\txtime_nsec_1 = offset + xtime_nsec_2\n\t * Which gives us:\n\t *\txtime_nsec_2 = xtime_nsec_1 - offset\n\t * Which simplfies to:\n\t *\txtime_nsec -= offset\n\t */\n\tif ((mult_adj > 0) && (tk->tkr_mono.mult + mult_adj < mult_adj)) {\n\t\t/* NTP adjustment caused clocksource mult overflow */\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\ttk->tkr_mono.mult += mult_adj;\n\ttk->xtime_interval += interval;\n\ttk->tkr_mono.xtime_nsec -= offset;\n}"
  },
  {
    "function_name": "timekeeping_init_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1812-1816",
    "snippet": "static int __init timekeeping_init_ops(void)\n{\n\tregister_syscore_ops(&timekeeping_syscore_ops);\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct syscore_ops timekeeping_syscore_ops = {\n\t.resume\t\t= timekeeping_resume,\n\t.suspend\t= timekeeping_suspend,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_syscore_ops",
          "args": [
            "&timekeeping_syscore_ops"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic struct syscore_ops timekeeping_syscore_ops = {\n\t.resume\t\t= timekeeping_resume,\n\t.suspend\t= timekeeping_suspend,\n};\n\nstatic int __init timekeeping_init_ops(void)\n{\n\tregister_syscore_ops(&timekeeping_syscore_ops);\n\treturn 0;\n}"
  },
  {
    "function_name": "timekeeping_suspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1737-1804",
    "snippet": "int timekeeping_suspend(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64\t\tdelta, delta_delta;\n\tstatic struct timespec64\told_delta;\n\tstruct clocksource *curr_clock;\n\tu64 cycle_now;\n\n\tread_persistent_clock64(&timekeeping_suspend_time);\n\n\t/*\n\t * On some systems the persistent_clock can not be detected at\n\t * timekeeping_init by its return value, so if we see a valid\n\t * value returned, update the persistent_clock_exists flag.\n\t */\n\tif (timekeeping_suspend_time.tv_sec || timekeeping_suspend_time.tv_nsec)\n\t\tpersistent_clock_exists = true;\n\n\tsuspend_timing_needed = true;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\ttimekeeping_forward_now(tk);\n\ttimekeeping_suspended = 1;\n\n\t/*\n\t * Since we've called forward_now, cycle_last stores the value\n\t * just read from the current clocksource. Save this to potentially\n\t * use in suspend timing.\n\t */\n\tcurr_clock = tk->tkr_mono.clock;\n\tcycle_now = tk->tkr_mono.cycle_last;\n\tclocksource_start_suspend_timing(curr_clock, cycle_now);\n\n\tif (persistent_clock_exists) {\n\t\t/*\n\t\t * To avoid drift caused by repeated suspend/resumes,\n\t\t * which each can add ~1 second drift error,\n\t\t * try to compensate so the difference in system time\n\t\t * and persistent_clock time stays close to constant.\n\t\t */\n\t\tdelta = timespec64_sub(tk_xtime(tk), timekeeping_suspend_time);\n\t\tdelta_delta = timespec64_sub(delta, old_delta);\n\t\tif (abs(delta_delta.tv_sec) >= 2) {\n\t\t\t/*\n\t\t\t * if delta_delta is too large, assume time correction\n\t\t\t * has occurred and set old_delta to the current delta.\n\t\t\t */\n\t\t\told_delta = delta;\n\t\t} else {\n\t\t\t/* Otherwise try to adjust old_system to compensate */\n\t\t\ttimekeeping_suspend_time =\n\t\t\t\ttimespec64_add(timekeeping_suspend_time, delta_delta);\n\t\t}\n\t}\n\n\ttimekeeping_update(tk, TK_MIRROR);\n\thalt_fast_timekeeper(tk);\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\ttick_suspend();\n\tclocksource_suspend();\n\tclockevents_suspend();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_MIRROR\t\t(1 << 1)"
    ],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(timekeeper_lock);",
      "static bool suspend_timing_needed;",
      "static bool persistent_clock_exists;",
      "static struct timespec64 timekeeping_suspend_time;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_suspend",
          "args": [],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_suspend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "602-609",
          "snippet": "void clockevents_suspend(void)\n{\n\tstruct clock_event_device *dev;\n\n\tlist_for_each_entry_reverse(dev, &clockevent_devices, list)\n\t\tif (dev->suspend && !clockevent_state_detached(dev))\n\t\t\tdev->suspend(dev);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevent_devices);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\n\nvoid clockevents_suspend(void)\n{\n\tstruct clock_event_device *dev;\n\n\tlist_for_each_entry_reverse(dev, &clockevent_devices, list)\n\t\tif (dev->suspend && !clockevent_state_detached(dev))\n\t\t\tdev->suspend(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_suspend",
          "args": [],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_suspend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "611-618",
          "snippet": "void clocksource_suspend(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry_reverse(cs, &clocksource_list, list)\n\t\tif (cs->suspend)\n\t\t\tcs->suspend(cs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clocksource_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\n\nvoid clocksource_suspend(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry_reverse(cs, &clocksource_list, list)\n\t\tif (cs->suspend)\n\t\t\tcs->suspend(cs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_suspend",
          "args": [],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "tick_suspend_broadcast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast.c",
          "lines": "462-474",
          "snippet": "void tick_suspend_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\tif (bc)\n\t\tclockevents_shutdown(bc);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;",
            "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nvoid tick_suspend_broadcast(void)\n{\n\tstruct clock_event_device *bc;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&tick_broadcast_lock, flags);\n\n\tbc = tick_broadcast_device.evtdev;\n\tif (bc)\n\t\tclockevents_shutdown(bc);\n\n\traw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "halt_fast_timekeeper",
          "args": [
            "tk"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "halt_fast_timekeeper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "554-569",
          "snippet": "static void halt_fast_timekeeper(const struct timekeeper *tk)\n{\n\tstatic struct tk_read_base tkr_dummy;\n\tconst struct tk_read_base *tkr = &tk->tkr_mono;\n\n\tmemcpy(&tkr_dummy, tkr, sizeof(tkr_dummy));\n\tcycles_at_suspend = tk_clock_read(tkr);\n\ttkr_dummy.clock = &dummy_clock;\n\ttkr_dummy.base_real = tkr->base + tk->offs_real;\n\tupdate_fast_timekeeper(&tkr_dummy, &tk_fast_mono);\n\n\ttkr = &tk->tkr_raw;\n\tmemcpy(&tkr_dummy, tkr, sizeof(tkr_dummy));\n\ttkr_dummy.clock = &dummy_clock;\n\tupdate_fast_timekeeper(&tkr_dummy, &tk_fast_raw);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 cycles_at_suspend;",
            "static struct clocksource dummy_clock = {\n\t.read = dummy_clock_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic u64 cycles_at_suspend;\nstatic struct clocksource dummy_clock = {\n\t.read = dummy_clock_read,\n};\n\nstatic void halt_fast_timekeeper(const struct timekeeper *tk)\n{\n\tstatic struct tk_read_base tkr_dummy;\n\tconst struct tk_read_base *tkr = &tk->tkr_mono;\n\n\tmemcpy(&tkr_dummy, tkr, sizeof(tkr_dummy));\n\tcycles_at_suspend = tk_clock_read(tkr);\n\ttkr_dummy.clock = &dummy_clock;\n\ttkr_dummy.base_real = tkr->base + tk->offs_real;\n\tupdate_fast_timekeeper(&tkr_dummy, &tk_fast_mono);\n\n\ttkr = &tk->tkr_raw;\n\tmemcpy(&tkr_dummy, tkr, sizeof(tkr_dummy));\n\ttkr_dummy.clock = &dummy_clock;\n\tupdate_fast_timekeeper(&tkr_dummy, &tk_fast_raw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_update",
          "args": [
            "tk",
            "TK_MIRROR"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "658-685",
          "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_add",
          "args": [
            "timekeeping_suspend_time",
            "delta_delta"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "timespec64_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "816-830",
          "snippet": "struct timespec64 timespec64_add_safe(const struct timespec64 lhs,\n\t\t\t\tconst struct timespec64 rhs)\n{\n\tstruct timespec64 res;\n\n\tset_normalized_timespec64(&res, (timeu64_t) lhs.tv_sec + rhs.tv_sec,\n\t\t\tlhs.tv_nsec + rhs.tv_nsec);\n\n\tif (unlikely(res.tv_sec < lhs.tv_sec || res.tv_sec < rhs.tv_sec)) {\n\t\tres.tv_sec = TIME64_MAX;\n\t\tres.tv_nsec = 0;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 timespec64_add_safe(const struct timespec64 lhs,\n\t\t\t\tconst struct timespec64 rhs)\n{\n\tstruct timespec64 res;\n\n\tset_normalized_timespec64(&res, (timeu64_t) lhs.tv_sec + rhs.tv_sec,\n\t\t\tlhs.tv_nsec + rhs.tv_nsec);\n\n\tif (unlikely(res.tv_sec < lhs.tv_sec || res.tv_sec < rhs.tv_sec)) {\n\t\tres.tv_sec = TIME64_MAX;\n\t\tres.tv_nsec = 0;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "delta_delta.tv_sec"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "462-469",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "delta",
            "old_delta"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "tk_xtime(tk)",
            "timekeeping_suspend_time"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_xtime",
          "args": [
            "tk"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "tk_xtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "109-116",
          "snippet": "static inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_start_suspend_timing",
          "args": [
            "curr_clock",
            "cycle_now"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_start_suspend_timing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "536-558",
          "snippet": "void clocksource_start_suspend_timing(struct clocksource *cs, u64 start_cycles)\n{\n\tif (!suspend_clocksource)\n\t\treturn;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value as suspend_start to avoid same reading\n\t * from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs)) {\n\t\tsuspend_start = start_cycles;\n\t\treturn;\n\t}\n\n\tif (suspend_clocksource->enable &&\n\t    suspend_clocksource->enable(suspend_clocksource)) {\n\t\tpr_warn_once(\"Failed to enable the non-suspend-able clocksource.\\n\");\n\t\treturn;\n\t}\n\n\tsuspend_start = suspend_clocksource->read(suspend_clocksource);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;",
            "static u64 suspend_start;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic u64 suspend_start;\n\nvoid clocksource_start_suspend_timing(struct clocksource *cs, u64 start_cycles)\n{\n\tif (!suspend_clocksource)\n\t\treturn;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value as suspend_start to avoid same reading\n\t * from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs)) {\n\t\tsuspend_start = start_cycles;\n\t\treturn;\n\t}\n\n\tif (suspend_clocksource->enable &&\n\t    suspend_clocksource->enable(suspend_clocksource)) {\n\t\tpr_warn_once(\"Failed to enable the non-suspend-able clocksource.\\n\");\n\t\treturn;\n\t}\n\n\tsuspend_start = suspend_clocksource->read(suspend_clocksource);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_forward_now",
          "args": [
            "tk"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_forward_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "694-715",
          "snippet": "static void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_mono.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_mono.shift;\n\n\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_raw.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_raw.shift;\n\n\ttk_normalize_xtime(tk);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_mono.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_mono.shift;\n\n\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_raw.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_raw.shift;\n\n\ttk_normalize_xtime(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_persistent_clock64",
          "args": [
            "&timekeeping_suspend_time"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "read_persistent_clock64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1484-1490",
          "snippet": "void __weak read_persistent_clock64(struct timespec64 *ts64)\n{\n\tstruct timespec ts;\n\n\tread_persistent_clock(&ts);\n\t*ts64 = timespec_to_timespec64(ts);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __weak"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid __weak;\n\nvoid __weak read_persistent_clock64(struct timespec64 *ts64)\n{\n\tstruct timespec ts;\n\n\tread_persistent_clock(&ts);\n\t*ts64 = timespec_to_timespec64(ts);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_MIRROR\t\t(1 << 1)\n\nstatic DEFINE_RAW_SPINLOCK(timekeeper_lock);\nstatic bool suspend_timing_needed;\nstatic bool persistent_clock_exists;\nstatic struct timespec64 timekeeping_suspend_time;\n\nint timekeeping_suspend(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64\t\tdelta, delta_delta;\n\tstatic struct timespec64\told_delta;\n\tstruct clocksource *curr_clock;\n\tu64 cycle_now;\n\n\tread_persistent_clock64(&timekeeping_suspend_time);\n\n\t/*\n\t * On some systems the persistent_clock can not be detected at\n\t * timekeeping_init by its return value, so if we see a valid\n\t * value returned, update the persistent_clock_exists flag.\n\t */\n\tif (timekeeping_suspend_time.tv_sec || timekeeping_suspend_time.tv_nsec)\n\t\tpersistent_clock_exists = true;\n\n\tsuspend_timing_needed = true;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\ttimekeeping_forward_now(tk);\n\ttimekeeping_suspended = 1;\n\n\t/*\n\t * Since we've called forward_now, cycle_last stores the value\n\t * just read from the current clocksource. Save this to potentially\n\t * use in suspend timing.\n\t */\n\tcurr_clock = tk->tkr_mono.clock;\n\tcycle_now = tk->tkr_mono.cycle_last;\n\tclocksource_start_suspend_timing(curr_clock, cycle_now);\n\n\tif (persistent_clock_exists) {\n\t\t/*\n\t\t * To avoid drift caused by repeated suspend/resumes,\n\t\t * which each can add ~1 second drift error,\n\t\t * try to compensate so the difference in system time\n\t\t * and persistent_clock time stays close to constant.\n\t\t */\n\t\tdelta = timespec64_sub(tk_xtime(tk), timekeeping_suspend_time);\n\t\tdelta_delta = timespec64_sub(delta, old_delta);\n\t\tif (abs(delta_delta.tv_sec) >= 2) {\n\t\t\t/*\n\t\t\t * if delta_delta is too large, assume time correction\n\t\t\t * has occurred and set old_delta to the current delta.\n\t\t\t */\n\t\t\told_delta = delta;\n\t\t} else {\n\t\t\t/* Otherwise try to adjust old_system to compensate */\n\t\t\ttimekeeping_suspend_time =\n\t\t\t\ttimespec64_add(timekeeping_suspend_time, delta_delta);\n\t\t}\n\t}\n\n\ttimekeeping_update(tk, TK_MIRROR);\n\thalt_fast_timekeeper(tk);\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\ttick_suspend();\n\tclocksource_suspend();\n\tclockevents_suspend();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "timekeeping_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1677-1735",
    "snippet": "void timekeeping_resume(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct clocksource *clock = tk->tkr_mono.clock;\n\tunsigned long flags;\n\tstruct timespec64 ts_new, ts_delta;\n\tu64 cycle_now, nsec;\n\tbool inject_sleeptime = false;\n\n\tread_persistent_clock64(&ts_new);\n\n\tclockevents_resume();\n\tclocksource_resume();\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\t/*\n\t * After system resumes, we need to calculate the suspended time and\n\t * compensate it for the OS time. There are 3 sources that could be\n\t * used: Nonstop clocksource during suspend, persistent clock and rtc\n\t * device.\n\t *\n\t * One specific platform may have 1 or 2 or all of them, and the\n\t * preference will be:\n\t *\tsuspend-nonstop clocksource -> persistent clock -> rtc\n\t * The less preferred source will only be tried if there is no better\n\t * usable source. The rtc part is handled separately in rtc core code.\n\t */\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tnsec = clocksource_stop_suspend_timing(clock, cycle_now);\n\tif (nsec > 0) {\n\t\tts_delta = ns_to_timespec64(nsec);\n\t\tinject_sleeptime = true;\n\t} else if (timespec64_compare(&ts_new, &timekeeping_suspend_time) > 0) {\n\t\tts_delta = timespec64_sub(ts_new, timekeeping_suspend_time);\n\t\tinject_sleeptime = true;\n\t}\n\n\tif (inject_sleeptime) {\n\t\tsuspend_timing_needed = false;\n\t\t__timekeeping_inject_sleeptime(tk, &ts_delta);\n\t}\n\n\t/* Re-base the last cycle value */\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->ntp_error = 0;\n\ttimekeeping_suspended = 0;\n\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\ttouch_softlockup_watchdog();\n\n\ttick_resume();\n\thrtimers_resume();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_CLOCK_WAS_SET\t(1 << 2)",
      "#define TK_MIRROR\t\t(1 << 1)"
    ],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(timekeeper_lock);",
      "static bool suspend_timing_needed;",
      "static struct timespec64 timekeeping_suspend_time;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimers_resume",
          "args": [],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimers_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "872-879",
          "snippet": "void hrtimers_resume(void)\n{\n\tlockdep_assert_irqs_disabled();\n\t/* Retrigger on the local CPU */\n\tretrigger_next_event(NULL);\n\t/* And schedule a retrigger for all others */\n\tclock_was_set_delayed();\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimers_resume(void)\n{\n\tlockdep_assert_irqs_disabled();\n\t/* Retrigger on the local CPU */\n\tretrigger_next_event(NULL);\n\t/* And schedule a retrigger for all others */\n\tclock_was_set_delayed();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_resume",
          "args": [],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "tick_resume_oneshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-oneshot.c",
          "lines": "54-60",
          "snippet": "void tick_resume_oneshot(void)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\tclockevents_program_event(dev, ktime_get(), true);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_resume_oneshot(void)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_ONESHOT);\n\tclockevents_program_event(dev, ktime_get(), true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_softlockup_watchdog",
          "args": [],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "touch_softlockup_watchdog_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog.c",
          "lines": "298-302",
          "snippet": "void touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_touch_ts, 0);\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nvoid touch_softlockup_watchdog_sync(void)\n{\n\t__this_cpu_write(softlockup_touch_sync, true);\n\t__this_cpu_write(watchdog_touch_ts, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_update",
          "args": [
            "tk",
            "TK_MIRROR | TK_CLOCK_WAS_SET"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "658-685",
          "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__timekeeping_inject_sleeptime",
          "args": [
            "tk",
            "&ts_delta"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "__timekeeping_inject_sleeptime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1588-1601",
          "snippet": "static void __timekeeping_inject_sleeptime(struct timekeeper *tk,\n\t\t\t\t\t   const struct timespec64 *delta)\n{\n\tif (!timespec64_valid_strict(delta)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"__timekeeping_inject_sleeptime: Invalid \"\n\t\t\t\t\"sleep delta value!\\n\");\n\t\treturn;\n\t}\n\ttk_xtime_add(tk, delta);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *delta));\n\ttk_update_sleep_time(tk, timespec64_to_ktime(*delta));\n\ttk_debug_account_sleep_time(delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void __timekeeping_inject_sleeptime(struct timekeeper *tk,\n\t\t\t\t\t   const struct timespec64 *delta)\n{\n\tif (!timespec64_valid_strict(delta)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"__timekeeping_inject_sleeptime: Invalid \"\n\t\t\t\t\"sleep delta value!\\n\");\n\t\treturn;\n\t}\n\ttk_xtime_add(tk, delta);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *delta));\n\ttk_update_sleep_time(tk, timespec64_to_ktime(*delta));\n\ttk_debug_account_sleep_time(delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "ts_new",
            "timekeeping_suspend_time"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_compare",
          "args": [
            "&ts_new",
            "&timekeeping_suspend_time"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_timespec64",
          "args": [
            "nsec"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "ns_to_timespec64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "522-538",
          "snippet": "struct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts;\n\ts32 rem;\n\n\tif (!nsec)\n\t\treturn (struct timespec64) {0, 0};\n\n\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (unlikely(rem < 0)) {\n\t\tts.tv_sec--;\n\t\trem += NSEC_PER_SEC;\n\t}\n\tts.tv_nsec = rem;\n\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts;\n\ts32 rem;\n\n\tif (!nsec)\n\t\treturn (struct timespec64) {0, 0};\n\n\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (unlikely(rem < 0)) {\n\t\tts.tv_sec--;\n\t\trem += NSEC_PER_SEC;\n\t}\n\tts.tv_nsec = rem;\n\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_stop_suspend_timing",
          "args": [
            "clock",
            "cycle_now"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_stop_suspend_timing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "574-606",
          "snippet": "u64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;",
            "static u64 suspend_start;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic u64 suspend_start;\n\nu64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "166-171",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_resume",
          "args": [],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "623-632",
          "snippet": "void clocksource_resume(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &clocksource_list, list)\n\t\tif (cs->resume)\n\t\t\tcs->resume(cs);\n\n\tclocksource_resume_watchdog();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clocksource_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic LIST_HEAD(clocksource_list);\n\nvoid clocksource_resume(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &clocksource_list, list)\n\t\tif (cs->resume)\n\t\t\tcs->resume(cs);\n\n\tclocksource_resume_watchdog();\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_resume",
          "args": [],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "614-621",
          "snippet": "void clockevents_resume(void)\n{\n\tstruct clock_event_device *dev;\n\n\tlist_for_each_entry(dev, &clockevent_devices, list)\n\t\tif (dev->resume && !clockevent_state_detached(dev))\n\t\t\tdev->resume(dev);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevent_devices);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\n\nvoid clockevents_resume(void)\n{\n\tstruct clock_event_device *dev;\n\n\tlist_for_each_entry(dev, &clockevent_devices, list)\n\t\tif (dev->resume && !clockevent_state_detached(dev))\n\t\t\tdev->resume(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_persistent_clock64",
          "args": [
            "&ts_new"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "read_persistent_clock64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1484-1490",
          "snippet": "void __weak read_persistent_clock64(struct timespec64 *ts64)\n{\n\tstruct timespec ts;\n\n\tread_persistent_clock(&ts);\n\t*ts64 = timespec_to_timespec64(ts);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __weak"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid __weak;\n\nvoid __weak read_persistent_clock64(struct timespec64 *ts64)\n{\n\tstruct timespec ts;\n\n\tread_persistent_clock(&ts);\n\t*ts64 = timespec_to_timespec64(ts);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n\nstatic DEFINE_RAW_SPINLOCK(timekeeper_lock);\nstatic bool suspend_timing_needed;\nstatic struct timespec64 timekeeping_suspend_time;\n\nvoid timekeeping_resume(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct clocksource *clock = tk->tkr_mono.clock;\n\tunsigned long flags;\n\tstruct timespec64 ts_new, ts_delta;\n\tu64 cycle_now, nsec;\n\tbool inject_sleeptime = false;\n\n\tread_persistent_clock64(&ts_new);\n\n\tclockevents_resume();\n\tclocksource_resume();\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\t/*\n\t * After system resumes, we need to calculate the suspended time and\n\t * compensate it for the OS time. There are 3 sources that could be\n\t * used: Nonstop clocksource during suspend, persistent clock and rtc\n\t * device.\n\t *\n\t * One specific platform may have 1 or 2 or all of them, and the\n\t * preference will be:\n\t *\tsuspend-nonstop clocksource -> persistent clock -> rtc\n\t * The less preferred source will only be tried if there is no better\n\t * usable source. The rtc part is handled separately in rtc core code.\n\t */\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tnsec = clocksource_stop_suspend_timing(clock, cycle_now);\n\tif (nsec > 0) {\n\t\tts_delta = ns_to_timespec64(nsec);\n\t\tinject_sleeptime = true;\n\t} else if (timespec64_compare(&ts_new, &timekeeping_suspend_time) > 0) {\n\t\tts_delta = timespec64_sub(ts_new, timekeeping_suspend_time);\n\t\tinject_sleeptime = true;\n\t}\n\n\tif (inject_sleeptime) {\n\t\tsuspend_timing_needed = false;\n\t\t__timekeeping_inject_sleeptime(tk, &ts_delta);\n\t}\n\n\t/* Re-base the last cycle value */\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->ntp_error = 0;\n\ttimekeeping_suspended = 0;\n\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\ttouch_softlockup_watchdog();\n\n\ttick_resume();\n\thrtimers_resume();\n}"
  },
  {
    "function_name": "timekeeping_inject_sleeptime64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1650-1671",
    "snippet": "void timekeeping_inject_sleeptime64(const struct timespec64 *delta)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\tsuspend_timing_needed = false;\n\n\ttimekeeping_forward_now(tk);\n\n\t__timekeeping_inject_sleeptime(tk, delta);\n\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* signal hrtimers about time change */\n\tclock_was_set();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_CLOCK_WAS_SET\t(1 << 2)",
      "#define TK_MIRROR\t\t(1 << 1)",
      "#define TK_CLEAR_NTP\t\t(1 << 0)"
    ],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(timekeeper_lock);",
      "static bool suspend_timing_needed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clock_was_set",
          "args": [],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "clock_was_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "857-864",
          "snippet": "void clock_was_set(void)\n{\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t/* Retrigger the CPU local events everywhere */\n\ton_each_cpu(retrigger_next_event, NULL, 1);\n#endif\n\ttimerfd_clock_was_set();\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid clock_was_set(void)\n{\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t/* Retrigger the CPU local events everywhere */\n\ton_each_cpu(retrigger_next_event, NULL, 1);\n#endif\n\ttimerfd_clock_was_set();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_update",
          "args": [
            "tk",
            "TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "658-685",
          "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__timekeeping_inject_sleeptime",
          "args": [
            "tk",
            "delta"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "__timekeeping_inject_sleeptime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1588-1601",
          "snippet": "static void __timekeeping_inject_sleeptime(struct timekeeper *tk,\n\t\t\t\t\t   const struct timespec64 *delta)\n{\n\tif (!timespec64_valid_strict(delta)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"__timekeeping_inject_sleeptime: Invalid \"\n\t\t\t\t\"sleep delta value!\\n\");\n\t\treturn;\n\t}\n\ttk_xtime_add(tk, delta);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *delta));\n\ttk_update_sleep_time(tk, timespec64_to_ktime(*delta));\n\ttk_debug_account_sleep_time(delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void __timekeeping_inject_sleeptime(struct timekeeper *tk,\n\t\t\t\t\t   const struct timespec64 *delta)\n{\n\tif (!timespec64_valid_strict(delta)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"__timekeeping_inject_sleeptime: Invalid \"\n\t\t\t\t\"sleep delta value!\\n\");\n\t\treturn;\n\t}\n\ttk_xtime_add(tk, delta);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *delta));\n\ttk_update_sleep_time(tk, timespec64_to_ktime(*delta));\n\ttk_debug_account_sleep_time(delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_forward_now",
          "args": [
            "tk"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_forward_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "694-715",
          "snippet": "static void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_mono.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_mono.shift;\n\n\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_raw.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_raw.shift;\n\n\ttk_normalize_xtime(tk);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_mono.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_mono.shift;\n\n\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_raw.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_raw.shift;\n\n\ttk_normalize_xtime(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic DEFINE_RAW_SPINLOCK(timekeeper_lock);\nstatic bool suspend_timing_needed;\n\nvoid timekeeping_inject_sleeptime64(const struct timespec64 *delta)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\tsuspend_timing_needed = false;\n\n\ttimekeeping_forward_now(tk);\n\n\t__timekeeping_inject_sleeptime(tk, delta);\n\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* signal hrtimers about time change */\n\tclock_was_set();\n}"
  },
  {
    "function_name": "timekeeping_rtc_skipsuspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1634-1637",
    "snippet": "bool timekeeping_rtc_skipsuspend(void)\n{\n\treturn persistent_clock_exists;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool persistent_clock_exists;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic bool persistent_clock_exists;\n\nbool timekeeping_rtc_skipsuspend(void)\n{\n\treturn persistent_clock_exists;\n}"
  },
  {
    "function_name": "timekeeping_rtc_skipresume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1620-1623",
    "snippet": "bool timekeeping_rtc_skipresume(void)\n{\n\treturn !suspend_timing_needed;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool suspend_timing_needed;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic bool suspend_timing_needed;\n\nbool timekeeping_rtc_skipresume(void)\n{\n\treturn !suspend_timing_needed;\n}"
  },
  {
    "function_name": "__timekeeping_inject_sleeptime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1588-1601",
    "snippet": "static void __timekeeping_inject_sleeptime(struct timekeeper *tk,\n\t\t\t\t\t   const struct timespec64 *delta)\n{\n\tif (!timespec64_valid_strict(delta)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"__timekeeping_inject_sleeptime: Invalid \"\n\t\t\t\t\"sleep delta value!\\n\");\n\t\treturn;\n\t}\n\ttk_xtime_add(tk, delta);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *delta));\n\ttk_update_sleep_time(tk, timespec64_to_ktime(*delta));\n\ttk_debug_account_sleep_time(delta);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tk_debug_account_sleep_time",
          "args": [
            "delta"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "tk_debug_account_sleep_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping_debug.c",
          "lines": "73-81",
          "snippet": "void tk_debug_account_sleep_time(const struct timespec64 *t)\n{\n\t/* Cap bin index so we don't overflow the array */\n\tint bin = min(fls(t->tv_sec), NUM_BINS-1);\n\n\tsleep_time_bin[bin]++;\n\tpm_deferred_pr_dbg(\"Timekeeping suspended for %lld.%03lu seconds\\n\",\n\t\t\t   (s64)t->tv_sec, t->tv_nsec / NSEC_PER_MSEC);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include <linux/time.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [
            "#define NUM_BINS 32"
          ],
          "globals_used": [
            "static unsigned int sleep_time_bin[NUM_BINS] = {0};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include <linux/time.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/debugfs.h>\n\n#define NUM_BINS 32\n\nstatic unsigned int sleep_time_bin[NUM_BINS] = {0};\n\nvoid tk_debug_account_sleep_time(const struct timespec64 *t)\n{\n\t/* Cap bin index so we don't overflow the array */\n\tint bin = min(fls(t->tv_sec), NUM_BINS-1);\n\n\tsleep_time_bin[bin]++;\n\tpm_deferred_pr_dbg(\"Timekeeping suspended for %lld.%03lu seconds\\n\",\n\t\t\t   (s64)t->tv_sec, t->tv_nsec / NSEC_PER_MSEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_update_sleep_time",
          "args": [
            "tk",
            "timespec64_to_ktime(*delta)"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "tk_update_sleep_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "148-151",
          "snippet": "static inline void tk_update_sleep_time(struct timekeeper *tk, ktime_t delta)\n{\n\ttk->offs_boot = ktime_add(tk->offs_boot, delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_update_sleep_time(struct timekeeper *tk, ktime_t delta)\n{\n\ttk->offs_boot = ktime_add(tk->offs_boot, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "*delta"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_set_wall_to_mono",
          "args": [
            "tk",
            "timespec64_sub(tk->wall_to_monotonic, *delta)"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "tk_set_wall_to_mono",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "131-146",
          "snippet": "static void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "tk->wall_to_monotonic",
            "*delta"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_xtime_add",
          "args": [
            "tk",
            "delta"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "tk_xtime_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "124-129",
          "snippet": "static void tk_xtime_add(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec += ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec += (u64)ts->tv_nsec << tk->tkr_mono.shift;\n\ttk_normalize_xtime(tk);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_xtime_add(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec += ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec += (u64)ts->tv_nsec << tk->tkr_mono.shift;\n\ttk_normalize_xtime(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "KERN_WARNING\n\t\t\t\t\"__timekeeping_inject_sleeptime: Invalid \"\n\t\t\t\t\"sleep delta value!\\n\""
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "printk_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2926-2936",
          "snippet": "int printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_valid_strict",
          "args": [
            "delta"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void __timekeeping_inject_sleeptime(struct timekeeper *tk,\n\t\t\t\t\t   const struct timespec64 *delta)\n{\n\tif (!timespec64_valid_strict(delta)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"__timekeeping_inject_sleeptime: Invalid \"\n\t\t\t\t\"sleep delta value!\\n\");\n\t\treturn;\n\t}\n\ttk_xtime_add(tk, delta);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *delta));\n\ttk_update_sleep_time(tk, timespec64_to_ktime(*delta));\n\ttk_debug_account_sleep_time(delta);\n}"
  },
  {
    "function_name": "timekeeping_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1533-1576",
    "snippet": "void __init timekeeping_init(void)\n{\n\tstruct timespec64 wall_time, boot_offset, wall_to_mono;\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct clocksource *clock;\n\tunsigned long flags;\n\n\tread_persistent_wall_and_boot_offset(&wall_time, &boot_offset);\n\tif (timespec64_valid_strict(&wall_time) &&\n\t    timespec64_to_ns(&wall_time) > 0) {\n\t\tpersistent_clock_exists = true;\n\t} else if (timespec64_to_ns(&wall_time) != 0) {\n\t\tpr_warn(\"Persistent clock returned invalid value\");\n\t\twall_time = (struct timespec64){0};\n\t}\n\n\tif (timespec64_compare(&wall_time, &boot_offset) < 0)\n\t\tboot_offset = (struct timespec64){0};\n\n\t/*\n\t * We want set wall_to_mono, so the following is true:\n\t * wall time + wall_to_mono = boot time\n\t */\n\twall_to_mono = timespec64_sub(boot_offset, wall_time);\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\tntp_init();\n\n\tclock = clocksource_default_clock();\n\tif (clock->enable)\n\t\tclock->enable(clock);\n\ttk_setup_internals(tk, clock);\n\n\ttk_set_xtime(tk, &wall_time);\n\ttk->raw_sec = 0;\n\n\ttk_set_wall_to_mono(tk, wall_to_mono);\n\n\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_CLOCK_WAS_SET\t(1 << 2)",
      "#define TK_MIRROR\t\t(1 << 1)"
    ],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(timekeeper_lock);",
      "static bool persistent_clock_exists;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_update",
          "args": [
            "tk",
            "TK_MIRROR | TK_CLOCK_WAS_SET"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "658-685",
          "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_set_wall_to_mono",
          "args": [
            "tk",
            "wall_to_mono"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "tk_set_wall_to_mono",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "131-146",
          "snippet": "static void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_set_xtime",
          "args": [
            "tk",
            "&wall_time"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "tk_set_xtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "118-122",
          "snippet": "static void tk_set_xtime(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec = ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec = (u64)ts->tv_nsec << tk->tkr_mono.shift;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_set_xtime(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec = ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec = (u64)ts->tv_nsec << tk->tkr_mono.shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_setup_internals",
          "args": [
            "tk",
            "clock"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "tk_setup_internals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "284-345",
          "snippet": "static void tk_setup_internals(struct timekeeper *tk, struct clocksource *clock)\n{\n\tu64 interval;\n\tu64 tmp, ntpinterval;\n\tstruct clocksource *old_clock;\n\n\t++tk->cs_was_changed_seq;\n\told_clock = tk->tkr_mono.clock;\n\ttk->tkr_mono.clock = clock;\n\ttk->tkr_mono.mask = clock->mask;\n\ttk->tkr_mono.cycle_last = tk_clock_read(&tk->tkr_mono);\n\n\ttk->tkr_raw.clock = clock;\n\ttk->tkr_raw.mask = clock->mask;\n\ttk->tkr_raw.cycle_last = tk->tkr_mono.cycle_last;\n\n\t/* Do the ns -> cycle conversion first, using original mult */\n\ttmp = NTP_INTERVAL_LENGTH;\n\ttmp <<= clock->shift;\n\tntpinterval = tmp;\n\ttmp += clock->mult/2;\n\tdo_div(tmp, clock->mult);\n\tif (tmp == 0)\n\t\ttmp = 1;\n\n\tinterval = (u64) tmp;\n\ttk->cycle_interval = interval;\n\n\t/* Go back from cycles -> shifted ns */\n\ttk->xtime_interval = interval * clock->mult;\n\ttk->xtime_remainder = ntpinterval - tk->xtime_interval;\n\ttk->raw_interval = interval * clock->mult;\n\n\t /* if changing clocks, convert xtime_nsec shift units */\n\tif (old_clock) {\n\t\tint shift_change = clock->shift - old_clock->shift;\n\t\tif (shift_change < 0) {\n\t\t\ttk->tkr_mono.xtime_nsec >>= -shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec >>= -shift_change;\n\t\t} else {\n\t\t\ttk->tkr_mono.xtime_nsec <<= shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec <<= shift_change;\n\t\t}\n\t}\n\n\ttk->tkr_mono.shift = clock->shift;\n\ttk->tkr_raw.shift = clock->shift;\n\n\ttk->ntp_error = 0;\n\ttk->ntp_error_shift = NTP_SCALE_SHIFT - clock->shift;\n\ttk->ntp_tick = ntpinterval << tk->ntp_error_shift;\n\n\t/*\n\t * The timekeeper keeps its own mult values for the currently\n\t * active clocksource. These value will be adjusted via NTP\n\t * to counteract clock drifting.\n\t */\n\ttk->tkr_mono.mult = clock->mult;\n\ttk->tkr_raw.mult = clock->mult;\n\ttk->ntp_err_mult = 0;\n\ttk->skip_second_overflow = 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_setup_internals(struct timekeeper *tk, struct clocksource *clock)\n{\n\tu64 interval;\n\tu64 tmp, ntpinterval;\n\tstruct clocksource *old_clock;\n\n\t++tk->cs_was_changed_seq;\n\told_clock = tk->tkr_mono.clock;\n\ttk->tkr_mono.clock = clock;\n\ttk->tkr_mono.mask = clock->mask;\n\ttk->tkr_mono.cycle_last = tk_clock_read(&tk->tkr_mono);\n\n\ttk->tkr_raw.clock = clock;\n\ttk->tkr_raw.mask = clock->mask;\n\ttk->tkr_raw.cycle_last = tk->tkr_mono.cycle_last;\n\n\t/* Do the ns -> cycle conversion first, using original mult */\n\ttmp = NTP_INTERVAL_LENGTH;\n\ttmp <<= clock->shift;\n\tntpinterval = tmp;\n\ttmp += clock->mult/2;\n\tdo_div(tmp, clock->mult);\n\tif (tmp == 0)\n\t\ttmp = 1;\n\n\tinterval = (u64) tmp;\n\ttk->cycle_interval = interval;\n\n\t/* Go back from cycles -> shifted ns */\n\ttk->xtime_interval = interval * clock->mult;\n\ttk->xtime_remainder = ntpinterval - tk->xtime_interval;\n\ttk->raw_interval = interval * clock->mult;\n\n\t /* if changing clocks, convert xtime_nsec shift units */\n\tif (old_clock) {\n\t\tint shift_change = clock->shift - old_clock->shift;\n\t\tif (shift_change < 0) {\n\t\t\ttk->tkr_mono.xtime_nsec >>= -shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec >>= -shift_change;\n\t\t} else {\n\t\t\ttk->tkr_mono.xtime_nsec <<= shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec <<= shift_change;\n\t\t}\n\t}\n\n\ttk->tkr_mono.shift = clock->shift;\n\ttk->tkr_raw.shift = clock->shift;\n\n\ttk->ntp_error = 0;\n\ttk->ntp_error_shift = NTP_SCALE_SHIFT - clock->shift;\n\ttk->ntp_tick = ntpinterval << tk->ntp_error_shift;\n\n\t/*\n\t * The timekeeper keeps its own mult values for the currently\n\t * active clocksource. These value will be adjusted via NTP\n\t * to counteract clock drifting.\n\t */\n\ttk->tkr_mono.mult = clock->mult;\n\ttk->tkr_raw.mult = clock->mult;\n\ttk->ntp_err_mult = 0;\n\ttk->skip_second_overflow = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clock->enable",
          "args": [
            "clock"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_default_clock",
          "args": [],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_default_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/jiffies.c",
          "lines": "103-106",
          "snippet": "__weak clocksource_default_clock(void)\n{\n\treturn &clocksource_jiffies;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource clocksource_jiffies = {\n\t.name\t\t= \"jiffies\",\n\t.rating\t\t= 1, /* lowest valid rating*/\n\t.read\t\t= jiffies_read,\n\t.mask\t\t= CLOCKSOURCE_MASK(32),\n\t.mult\t\t= TICK_NSEC << JIFFIES_SHIFT, /* details above */\n\t.shift\t\t= JIFFIES_SHIFT,\n\t.max_cycles\t= 10,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n\nstatic struct clocksource clocksource_jiffies = {\n\t.name\t\t= \"jiffies\",\n\t.rating\t\t= 1, /* lowest valid rating*/\n\t.read\t\t= jiffies_read,\n\t.mask\t\t= CLOCKSOURCE_MASK(32),\n\t.mult\t\t= TICK_NSEC << JIFFIES_SHIFT, /* details above */\n\t.shift\t\t= JIFFIES_SHIFT,\n\t.max_cycles\t= 10,\n};\n\n__weak clocksource_default_clock(void)\n{\n\treturn &clocksource_jiffies;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntp_init",
          "args": [],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "1033-1036",
          "snippet": "void __init ntp_init(void)\n{\n\tntp_clear();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nvoid __init ntp_init(void)\n{\n\tntp_clear();\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "boot_offset",
            "wall_time"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_compare",
          "args": [
            "&wall_time",
            "&boot_offset"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Persistent clock returned invalid value\""
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ns",
          "args": [
            "&wall_time"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ns",
          "args": [
            "&wall_time"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_valid_strict",
          "args": [
            "&wall_time"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_persistent_wall_and_boot_offset",
          "args": [
            "&wall_time",
            "&boot_offset"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "read_persistent_wall_and_boot_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1504-1510",
          "snippet": "__init\nread_persistent_wall_and_boot_offset(struct timespec64 *wall_time,\n\t\t\t\t     struct timespec64 *boot_offset)\n{\n\tread_persistent_clock64(wall_time);\n\t*boot_offset = ns_to_timespec64(local_clock());\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n__init\nread_persistent_wall_and_boot_offset(struct timespec64 *wall_time,\n\t\t\t\t     struct timespec64 *boot_offset)\n{\n\tread_persistent_clock64(wall_time);\n\t*boot_offset = ns_to_timespec64(local_clock());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n\nstatic DEFINE_RAW_SPINLOCK(timekeeper_lock);\nstatic bool persistent_clock_exists;\n\nvoid __init timekeeping_init(void)\n{\n\tstruct timespec64 wall_time, boot_offset, wall_to_mono;\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct clocksource *clock;\n\tunsigned long flags;\n\n\tread_persistent_wall_and_boot_offset(&wall_time, &boot_offset);\n\tif (timespec64_valid_strict(&wall_time) &&\n\t    timespec64_to_ns(&wall_time) > 0) {\n\t\tpersistent_clock_exists = true;\n\t} else if (timespec64_to_ns(&wall_time) != 0) {\n\t\tpr_warn(\"Persistent clock returned invalid value\");\n\t\twall_time = (struct timespec64){0};\n\t}\n\n\tif (timespec64_compare(&wall_time, &boot_offset) < 0)\n\t\tboot_offset = (struct timespec64){0};\n\n\t/*\n\t * We want set wall_to_mono, so the following is true:\n\t * wall time + wall_to_mono = boot time\n\t */\n\twall_to_mono = timespec64_sub(boot_offset, wall_time);\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\tntp_init();\n\n\tclock = clocksource_default_clock();\n\tif (clock->enable)\n\t\tclock->enable(clock);\n\ttk_setup_internals(tk, clock);\n\n\ttk_set_xtime(tk, &wall_time);\n\ttk->raw_sec = 0;\n\n\ttk_set_wall_to_mono(tk, wall_to_mono);\n\n\ttimekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n}"
  },
  {
    "function_name": "read_persistent_wall_and_boot_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1504-1510",
    "snippet": "__init\nread_persistent_wall_and_boot_offset(struct timespec64 *wall_time,\n\t\t\t\t     struct timespec64 *boot_offset)\n{\n\tread_persistent_clock64(wall_time);\n\t*boot_offset = ns_to_timespec64(local_clock());\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_to_timespec64",
          "args": [
            "local_clock()"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "ns_to_timespec64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "522-538",
          "snippet": "struct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts;\n\ts32 rem;\n\n\tif (!nsec)\n\t\treturn (struct timespec64) {0, 0};\n\n\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (unlikely(rem < 0)) {\n\t\tts.tv_sec--;\n\t\trem += NSEC_PER_SEC;\n\t}\n\tts.tv_nsec = rem;\n\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 ns_to_timespec64(const s64 nsec)\n{\n\tstruct timespec64 ts;\n\ts32 rem;\n\n\tif (!nsec)\n\t\treturn (struct timespec64) {0, 0};\n\n\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (unlikely(rem < 0)) {\n\t\tts.tv_sec--;\n\t\trem += NSEC_PER_SEC;\n\t}\n\tts.tv_nsec = rem;\n\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_clock",
          "args": [],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_persistent_clock64",
          "args": [
            "wall_time"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "read_persistent_clock64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1484-1490",
          "snippet": "void __weak read_persistent_clock64(struct timespec64 *ts64)\n{\n\tstruct timespec ts;\n\n\tread_persistent_clock(&ts);\n\t*ts64 = timespec_to_timespec64(ts);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __weak"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid __weak;\n\nvoid __weak read_persistent_clock64(struct timespec64 *ts64)\n{\n\tstruct timespec ts;\n\n\tread_persistent_clock(&ts);\n\t*ts64 = timespec_to_timespec64(ts);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n__init\nread_persistent_wall_and_boot_offset(struct timespec64 *wall_time,\n\t\t\t\t     struct timespec64 *boot_offset)\n{\n\tread_persistent_clock64(wall_time);\n\t*boot_offset = ns_to_timespec64(local_clock());\n}"
  },
  {
    "function_name": "read_persistent_clock64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1484-1490",
    "snippet": "void __weak read_persistent_clock64(struct timespec64 *ts64)\n{\n\tstruct timespec ts;\n\n\tread_persistent_clock(&ts);\n\t*ts64 = timespec_to_timespec64(ts);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void __weak"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timespec_to_timespec64",
          "args": [
            "ts"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_persistent_clock",
          "args": [
            "&ts"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "read_persistent_clock64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1484-1490",
          "snippet": "void __weak read_persistent_clock64(struct timespec64 *ts64)\n{\n\tstruct timespec ts;\n\n\tread_persistent_clock(&ts);\n\t*ts64 = timespec_to_timespec64(ts);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid __weak;\n\nvoid __weak read_persistent_clock64(struct timespec64 *ts64)\n{\n\tstruct timespec ts;\n\n\tread_persistent_clock(&ts);\n\t*ts64 = timespec_to_timespec64(ts);\n}"
  },
  {
    "function_name": "read_persistent_clock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1478-1482",
    "snippet": "void __weak read_persistent_clock(struct timespec *ts)\n{\n\tts->tv_sec = 0;\n\tts->tv_nsec = 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void __weak"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid __weak;\n\nvoid __weak read_persistent_clock(struct timespec *ts)\n{\n\tts->tv_sec = 0;\n\tts->tv_nsec = 0;\n}"
  },
  {
    "function_name": "timekeeping_max_deferment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1453-1467",
    "snippet": "u64 timekeeping_max_deferment(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->max_idle_ns;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 timekeeping_max_deferment(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->max_idle_ns;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "timekeeping_valid_for_hres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1434-1448",
    "snippet": "int timekeeping_valid_for_hres(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tint ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->flags & CLOCK_SOURCE_VALID_FOR_HRES;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nint timekeeping_valid_for_hres(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tint ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tret = tk->tkr_mono.clock->flags & CLOCK_SOURCE_VALID_FOR_HRES;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ktime_get_raw_ts64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1412-1427",
    "snippet": "void ktime_get_raw_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tts->tv_sec = tk->raw_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_raw);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timespec64_add_ns",
          "args": [
            "ts",
            "nsecs"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_get_ns",
          "args": [
            "&tk->tkr_raw"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_get_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "367-373",
          "snippet": "static inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_raw_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tts->tv_sec = tk->raw_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_raw);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}"
  },
  {
    "function_name": "timekeeping_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1395-1404",
    "snippet": "int timekeeping_notify(struct clocksource *clock)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tif (tk->tkr_mono.clock == clock)\n\t\treturn 0;\n\tstop_machine(change_clocksource, clock, NULL);\n\ttick_clock_notify();\n\treturn tk->tkr_mono.clock == clock ? 0 : -1;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_clock_notify",
          "args": [],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "tick_clock_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "1345-1351",
          "snippet": "void tick_clock_notify(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tset_bit(0, &per_cpu(tick_cpu_sched, cpu).check_clocks);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nvoid tick_clock_notify(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tset_bit(0, &per_cpu(tick_cpu_sched, cpu).check_clocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_machine",
          "args": [
            "change_clocksource",
            "clock",
            "NULL"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "stop_machine_from_inactive_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stop_machine.c",
          "lines": "653-682",
          "snippet": "int stop_machine_from_inactive_cpu(cpu_stop_fn_t fn, void *data,\n\t\t\t\t  const struct cpumask *cpus)\n{\n\tstruct multi_stop_data msdata = { .fn = fn, .data = data,\n\t\t\t\t\t    .active_cpus = cpus };\n\tstruct cpu_stop_done done;\n\tint ret;\n\n\t/* Local CPU must be inactive and CPU hotplug in progress. */\n\tBUG_ON(cpu_active(raw_smp_processor_id()));\n\tmsdata.num_threads = num_active_cpus() + 1;\t/* +1 for local */\n\n\t/* No proper task established and can't sleep - busy wait for lock. */\n\twhile (!mutex_trylock(&stop_cpus_mutex))\n\t\tcpu_relax();\n\n\t/* Schedule work on other CPUs and execute directly for local CPU */\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\tcpu_stop_init_done(&done, num_active_cpus());\n\tqueue_stop_cpus_work(cpu_active_mask, multi_cpu_stop, &msdata,\n\t\t\t     &done);\n\tret = multi_cpu_stop(&msdata);\n\n\t/* Busy wait for completion. */\n\twhile (!completion_done(&done.completion))\n\t\tcpu_relax();\n\n\tmutex_unlock(&stop_cpus_mutex);\n\treturn ret ?: done.ret;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(stop_cpus_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n\nstatic DEFINE_MUTEX(stop_cpus_mutex);\n\nint stop_machine_from_inactive_cpu(cpu_stop_fn_t fn, void *data,\n\t\t\t\t  const struct cpumask *cpus)\n{\n\tstruct multi_stop_data msdata = { .fn = fn, .data = data,\n\t\t\t\t\t    .active_cpus = cpus };\n\tstruct cpu_stop_done done;\n\tint ret;\n\n\t/* Local CPU must be inactive and CPU hotplug in progress. */\n\tBUG_ON(cpu_active(raw_smp_processor_id()));\n\tmsdata.num_threads = num_active_cpus() + 1;\t/* +1 for local */\n\n\t/* No proper task established and can't sleep - busy wait for lock. */\n\twhile (!mutex_trylock(&stop_cpus_mutex))\n\t\tcpu_relax();\n\n\t/* Schedule work on other CPUs and execute directly for local CPU */\n\tset_state(&msdata, MULTI_STOP_PREPARE);\n\tcpu_stop_init_done(&done, num_active_cpus());\n\tqueue_stop_cpus_work(cpu_active_mask, multi_cpu_stop, &msdata,\n\t\t\t     &done);\n\tret = multi_cpu_stop(&msdata);\n\n\t/* Busy wait for completion. */\n\twhile (!completion_done(&done.completion))\n\t\tcpu_relax();\n\n\tmutex_unlock(&stop_cpus_mutex);\n\treturn ret ?: done.ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nint timekeeping_notify(struct clocksource *clock)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tif (tk->tkr_mono.clock == clock)\n\t\treturn 0;\n\tstop_machine(change_clocksource, clock, NULL);\n\ttick_clock_notify();\n\treturn tk->tkr_mono.clock == clock ? 0 : -1;\n}"
  },
  {
    "function_name": "change_clocksource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1353-1386",
    "snippet": "static int change_clocksource(void *data)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct clocksource *new, *old;\n\tunsigned long flags;\n\n\tnew = (struct clocksource *) data;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\t/*\n\t * If the cs is in module, get a module reference. Succeeds\n\t * for built-in code (owner == NULL) as well.\n\t */\n\tif (try_module_get(new->owner)) {\n\t\tif (!new->enable || new->enable(new) == 0) {\n\t\t\told = tk->tkr_mono.clock;\n\t\t\ttk_setup_internals(tk, new);\n\t\t\tif (old->disable)\n\t\t\t\told->disable(old);\n\t\t\tmodule_put(old->owner);\n\t\t} else {\n\t\t\tmodule_put(new->owner);\n\t\t}\n\t}\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_CLOCK_WAS_SET\t(1 << 2)",
      "#define TK_MIRROR\t\t(1 << 1)",
      "#define TK_CLEAR_NTP\t\t(1 << 0)"
    ],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(timekeeper_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_update",
          "args": [
            "tk",
            "TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "658-685",
          "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "new->owner"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1132-1143",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "old->disable",
          "args": [
            "old"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_setup_internals",
          "args": [
            "tk",
            "new"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "tk_setup_internals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "284-345",
          "snippet": "static void tk_setup_internals(struct timekeeper *tk, struct clocksource *clock)\n{\n\tu64 interval;\n\tu64 tmp, ntpinterval;\n\tstruct clocksource *old_clock;\n\n\t++tk->cs_was_changed_seq;\n\told_clock = tk->tkr_mono.clock;\n\ttk->tkr_mono.clock = clock;\n\ttk->tkr_mono.mask = clock->mask;\n\ttk->tkr_mono.cycle_last = tk_clock_read(&tk->tkr_mono);\n\n\ttk->tkr_raw.clock = clock;\n\ttk->tkr_raw.mask = clock->mask;\n\ttk->tkr_raw.cycle_last = tk->tkr_mono.cycle_last;\n\n\t/* Do the ns -> cycle conversion first, using original mult */\n\ttmp = NTP_INTERVAL_LENGTH;\n\ttmp <<= clock->shift;\n\tntpinterval = tmp;\n\ttmp += clock->mult/2;\n\tdo_div(tmp, clock->mult);\n\tif (tmp == 0)\n\t\ttmp = 1;\n\n\tinterval = (u64) tmp;\n\ttk->cycle_interval = interval;\n\n\t/* Go back from cycles -> shifted ns */\n\ttk->xtime_interval = interval * clock->mult;\n\ttk->xtime_remainder = ntpinterval - tk->xtime_interval;\n\ttk->raw_interval = interval * clock->mult;\n\n\t /* if changing clocks, convert xtime_nsec shift units */\n\tif (old_clock) {\n\t\tint shift_change = clock->shift - old_clock->shift;\n\t\tif (shift_change < 0) {\n\t\t\ttk->tkr_mono.xtime_nsec >>= -shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec >>= -shift_change;\n\t\t} else {\n\t\t\ttk->tkr_mono.xtime_nsec <<= shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec <<= shift_change;\n\t\t}\n\t}\n\n\ttk->tkr_mono.shift = clock->shift;\n\ttk->tkr_raw.shift = clock->shift;\n\n\ttk->ntp_error = 0;\n\ttk->ntp_error_shift = NTP_SCALE_SHIFT - clock->shift;\n\ttk->ntp_tick = ntpinterval << tk->ntp_error_shift;\n\n\t/*\n\t * The timekeeper keeps its own mult values for the currently\n\t * active clocksource. These value will be adjusted via NTP\n\t * to counteract clock drifting.\n\t */\n\ttk->tkr_mono.mult = clock->mult;\n\ttk->tkr_raw.mult = clock->mult;\n\ttk->ntp_err_mult = 0;\n\ttk->skip_second_overflow = 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_setup_internals(struct timekeeper *tk, struct clocksource *clock)\n{\n\tu64 interval;\n\tu64 tmp, ntpinterval;\n\tstruct clocksource *old_clock;\n\n\t++tk->cs_was_changed_seq;\n\told_clock = tk->tkr_mono.clock;\n\ttk->tkr_mono.clock = clock;\n\ttk->tkr_mono.mask = clock->mask;\n\ttk->tkr_mono.cycle_last = tk_clock_read(&tk->tkr_mono);\n\n\ttk->tkr_raw.clock = clock;\n\ttk->tkr_raw.mask = clock->mask;\n\ttk->tkr_raw.cycle_last = tk->tkr_mono.cycle_last;\n\n\t/* Do the ns -> cycle conversion first, using original mult */\n\ttmp = NTP_INTERVAL_LENGTH;\n\ttmp <<= clock->shift;\n\tntpinterval = tmp;\n\ttmp += clock->mult/2;\n\tdo_div(tmp, clock->mult);\n\tif (tmp == 0)\n\t\ttmp = 1;\n\n\tinterval = (u64) tmp;\n\ttk->cycle_interval = interval;\n\n\t/* Go back from cycles -> shifted ns */\n\ttk->xtime_interval = interval * clock->mult;\n\ttk->xtime_remainder = ntpinterval - tk->xtime_interval;\n\ttk->raw_interval = interval * clock->mult;\n\n\t /* if changing clocks, convert xtime_nsec shift units */\n\tif (old_clock) {\n\t\tint shift_change = clock->shift - old_clock->shift;\n\t\tif (shift_change < 0) {\n\t\t\ttk->tkr_mono.xtime_nsec >>= -shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec >>= -shift_change;\n\t\t} else {\n\t\t\ttk->tkr_mono.xtime_nsec <<= shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec <<= shift_change;\n\t\t}\n\t}\n\n\ttk->tkr_mono.shift = clock->shift;\n\ttk->tkr_raw.shift = clock->shift;\n\n\ttk->ntp_error = 0;\n\ttk->ntp_error_shift = NTP_SCALE_SHIFT - clock->shift;\n\ttk->ntp_tick = ntpinterval << tk->ntp_error_shift;\n\n\t/*\n\t * The timekeeper keeps its own mult values for the currently\n\t * active clocksource. These value will be adjusted via NTP\n\t * to counteract clock drifting.\n\t */\n\ttk->tkr_mono.mult = clock->mult;\n\ttk->tkr_raw.mult = clock->mult;\n\ttk->ntp_err_mult = 0;\n\ttk->skip_second_overflow = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new->enable",
          "args": [
            "new"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "new->owner"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1113-1129",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_forward_now",
          "args": [
            "tk"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_forward_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "694-715",
          "snippet": "static void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_mono.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_mono.shift;\n\n\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_raw.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_raw.shift;\n\n\ttk_normalize_xtime(tk);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_mono.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_mono.shift;\n\n\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_raw.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_raw.shift;\n\n\ttk_normalize_xtime(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic DEFINE_RAW_SPINLOCK(timekeeper_lock);\n\nstatic int change_clocksource(void *data)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct clocksource *new, *old;\n\tunsigned long flags;\n\n\tnew = (struct clocksource *) data;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\t/*\n\t * If the cs is in module, get a module reference. Succeeds\n\t * for built-in code (owner == NULL) as well.\n\t */\n\tif (try_module_get(new->owner)) {\n\t\tif (!new->enable || new->enable(new) == 0) {\n\t\t\told = tk->tkr_mono.clock;\n\t\t\ttk_setup_internals(tk, new);\n\t\t\tif (old->disable)\n\t\t\t\told->disable(old);\n\t\t\tmodule_put(old->owner);\n\t\t} else {\n\t\t\tmodule_put(new->owner);\n\t\t}\n\t}\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__timekeeping_set_tai_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1342-1346",
    "snippet": "static void __timekeeping_set_tai_offset(struct timekeeper *tk, s32 tai_offset)\n{\n\ttk->tai_offset = tai_offset;\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tai_offset, 0));\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "tk->offs_real",
            "ktime_set(tai_offset, 0)"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_set",
          "args": [
            "tai_offset",
            "0"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void __timekeeping_set_tai_offset(struct timekeeper *tk, s32 tai_offset)\n{\n\ttk->tai_offset = tai_offset;\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tai_offset, 0));\n}"
  },
  {
    "function_name": "timekeeping_warp_clock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1326-1336",
    "snippet": "void timekeeping_warp_clock(void)\n{\n\tif (sys_tz.tz_minuteswest != 0) {\n\t\tstruct timespec64 adjust;\n\n\t\tpersistent_clock_is_local = 1;\n\t\tadjust.tv_sec = sys_tz.tz_minuteswest * 60;\n\t\tadjust.tv_nsec = 0;\n\t\ttimekeeping_inject_offset(&adjust);\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int persistent_clock_is_local;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timekeeping_inject_offset",
          "args": [
            "&adjust"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_inject_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1266-1302",
          "snippet": "static int timekeeping_inject_offset(const struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64 tmp;\n\tint ret = 0;\n\n\tif (ts->tv_nsec < 0 || ts->tv_nsec >= NSEC_PER_SEC)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\t/* Make sure the proposed value is valid */\n\ttmp = timespec64_add(tk_xtime(tk), *ts);\n\tif (timespec64_compare(&tk->wall_to_monotonic, ts) > 0 ||\n\t    !timespec64_valid_strict(&tmp)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk_xtime_add(tk, ts);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *ts));\n\nerror: /* even if we error out, we forwarded the time, so call update */\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* signal hrtimers about time change */\n\tclock_was_set();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static DEFINE_RAW_SPINLOCK(timekeeper_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic DEFINE_RAW_SPINLOCK(timekeeper_lock);\n\nstatic int timekeeping_inject_offset(const struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64 tmp;\n\tint ret = 0;\n\n\tif (ts->tv_nsec < 0 || ts->tv_nsec >= NSEC_PER_SEC)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\t/* Make sure the proposed value is valid */\n\ttmp = timespec64_add(tk_xtime(tk), *ts);\n\tif (timespec64_compare(&tk->wall_to_monotonic, ts) > 0 ||\n\t    !timespec64_valid_strict(&tmp)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk_xtime_add(tk, ts);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *ts));\n\nerror: /* even if we error out, we forwarded the time, so call update */\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* signal hrtimers about time change */\n\tclock_was_set();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nint persistent_clock_is_local;\n\nvoid timekeeping_warp_clock(void)\n{\n\tif (sys_tz.tz_minuteswest != 0) {\n\t\tstruct timespec64 adjust;\n\n\t\tpersistent_clock_is_local = 1;\n\t\tadjust.tv_sec = sys_tz.tz_minuteswest * 60;\n\t\tadjust.tv_nsec = 0;\n\t\ttimekeeping_inject_offset(&adjust);\n\t}\n}"
  },
  {
    "function_name": "timekeeping_inject_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1266-1302",
    "snippet": "static int timekeeping_inject_offset(const struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64 tmp;\n\tint ret = 0;\n\n\tif (ts->tv_nsec < 0 || ts->tv_nsec >= NSEC_PER_SEC)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\t/* Make sure the proposed value is valid */\n\ttmp = timespec64_add(tk_xtime(tk), *ts);\n\tif (timespec64_compare(&tk->wall_to_monotonic, ts) > 0 ||\n\t    !timespec64_valid_strict(&tmp)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk_xtime_add(tk, ts);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *ts));\n\nerror: /* even if we error out, we forwarded the time, so call update */\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* signal hrtimers about time change */\n\tclock_was_set();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_CLOCK_WAS_SET\t(1 << 2)",
      "#define TK_MIRROR\t\t(1 << 1)",
      "#define TK_CLEAR_NTP\t\t(1 << 0)"
    ],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(timekeeper_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clock_was_set",
          "args": [],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "clock_was_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "857-864",
          "snippet": "void clock_was_set(void)\n{\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t/* Retrigger the CPU local events everywhere */\n\ton_each_cpu(retrigger_next_event, NULL, 1);\n#endif\n\ttimerfd_clock_was_set();\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid clock_was_set(void)\n{\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t/* Retrigger the CPU local events everywhere */\n\ton_each_cpu(retrigger_next_event, NULL, 1);\n#endif\n\ttimerfd_clock_was_set();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_update",
          "args": [
            "tk",
            "TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "658-685",
          "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_set_wall_to_mono",
          "args": [
            "tk",
            "timespec64_sub(tk->wall_to_monotonic, *ts)"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "tk_set_wall_to_mono",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "131-146",
          "snippet": "static void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "tk->wall_to_monotonic",
            "*ts"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_xtime_add",
          "args": [
            "tk",
            "ts"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "tk_xtime_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "124-129",
          "snippet": "static void tk_xtime_add(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec += ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec += (u64)ts->tv_nsec << tk->tkr_mono.shift;\n\ttk_normalize_xtime(tk);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_xtime_add(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec += ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec += (u64)ts->tv_nsec << tk->tkr_mono.shift;\n\ttk_normalize_xtime(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_valid_strict",
          "args": [
            "&tmp"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_compare",
          "args": [
            "&tk->wall_to_monotonic",
            "ts"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_add",
          "args": [
            "tk_xtime(tk)",
            "*ts"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "timespec64_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "816-830",
          "snippet": "struct timespec64 timespec64_add_safe(const struct timespec64 lhs,\n\t\t\t\tconst struct timespec64 rhs)\n{\n\tstruct timespec64 res;\n\n\tset_normalized_timespec64(&res, (timeu64_t) lhs.tv_sec + rhs.tv_sec,\n\t\t\tlhs.tv_nsec + rhs.tv_nsec);\n\n\tif (unlikely(res.tv_sec < lhs.tv_sec || res.tv_sec < rhs.tv_sec)) {\n\t\tres.tv_sec = TIME64_MAX;\n\t\tres.tv_nsec = 0;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 timespec64_add_safe(const struct timespec64 lhs,\n\t\t\t\tconst struct timespec64 rhs)\n{\n\tstruct timespec64 res;\n\n\tset_normalized_timespec64(&res, (timeu64_t) lhs.tv_sec + rhs.tv_sec,\n\t\t\tlhs.tv_nsec + rhs.tv_nsec);\n\n\tif (unlikely(res.tv_sec < lhs.tv_sec || res.tv_sec < rhs.tv_sec)) {\n\t\tres.tv_sec = TIME64_MAX;\n\t\tres.tv_nsec = 0;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_xtime",
          "args": [
            "tk"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "tk_xtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "109-116",
          "snippet": "static inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_forward_now",
          "args": [
            "tk"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_forward_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "694-715",
          "snippet": "static void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_mono.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_mono.shift;\n\n\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_raw.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_raw.shift;\n\n\ttk_normalize_xtime(tk);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_mono.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_mono.shift;\n\n\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_raw.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_raw.shift;\n\n\ttk_normalize_xtime(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic DEFINE_RAW_SPINLOCK(timekeeper_lock);\n\nstatic int timekeeping_inject_offset(const struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tstruct timespec64 tmp;\n\tint ret = 0;\n\n\tif (ts->tv_nsec < 0 || ts->tv_nsec >= NSEC_PER_SEC)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\t/* Make sure the proposed value is valid */\n\ttmp = timespec64_add(tk_xtime(tk), *ts);\n\tif (timespec64_compare(&tk->wall_to_monotonic, ts) > 0 ||\n\t    !timespec64_valid_strict(&tmp)) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\ttk_xtime_add(tk, ts);\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, *ts));\n\nerror: /* even if we error out, we forwarded the time, so call update */\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* signal hrtimers about time change */\n\tclock_was_set();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "do_settimeofday64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1220-1257",
    "snippet": "int do_settimeofday64(const struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 ts_delta, xt;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!timespec64_valid_strict(ts))\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\txt = tk_xtime(tk);\n\tts_delta.tv_sec = ts->tv_sec - xt.tv_sec;\n\tts_delta.tv_nsec = ts->tv_nsec - xt.tv_nsec;\n\n\tif (timespec64_compare(&tk->wall_to_monotonic, &ts_delta) > 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, ts_delta));\n\n\ttk_set_xtime(tk, ts);\nout:\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* signal hrtimers about time change */\n\tclock_was_set();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_CLOCK_WAS_SET\t(1 << 2)",
      "#define TK_MIRROR\t\t(1 << 1)",
      "#define TK_CLEAR_NTP\t\t(1 << 0)"
    ],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(timekeeper_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clock_was_set",
          "args": [],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "clock_was_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "857-864",
          "snippet": "void clock_was_set(void)\n{\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t/* Retrigger the CPU local events everywhere */\n\ton_each_cpu(retrigger_next_event, NULL, 1);\n#endif\n\ttimerfd_clock_was_set();\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid clock_was_set(void)\n{\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t/* Retrigger the CPU local events everywhere */\n\ton_each_cpu(retrigger_next_event, NULL, 1);\n#endif\n\ttimerfd_clock_was_set();\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_update",
          "args": [
            "tk",
            "TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "658-685",
          "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [
            "#define TK_CLOCK_WAS_SET\t(1 << 2)",
            "#define TK_MIRROR\t\t(1 << 1)",
            "#define TK_CLEAR_NTP\t\t(1 << 0)"
          ],
          "globals_used": [
            "static struct timekeeper shadow_timekeeper;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_set_xtime",
          "args": [
            "tk",
            "ts"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "tk_set_xtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "118-122",
          "snippet": "static void tk_set_xtime(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec = ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec = (u64)ts->tv_nsec << tk->tkr_mono.shift;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_set_xtime(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec = ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec = (u64)ts->tv_nsec << tk->tkr_mono.shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_set_wall_to_mono",
          "args": [
            "tk",
            "timespec64_sub(tk->wall_to_monotonic, ts_delta)"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "tk_set_wall_to_mono",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "131-146",
          "snippet": "static void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "tk->wall_to_monotonic",
            "ts_delta"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_compare",
          "args": [
            "&tk->wall_to_monotonic",
            "&ts_delta"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_xtime",
          "args": [
            "tk"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "tk_xtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "109-116",
          "snippet": "static inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_forward_now",
          "args": [
            "tk"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_forward_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "694-715",
          "snippet": "static void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_mono.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_mono.shift;\n\n\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_raw.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_raw.shift;\n\n\ttk_normalize_xtime(tk);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_mono.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_mono.shift;\n\n\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_raw.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_raw.shift;\n\n\ttk_normalize_xtime(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_valid_strict",
          "args": [
            "ts"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic DEFINE_RAW_SPINLOCK(timekeeper_lock);\n\nint do_settimeofday64(const struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 ts_delta, xt;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!timespec64_valid_strict(ts))\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\twrite_seqcount_begin(&tk_core.seq);\n\n\ttimekeeping_forward_now(tk);\n\n\txt = tk_xtime(tk);\n\tts_delta.tv_sec = ts->tv_sec - xt.tv_sec;\n\tts_delta.tv_nsec = ts->tv_nsec - xt.tv_nsec;\n\n\tif (timespec64_compare(&tk->wall_to_monotonic, &ts_delta) > 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttk_set_wall_to_mono(tk, timespec64_sub(tk->wall_to_monotonic, ts_delta));\n\n\ttk_set_xtime(tk, ts);\nout:\n\ttimekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET);\n\n\twrite_seqcount_end(&tk_core.seq);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\t/* signal hrtimers about time change */\n\tclock_was_set();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "get_device_system_crosststamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1113-1211",
    "snippet": "int get_device_system_crosststamp(int (*get_time_fn)\n\t\t\t\t  (ktime_t *device_time,\n\t\t\t\t   struct system_counterval_t *sys_counterval,\n\t\t\t\t   void *ctx),\n\t\t\t\t  void *ctx,\n\t\t\t\t  struct system_time_snapshot *history_begin,\n\t\t\t\t  struct system_device_crosststamp *xtstamp)\n{\n\tstruct system_counterval_t system_counterval;\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tu64 cycles, now, interval_start;\n\tunsigned int clock_was_set_seq = 0;\n\tktime_t base_real, base_raw;\n\tu64 nsec_real, nsec_raw;\n\tu8 cs_was_changed_seq;\n\tunsigned long seq;\n\tbool do_interp;\n\tint ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\t/*\n\t\t * Try to synchronously capture device time and a system\n\t\t * counter value calling back into the device driver\n\t\t */\n\t\tret = get_time_fn(&xtstamp->device, &system_counterval, ctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * Verify that the clocksource associated with the captured\n\t\t * system counter value is the same as the currently installed\n\t\t * timekeeper clocksource\n\t\t */\n\t\tif (tk->tkr_mono.clock != system_counterval.cs)\n\t\t\treturn -ENODEV;\n\t\tcycles = system_counterval.cycles;\n\n\t\t/*\n\t\t * Check whether the system counter value provided by the\n\t\t * device driver is on the current timekeeping interval.\n\t\t */\n\t\tnow = tk_clock_read(&tk->tkr_mono);\n\t\tinterval_start = tk->tkr_mono.cycle_last;\n\t\tif (!cycle_between(interval_start, cycles, now)) {\n\t\t\tclock_was_set_seq = tk->clock_was_set_seq;\n\t\t\tcs_was_changed_seq = tk->cs_was_changed_seq;\n\t\t\tcycles = interval_start;\n\t\t\tdo_interp = true;\n\t\t} else {\n\t\t\tdo_interp = false;\n\t\t}\n\n\t\tbase_real = ktime_add(tk->tkr_mono.base,\n\t\t\t\t      tk_core.timekeeper.offs_real);\n\t\tbase_raw = tk->tkr_raw.base;\n\n\t\tnsec_real = timekeeping_cycles_to_ns(&tk->tkr_mono,\n\t\t\t\t\t\t     system_counterval.cycles);\n\t\tnsec_raw = timekeeping_cycles_to_ns(&tk->tkr_raw,\n\t\t\t\t\t\t    system_counterval.cycles);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\txtstamp->sys_realtime = ktime_add_ns(base_real, nsec_real);\n\txtstamp->sys_monoraw = ktime_add_ns(base_raw, nsec_raw);\n\n\t/*\n\t * Interpolate if necessary, adjusting back from the start of the\n\t * current interval\n\t */\n\tif (do_interp) {\n\t\tu64 partial_history_cycles, total_history_cycles;\n\t\tbool discontinuity;\n\n\t\t/*\n\t\t * Check that the counter value occurs after the provided\n\t\t * history reference and that the history doesn't cross a\n\t\t * clocksource change\n\t\t */\n\t\tif (!history_begin ||\n\t\t    !cycle_between(history_begin->cycles,\n\t\t\t\t   system_counterval.cycles, cycles) ||\n\t\t    history_begin->cs_was_changed_seq != cs_was_changed_seq)\n\t\t\treturn -EINVAL;\n\t\tpartial_history_cycles = cycles - system_counterval.cycles;\n\t\ttotal_history_cycles = cycles - history_begin->cycles;\n\t\tdiscontinuity =\n\t\t\thistory_begin->clock_was_set_seq != clock_was_set_seq;\n\n\t\tret = adjust_historical_crosststamp(history_begin,\n\t\t\t\t\t\t    partial_history_cycles,\n\t\t\t\t\t\t    total_history_cycles,\n\t\t\t\t\t\t    discontinuity, xtstamp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "adjust_historical_crosststamp",
          "args": [
            "history_begin",
            "partial_history_cycles",
            "total_history_cycles",
            "discontinuity",
            "xtstamp"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_historical_crosststamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1028-1088",
          "snippet": "static int adjust_historical_crosststamp(struct system_time_snapshot *history,\n\t\t\t\t\t u64 partial_history_cycles,\n\t\t\t\t\t u64 total_history_cycles,\n\t\t\t\t\t bool discontinuity,\n\t\t\t\t\t struct system_device_crosststamp *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tu64 corr_raw, corr_real;\n\tbool interp_forward;\n\tint ret;\n\n\tif (total_history_cycles == 0 || partial_history_cycles == 0)\n\t\treturn 0;\n\n\t/* Interpolate shortest distance from beginning or end of history */\n\tinterp_forward = partial_history_cycles > total_history_cycles / 2;\n\tpartial_history_cycles = interp_forward ?\n\t\ttotal_history_cycles - partial_history_cycles :\n\t\tpartial_history_cycles;\n\n\t/*\n\t * Scale the monotonic raw time delta by:\n\t *\tpartial_history_cycles / total_history_cycles\n\t */\n\tcorr_raw = (u64)ktime_to_ns(\n\t\tktime_sub(ts->sys_monoraw, history->raw));\n\tret = scale64_check_overflow(partial_history_cycles,\n\t\t\t\t     total_history_cycles, &corr_raw);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If there is a discontinuity in the history, scale monotonic raw\n\t *\tcorrection by:\n\t *\tmult(real)/mult(raw) yielding the realtime correction\n\t * Otherwise, calculate the realtime correction similar to monotonic\n\t *\traw calculation\n\t */\n\tif (discontinuity) {\n\t\tcorr_real = mul_u64_u32_div\n\t\t\t(corr_raw, tk->tkr_mono.mult, tk->tkr_raw.mult);\n\t} else {\n\t\tcorr_real = (u64)ktime_to_ns(\n\t\t\tktime_sub(ts->sys_realtime, history->real));\n\t\tret = scale64_check_overflow(partial_history_cycles,\n\t\t\t\t\t     total_history_cycles, &corr_real);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Fixup monotonic raw and real time time values */\n\tif (interp_forward) {\n\t\tts->sys_monoraw = ktime_add_ns(history->raw, corr_raw);\n\t\tts->sys_realtime = ktime_add_ns(history->real, corr_real);\n\t} else {\n\t\tts->sys_monoraw = ktime_sub_ns(ts->sys_monoraw, corr_raw);\n\t\tts->sys_realtime = ktime_sub_ns(ts->sys_realtime, corr_real);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic int adjust_historical_crosststamp(struct system_time_snapshot *history,\n\t\t\t\t\t u64 partial_history_cycles,\n\t\t\t\t\t u64 total_history_cycles,\n\t\t\t\t\t bool discontinuity,\n\t\t\t\t\t struct system_device_crosststamp *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tu64 corr_raw, corr_real;\n\tbool interp_forward;\n\tint ret;\n\n\tif (total_history_cycles == 0 || partial_history_cycles == 0)\n\t\treturn 0;\n\n\t/* Interpolate shortest distance from beginning or end of history */\n\tinterp_forward = partial_history_cycles > total_history_cycles / 2;\n\tpartial_history_cycles = interp_forward ?\n\t\ttotal_history_cycles - partial_history_cycles :\n\t\tpartial_history_cycles;\n\n\t/*\n\t * Scale the monotonic raw time delta by:\n\t *\tpartial_history_cycles / total_history_cycles\n\t */\n\tcorr_raw = (u64)ktime_to_ns(\n\t\tktime_sub(ts->sys_monoraw, history->raw));\n\tret = scale64_check_overflow(partial_history_cycles,\n\t\t\t\t     total_history_cycles, &corr_raw);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If there is a discontinuity in the history, scale monotonic raw\n\t *\tcorrection by:\n\t *\tmult(real)/mult(raw) yielding the realtime correction\n\t * Otherwise, calculate the realtime correction similar to monotonic\n\t *\traw calculation\n\t */\n\tif (discontinuity) {\n\t\tcorr_real = mul_u64_u32_div\n\t\t\t(corr_raw, tk->tkr_mono.mult, tk->tkr_raw.mult);\n\t} else {\n\t\tcorr_real = (u64)ktime_to_ns(\n\t\t\tktime_sub(ts->sys_realtime, history->real));\n\t\tret = scale64_check_overflow(partial_history_cycles,\n\t\t\t\t\t     total_history_cycles, &corr_real);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Fixup monotonic raw and real time time values */\n\tif (interp_forward) {\n\t\tts->sys_monoraw = ktime_add_ns(history->raw, corr_raw);\n\t\tts->sys_realtime = ktime_add_ns(history->real, corr_real);\n\t} else {\n\t\tts->sys_monoraw = ktime_sub_ns(ts->sys_monoraw, corr_raw);\n\t\tts->sys_realtime = ktime_sub_ns(ts->sys_realtime, corr_real);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cycle_between",
          "args": [
            "history_begin->cycles",
            "system_counterval.cycles",
            "cycles"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "cycle_between",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "1093-1100",
          "snippet": "static bool cycle_between(u64 before, u64 test, u64 after)\n{\n\tif (test > before && test < after)\n\t\treturn true;\n\tif (test < before && before > after)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic bool cycle_between(u64 before, u64 test, u64 after)\n{\n\tif (test > before && test < after)\n\t\treturn true;\n\tif (test < before && before > after)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "base_raw",
            "nsec_raw"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "base_real",
            "nsec_real"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_cycles_to_ns",
          "args": [
            "&tk->tkr_raw",
            "system_counterval.cycles"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_cycles_to_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "375-382",
          "snippet": "static inline u64 timekeeping_cycles_to_ns(const struct tk_read_base *tkr, u64 cycles)\n{\n\tu64 delta;\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycles, tkr->cycle_last, tkr->mask);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_cycles_to_ns(const struct tk_read_base *tkr, u64 cycles)\n{\n\tu64 delta;\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycles, tkr->cycle_last, tkr->mask);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "tk->tkr_mono.base",
            "tk_core.timekeeper.offs_real"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "166-171",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_time_fn",
          "args": [
            "&xtstamp->device",
            "&system_counterval",
            "ctx"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nint get_device_system_crosststamp(int (*get_time_fn)\n\t\t\t\t  (ktime_t *device_time,\n\t\t\t\t   struct system_counterval_t *sys_counterval,\n\t\t\t\t   void *ctx),\n\t\t\t\t  void *ctx,\n\t\t\t\t  struct system_time_snapshot *history_begin,\n\t\t\t\t  struct system_device_crosststamp *xtstamp)\n{\n\tstruct system_counterval_t system_counterval;\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tu64 cycles, now, interval_start;\n\tunsigned int clock_was_set_seq = 0;\n\tktime_t base_real, base_raw;\n\tu64 nsec_real, nsec_raw;\n\tu8 cs_was_changed_seq;\n\tunsigned long seq;\n\tbool do_interp;\n\tint ret;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\t/*\n\t\t * Try to synchronously capture device time and a system\n\t\t * counter value calling back into the device driver\n\t\t */\n\t\tret = get_time_fn(&xtstamp->device, &system_counterval, ctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * Verify that the clocksource associated with the captured\n\t\t * system counter value is the same as the currently installed\n\t\t * timekeeper clocksource\n\t\t */\n\t\tif (tk->tkr_mono.clock != system_counterval.cs)\n\t\t\treturn -ENODEV;\n\t\tcycles = system_counterval.cycles;\n\n\t\t/*\n\t\t * Check whether the system counter value provided by the\n\t\t * device driver is on the current timekeeping interval.\n\t\t */\n\t\tnow = tk_clock_read(&tk->tkr_mono);\n\t\tinterval_start = tk->tkr_mono.cycle_last;\n\t\tif (!cycle_between(interval_start, cycles, now)) {\n\t\t\tclock_was_set_seq = tk->clock_was_set_seq;\n\t\t\tcs_was_changed_seq = tk->cs_was_changed_seq;\n\t\t\tcycles = interval_start;\n\t\t\tdo_interp = true;\n\t\t} else {\n\t\t\tdo_interp = false;\n\t\t}\n\n\t\tbase_real = ktime_add(tk->tkr_mono.base,\n\t\t\t\t      tk_core.timekeeper.offs_real);\n\t\tbase_raw = tk->tkr_raw.base;\n\n\t\tnsec_real = timekeeping_cycles_to_ns(&tk->tkr_mono,\n\t\t\t\t\t\t     system_counterval.cycles);\n\t\tnsec_raw = timekeeping_cycles_to_ns(&tk->tkr_raw,\n\t\t\t\t\t\t    system_counterval.cycles);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\txtstamp->sys_realtime = ktime_add_ns(base_real, nsec_real);\n\txtstamp->sys_monoraw = ktime_add_ns(base_raw, nsec_raw);\n\n\t/*\n\t * Interpolate if necessary, adjusting back from the start of the\n\t * current interval\n\t */\n\tif (do_interp) {\n\t\tu64 partial_history_cycles, total_history_cycles;\n\t\tbool discontinuity;\n\n\t\t/*\n\t\t * Check that the counter value occurs after the provided\n\t\t * history reference and that the history doesn't cross a\n\t\t * clocksource change\n\t\t */\n\t\tif (!history_begin ||\n\t\t    !cycle_between(history_begin->cycles,\n\t\t\t\t   system_counterval.cycles, cycles) ||\n\t\t    history_begin->cs_was_changed_seq != cs_was_changed_seq)\n\t\t\treturn -EINVAL;\n\t\tpartial_history_cycles = cycles - system_counterval.cycles;\n\t\ttotal_history_cycles = cycles - history_begin->cycles;\n\t\tdiscontinuity =\n\t\t\thistory_begin->clock_was_set_seq != clock_was_set_seq;\n\n\t\tret = adjust_historical_crosststamp(history_begin,\n\t\t\t\t\t\t    partial_history_cycles,\n\t\t\t\t\t\t    total_history_cycles,\n\t\t\t\t\t\t    discontinuity, xtstamp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cycle_between",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1093-1100",
    "snippet": "static bool cycle_between(u64 before, u64 test, u64 after)\n{\n\tif (test > before && test < after)\n\t\treturn true;\n\tif (test < before && before > after)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic bool cycle_between(u64 before, u64 test, u64 after)\n{\n\tif (test > before && test < after)\n\t\treturn true;\n\tif (test < before && before > after)\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "adjust_historical_crosststamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "1028-1088",
    "snippet": "static int adjust_historical_crosststamp(struct system_time_snapshot *history,\n\t\t\t\t\t u64 partial_history_cycles,\n\t\t\t\t\t u64 total_history_cycles,\n\t\t\t\t\t bool discontinuity,\n\t\t\t\t\t struct system_device_crosststamp *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tu64 corr_raw, corr_real;\n\tbool interp_forward;\n\tint ret;\n\n\tif (total_history_cycles == 0 || partial_history_cycles == 0)\n\t\treturn 0;\n\n\t/* Interpolate shortest distance from beginning or end of history */\n\tinterp_forward = partial_history_cycles > total_history_cycles / 2;\n\tpartial_history_cycles = interp_forward ?\n\t\ttotal_history_cycles - partial_history_cycles :\n\t\tpartial_history_cycles;\n\n\t/*\n\t * Scale the monotonic raw time delta by:\n\t *\tpartial_history_cycles / total_history_cycles\n\t */\n\tcorr_raw = (u64)ktime_to_ns(\n\t\tktime_sub(ts->sys_monoraw, history->raw));\n\tret = scale64_check_overflow(partial_history_cycles,\n\t\t\t\t     total_history_cycles, &corr_raw);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If there is a discontinuity in the history, scale monotonic raw\n\t *\tcorrection by:\n\t *\tmult(real)/mult(raw) yielding the realtime correction\n\t * Otherwise, calculate the realtime correction similar to monotonic\n\t *\traw calculation\n\t */\n\tif (discontinuity) {\n\t\tcorr_real = mul_u64_u32_div\n\t\t\t(corr_raw, tk->tkr_mono.mult, tk->tkr_raw.mult);\n\t} else {\n\t\tcorr_real = (u64)ktime_to_ns(\n\t\t\tktime_sub(ts->sys_realtime, history->real));\n\t\tret = scale64_check_overflow(partial_history_cycles,\n\t\t\t\t\t     total_history_cycles, &corr_real);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Fixup monotonic raw and real time time values */\n\tif (interp_forward) {\n\t\tts->sys_monoraw = ktime_add_ns(history->raw, corr_raw);\n\t\tts->sys_realtime = ktime_add_ns(history->real, corr_real);\n\t} else {\n\t\tts->sys_monoraw = ktime_sub_ns(ts->sys_monoraw, corr_raw);\n\t\tts->sys_realtime = ktime_sub_ns(ts->sys_realtime, corr_real);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_sub_ns",
          "args": [
            "ts->sys_realtime",
            "corr_real"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub_ns",
          "args": [
            "ts->sys_monoraw",
            "corr_raw"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "history->real",
            "corr_real"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "history->raw",
            "corr_raw"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scale64_check_overflow",
          "args": [
            "partial_history_cycles",
            "total_history_cycles",
            "&corr_real"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "scale64_check_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "994-1009",
          "snippet": "static int scale64_check_overflow(u64 mult, u64 div, u64 *base)\n{\n\tu64 tmp, rem;\n\n\ttmp = div64_u64_rem(*base, div, &rem);\n\n\tif (((int)sizeof(u64)*8 - fls64(mult) < fls64(tmp)) ||\n\t    ((int)sizeof(u64)*8 - fls64(mult) < fls64(rem)))\n\t\treturn -EOVERFLOW;\n\ttmp *= mult;\n\trem *= mult;\n\n\tdo_div(rem, div);\n\t*base = tmp + rem;\n\treturn 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic int scale64_check_overflow(u64 mult, u64 div, u64 *base)\n{\n\tu64 tmp, rem;\n\n\ttmp = div64_u64_rem(*base, div, &rem);\n\n\tif (((int)sizeof(u64)*8 - fls64(mult) < fls64(tmp)) ||\n\t    ((int)sizeof(u64)*8 - fls64(mult) < fls64(rem)))\n\t\treturn -EOVERFLOW;\n\ttmp *= mult;\n\trem *= mult;\n\n\tdo_div(rem, div);\n\t*base = tmp + rem;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_sub(ts->sys_realtime, history->real)"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "ts->sys_realtime",
            "history->real"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mul_u64_u32_div",
          "args": [
            "corr_raw",
            "tk->tkr_mono.mult",
            "tk->tkr_raw.mult"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_sub(ts->sys_monoraw, history->raw)"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "ts->sys_monoraw",
            "history->raw"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic int adjust_historical_crosststamp(struct system_time_snapshot *history,\n\t\t\t\t\t u64 partial_history_cycles,\n\t\t\t\t\t u64 total_history_cycles,\n\t\t\t\t\t bool discontinuity,\n\t\t\t\t\t struct system_device_crosststamp *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tu64 corr_raw, corr_real;\n\tbool interp_forward;\n\tint ret;\n\n\tif (total_history_cycles == 0 || partial_history_cycles == 0)\n\t\treturn 0;\n\n\t/* Interpolate shortest distance from beginning or end of history */\n\tinterp_forward = partial_history_cycles > total_history_cycles / 2;\n\tpartial_history_cycles = interp_forward ?\n\t\ttotal_history_cycles - partial_history_cycles :\n\t\tpartial_history_cycles;\n\n\t/*\n\t * Scale the monotonic raw time delta by:\n\t *\tpartial_history_cycles / total_history_cycles\n\t */\n\tcorr_raw = (u64)ktime_to_ns(\n\t\tktime_sub(ts->sys_monoraw, history->raw));\n\tret = scale64_check_overflow(partial_history_cycles,\n\t\t\t\t     total_history_cycles, &corr_raw);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * If there is a discontinuity in the history, scale monotonic raw\n\t *\tcorrection by:\n\t *\tmult(real)/mult(raw) yielding the realtime correction\n\t * Otherwise, calculate the realtime correction similar to monotonic\n\t *\traw calculation\n\t */\n\tif (discontinuity) {\n\t\tcorr_real = mul_u64_u32_div\n\t\t\t(corr_raw, tk->tkr_mono.mult, tk->tkr_raw.mult);\n\t} else {\n\t\tcorr_real = (u64)ktime_to_ns(\n\t\t\tktime_sub(ts->sys_realtime, history->real));\n\t\tret = scale64_check_overflow(partial_history_cycles,\n\t\t\t\t\t     total_history_cycles, &corr_real);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Fixup monotonic raw and real time time values */\n\tif (interp_forward) {\n\t\tts->sys_monoraw = ktime_add_ns(history->raw, corr_raw);\n\t\tts->sys_realtime = ktime_add_ns(history->real, corr_real);\n\t} else {\n\t\tts->sys_monoraw = ktime_sub_ns(ts->sys_monoraw, corr_raw);\n\t\tts->sys_realtime = ktime_sub_ns(ts->sys_realtime, corr_real);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "scale64_check_overflow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "994-1009",
    "snippet": "static int scale64_check_overflow(u64 mult, u64 div, u64 *base)\n{\n\tu64 tmp, rem;\n\n\ttmp = div64_u64_rem(*base, div, &rem);\n\n\tif (((int)sizeof(u64)*8 - fls64(mult) < fls64(tmp)) ||\n\t    ((int)sizeof(u64)*8 - fls64(mult) < fls64(rem)))\n\t\treturn -EOVERFLOW;\n\ttmp *= mult;\n\trem *= mult;\n\n\tdo_div(rem, div);\n\t*base = tmp + rem;\n\treturn 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "rem",
            "div"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls64",
          "args": [
            "rem"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls64",
          "args": [
            "mult"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls64",
          "args": [
            "tmp"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls64",
          "args": [
            "mult"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64_rem",
          "args": [
            "*base",
            "div",
            "&rem"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic int scale64_check_overflow(u64 mult, u64 div, u64 *base)\n{\n\tu64 tmp, rem;\n\n\ttmp = div64_u64_rem(*base, div, &rem);\n\n\tif (((int)sizeof(u64)*8 - fls64(mult) < fls64(tmp)) ||\n\t    ((int)sizeof(u64)*8 - fls64(mult) < fls64(rem)))\n\t\treturn -EOVERFLOW;\n\ttmp *= mult;\n\trem *= mult;\n\n\tdo_div(rem, div);\n\t*base = tmp + rem;\n\treturn 0;\n}"
  },
  {
    "function_name": "ktime_get_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "963-990",
    "snippet": "void ktime_get_snapshot(struct system_time_snapshot *systime_snapshot)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tktime_t base_raw;\n\tktime_t base_real;\n\tu64 nsec_raw;\n\tu64 nsec_real;\n\tu64 now;\n\n\tWARN_ON_ONCE(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tnow = tk_clock_read(&tk->tkr_mono);\n\t\tsystime_snapshot->cs_was_changed_seq = tk->cs_was_changed_seq;\n\t\tsystime_snapshot->clock_was_set_seq = tk->clock_was_set_seq;\n\t\tbase_real = ktime_add(tk->tkr_mono.base,\n\t\t\t\t      tk_core.timekeeper.offs_real);\n\t\tbase_raw = tk->tkr_raw.base;\n\t\tnsec_real = timekeeping_cycles_to_ns(&tk->tkr_mono, now);\n\t\tnsec_raw  = timekeeping_cycles_to_ns(&tk->tkr_raw, now);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tsystime_snapshot->cycles = now;\n\tsystime_snapshot->real = ktime_add_ns(base_real, nsec_real);\n\tsystime_snapshot->raw = ktime_add_ns(base_raw, nsec_raw);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "base_raw",
            "nsec_raw"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "base_real",
            "nsec_real"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_cycles_to_ns",
          "args": [
            "&tk->tkr_raw",
            "now"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_cycles_to_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "375-382",
          "snippet": "static inline u64 timekeeping_cycles_to_ns(const struct tk_read_base *tkr, u64 cycles)\n{\n\tu64 delta;\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycles, tkr->cycle_last, tkr->mask);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_cycles_to_ns(const struct tk_read_base *tkr, u64 cycles)\n{\n\tu64 delta;\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycles, tkr->cycle_last, tkr->mask);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "tk->tkr_mono.base",
            "tk_core.timekeeper.offs_real"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "166-171",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_snapshot(struct system_time_snapshot *systime_snapshot)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tktime_t base_raw;\n\tktime_t base_real;\n\tu64 nsec_raw;\n\tu64 nsec_real;\n\tu64 now;\n\n\tWARN_ON_ONCE(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tnow = tk_clock_read(&tk->tkr_mono);\n\t\tsystime_snapshot->cs_was_changed_seq = tk->cs_was_changed_seq;\n\t\tsystime_snapshot->clock_was_set_seq = tk->clock_was_set_seq;\n\t\tbase_real = ktime_add(tk->tkr_mono.base,\n\t\t\t\t      tk_core.timekeeper.offs_real);\n\t\tbase_raw = tk->tkr_raw.base;\n\t\tnsec_real = timekeeping_cycles_to_ns(&tk->tkr_mono, now);\n\t\tnsec_raw  = timekeeping_cycles_to_ns(&tk->tkr_raw, now);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tsystime_snapshot->cycles = now;\n\tsystime_snapshot->real = ktime_add_ns(base_real, nsec_real);\n\tsystime_snapshot->raw = ktime_add_ns(base_raw, nsec_raw);\n}"
  },
  {
    "function_name": "__ktime_get_real_seconds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "952-957",
    "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
  },
  {
    "function_name": "ktime_get_real_seconds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "928-944",
    "snippet": "time64_t ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\ttime64_t seconds;\n\tunsigned int seq;\n\n\tif (IS_ENABLED(CONFIG_64BIT))\n\t\treturn tk->xtime_sec;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tseconds = tk->xtime_sec;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn seconds;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_64BIT"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\ttime64_t seconds;\n\tunsigned int seq;\n\n\tif (IS_ENABLED(CONFIG_64BIT))\n\t\treturn tk->xtime_sec;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tseconds = tk->xtime_sec;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn seconds;\n}"
  },
  {
    "function_name": "ktime_get_seconds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "908-914",
    "snippet": "time64_t ktime_get_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tWARN_ON(timekeeping_suspended);\n\treturn tk->ktime_sec;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t ktime_get_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tWARN_ON(timekeeping_suspended);\n\treturn tk->ktime_sec;\n}"
  },
  {
    "function_name": "ktime_get_ts64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "876-896",
    "snippet": "void ktime_get_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 tomono;\n\tunsigned int seq;\n\tu64 nsec;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsec = timekeeping_get_ns(&tk->tkr_mono);\n\t\ttomono = tk->wall_to_monotonic;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_sec += tomono.tv_sec;\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsec + tomono.tv_nsec);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timespec64_add_ns",
          "args": [
            "ts",
            "nsec + tomono.tv_nsec"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_get_ns",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_get_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "367-373",
          "snippet": "static inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tstruct timespec64 tomono;\n\tunsigned int seq;\n\tu64 nsec;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsec = timekeeping_get_ns(&tk->tkr_mono);\n\t\ttomono = tk->wall_to_monotonic;\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_sec += tomono.tv_sec;\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsec + tomono.tv_nsec);\n}"
  },
  {
    "function_name": "ktime_get_raw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "850-865",
    "snippet": "ktime_t ktime_get_raw(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tbase = tk->tkr_raw.base;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_raw);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ktime_add_ns(base, nsecs);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "base",
            "nsecs"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_get_ns",
          "args": [
            "&tk->tkr_raw"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_get_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "367-373",
          "snippet": "static inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nktime_t ktime_get_raw(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base;\n\tu64 nsecs;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tbase = tk->tkr_raw.base;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_raw);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ktime_add_ns(base, nsecs);\n}"
  },
  {
    "function_name": "ktime_mono_to_any",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "832-844",
    "snippet": "ktime_t ktime_mono_to_any(ktime_t tmono, enum tk_offsets offs)\n{\n\tktime_t *offset = offsets[offs];\n\tunsigned long seq;\n\tktime_t tconv;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\ttconv = ktime_add(tmono, *offset);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn tconv;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ktime_t *offsets[TK_OFFS_MAX] = {\n\t[TK_OFFS_REAL]\t= &tk_core.timekeeper.offs_real,\n\t[TK_OFFS_BOOT]\t= &tk_core.timekeeper.offs_boot,\n\t[TK_OFFS_TAI]\t= &tk_core.timekeeper.offs_tai,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "tmono",
            "*offset"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic ktime_t *offsets[TK_OFFS_MAX] = {\n\t[TK_OFFS_REAL]\t= &tk_core.timekeeper.offs_real,\n\t[TK_OFFS_BOOT]\t= &tk_core.timekeeper.offs_boot,\n\t[TK_OFFS_TAI]\t= &tk_core.timekeeper.offs_tai,\n};\n\nktime_t ktime_mono_to_any(ktime_t tmono, enum tk_offsets offs)\n{\n\tktime_t *offset = offsets[offs];\n\tunsigned long seq;\n\tktime_t tconv;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\ttconv = ktime_add(tmono, *offset);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn tconv;\n}"
  },
  {
    "function_name": "ktime_get_coarse_with_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "808-824",
    "snippet": "ktime_t ktime_get_coarse_with_offset(enum tk_offsets offs)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base, *offset = offsets[offs];\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tbase = ktime_add(tk->tkr_mono.base, *offset);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn base;\n\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ktime_t *offsets[TK_OFFS_MAX] = {\n\t[TK_OFFS_REAL]\t= &tk_core.timekeeper.offs_real,\n\t[TK_OFFS_BOOT]\t= &tk_core.timekeeper.offs_boot,\n\t[TK_OFFS_TAI]\t= &tk_core.timekeeper.offs_tai,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "tk->tkr_mono.base",
            "*offset"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic ktime_t *offsets[TK_OFFS_MAX] = {\n\t[TK_OFFS_REAL]\t= &tk_core.timekeeper.offs_real,\n\t[TK_OFFS_BOOT]\t= &tk_core.timekeeper.offs_boot,\n\t[TK_OFFS_TAI]\t= &tk_core.timekeeper.offs_tai,\n};\n\nktime_t ktime_get_coarse_with_offset(enum tk_offsets offs)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base, *offset = offsets[offs];\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tbase = ktime_add(tk->tkr_mono.base, *offset);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn base;\n\n}"
  },
  {
    "function_name": "ktime_get_with_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "787-805",
    "snippet": "ktime_t ktime_get_with_offset(enum tk_offsets offs)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base, *offset = offsets[offs];\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tbase = ktime_add(tk->tkr_mono.base, *offset);\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ktime_add_ns(base, nsecs);\n\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ktime_t *offsets[TK_OFFS_MAX] = {\n\t[TK_OFFS_REAL]\t= &tk_core.timekeeper.offs_real,\n\t[TK_OFFS_BOOT]\t= &tk_core.timekeeper.offs_boot,\n\t[TK_OFFS_TAI]\t= &tk_core.timekeeper.offs_tai,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "base",
            "nsecs"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_get_ns",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_get_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "367-373",
          "snippet": "static inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "tk->tkr_mono.base",
            "*offset"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic ktime_t *offsets[TK_OFFS_MAX] = {\n\t[TK_OFFS_REAL]\t= &tk_core.timekeeper.offs_real,\n\t[TK_OFFS_BOOT]\t= &tk_core.timekeeper.offs_boot,\n\t[TK_OFFS_TAI]\t= &tk_core.timekeeper.offs_tai,\n};\n\nktime_t ktime_get_with_offset(enum tk_offsets offs)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base, *offset = offsets[offs];\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tbase = ktime_add(tk->tkr_mono.base, *offset);\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ktime_add_ns(base, nsecs);\n\n}"
  },
  {
    "function_name": "ktime_get_resolution_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "764-778",
    "snippet": "u32 ktime_get_resolution_ns(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu32 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tnsecs = tk->tkr_mono.mult >> tk->tkr_mono.shift;\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn nsecs;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu32 ktime_get_resolution_ns(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu32 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tnsecs = tk->tkr_mono.mult >> tk->tkr_mono.shift;\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn nsecs;\n}"
  },
  {
    "function_name": "ktime_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "744-761",
    "snippet": "ktime_t ktime_get(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tbase = tk->tkr_mono.base;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ktime_add_ns(base, nsecs);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "base",
            "nsecs"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_get_ns",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_get_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "367-373",
          "snippet": "static inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nktime_t ktime_get(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tktime_t base;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tbase = tk->tkr_mono.base;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\treturn ktime_add_ns(base, nsecs);\n}"
  },
  {
    "function_name": "ktime_get_real_ts64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "723-741",
    "snippet": "void ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timespec64_add_ns",
          "args": [
            "ts",
            "nsecs"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_get_ns",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_get_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "367-373",
          "snippet": "static inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}"
  },
  {
    "function_name": "timekeeping_forward_now",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "694-715",
    "snippet": "static void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_mono.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_mono.shift;\n\n\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_raw.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_raw.shift;\n\n\ttk_normalize_xtime(tk);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tk_normalize_xtime",
          "args": [
            "tk"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "tk_normalize_xtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "97-107",
          "snippet": "static inline void tk_normalize_xtime(struct timekeeper *tk)\n{\n\twhile (tk->tkr_mono.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_mono.shift)) {\n\t\ttk->tkr_mono.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\t\ttk->xtime_sec++;\n\t}\n\twhile (tk->tkr_raw.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_raw.shift)) {\n\t\ttk->tkr_raw.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\t\ttk->raw_sec++;\n\t}\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_normalize_xtime(struct timekeeper *tk)\n{\n\twhile (tk->tkr_mono.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_mono.shift)) {\n\t\ttk->tkr_mono.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\t\ttk->xtime_sec++;\n\t}\n\twhile (tk->tkr_raw.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_raw.shift)) {\n\t\ttk->tkr_raw.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\t\ttk->raw_sec++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_gettimeoffset",
          "args": [],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "arch_gettimeoffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "353-353",
          "snippet": "static inline u32 arch_gettimeoffset(void) { return 0; }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u32 arch_gettimeoffset(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "cycle_now",
            "tk->tkr_mono.cycle_last",
            "tk->tkr_mono.mask"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping_internal.h",
          "lines": "28-31",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "166-171",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void timekeeping_forward_now(struct timekeeper *tk)\n{\n\tu64 cycle_now, delta;\n\n\tcycle_now = tk_clock_read(&tk->tkr_mono);\n\tdelta = clocksource_delta(cycle_now, tk->tkr_mono.cycle_last, tk->tkr_mono.mask);\n\ttk->tkr_mono.cycle_last = cycle_now;\n\ttk->tkr_raw.cycle_last  = cycle_now;\n\n\ttk->tkr_mono.xtime_nsec += delta * tk->tkr_mono.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_mono.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_mono.shift;\n\n\n\ttk->tkr_raw.xtime_nsec += delta * tk->tkr_raw.mult;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\ttk->tkr_raw.xtime_nsec += (u64)arch_gettimeoffset() << tk->tkr_raw.shift;\n\n\ttk_normalize_xtime(tk);\n}"
  },
  {
    "function_name": "timekeeping_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "658-685",
    "snippet": "static void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define TK_CLOCK_WAS_SET\t(1 << 2)",
      "#define TK_MIRROR\t\t(1 << 1)",
      "#define TK_CLEAR_NTP\t\t(1 << 0)"
    ],
    "globals_used": [
      "static struct timekeeper shadow_timekeeper;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&shadow_timekeeper",
            "&tk_core.timekeeper",
            "sizeof(tk_core.timekeeper)"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_fast_timekeeper",
          "args": [
            "&tk->tkr_raw",
            "&tk_fast_raw"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "update_fast_timekeeper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "398-414",
          "snippet": "static void update_fast_timekeeper(const struct tk_read_base *tkr,\n\t\t\t\t   struct tk_fast *tkf)\n{\n\tstruct tk_read_base *base = tkf->base;\n\n\t/* Force readers off to base[1] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[0] */\n\tmemcpy(base, tkr, sizeof(*base));\n\n\t/* Force readers back to base[0] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[1] */\n\tmemcpy(base + 1, base, sizeof(*base));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void update_fast_timekeeper(const struct tk_read_base *tkr,\n\t\t\t\t   struct tk_fast *tkf)\n{\n\tstruct tk_read_base *base = tkf->base;\n\n\t/* Force readers off to base[1] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[0] */\n\tmemcpy(base, tkr, sizeof(*base));\n\n\t/* Force readers back to base[0] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[1] */\n\tmemcpy(base + 1, base, sizeof(*base));\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_pvclock_gtod",
          "args": [
            "tk",
            "action & TK_CLOCK_WAS_SET"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "update_pvclock_gtod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "573-576",
          "snippet": "static void update_pvclock_gtod(struct timekeeper *tk, bool was_set)\n{\n\traw_notifier_call_chain(&pvclock_gtod_chain, was_set, tk);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static RAW_NOTIFIER_HEAD(pvclock_gtod_chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic RAW_NOTIFIER_HEAD(pvclock_gtod_chain);\n\nstatic void update_pvclock_gtod(struct timekeeper *tk, bool was_set)\n{\n\traw_notifier_call_chain(&pvclock_gtod_chain, was_set, tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_vsyscall",
          "args": [
            "tk"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_update_ktime_data",
          "args": [
            "tk"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "tk_update_ktime_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "627-655",
          "snippet": "static inline void tk_update_ktime_data(struct timekeeper *tk)\n{\n\tu64 seconds;\n\tu32 nsec;\n\n\t/*\n\t * The xtime based monotonic readout is:\n\t *\tnsec = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec + now();\n\t * The ktime based monotonic readout is:\n\t *\tnsec = base_mono + now();\n\t * ==> base_mono = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec\n\t */\n\tseconds = (u64)(tk->xtime_sec + tk->wall_to_monotonic.tv_sec);\n\tnsec = (u32) tk->wall_to_monotonic.tv_nsec;\n\ttk->tkr_mono.base = ns_to_ktime(seconds * NSEC_PER_SEC + nsec);\n\n\t/*\n\t * The sum of the nanoseconds portions of xtime and\n\t * wall_to_monotonic can be greater/equal one second. Take\n\t * this into account before updating tk->ktime_sec.\n\t */\n\tnsec += (u32)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\tif (nsec >= NSEC_PER_SEC)\n\t\tseconds++;\n\ttk->ktime_sec = seconds;\n\n\t/* Update the monotonic raw base */\n\ttk->tkr_raw.base = ns_to_ktime(tk->raw_sec * NSEC_PER_SEC);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_update_ktime_data(struct timekeeper *tk)\n{\n\tu64 seconds;\n\tu32 nsec;\n\n\t/*\n\t * The xtime based monotonic readout is:\n\t *\tnsec = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec + now();\n\t * The ktime based monotonic readout is:\n\t *\tnsec = base_mono + now();\n\t * ==> base_mono = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec\n\t */\n\tseconds = (u64)(tk->xtime_sec + tk->wall_to_monotonic.tv_sec);\n\tnsec = (u32) tk->wall_to_monotonic.tv_nsec;\n\ttk->tkr_mono.base = ns_to_ktime(seconds * NSEC_PER_SEC + nsec);\n\n\t/*\n\t * The sum of the nanoseconds portions of xtime and\n\t * wall_to_monotonic can be greater/equal one second. Take\n\t * this into account before updating tk->ktime_sec.\n\t */\n\tnsec += (u32)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\tif (nsec >= NSEC_PER_SEC)\n\t\tseconds++;\n\ttk->ktime_sec = seconds;\n\n\t/* Update the monotonic raw base */\n\ttk->tkr_raw.base = ns_to_ktime(tk->raw_sec * NSEC_PER_SEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_update_leap_state",
          "args": [
            "tk"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "tk_update_leap_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "616-622",
          "snippet": "static inline void tk_update_leap_state(struct timekeeper *tk)\n{\n\ttk->next_leap_ktime = ntp_get_next_leap();\n\tif (tk->next_leap_ktime != KTIME_MAX)\n\t\t/* Convert to monotonic time */\n\t\ttk->next_leap_ktime = ktime_sub(tk->next_leap_ktime, tk->offs_real);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_update_leap_state(struct timekeeper *tk)\n{\n\ttk->next_leap_ktime = ntp_get_next_leap();\n\tif (tk->next_leap_ktime != KTIME_MAX)\n\t\t/* Convert to monotonic time */\n\t\ttk->next_leap_ktime = ktime_sub(tk->next_leap_ktime, tk->offs_real);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntp_clear",
          "args": [],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "350-365",
          "snippet": "void ntp_clear(void)\n{\n\ttime_adjust\t= 0;\t\t/* stop active adjtime() */\n\ttime_status\t|= STA_UNSYNC;\n\ttime_maxerror\t= NTP_PHASE_LIMIT;\n\ttime_esterror\t= NTP_PHASE_LIMIT;\n\n\tntp_update_frequency();\n\n\ttick_length\t= tick_length_base;\n\ttime_offset\t= 0;\n\n\tntp_next_leap_sec = TIME64_MAX;\n\t/* Clear PPS state variables */\n\tpps_clear();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64\t\t\ttick_length;",
            "static u64\t\t\ttick_length_base;",
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static s64\t\t\ttime_offset;",
            "static long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;",
            "static long\t\t\ttime_esterror = NTP_PHASE_LIMIT;",
            "static long\t\t\ttime_adjust;",
            "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_esterror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_adjust;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nvoid ntp_clear(void)\n{\n\ttime_adjust\t= 0;\t\t/* stop active adjtime() */\n\ttime_status\t|= STA_UNSYNC;\n\ttime_maxerror\t= NTP_PHASE_LIMIT;\n\ttime_esterror\t= NTP_PHASE_LIMIT;\n\n\tntp_update_frequency();\n\n\ttick_length\t= tick_length_base;\n\ttime_offset\t= 0;\n\n\tntp_next_leap_sec = TIME64_MAX;\n\t/* Clear PPS state variables */\n\tpps_clear();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define TK_CLOCK_WAS_SET\t(1 << 2)\n#define TK_MIRROR\t\t(1 << 1)\n#define TK_CLEAR_NTP\t\t(1 << 0)\n\nstatic struct timekeeper shadow_timekeeper;\n\nstatic void timekeeping_update(struct timekeeper *tk, unsigned int action)\n{\n\tif (action & TK_CLEAR_NTP) {\n\t\ttk->ntp_error = 0;\n\t\tntp_clear();\n\t}\n\n\ttk_update_leap_state(tk);\n\ttk_update_ktime_data(tk);\n\n\tupdate_vsyscall(tk);\n\tupdate_pvclock_gtod(tk, action & TK_CLOCK_WAS_SET);\n\n\ttk->tkr_mono.base_real = tk->tkr_mono.base + tk->offs_real;\n\tupdate_fast_timekeeper(&tk->tkr_mono, &tk_fast_mono);\n\tupdate_fast_timekeeper(&tk->tkr_raw,  &tk_fast_raw);\n\n\tif (action & TK_CLOCK_WAS_SET)\n\t\ttk->clock_was_set_seq++;\n\t/*\n\t * The mirroring of the data to the shadow-timekeeper needs\n\t * to happen last here to ensure we don't over-write the\n\t * timekeeper structure on the next update with stale data\n\t */\n\tif (action & TK_MIRROR)\n\t\tmemcpy(&shadow_timekeeper, &tk_core.timekeeper,\n\t\t       sizeof(tk_core.timekeeper));\n}"
  },
  {
    "function_name": "tk_update_ktime_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "627-655",
    "snippet": "static inline void tk_update_ktime_data(struct timekeeper *tk)\n{\n\tu64 seconds;\n\tu32 nsec;\n\n\t/*\n\t * The xtime based monotonic readout is:\n\t *\tnsec = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec + now();\n\t * The ktime based monotonic readout is:\n\t *\tnsec = base_mono + now();\n\t * ==> base_mono = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec\n\t */\n\tseconds = (u64)(tk->xtime_sec + tk->wall_to_monotonic.tv_sec);\n\tnsec = (u32) tk->wall_to_monotonic.tv_nsec;\n\ttk->tkr_mono.base = ns_to_ktime(seconds * NSEC_PER_SEC + nsec);\n\n\t/*\n\t * The sum of the nanoseconds portions of xtime and\n\t * wall_to_monotonic can be greater/equal one second. Take\n\t * this into account before updating tk->ktime_sec.\n\t */\n\tnsec += (u32)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\tif (nsec >= NSEC_PER_SEC)\n\t\tseconds++;\n\ttk->ktime_sec = seconds;\n\n\t/* Update the monotonic raw base */\n\ttk->tkr_raw.base = ns_to_ktime(tk->raw_sec * NSEC_PER_SEC);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_to_ktime",
          "args": [
            "tk->raw_sec * NSEC_PER_SEC"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_ktime",
          "args": [
            "seconds * NSEC_PER_SEC + nsec"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tk->xtime_sec + tk->wall_to_monotonic.tv_sec"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_update_ktime_data(struct timekeeper *tk)\n{\n\tu64 seconds;\n\tu32 nsec;\n\n\t/*\n\t * The xtime based monotonic readout is:\n\t *\tnsec = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec + now();\n\t * The ktime based monotonic readout is:\n\t *\tnsec = base_mono + now();\n\t * ==> base_mono = (xtime_sec + wtm_sec) * 1e9 + wtm_nsec\n\t */\n\tseconds = (u64)(tk->xtime_sec + tk->wall_to_monotonic.tv_sec);\n\tnsec = (u32) tk->wall_to_monotonic.tv_nsec;\n\ttk->tkr_mono.base = ns_to_ktime(seconds * NSEC_PER_SEC + nsec);\n\n\t/*\n\t * The sum of the nanoseconds portions of xtime and\n\t * wall_to_monotonic can be greater/equal one second. Take\n\t * this into account before updating tk->ktime_sec.\n\t */\n\tnsec += (u32)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\tif (nsec >= NSEC_PER_SEC)\n\t\tseconds++;\n\ttk->ktime_sec = seconds;\n\n\t/* Update the monotonic raw base */\n\ttk->tkr_raw.base = ns_to_ktime(tk->raw_sec * NSEC_PER_SEC);\n}"
  },
  {
    "function_name": "tk_update_leap_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "616-622",
    "snippet": "static inline void tk_update_leap_state(struct timekeeper *tk)\n{\n\ttk->next_leap_ktime = ntp_get_next_leap();\n\tif (tk->next_leap_ktime != KTIME_MAX)\n\t\t/* Convert to monotonic time */\n\t\ttk->next_leap_ktime = ktime_sub(tk->next_leap_ktime, tk->offs_real);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "tk->next_leap_ktime",
            "tk->offs_real"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntp_get_next_leap",
          "args": [],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_get_next_leap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "379-387",
          "snippet": "ktime_t ntp_get_next_leap(void)\n{\n\tktime_t ret;\n\n\tif ((time_state == TIME_INS) && (time_status & STA_INS))\n\t\treturn ktime_set(ntp_next_leap_sec, 0);\n\tret = KTIME_MAX;\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\ttime_state = TIME_OK;",
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_state = TIME_OK;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nktime_t ntp_get_next_leap(void)\n{\n\tktime_t ret;\n\n\tif ((time_state == TIME_INS) && (time_status & STA_INS))\n\t\treturn ktime_set(ntp_next_leap_sec, 0);\n\tret = KTIME_MAX;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_update_leap_state(struct timekeeper *tk)\n{\n\ttk->next_leap_ktime = ntp_get_next_leap();\n\tif (tk->next_leap_ktime != KTIME_MAX)\n\t\t/* Convert to monotonic time */\n\t\ttk->next_leap_ktime = ktime_sub(tk->next_leap_ktime, tk->offs_real);\n}"
  },
  {
    "function_name": "pvclock_gtod_unregister_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "600-610",
    "snippet": "int pvclock_gtod_unregister_notifier(struct notifier_block *nb)\n{\n\tunsigned long flags;\n\tint ret;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\tret = raw_notifier_chain_unregister(&pvclock_gtod_chain, nb);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(timekeeper_lock);",
      "static RAW_NOTIFIER_HEAD(pvclock_gtod_chain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_notifier_chain_unregister",
          "args": [
            "&pvclock_gtod_chain",
            "nb"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "raw_notifier_chain_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "364-368",
          "snippet": "int raw_notifier_chain_unregister(struct raw_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\treturn notifier_chain_unregister(&nh->head, n);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint raw_notifier_chain_unregister(struct raw_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\treturn notifier_chain_unregister(&nh->head, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic DEFINE_RAW_SPINLOCK(timekeeper_lock);\nstatic RAW_NOTIFIER_HEAD(pvclock_gtod_chain);\n\nint pvclock_gtod_unregister_notifier(struct notifier_block *nb)\n{\n\tunsigned long flags;\n\tint ret;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\tret = raw_notifier_chain_unregister(&pvclock_gtod_chain, nb);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pvclock_gtod_register_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "581-593",
    "snippet": "int pvclock_gtod_register_notifier(struct notifier_block *nb)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tint ret;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\tret = raw_notifier_chain_register(&pvclock_gtod_chain, nb);\n\tupdate_pvclock_gtod(tk, true);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(timekeeper_lock);",
      "static RAW_NOTIFIER_HEAD(pvclock_gtod_chain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_pvclock_gtod",
          "args": [
            "tk",
            "true"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "update_pvclock_gtod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "573-576",
          "snippet": "static void update_pvclock_gtod(struct timekeeper *tk, bool was_set)\n{\n\traw_notifier_call_chain(&pvclock_gtod_chain, was_set, tk);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static RAW_NOTIFIER_HEAD(pvclock_gtod_chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic RAW_NOTIFIER_HEAD(pvclock_gtod_chain);\n\nstatic void update_pvclock_gtod(struct timekeeper *tk, bool was_set)\n{\n\traw_notifier_call_chain(&pvclock_gtod_chain, was_set, tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_notifier_chain_register",
          "args": [
            "&pvclock_gtod_chain",
            "nb"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "raw_notifier_chain_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "347-351",
          "snippet": "int raw_notifier_chain_register(struct raw_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\treturn notifier_chain_register(&nh->head, n);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint raw_notifier_chain_register(struct raw_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\treturn notifier_chain_register(&nh->head, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic DEFINE_RAW_SPINLOCK(timekeeper_lock);\nstatic RAW_NOTIFIER_HEAD(pvclock_gtod_chain);\n\nint pvclock_gtod_register_notifier(struct notifier_block *nb)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long flags;\n\tint ret;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\tret = raw_notifier_chain_register(&pvclock_gtod_chain, nb);\n\tupdate_pvclock_gtod(tk, true);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "update_pvclock_gtod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "573-576",
    "snippet": "static void update_pvclock_gtod(struct timekeeper *tk, bool was_set)\n{\n\traw_notifier_call_chain(&pvclock_gtod_chain, was_set, tk);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static RAW_NOTIFIER_HEAD(pvclock_gtod_chain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_notifier_call_chain",
          "args": [
            "&pvclock_gtod_chain",
            "was_set",
            "tk"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "raw_notifier_call_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "398-402",
          "snippet": "int raw_notifier_call_chain(struct raw_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\treturn __raw_notifier_call_chain(nh, val, v, -1, NULL);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint raw_notifier_call_chain(struct raw_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\treturn __raw_notifier_call_chain(nh, val, v, -1, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic RAW_NOTIFIER_HEAD(pvclock_gtod_chain);\n\nstatic void update_pvclock_gtod(struct timekeeper *tk, bool was_set)\n{\n\traw_notifier_call_chain(&pvclock_gtod_chain, was_set, tk);\n}"
  },
  {
    "function_name": "halt_fast_timekeeper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "554-569",
    "snippet": "static void halt_fast_timekeeper(const struct timekeeper *tk)\n{\n\tstatic struct tk_read_base tkr_dummy;\n\tconst struct tk_read_base *tkr = &tk->tkr_mono;\n\n\tmemcpy(&tkr_dummy, tkr, sizeof(tkr_dummy));\n\tcycles_at_suspend = tk_clock_read(tkr);\n\ttkr_dummy.clock = &dummy_clock;\n\ttkr_dummy.base_real = tkr->base + tk->offs_real;\n\tupdate_fast_timekeeper(&tkr_dummy, &tk_fast_mono);\n\n\ttkr = &tk->tkr_raw;\n\tmemcpy(&tkr_dummy, tkr, sizeof(tkr_dummy));\n\ttkr_dummy.clock = &dummy_clock;\n\tupdate_fast_timekeeper(&tkr_dummy, &tk_fast_raw);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 cycles_at_suspend;",
      "static struct clocksource dummy_clock = {\n\t.read = dummy_clock_read,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_fast_timekeeper",
          "args": [
            "&tkr_dummy",
            "&tk_fast_raw"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "update_fast_timekeeper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "398-414",
          "snippet": "static void update_fast_timekeeper(const struct tk_read_base *tkr,\n\t\t\t\t   struct tk_fast *tkf)\n{\n\tstruct tk_read_base *base = tkf->base;\n\n\t/* Force readers off to base[1] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[0] */\n\tmemcpy(base, tkr, sizeof(*base));\n\n\t/* Force readers back to base[0] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[1] */\n\tmemcpy(base + 1, base, sizeof(*base));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void update_fast_timekeeper(const struct tk_read_base *tkr,\n\t\t\t\t   struct tk_fast *tkf)\n{\n\tstruct tk_read_base *base = tkf->base;\n\n\t/* Force readers off to base[1] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[0] */\n\tmemcpy(base, tkr, sizeof(*base));\n\n\t/* Force readers back to base[0] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[1] */\n\tmemcpy(base + 1, base, sizeof(*base));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tkr_dummy",
            "tkr",
            "sizeof(tkr_dummy)"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "tkr"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "166-171",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic u64 cycles_at_suspend;\nstatic struct clocksource dummy_clock = {\n\t.read = dummy_clock_read,\n};\n\nstatic void halt_fast_timekeeper(const struct timekeeper *tk)\n{\n\tstatic struct tk_read_base tkr_dummy;\n\tconst struct tk_read_base *tkr = &tk->tkr_mono;\n\n\tmemcpy(&tkr_dummy, tkr, sizeof(tkr_dummy));\n\tcycles_at_suspend = tk_clock_read(tkr);\n\ttkr_dummy.clock = &dummy_clock;\n\ttkr_dummy.base_real = tkr->base + tk->offs_real;\n\tupdate_fast_timekeeper(&tkr_dummy, &tk_fast_mono);\n\n\ttkr = &tk->tkr_raw;\n\tmemcpy(&tkr_dummy, tkr, sizeof(tkr_dummy));\n\ttkr_dummy.clock = &dummy_clock;\n\tupdate_fast_timekeeper(&tkr_dummy, &tk_fast_raw);\n}"
  },
  {
    "function_name": "ktime_get_real_fast_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "538-541",
    "snippet": "u64 ktime_get_real_fast_ns(void)\n{\n\treturn __ktime_get_real_fast_ns(&tk_fast_mono);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ktime_get_real_fast_ns",
          "args": [
            "&tk_fast_mono"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_fast_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "514-533",
          "snippet": "static __always_inline u64 __ktime_get_real_fast_ns(struct tk_fast *tkf)\n{\n\tstruct tk_read_base *tkr;\n\tunsigned int seq;\n\tu64 now;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tnow = ktime_to_ns(tkr->base_real);\n\n\t\tnow += timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(\n\t\t\t\t\ttk_clock_read(tkr),\n\t\t\t\t\ttkr->cycle_last,\n\t\t\t\t\ttkr->mask));\n\t} while (read_seqcount_retry(&tkf->seq, seq));\n\n\treturn now;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic __always_inline u64 __ktime_get_real_fast_ns(struct tk_fast *tkf)\n{\n\tstruct tk_read_base *tkr;\n\tunsigned int seq;\n\tu64 now;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tnow = ktime_to_ns(tkr->base_real);\n\n\t\tnow += timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(\n\t\t\t\t\ttk_clock_read(tkr),\n\t\t\t\t\ttkr->cycle_last,\n\t\t\t\t\ttkr->mask));\n\t} while (read_seqcount_retry(&tkf->seq, seq));\n\n\treturn now;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_real_fast_ns(void)\n{\n\treturn __ktime_get_real_fast_ns(&tk_fast_mono);\n}"
  },
  {
    "function_name": "__ktime_get_real_fast_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "514-533",
    "snippet": "static __always_inline u64 __ktime_get_real_fast_ns(struct tk_fast *tkf)\n{\n\tstruct tk_read_base *tkr;\n\tunsigned int seq;\n\tu64 now;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tnow = ktime_to_ns(tkr->base_real);\n\n\t\tnow += timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(\n\t\t\t\t\ttk_clock_read(tkr),\n\t\t\t\t\ttkr->cycle_last,\n\t\t\t\t\ttkr->mask));\n\t} while (read_seqcount_retry(&tkf->seq, seq));\n\n\treturn now;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tkf->seq",
            "seq"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_delta_to_ns",
          "args": [
            "tkr",
            "clocksource_delta(\n\t\t\t\t\ttk_clock_read(tkr),\n\t\t\t\t\ttkr->cycle_last,\n\t\t\t\t\ttkr->mask)"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_delta_to_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "356-365",
          "snippet": "static inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\treturn nsec + arch_gettimeoffset();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\treturn nsec + arch_gettimeoffset();\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "tk_clock_read(tkr)",
            "tkr->cycle_last",
            "tkr->mask"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping_internal.h",
          "lines": "28-31",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "tkr"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "166-171",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "tkr->base_real"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_read_seqcount_latch",
          "args": [
            "&tkf->seq"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic __always_inline u64 __ktime_get_real_fast_ns(struct tk_fast *tkf)\n{\n\tstruct tk_read_base *tkr;\n\tunsigned int seq;\n\tu64 now;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tnow = ktime_to_ns(tkr->base_real);\n\n\t\tnow += timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(\n\t\t\t\t\ttk_clock_read(tkr),\n\t\t\t\t\ttkr->cycle_last,\n\t\t\t\t\ttkr->mask));\n\t} while (read_seqcount_retry(&tkf->seq, seq));\n\n\treturn now;\n}"
  },
  {
    "function_name": "ktime_get_boot_fast_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "502-507",
    "snippet": "u64 notrace ktime_get_boot_fast_ns(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn (ktime_get_mono_fast_ns() + ktime_to_ns(tk->offs_boot));\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "tk->offs_boot"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_mono_fast_ns",
          "args": [],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_mono_fast_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "469-472",
          "snippet": "u64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 notrace ktime_get_boot_fast_ns(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn (ktime_get_mono_fast_ns() + ktime_to_ns(tk->offs_boot));\n}"
  },
  {
    "function_name": "ktime_get_raw_fast_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "475-478",
    "snippet": "u64 ktime_get_raw_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_raw);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ktime_get_fast_ns",
          "args": [
            "&tk_fast_raw"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_fast_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "448-467",
          "snippet": "static __always_inline u64 __ktime_get_fast_ns(struct tk_fast *tkf)\n{\n\tstruct tk_read_base *tkr;\n\tunsigned int seq;\n\tu64 now;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tnow = ktime_to_ns(tkr->base);\n\n\t\tnow += timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(\n\t\t\t\t\ttk_clock_read(tkr),\n\t\t\t\t\ttkr->cycle_last,\n\t\t\t\t\ttkr->mask));\n\t} while (read_seqcount_retry(&tkf->seq, seq));\n\n\treturn now;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic __always_inline u64 __ktime_get_fast_ns(struct tk_fast *tkf)\n{\n\tstruct tk_read_base *tkr;\n\tunsigned int seq;\n\tu64 now;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tnow = ktime_to_ns(tkr->base);\n\n\t\tnow += timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(\n\t\t\t\t\ttk_clock_read(tkr),\n\t\t\t\t\ttkr->cycle_last,\n\t\t\t\t\ttkr->mask));\n\t} while (read_seqcount_retry(&tkf->seq, seq));\n\n\treturn now;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_raw_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_raw);\n}"
  },
  {
    "function_name": "ktime_get_mono_fast_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "469-472",
    "snippet": "u64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ktime_get_fast_ns",
          "args": [
            "&tk_fast_mono"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_fast_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "448-467",
          "snippet": "static __always_inline u64 __ktime_get_fast_ns(struct tk_fast *tkf)\n{\n\tstruct tk_read_base *tkr;\n\tunsigned int seq;\n\tu64 now;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tnow = ktime_to_ns(tkr->base);\n\n\t\tnow += timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(\n\t\t\t\t\ttk_clock_read(tkr),\n\t\t\t\t\ttkr->cycle_last,\n\t\t\t\t\ttkr->mask));\n\t} while (read_seqcount_retry(&tkf->seq, seq));\n\n\treturn now;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic __always_inline u64 __ktime_get_fast_ns(struct tk_fast *tkf)\n{\n\tstruct tk_read_base *tkr;\n\tunsigned int seq;\n\tu64 now;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tnow = ktime_to_ns(tkr->base);\n\n\t\tnow += timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(\n\t\t\t\t\ttk_clock_read(tkr),\n\t\t\t\t\ttkr->cycle_last,\n\t\t\t\t\ttkr->mask));\n\t} while (read_seqcount_retry(&tkf->seq, seq));\n\n\treturn now;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}"
  },
  {
    "function_name": "__ktime_get_fast_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "448-467",
    "snippet": "static __always_inline u64 __ktime_get_fast_ns(struct tk_fast *tkf)\n{\n\tstruct tk_read_base *tkr;\n\tunsigned int seq;\n\tu64 now;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tnow = ktime_to_ns(tkr->base);\n\n\t\tnow += timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(\n\t\t\t\t\ttk_clock_read(tkr),\n\t\t\t\t\ttkr->cycle_last,\n\t\t\t\t\ttkr->mask));\n\t} while (read_seqcount_retry(&tkf->seq, seq));\n\n\treturn now;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tkf->seq",
            "seq"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timekeeping_delta_to_ns",
          "args": [
            "tkr",
            "clocksource_delta(\n\t\t\t\t\ttk_clock_read(tkr),\n\t\t\t\t\ttkr->cycle_last,\n\t\t\t\t\ttkr->mask)"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_delta_to_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "356-365",
          "snippet": "static inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\treturn nsec + arch_gettimeoffset();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\treturn nsec + arch_gettimeoffset();\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "tk_clock_read(tkr)",
            "tkr->cycle_last",
            "tkr->mask"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping_internal.h",
          "lines": "28-31",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "tkr"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "166-171",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "tkr->base"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_read_seqcount_latch",
          "args": [
            "&tkf->seq"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic __always_inline u64 __ktime_get_fast_ns(struct tk_fast *tkf)\n{\n\tstruct tk_read_base *tkr;\n\tunsigned int seq;\n\tu64 now;\n\n\tdo {\n\t\tseq = raw_read_seqcount_latch(&tkf->seq);\n\t\ttkr = tkf->base + (seq & 0x01);\n\t\tnow = ktime_to_ns(tkr->base);\n\n\t\tnow += timekeeping_delta_to_ns(tkr,\n\t\t\t\tclocksource_delta(\n\t\t\t\t\ttk_clock_read(tkr),\n\t\t\t\t\ttkr->cycle_last,\n\t\t\t\t\ttkr->mask));\n\t} while (read_seqcount_retry(&tkf->seq, seq));\n\n\treturn now;\n}"
  },
  {
    "function_name": "update_fast_timekeeper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "398-414",
    "snippet": "static void update_fast_timekeeper(const struct tk_read_base *tkr,\n\t\t\t\t   struct tk_fast *tkf)\n{\n\tstruct tk_read_base *base = tkf->base;\n\n\t/* Force readers off to base[1] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[0] */\n\tmemcpy(base, tkr, sizeof(*base));\n\n\t/* Force readers back to base[0] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[1] */\n\tmemcpy(base + 1, base, sizeof(*base));\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "base + 1",
            "base",
            "sizeof(*base)"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_write_seqcount_latch",
          "args": [
            "&tkf->seq"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_write_seqcount_latch",
          "args": [
            "&tkf->seq"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void update_fast_timekeeper(const struct tk_read_base *tkr,\n\t\t\t\t   struct tk_fast *tkf)\n{\n\tstruct tk_read_base *base = tkf->base;\n\n\t/* Force readers off to base[1] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[0] */\n\tmemcpy(base, tkr, sizeof(*base));\n\n\t/* Force readers back to base[0] */\n\traw_write_seqcount_latch(&tkf->seq);\n\n\t/* Update base[1] */\n\tmemcpy(base + 1, base, sizeof(*base));\n}"
  },
  {
    "function_name": "timekeeping_cycles_to_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "375-382",
    "snippet": "static inline u64 timekeeping_cycles_to_ns(const struct tk_read_base *tkr, u64 cycles)\n{\n\tu64 delta;\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycles, tkr->cycle_last, tkr->mask);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timekeeping_delta_to_ns",
          "args": [
            "tkr",
            "delta"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_delta_to_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "356-365",
          "snippet": "static inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\treturn nsec + arch_gettimeoffset();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\treturn nsec + arch_gettimeoffset();\n}"
        }
      },
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "cycles",
            "tkr->cycle_last",
            "tkr->mask"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping_internal.h",
          "lines": "28-31",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_cycles_to_ns(const struct tk_read_base *tkr, u64 cycles)\n{\n\tu64 delta;\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycles, tkr->cycle_last, tkr->mask);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
  },
  {
    "function_name": "timekeeping_get_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "367-373",
    "snippet": "static inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timekeeping_delta_to_ns",
          "args": [
            "tkr",
            "delta"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_delta_to_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "356-365",
          "snippet": "static inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\treturn nsec + arch_gettimeoffset();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\treturn nsec + arch_gettimeoffset();\n}"
        }
      },
      {
        "call_info": {
          "callee": "timekeeping_get_delta",
          "args": [
            "tkr"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "timekeeping_get_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "259-270",
          "snippet": "static inline u64 timekeeping_get_delta(const struct tk_read_base *tkr)\n{\n\tu64 cycle_now, delta;\n\n\t/* read clocksource */\n\tcycle_now = tk_clock_read(tkr);\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycle_now, tkr->cycle_last, tkr->mask);\n\n\treturn delta;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_delta(const struct tk_read_base *tkr)\n{\n\tu64 cycle_now, delta;\n\n\t/* read clocksource */\n\tcycle_now = tk_clock_read(tkr);\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycle_now, tkr->cycle_last, tkr->mask);\n\n\treturn delta;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_ns(const struct tk_read_base *tkr)\n{\n\tu64 delta;\n\n\tdelta = timekeeping_get_delta(tkr);\n\treturn timekeeping_delta_to_ns(tkr, delta);\n}"
  },
  {
    "function_name": "timekeeping_delta_to_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "356-365",
    "snippet": "static inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\treturn nsec + arch_gettimeoffset();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_gettimeoffset",
          "args": [],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "arch_gettimeoffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "353-353",
          "snippet": "static inline u32 arch_gettimeoffset(void) { return 0; }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u32 arch_gettimeoffset(void) { return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_delta_to_ns(const struct tk_read_base *tkr, u64 delta)\n{\n\tu64 nsec;\n\n\tnsec = delta * tkr->mult + tkr->xtime_nsec;\n\tnsec >>= tkr->shift;\n\n\t/* If arch requires, add in get_arch_timeoffset() */\n\treturn nsec + arch_gettimeoffset();\n}"
  },
  {
    "function_name": "arch_gettimeoffset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "353-353",
    "snippet": "static inline u32 arch_gettimeoffset(void) { return 0; }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u32 arch_gettimeoffset(void) { return 0; }"
  },
  {
    "function_name": "default_arch_gettimeoffset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "350-350",
    "snippet": "static u32 default_arch_gettimeoffset(void) { return 0; }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic u32 default_arch_gettimeoffset(void) { return 0; }"
  },
  {
    "function_name": "tk_setup_internals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "284-345",
    "snippet": "static void tk_setup_internals(struct timekeeper *tk, struct clocksource *clock)\n{\n\tu64 interval;\n\tu64 tmp, ntpinterval;\n\tstruct clocksource *old_clock;\n\n\t++tk->cs_was_changed_seq;\n\told_clock = tk->tkr_mono.clock;\n\ttk->tkr_mono.clock = clock;\n\ttk->tkr_mono.mask = clock->mask;\n\ttk->tkr_mono.cycle_last = tk_clock_read(&tk->tkr_mono);\n\n\ttk->tkr_raw.clock = clock;\n\ttk->tkr_raw.mask = clock->mask;\n\ttk->tkr_raw.cycle_last = tk->tkr_mono.cycle_last;\n\n\t/* Do the ns -> cycle conversion first, using original mult */\n\ttmp = NTP_INTERVAL_LENGTH;\n\ttmp <<= clock->shift;\n\tntpinterval = tmp;\n\ttmp += clock->mult/2;\n\tdo_div(tmp, clock->mult);\n\tif (tmp == 0)\n\t\ttmp = 1;\n\n\tinterval = (u64) tmp;\n\ttk->cycle_interval = interval;\n\n\t/* Go back from cycles -> shifted ns */\n\ttk->xtime_interval = interval * clock->mult;\n\ttk->xtime_remainder = ntpinterval - tk->xtime_interval;\n\ttk->raw_interval = interval * clock->mult;\n\n\t /* if changing clocks, convert xtime_nsec shift units */\n\tif (old_clock) {\n\t\tint shift_change = clock->shift - old_clock->shift;\n\t\tif (shift_change < 0) {\n\t\t\ttk->tkr_mono.xtime_nsec >>= -shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec >>= -shift_change;\n\t\t} else {\n\t\t\ttk->tkr_mono.xtime_nsec <<= shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec <<= shift_change;\n\t\t}\n\t}\n\n\ttk->tkr_mono.shift = clock->shift;\n\ttk->tkr_raw.shift = clock->shift;\n\n\ttk->ntp_error = 0;\n\ttk->ntp_error_shift = NTP_SCALE_SHIFT - clock->shift;\n\ttk->ntp_tick = ntpinterval << tk->ntp_error_shift;\n\n\t/*\n\t * The timekeeper keeps its own mult values for the currently\n\t * active clocksource. These value will be adjusted via NTP\n\t * to counteract clock drifting.\n\t */\n\ttk->tkr_mono.mult = clock->mult;\n\ttk->tkr_raw.mult = clock->mult;\n\ttk->ntp_err_mult = 0;\n\ttk->skip_second_overflow = 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tmp",
            "clock->mult"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "&tk->tkr_mono"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "166-171",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_setup_internals(struct timekeeper *tk, struct clocksource *clock)\n{\n\tu64 interval;\n\tu64 tmp, ntpinterval;\n\tstruct clocksource *old_clock;\n\n\t++tk->cs_was_changed_seq;\n\told_clock = tk->tkr_mono.clock;\n\ttk->tkr_mono.clock = clock;\n\ttk->tkr_mono.mask = clock->mask;\n\ttk->tkr_mono.cycle_last = tk_clock_read(&tk->tkr_mono);\n\n\ttk->tkr_raw.clock = clock;\n\ttk->tkr_raw.mask = clock->mask;\n\ttk->tkr_raw.cycle_last = tk->tkr_mono.cycle_last;\n\n\t/* Do the ns -> cycle conversion first, using original mult */\n\ttmp = NTP_INTERVAL_LENGTH;\n\ttmp <<= clock->shift;\n\tntpinterval = tmp;\n\ttmp += clock->mult/2;\n\tdo_div(tmp, clock->mult);\n\tif (tmp == 0)\n\t\ttmp = 1;\n\n\tinterval = (u64) tmp;\n\ttk->cycle_interval = interval;\n\n\t/* Go back from cycles -> shifted ns */\n\ttk->xtime_interval = interval * clock->mult;\n\ttk->xtime_remainder = ntpinterval - tk->xtime_interval;\n\ttk->raw_interval = interval * clock->mult;\n\n\t /* if changing clocks, convert xtime_nsec shift units */\n\tif (old_clock) {\n\t\tint shift_change = clock->shift - old_clock->shift;\n\t\tif (shift_change < 0) {\n\t\t\ttk->tkr_mono.xtime_nsec >>= -shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec >>= -shift_change;\n\t\t} else {\n\t\t\ttk->tkr_mono.xtime_nsec <<= shift_change;\n\t\t\ttk->tkr_raw.xtime_nsec <<= shift_change;\n\t\t}\n\t}\n\n\ttk->tkr_mono.shift = clock->shift;\n\ttk->tkr_raw.shift = clock->shift;\n\n\ttk->ntp_error = 0;\n\ttk->ntp_error_shift = NTP_SCALE_SHIFT - clock->shift;\n\ttk->ntp_tick = ntpinterval << tk->ntp_error_shift;\n\n\t/*\n\t * The timekeeper keeps its own mult values for the currently\n\t * active clocksource. These value will be adjusted via NTP\n\t * to counteract clock drifting.\n\t */\n\ttk->tkr_mono.mult = clock->mult;\n\ttk->tkr_raw.mult = clock->mult;\n\ttk->ntp_err_mult = 0;\n\ttk->skip_second_overflow = 0;\n}"
  },
  {
    "function_name": "timekeeping_get_delta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "259-270",
    "snippet": "static inline u64 timekeeping_get_delta(const struct tk_read_base *tkr)\n{\n\tu64 cycle_now, delta;\n\n\t/* read clocksource */\n\tcycle_now = tk_clock_read(tkr);\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycle_now, tkr->cycle_last, tkr->mask);\n\n\treturn delta;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "cycle_now",
            "tkr->cycle_last",
            "tkr->mask"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping_internal.h",
          "lines": "28-31",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "tkr"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "166-171",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_delta(const struct tk_read_base *tkr)\n{\n\tu64 cycle_now, delta;\n\n\t/* read clocksource */\n\tcycle_now = tk_clock_read(tkr);\n\n\t/* calculate the delta since the last update_wall_time */\n\tdelta = clocksource_delta(cycle_now, tkr->cycle_last, tkr->mask);\n\n\treturn delta;\n}"
  },
  {
    "function_name": "timekeeping_check_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "256-258",
    "snippet": "static inline void timekeeping_check_update(struct timekeeper *tk, u64 offset)\n{\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void timekeeping_check_update(struct timekeeper *tk, u64 offset)\n{\n}"
  },
  {
    "function_name": "timekeeping_get_delta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "215-254",
    "snippet": "static inline u64 timekeeping_get_delta(const struct tk_read_base *tkr)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tu64 now, last, mask, max, delta;\n\tunsigned int seq;\n\n\t/*\n\t * Since we're called holding a seqlock, the data may shift\n\t * under us while we're doing the calculation. This can cause\n\t * false positives, since we'd note a problem but throw the\n\t * results away. So nest another seqlock here to atomically\n\t * grab the points we are checking with.\n\t */\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tnow = tk_clock_read(tkr);\n\t\tlast = tkr->cycle_last;\n\t\tmask = tkr->mask;\n\t\tmax = tkr->clock->max_cycles;\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tdelta = clocksource_delta(now, last, mask);\n\n\t/*\n\t * Try to catch underflows by checking if we are seeing small\n\t * mask-relative negative values.\n\t */\n\tif (unlikely((~delta & mask) < (mask >> 3))) {\n\t\ttk->underflow_seen = 1;\n\t\tdelta = 0;\n\t}\n\n\t/* Cap delta value to the max_cycles values to avoid mult overflows */\n\tif (unlikely(delta > max)) {\n\t\ttk->overflow_seen = 1;\n\t\tdelta = tkr->clock->max_cycles;\n\t}\n\n\treturn delta;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "delta > max"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(~delta & mask) < (mask >> 3)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clocksource_delta",
          "args": [
            "now",
            "last",
            "mask"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping_internal.h",
          "lines": "28-31",
          "snippet": "static inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}",
          "includes": [
            "#include <linux/time.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/time.h>\n#include <linux/clocksource.h>\n\nstatic inline u64 clocksource_delta(u64 now, u64 last, u64 mask)\n{\n\treturn (now - last) & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&tk_core.seq",
            "seq"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tk_clock_read",
          "args": [
            "tkr"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "tk_clock_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "166-171",
          "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqcount_begin",
          "args": [
            "&tk_core.seq"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 timekeeping_get_delta(const struct tk_read_base *tkr)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tu64 now, last, mask, max, delta;\n\tunsigned int seq;\n\n\t/*\n\t * Since we're called holding a seqlock, the data may shift\n\t * under us while we're doing the calculation. This can cause\n\t * false positives, since we'd note a problem but throw the\n\t * results away. So nest another seqlock here to atomically\n\t * grab the points we are checking with.\n\t */\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\t\tnow = tk_clock_read(tkr);\n\t\tlast = tkr->cycle_last;\n\t\tmask = tkr->mask;\n\t\tmax = tkr->clock->max_cycles;\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tdelta = clocksource_delta(now, last, mask);\n\n\t/*\n\t * Try to catch underflows by checking if we are seeing small\n\t * mask-relative negative values.\n\t */\n\tif (unlikely((~delta & mask) < (mask >> 3))) {\n\t\ttk->underflow_seen = 1;\n\t\tdelta = 0;\n\t}\n\n\t/* Cap delta value to the max_cycles values to avoid mult overflows */\n\tif (unlikely(delta > max)) {\n\t\ttk->overflow_seen = 1;\n\t\tdelta = tkr->clock->max_cycles;\n\t}\n\n\treturn delta;\n}"
  },
  {
    "function_name": "timekeeping_check_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "176-213",
    "snippet": "static void timekeeping_check_update(struct timekeeper *tk, u64 offset)\n{\n\n\tu64 max_cycles = tk->tkr_mono.clock->max_cycles;\n\tconst char *name = tk->tkr_mono.clock->name;\n\n\tif (offset > max_cycles) {\n\t\tprintk_deferred(\"WARNING: timekeeping: Cycle offset (%lld) is larger than allowed by the '%s' clock's max_cycles value (%lld): time overflow danger\\n\",\n\t\t\t\toffset, name, max_cycles);\n\t\tprintk_deferred(\"         timekeeping: Your kernel is sick, but tries to cope by capping time updates\\n\");\n\t} else {\n\t\tif (offset > (max_cycles >> 1)) {\n\t\t\tprintk_deferred(\"INFO: timekeeping: Cycle offset (%lld) is larger than the '%s' clock's 50%% safety margin (%lld)\\n\",\n\t\t\t\t\toffset, name, max_cycles >> 1);\n\t\t\tprintk_deferred(\"      timekeeping: Your kernel is still fine, but is feeling a bit nervous\\n\");\n\t\t}\n\t}\n\n\tif (tk->underflow_seen) {\n\t\tif (jiffies - tk->last_warning > WARNING_FREQ) {\n\t\t\tprintk_deferred(\"WARNING: Underflow in clocksource '%s' observed, time update ignored.\\n\", name);\n\t\t\tprintk_deferred(\"         Please report this, consider using a different clocksource, if possible.\\n\");\n\t\t\tprintk_deferred(\"         Your kernel is probably still fine.\\n\");\n\t\t\ttk->last_warning = jiffies;\n\t\t}\n\t\ttk->underflow_seen = 0;\n\t}\n\n\tif (tk->overflow_seen) {\n\t\tif (jiffies - tk->last_warning > WARNING_FREQ) {\n\t\t\tprintk_deferred(\"WARNING: Overflow in clocksource '%s' observed, time update capped.\\n\", name);\n\t\t\tprintk_deferred(\"         Please report this, consider using a different clocksource, if possible.\\n\");\n\t\t\tprintk_deferred(\"         Your kernel is probably still fine.\\n\");\n\t\t\ttk->last_warning = jiffies;\n\t\t}\n\t\ttk->overflow_seen = 0;\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [
      "#define WARNING_FREQ (HZ*300) /* 5 minute rate-limiting */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "\"         Your kernel is probably still fine.\\n\""
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "printk_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2926-2936",
          "snippet": "int printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\n#define WARNING_FREQ (HZ*300) /* 5 minute rate-limiting */\n\nstatic void timekeeping_check_update(struct timekeeper *tk, u64 offset)\n{\n\n\tu64 max_cycles = tk->tkr_mono.clock->max_cycles;\n\tconst char *name = tk->tkr_mono.clock->name;\n\n\tif (offset > max_cycles) {\n\t\tprintk_deferred(\"WARNING: timekeeping: Cycle offset (%lld) is larger than allowed by the '%s' clock's max_cycles value (%lld): time overflow danger\\n\",\n\t\t\t\toffset, name, max_cycles);\n\t\tprintk_deferred(\"         timekeeping: Your kernel is sick, but tries to cope by capping time updates\\n\");\n\t} else {\n\t\tif (offset > (max_cycles >> 1)) {\n\t\t\tprintk_deferred(\"INFO: timekeeping: Cycle offset (%lld) is larger than the '%s' clock's 50%% safety margin (%lld)\\n\",\n\t\t\t\t\toffset, name, max_cycles >> 1);\n\t\t\tprintk_deferred(\"      timekeeping: Your kernel is still fine, but is feeling a bit nervous\\n\");\n\t\t}\n\t}\n\n\tif (tk->underflow_seen) {\n\t\tif (jiffies - tk->last_warning > WARNING_FREQ) {\n\t\t\tprintk_deferred(\"WARNING: Underflow in clocksource '%s' observed, time update ignored.\\n\", name);\n\t\t\tprintk_deferred(\"         Please report this, consider using a different clocksource, if possible.\\n\");\n\t\t\tprintk_deferred(\"         Your kernel is probably still fine.\\n\");\n\t\t\ttk->last_warning = jiffies;\n\t\t}\n\t\ttk->underflow_seen = 0;\n\t}\n\n\tif (tk->overflow_seen) {\n\t\tif (jiffies - tk->last_warning > WARNING_FREQ) {\n\t\t\tprintk_deferred(\"WARNING: Overflow in clocksource '%s' observed, time update capped.\\n\", name);\n\t\t\tprintk_deferred(\"         Please report this, consider using a different clocksource, if possible.\\n\");\n\t\t\tprintk_deferred(\"         Your kernel is probably still fine.\\n\");\n\t\t\ttk->last_warning = jiffies;\n\t\t}\n\t\ttk->overflow_seen = 0;\n\t}\n}"
  },
  {
    "function_name": "tk_clock_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "166-171",
    "snippet": "static inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clock->read",
          "args": [
            "clock"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "tkr->clock"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline u64 tk_clock_read(const struct tk_read_base *tkr)\n{\n\tstruct clocksource *clock = READ_ONCE(tkr->clock);\n\n\treturn clock->read(clock);\n}"
  },
  {
    "function_name": "tk_update_sleep_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "148-151",
    "snippet": "static inline void tk_update_sleep_time(struct timekeeper *tk, ktime_t delta)\n{\n\ttk->offs_boot = ktime_add(tk->offs_boot, delta);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "tk->offs_boot",
            "delta"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_update_sleep_time(struct timekeeper *tk, ktime_t delta)\n{\n\ttk->offs_boot = ktime_add(tk->offs_boot, delta);\n}"
  },
  {
    "function_name": "tk_set_wall_to_mono",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "131-146",
    "snippet": "static void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "tk->offs_real",
            "ktime_set(tk->tai_offset, 0)"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "323-335",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_set",
          "args": [
            "tk->tai_offset",
            "0"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "tmp"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_normalized_timespec64",
          "args": [
            "&tmp",
            "-wtm.tv_sec",
            "-wtm.tv_nsec"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "set_normalized_timespec64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "494-513",
          "snippet": "void set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)\n{\n\twhile (nsec >= NSEC_PER_SEC) {\n\t\t/*\n\t\t * The following asm() prevents the compiler from\n\t\t * optimising this loop into a modulo operation. See\n\t\t * also __iter_div_u64_rem() in include/linux/time.h\n\t\t */\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec -= NSEC_PER_SEC;\n\t\t++sec;\n\t}\n\twhile (nsec < 0) {\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec += NSEC_PER_SEC;\n\t\t--sec;\n\t}\n\tts->tv_sec = sec;\n\tts->tv_nsec = nsec;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)\n{\n\twhile (nsec >= NSEC_PER_SEC) {\n\t\t/*\n\t\t * The following asm() prevents the compiler from\n\t\t * optimising this loop into a modulo operation. See\n\t\t * also __iter_div_u64_rem() in include/linux/time.h\n\t\t */\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec -= NSEC_PER_SEC;\n\t\t++sec;\n\t}\n\twhile (nsec < 0) {\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec += NSEC_PER_SEC;\n\t\t--sec;\n\t}\n\tts->tv_sec = sec;\n\tts->tv_nsec = nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "tk->offs_real != timespec64_to_ktime(tmp)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "tmp"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_set_wall_to_mono(struct timekeeper *tk, struct timespec64 wtm)\n{\n\tstruct timespec64 tmp;\n\n\t/*\n\t * Verify consistency of: offset_real = -wall_to_monotonic\n\t * before modifying anything\n\t */\n\tset_normalized_timespec64(&tmp, -tk->wall_to_monotonic.tv_sec,\n\t\t\t\t\t-tk->wall_to_monotonic.tv_nsec);\n\tWARN_ON_ONCE(tk->offs_real != timespec64_to_ktime(tmp));\n\ttk->wall_to_monotonic = wtm;\n\tset_normalized_timespec64(&tmp, -wtm.tv_sec, -wtm.tv_nsec);\n\ttk->offs_real = timespec64_to_ktime(tmp);\n\ttk->offs_tai = ktime_add(tk->offs_real, ktime_set(tk->tai_offset, 0));\n}"
  },
  {
    "function_name": "tk_xtime_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "124-129",
    "snippet": "static void tk_xtime_add(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec += ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec += (u64)ts->tv_nsec << tk->tkr_mono.shift;\n\ttk_normalize_xtime(tk);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tk_normalize_xtime",
          "args": [
            "tk"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "tk_normalize_xtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "97-107",
          "snippet": "static inline void tk_normalize_xtime(struct timekeeper *tk)\n{\n\twhile (tk->tkr_mono.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_mono.shift)) {\n\t\ttk->tkr_mono.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\t\ttk->xtime_sec++;\n\t}\n\twhile (tk->tkr_raw.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_raw.shift)) {\n\t\ttk->tkr_raw.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\t\ttk->raw_sec++;\n\t}\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_normalize_xtime(struct timekeeper *tk)\n{\n\twhile (tk->tkr_mono.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_mono.shift)) {\n\t\ttk->tkr_mono.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\t\ttk->xtime_sec++;\n\t}\n\twhile (tk->tkr_raw.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_raw.shift)) {\n\t\ttk->tkr_raw.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\t\ttk->raw_sec++;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_xtime_add(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec += ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec += (u64)ts->tv_nsec << tk->tkr_mono.shift;\n\ttk_normalize_xtime(tk);\n}"
  },
  {
    "function_name": "tk_set_xtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "118-122",
    "snippet": "static void tk_set_xtime(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec = ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec = (u64)ts->tv_nsec << tk->tkr_mono.shift;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic void tk_set_xtime(struct timekeeper *tk, const struct timespec64 *ts)\n{\n\ttk->xtime_sec = ts->tv_sec;\n\ttk->tkr_mono.xtime_nsec = (u64)ts->tv_nsec << tk->tkr_mono.shift;\n}"
  },
  {
    "function_name": "tk_xtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "109-116",
    "snippet": "static inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline struct timespec64 tk_xtime(const struct timekeeper *tk)\n{\n\tstruct timespec64 ts;\n\n\tts.tv_sec = tk->xtime_sec;\n\tts.tv_nsec = (long)(tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift);\n\treturn ts;\n}"
  },
  {
    "function_name": "tk_normalize_xtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "97-107",
    "snippet": "static inline void tk_normalize_xtime(struct timekeeper *tk)\n{\n\twhile (tk->tkr_mono.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_mono.shift)) {\n\t\ttk->tkr_mono.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\t\ttk->xtime_sec++;\n\t}\n\twhile (tk->tkr_raw.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_raw.shift)) {\n\t\ttk->tkr_raw.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\t\ttk->raw_sec++;\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic inline void tk_normalize_xtime(struct timekeeper *tk)\n{\n\twhile (tk->tkr_mono.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_mono.shift)) {\n\t\ttk->tkr_mono.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_mono.shift;\n\t\ttk->xtime_sec++;\n\t}\n\twhile (tk->tkr_raw.xtime_nsec >= ((u64)NSEC_PER_SEC << tk->tkr_raw.shift)) {\n\t\ttk->tkr_raw.xtime_nsec -= (u64)NSEC_PER_SEC << tk->tkr_raw.shift;\n\t\ttk->raw_sec++;\n\t}\n}"
  },
  {
    "function_name": "dummy_clock_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
    "lines": "75-78",
    "snippet": "static u64 dummy_clock_read(struct clocksource *cs)\n{\n\treturn cycles_at_suspend;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include \"tick-internal.h\"",
      "#include <linux/compiler.h>",
      "#include <linux/pvclock_gtod.h>",
      "#include <linux/stop_machine.h>",
      "#include <linux/tick.h>",
      "#include <linux/time.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/syscore_ops.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/nmi.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/timekeeper_internal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 cycles_at_suspend;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nstatic u64 cycles_at_suspend;\n\nstatic u64 dummy_clock_read(struct clocksource *cs)\n{\n\treturn cycles_at_suspend;\n}"
  }
]