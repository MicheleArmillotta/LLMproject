[
  {
    "function_name": "gcov_iter_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "556-570",
    "snippet": "int gcov_iter_write(struct gcov_iterator *iter, struct seq_file *seq)\n{\n\tsize_t len;\n\n\tif (iter->pos >= iter->size)\n\t\treturn -EINVAL;\n\n\tlen = ITER_STRIDE;\n\tif (iter->pos + len > iter->size)\n\t\tlen = iter->size - iter->pos;\n\n\tseq_write(seq, iter->buffer + iter->pos, len);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define ITER_STRIDE\tPAGE_SIZE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_write",
          "args": [
            "seq",
            "iter->buffer + iter->pos",
            "len"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define ITER_STRIDE\tPAGE_SIZE\n\nint gcov_iter_write(struct gcov_iterator *iter, struct seq_file *seq)\n{\n\tsize_t len;\n\n\tif (iter->pos >= iter->size)\n\t\treturn -EINVAL;\n\n\tlen = ITER_STRIDE;\n\tif (iter->pos + len > iter->size)\n\t\tlen = iter->size - iter->pos;\n\n\tseq_write(seq, iter->buffer + iter->pos, len);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gcov_iter_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "538-547",
    "snippet": "int gcov_iter_next(struct gcov_iterator *iter)\n{\n\tif (iter->pos < iter->size)\n\t\titer->pos += ITER_STRIDE;\n\n\tif (iter->pos >= iter->size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define ITER_STRIDE\tPAGE_SIZE"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define ITER_STRIDE\tPAGE_SIZE\n\nint gcov_iter_next(struct gcov_iterator *iter)\n{\n\tif (iter->pos < iter->size)\n\t\titer->pos += ITER_STRIDE;\n\n\tif (iter->pos >= iter->size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gcov_iter_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "527-530",
    "snippet": "void gcov_iter_start(struct gcov_iterator *iter)\n{\n\titer->pos = 0;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid gcov_iter_start(struct gcov_iterator *iter)\n{\n\titer->pos = 0;\n}"
  },
  {
    "function_name": "gcov_iter_get_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "518-521",
    "snippet": "struct gcov_info *gcov_iter_get_info(struct gcov_iterator *iter)\n{\n\treturn iter->info;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstruct gcov_info *gcov_iter_get_info(struct gcov_iterator *iter)\n{\n\treturn iter->info;\n}"
  },
  {
    "function_name": "gcov_iter_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "508-512",
    "snippet": "void gcov_iter_free(struct gcov_iterator *iter)\n{\n\tvfree(iter->buffer);\n\tkfree(iter);\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iter"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "iter->buffer"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid gcov_iter_free(struct gcov_iterator *iter)\n{\n\tvfree(iter->buffer);\n\tkfree(iter);\n}"
  },
  {
    "function_name": "gcov_iter_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "479-501",
    "snippet": "struct gcov_iterator *gcov_iter_new(struct gcov_info *info)\n{\n\tstruct gcov_iterator *iter;\n\n\titer = kzalloc(sizeof(struct gcov_iterator), GFP_KERNEL);\n\tif (!iter)\n\t\tgoto err_free;\n\n\titer->info = info;\n\t/* Dry-run to get the actual buffer size. */\n\titer->size = convert_to_gcda(NULL, info);\n\titer->buffer = vmalloc(iter->size);\n\tif (!iter->buffer)\n\t\tgoto err_free;\n\n\tconvert_to_gcda(iter->buffer, info);\n\n\treturn iter;\n\nerr_free:\n\tkfree(iter);\n\treturn NULL;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iter"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_to_gcda",
          "args": [
            "iter->buffer",
            "info"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "convert_to_gcda",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
          "lines": "426-471",
          "snippet": "static size_t convert_to_gcda(char *buffer, struct gcov_info *info)\n{\n\tstruct gcov_fn_info *fi_ptr;\n\tstruct gcov_ctr_info *ci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tunsigned int cv_idx;\n\tsize_t pos = 0;\n\n\t/* File header. */\n\tpos += store_gcov_u32(buffer, pos, GCOV_DATA_MAGIC);\n\tpos += store_gcov_u32(buffer, pos, info->version);\n\tpos += store_gcov_u32(buffer, pos, info->stamp);\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tfi_ptr = info->functions[fi_idx];\n\n\t\t/* Function record. */\n\t\tpos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION);\n\t\tpos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION_LENGTH);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->ident);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->lineno_checksum);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->cfg_checksum);\n\n\t\tci_ptr = fi_ptr->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(info, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\t/* Counter record. */\n\t\t\tpos += store_gcov_u32(buffer, pos,\n\t\t\t\t\t      GCOV_TAG_FOR_COUNTER(ct_idx));\n\t\t\tpos += store_gcov_u32(buffer, pos, ci_ptr->num * 2);\n\n\t\t\tfor (cv_idx = 0; cv_idx < ci_ptr->num; cv_idx++) {\n\t\t\t\tpos += store_gcov_u64(buffer, pos,\n\t\t\t\t\t\t      ci_ptr->values[cv_idx]);\n\t\t\t}\n\n\t\t\tci_ptr++;\n\t\t}\n\t}\n\n\treturn pos;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define GCOV_TAG_FUNCTION_LENGTH\t3",
            "#define GCOV_COUNTERS\t\t\t8",
            "#define GCOV_COUNTERS\t\t\t9",
            "#define GCOV_COUNTERS\t\t\t10",
            "#define GCOV_COUNTERS\t\t\t9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define GCOV_TAG_FUNCTION_LENGTH\t3\n#define GCOV_COUNTERS\t\t\t8\n#define GCOV_COUNTERS\t\t\t9\n#define GCOV_COUNTERS\t\t\t10\n#define GCOV_COUNTERS\t\t\t9\n\nstatic size_t convert_to_gcda(char *buffer, struct gcov_info *info)\n{\n\tstruct gcov_fn_info *fi_ptr;\n\tstruct gcov_ctr_info *ci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tunsigned int cv_idx;\n\tsize_t pos = 0;\n\n\t/* File header. */\n\tpos += store_gcov_u32(buffer, pos, GCOV_DATA_MAGIC);\n\tpos += store_gcov_u32(buffer, pos, info->version);\n\tpos += store_gcov_u32(buffer, pos, info->stamp);\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tfi_ptr = info->functions[fi_idx];\n\n\t\t/* Function record. */\n\t\tpos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION);\n\t\tpos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION_LENGTH);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->ident);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->lineno_checksum);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->cfg_checksum);\n\n\t\tci_ptr = fi_ptr->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(info, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\t/* Counter record. */\n\t\t\tpos += store_gcov_u32(buffer, pos,\n\t\t\t\t\t      GCOV_TAG_FOR_COUNTER(ct_idx));\n\t\t\tpos += store_gcov_u32(buffer, pos, ci_ptr->num * 2);\n\n\t\t\tfor (cv_idx = 0; cv_idx < ci_ptr->num; cv_idx++) {\n\t\t\t\tpos += store_gcov_u64(buffer, pos,\n\t\t\t\t\t\t      ci_ptr->values[cv_idx]);\n\t\t\t}\n\n\t\t\tci_ptr++;\n\t\t}\n\t}\n\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "iter->size"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct gcov_iterator)",
            "GFP_KERNEL"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstruct gcov_iterator *gcov_iter_new(struct gcov_info *info)\n{\n\tstruct gcov_iterator *iter;\n\n\titer = kzalloc(sizeof(struct gcov_iterator), GFP_KERNEL);\n\tif (!iter)\n\t\tgoto err_free;\n\n\titer->info = info;\n\t/* Dry-run to get the actual buffer size. */\n\titer->size = convert_to_gcda(NULL, info);\n\titer->buffer = vmalloc(iter->size);\n\tif (!iter->buffer)\n\t\tgoto err_free;\n\n\tconvert_to_gcda(iter->buffer, info);\n\n\treturn iter;\n\nerr_free:\n\tkfree(iter);\n\treturn NULL;\n}"
  },
  {
    "function_name": "convert_to_gcda",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "426-471",
    "snippet": "static size_t convert_to_gcda(char *buffer, struct gcov_info *info)\n{\n\tstruct gcov_fn_info *fi_ptr;\n\tstruct gcov_ctr_info *ci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tunsigned int cv_idx;\n\tsize_t pos = 0;\n\n\t/* File header. */\n\tpos += store_gcov_u32(buffer, pos, GCOV_DATA_MAGIC);\n\tpos += store_gcov_u32(buffer, pos, info->version);\n\tpos += store_gcov_u32(buffer, pos, info->stamp);\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tfi_ptr = info->functions[fi_idx];\n\n\t\t/* Function record. */\n\t\tpos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION);\n\t\tpos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION_LENGTH);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->ident);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->lineno_checksum);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->cfg_checksum);\n\n\t\tci_ptr = fi_ptr->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(info, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\t/* Counter record. */\n\t\t\tpos += store_gcov_u32(buffer, pos,\n\t\t\t\t\t      GCOV_TAG_FOR_COUNTER(ct_idx));\n\t\t\tpos += store_gcov_u32(buffer, pos, ci_ptr->num * 2);\n\n\t\t\tfor (cv_idx = 0; cv_idx < ci_ptr->num; cv_idx++) {\n\t\t\t\tpos += store_gcov_u64(buffer, pos,\n\t\t\t\t\t\t      ci_ptr->values[cv_idx]);\n\t\t\t}\n\n\t\t\tci_ptr++;\n\t\t}\n\t}\n\n\treturn pos;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define GCOV_TAG_FUNCTION_LENGTH\t3",
      "#define GCOV_COUNTERS\t\t\t8",
      "#define GCOV_COUNTERS\t\t\t9",
      "#define GCOV_COUNTERS\t\t\t10",
      "#define GCOV_COUNTERS\t\t\t9"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "store_gcov_u64",
          "args": [
            "buffer",
            "pos",
            "ci_ptr->values[cv_idx]"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "store_gcov_u64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
          "lines": "405-417",
          "snippet": "static size_t store_gcov_u64(void *buffer, size_t off, u64 v)\n{\n\tu32 *data;\n\n\tif (buffer) {\n\t\tdata = buffer + off;\n\n\t\tdata[0] = (v & 0xffffffffUL);\n\t\tdata[1] = (v >> 32);\n\t}\n\n\treturn sizeof(*data) * 2;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic size_t store_gcov_u64(void *buffer, size_t off, u64 v)\n{\n\tu32 *data;\n\n\tif (buffer) {\n\t\tdata = buffer + off;\n\n\t\tdata[0] = (v & 0xffffffffUL);\n\t\tdata[1] = (v >> 32);\n\t}\n\n\treturn sizeof(*data) * 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store_gcov_u32",
          "args": [
            "buffer",
            "pos",
            "ci_ptr->num * 2"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "store_gcov_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
          "lines": "381-391",
          "snippet": "static size_t store_gcov_u32(void *buffer, size_t off, u32 v)\n{\n\tu32 *data;\n\n\tif (buffer) {\n\t\tdata = buffer + off;\n\t\t*data = v;\n\t}\n\n\treturn sizeof(*data);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic size_t store_gcov_u32(void *buffer, size_t off, u32 v)\n{\n\tu32 *data;\n\n\tif (buffer) {\n\t\tdata = buffer + off;\n\t\t*data = v;\n\t}\n\n\treturn sizeof(*data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GCOV_TAG_FOR_COUNTER",
          "args": [
            "ct_idx"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "counter_active",
          "args": [
            "info",
            "ct_idx"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "counter_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
          "lines": "162-165",
          "snippet": "static int counter_active(struct gcov_info *info, unsigned int type)\n{\n\treturn info->merge[type] ? 1 : 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int counter_active(struct gcov_info *info, unsigned int type)\n{\n\treturn info->merge[type] ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define GCOV_TAG_FUNCTION_LENGTH\t3\n#define GCOV_COUNTERS\t\t\t8\n#define GCOV_COUNTERS\t\t\t9\n#define GCOV_COUNTERS\t\t\t10\n#define GCOV_COUNTERS\t\t\t9\n\nstatic size_t convert_to_gcda(char *buffer, struct gcov_info *info)\n{\n\tstruct gcov_fn_info *fi_ptr;\n\tstruct gcov_ctr_info *ci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tunsigned int cv_idx;\n\tsize_t pos = 0;\n\n\t/* File header. */\n\tpos += store_gcov_u32(buffer, pos, GCOV_DATA_MAGIC);\n\tpos += store_gcov_u32(buffer, pos, info->version);\n\tpos += store_gcov_u32(buffer, pos, info->stamp);\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tfi_ptr = info->functions[fi_idx];\n\n\t\t/* Function record. */\n\t\tpos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION);\n\t\tpos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION_LENGTH);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->ident);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->lineno_checksum);\n\t\tpos += store_gcov_u32(buffer, pos, fi_ptr->cfg_checksum);\n\n\t\tci_ptr = fi_ptr->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(info, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\t/* Counter record. */\n\t\t\tpos += store_gcov_u32(buffer, pos,\n\t\t\t\t\t      GCOV_TAG_FOR_COUNTER(ct_idx));\n\t\t\tpos += store_gcov_u32(buffer, pos, ci_ptr->num * 2);\n\n\t\t\tfor (cv_idx = 0; cv_idx < ci_ptr->num; cv_idx++) {\n\t\t\t\tpos += store_gcov_u64(buffer, pos,\n\t\t\t\t\t\t      ci_ptr->values[cv_idx]);\n\t\t\t}\n\n\t\t\tci_ptr++;\n\t\t}\n\t}\n\n\treturn pos;\n}"
  },
  {
    "function_name": "store_gcov_u64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "405-417",
    "snippet": "static size_t store_gcov_u64(void *buffer, size_t off, u64 v)\n{\n\tu32 *data;\n\n\tif (buffer) {\n\t\tdata = buffer + off;\n\n\t\tdata[0] = (v & 0xffffffffUL);\n\t\tdata[1] = (v >> 32);\n\t}\n\n\treturn sizeof(*data) * 2;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic size_t store_gcov_u64(void *buffer, size_t off, u64 v)\n{\n\tu32 *data;\n\n\tif (buffer) {\n\t\tdata = buffer + off;\n\n\t\tdata[0] = (v & 0xffffffffUL);\n\t\tdata[1] = (v >> 32);\n\t}\n\n\treturn sizeof(*data) * 2;\n}"
  },
  {
    "function_name": "store_gcov_u32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "381-391",
    "snippet": "static size_t store_gcov_u32(void *buffer, size_t off, u32 v)\n{\n\tu32 *data;\n\n\tif (buffer) {\n\t\tdata = buffer + off;\n\t\t*data = v;\n\t}\n\n\treturn sizeof(*data);\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic size_t store_gcov_u32(void *buffer, size_t off, u32 v)\n{\n\tu32 *data;\n\n\tif (buffer) {\n\t\tdata = buffer + off;\n\t\t*data = v;\n\t}\n\n\treturn sizeof(*data);\n}"
  },
  {
    "function_name": "gcov_info_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "324-352",
    "snippet": "void gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tstruct gcov_ctr_info *ci_ptr;\n\n\tif (!info->functions)\n\t\tgoto free_info;\n\n\tactive = num_counter_active(info);\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tif (!info->functions[fi_idx])\n\t\t\tcontinue;\n\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++, ci_ptr++)\n\t\t\tvfree(ci_ptr->values);\n\n\t\tkfree(info->functions[fi_idx]);\n\t}\n\nfree_info:\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "ci_ptr->values"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_counter_active",
          "args": [
            "info"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "num_counter_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
          "lines": "168-178",
          "snippet": "static unsigned int num_counter_active(struct gcov_info *info)\n{\n\tunsigned int i;\n\tunsigned int result = 0;\n\n\tfor (i = 0; i < GCOV_COUNTERS; i++) {\n\t\tif (counter_active(info, i))\n\t\t\tresult++;\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define GCOV_COUNTERS\t\t\t8",
            "#define GCOV_COUNTERS\t\t\t9",
            "#define GCOV_COUNTERS\t\t\t10",
            "#define GCOV_COUNTERS\t\t\t9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define GCOV_COUNTERS\t\t\t8\n#define GCOV_COUNTERS\t\t\t9\n#define GCOV_COUNTERS\t\t\t10\n#define GCOV_COUNTERS\t\t\t9\n\nstatic unsigned int num_counter_active(struct gcov_info *info)\n{\n\tunsigned int i;\n\tunsigned int result = 0;\n\n\tfor (i = 0; i < GCOV_COUNTERS; i++) {\n\t\tif (counter_active(info, i))\n\t\t\tresult++;\n\t}\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tstruct gcov_ctr_info *ci_ptr;\n\n\tif (!info->functions)\n\t\tgoto free_info;\n\n\tactive = num_counter_active(info);\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tif (!info->functions[fi_idx])\n\t\t\tcontinue;\n\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++, ci_ptr++)\n\t\t\tvfree(ci_ptr->values);\n\n\t\tkfree(info->functions[fi_idx]);\n\t}\n\nfree_info:\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}"
  },
  {
    "function_name": "gcov_info_dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "255-318",
    "snippet": "struct gcov_info *gcov_info_dup(struct gcov_info *info)\n{\n\tstruct gcov_info *dup;\n\tstruct gcov_ctr_info *dci_ptr; /* dst counter info */\n\tstruct gcov_ctr_info *sci_ptr; /* src counter info */\n\tunsigned int active;\n\tunsigned int fi_idx; /* function info idx */\n\tunsigned int ct_idx; /* counter type idx */\n\tsize_t fi_size; /* function info size */\n\tsize_t cv_size; /* counter values size */\n\n\tdup = kmemdup(info, sizeof(*dup), GFP_KERNEL);\n\tif (!dup)\n\t\treturn NULL;\n\n\tdup->next = NULL;\n\tdup->filename = NULL;\n\tdup->functions = NULL;\n\n\tdup->filename = kstrdup(info->filename, GFP_KERNEL);\n\tif (!dup->filename)\n\t\tgoto err_free;\n\n\tdup->functions = kcalloc(info->n_functions,\n\t\t\t\t sizeof(struct gcov_fn_info *), GFP_KERNEL);\n\tif (!dup->functions)\n\t\tgoto err_free;\n\n\tactive = num_counter_active(info);\n\tfi_size = sizeof(struct gcov_fn_info);\n\tfi_size += sizeof(struct gcov_ctr_info) * active;\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tdup->functions[fi_idx] = kzalloc(fi_size, GFP_KERNEL);\n\t\tif (!dup->functions[fi_idx])\n\t\t\tgoto err_free;\n\n\t\t*(dup->functions[fi_idx]) = *(info->functions[fi_idx]);\n\n\t\tsci_ptr = info->functions[fi_idx]->ctrs;\n\t\tdci_ptr = dup->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++) {\n\n\t\t\tcv_size = sizeof(gcov_type) * sci_ptr->num;\n\n\t\t\tdci_ptr->values = vmalloc(cv_size);\n\n\t\t\tif (!dci_ptr->values)\n\t\t\t\tgoto err_free;\n\n\t\t\tdci_ptr->num = sci_ptr->num;\n\t\t\tmemcpy(dci_ptr->values, sci_ptr->values, cv_size);\n\n\t\t\tsci_ptr++;\n\t\t\tdci_ptr++;\n\t\t}\n\t}\n\n\treturn dup;\nerr_free:\n\tgcov_info_free(dup);\n\treturn NULL;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gcov_info_free",
          "args": [
            "dup"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_info_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
          "lines": "324-352",
          "snippet": "void gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tstruct gcov_ctr_info *ci_ptr;\n\n\tif (!info->functions)\n\t\tgoto free_info;\n\n\tactive = num_counter_active(info);\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tif (!info->functions[fi_idx])\n\t\t\tcontinue;\n\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++, ci_ptr++)\n\t\t\tvfree(ci_ptr->values);\n\n\t\tkfree(info->functions[fi_idx]);\n\t}\n\nfree_info:\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nvoid gcov_info_free(struct gcov_info *info)\n{\n\tunsigned int active;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tstruct gcov_ctr_info *ci_ptr;\n\n\tif (!info->functions)\n\t\tgoto free_info;\n\n\tactive = num_counter_active(info);\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tif (!info->functions[fi_idx])\n\t\t\tcontinue;\n\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++, ci_ptr++)\n\t\t\tvfree(ci_ptr->values);\n\n\t\tkfree(info->functions[fi_idx]);\n\t}\n\nfree_info:\n\tkfree(info->functions);\n\tkfree(info->filename);\n\tkfree(info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dci_ptr->values",
            "sci_ptr->values",
            "cv_size"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "cv_size"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "fi_size",
            "GFP_KERNEL"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_counter_active",
          "args": [
            "info"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "num_counter_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
          "lines": "168-178",
          "snippet": "static unsigned int num_counter_active(struct gcov_info *info)\n{\n\tunsigned int i;\n\tunsigned int result = 0;\n\n\tfor (i = 0; i < GCOV_COUNTERS; i++) {\n\t\tif (counter_active(info, i))\n\t\t\tresult++;\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define GCOV_COUNTERS\t\t\t8",
            "#define GCOV_COUNTERS\t\t\t9",
            "#define GCOV_COUNTERS\t\t\t10",
            "#define GCOV_COUNTERS\t\t\t9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define GCOV_COUNTERS\t\t\t8\n#define GCOV_COUNTERS\t\t\t9\n#define GCOV_COUNTERS\t\t\t10\n#define GCOV_COUNTERS\t\t\t9\n\nstatic unsigned int num_counter_active(struct gcov_info *info)\n{\n\tunsigned int i;\n\tunsigned int result = 0;\n\n\tfor (i = 0; i < GCOV_COUNTERS; i++) {\n\t\tif (counter_active(info, i))\n\t\t\tresult++;\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "info->n_functions",
            "sizeof(struct gcov_fn_info *)",
            "GFP_KERNEL"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "info->filename",
            "GFP_KERNEL"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "info",
            "sizeof(*dup)",
            "GFP_KERNEL"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstruct gcov_info *gcov_info_dup(struct gcov_info *info)\n{\n\tstruct gcov_info *dup;\n\tstruct gcov_ctr_info *dci_ptr; /* dst counter info */\n\tstruct gcov_ctr_info *sci_ptr; /* src counter info */\n\tunsigned int active;\n\tunsigned int fi_idx; /* function info idx */\n\tunsigned int ct_idx; /* counter type idx */\n\tsize_t fi_size; /* function info size */\n\tsize_t cv_size; /* counter values size */\n\n\tdup = kmemdup(info, sizeof(*dup), GFP_KERNEL);\n\tif (!dup)\n\t\treturn NULL;\n\n\tdup->next = NULL;\n\tdup->filename = NULL;\n\tdup->functions = NULL;\n\n\tdup->filename = kstrdup(info->filename, GFP_KERNEL);\n\tif (!dup->filename)\n\t\tgoto err_free;\n\n\tdup->functions = kcalloc(info->n_functions,\n\t\t\t\t sizeof(struct gcov_fn_info *), GFP_KERNEL);\n\tif (!dup->functions)\n\t\tgoto err_free;\n\n\tactive = num_counter_active(info);\n\tfi_size = sizeof(struct gcov_fn_info);\n\tfi_size += sizeof(struct gcov_ctr_info) * active;\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tdup->functions[fi_idx] = kzalloc(fi_size, GFP_KERNEL);\n\t\tif (!dup->functions[fi_idx])\n\t\t\tgoto err_free;\n\n\t\t*(dup->functions[fi_idx]) = *(info->functions[fi_idx]);\n\n\t\tsci_ptr = info->functions[fi_idx]->ctrs;\n\t\tdci_ptr = dup->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < active; ct_idx++) {\n\n\t\t\tcv_size = sizeof(gcov_type) * sci_ptr->num;\n\n\t\t\tdci_ptr->values = vmalloc(cv_size);\n\n\t\t\tif (!dci_ptr->values)\n\t\t\t\tgoto err_free;\n\n\t\t\tdci_ptr->num = sci_ptr->num;\n\t\t\tmemcpy(dci_ptr->values, sci_ptr->values, cv_size);\n\n\t\t\tsci_ptr++;\n\t\t\tdci_ptr++;\n\t\t}\n\t}\n\n\treturn dup;\nerr_free:\n\tgcov_info_free(dup);\n\treturn NULL;\n}"
  },
  {
    "function_name": "gcov_info_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "223-247",
    "snippet": "void gcov_info_add(struct gcov_info *dst, struct gcov_info *src)\n{\n\tstruct gcov_ctr_info *dci_ptr;\n\tstruct gcov_ctr_info *sci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tunsigned int val_idx;\n\n\tfor (fi_idx = 0; fi_idx < src->n_functions; fi_idx++) {\n\t\tdci_ptr = dst->functions[fi_idx]->ctrs;\n\t\tsci_ptr = src->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(src, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\tfor (val_idx = 0; val_idx < sci_ptr->num; val_idx++)\n\t\t\t\tdci_ptr->values[val_idx] +=\n\t\t\t\t\tsci_ptr->values[val_idx];\n\n\t\t\tdci_ptr++;\n\t\t\tsci_ptr++;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define GCOV_COUNTERS\t\t\t8",
      "#define GCOV_COUNTERS\t\t\t9",
      "#define GCOV_COUNTERS\t\t\t10",
      "#define GCOV_COUNTERS\t\t\t9"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "counter_active",
          "args": [
            "src",
            "ct_idx"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "counter_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
          "lines": "162-165",
          "snippet": "static int counter_active(struct gcov_info *info, unsigned int type)\n{\n\treturn info->merge[type] ? 1 : 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int counter_active(struct gcov_info *info, unsigned int type)\n{\n\treturn info->merge[type] ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define GCOV_COUNTERS\t\t\t8\n#define GCOV_COUNTERS\t\t\t9\n#define GCOV_COUNTERS\t\t\t10\n#define GCOV_COUNTERS\t\t\t9\n\nvoid gcov_info_add(struct gcov_info *dst, struct gcov_info *src)\n{\n\tstruct gcov_ctr_info *dci_ptr;\n\tstruct gcov_ctr_info *sci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\tunsigned int val_idx;\n\n\tfor (fi_idx = 0; fi_idx < src->n_functions; fi_idx++) {\n\t\tdci_ptr = dst->functions[fi_idx]->ctrs;\n\t\tsci_ptr = src->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(src, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\tfor (val_idx = 0; val_idx < sci_ptr->num; val_idx++)\n\t\t\t\tdci_ptr->values[val_idx] +=\n\t\t\t\t\tsci_ptr->values[val_idx];\n\n\t\t\tdci_ptr++;\n\t\t\tsci_ptr++;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "gcov_info_is_compatible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "211-214",
    "snippet": "int gcov_info_is_compatible(struct gcov_info *info1, struct gcov_info *info2)\n{\n\treturn (info1->stamp == info2->stamp);\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nint gcov_info_is_compatible(struct gcov_info *info1, struct gcov_info *info2)\n{\n\treturn (info1->stamp == info2->stamp);\n}"
  },
  {
    "function_name": "gcov_info_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "184-202",
    "snippet": "void gcov_info_reset(struct gcov_info *info)\n{\n\tstruct gcov_ctr_info *ci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(info, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\tmemset(ci_ptr->values, 0,\n\t\t\t\t\tsizeof(gcov_type) * ci_ptr->num);\n\t\t\tci_ptr++;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define GCOV_COUNTERS\t\t\t8",
      "#define GCOV_COUNTERS\t\t\t9",
      "#define GCOV_COUNTERS\t\t\t10",
      "#define GCOV_COUNTERS\t\t\t9"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ci_ptr->values",
            "0",
            "sizeof(gcov_type) * ci_ptr->num"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "counter_active",
          "args": [
            "info",
            "ct_idx"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "counter_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
          "lines": "162-165",
          "snippet": "static int counter_active(struct gcov_info *info, unsigned int type)\n{\n\treturn info->merge[type] ? 1 : 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int counter_active(struct gcov_info *info, unsigned int type)\n{\n\treturn info->merge[type] ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define GCOV_COUNTERS\t\t\t8\n#define GCOV_COUNTERS\t\t\t9\n#define GCOV_COUNTERS\t\t\t10\n#define GCOV_COUNTERS\t\t\t9\n\nvoid gcov_info_reset(struct gcov_info *info)\n{\n\tstruct gcov_ctr_info *ci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\n\tfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\n\t\tci_ptr = info->functions[fi_idx]->ctrs;\n\n\t\tfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\n\t\t\tif (!counter_active(info, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\tmemset(ci_ptr->values, 0,\n\t\t\t\t\tsizeof(gcov_type) * ci_ptr->num);\n\t\t\tci_ptr++;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "num_counter_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "168-178",
    "snippet": "static unsigned int num_counter_active(struct gcov_info *info)\n{\n\tunsigned int i;\n\tunsigned int result = 0;\n\n\tfor (i = 0; i < GCOV_COUNTERS; i++) {\n\t\tif (counter_active(info, i))\n\t\t\tresult++;\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define GCOV_COUNTERS\t\t\t8",
      "#define GCOV_COUNTERS\t\t\t9",
      "#define GCOV_COUNTERS\t\t\t10",
      "#define GCOV_COUNTERS\t\t\t9"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "counter_active",
          "args": [
            "info",
            "i"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "counter_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
          "lines": "162-165",
          "snippet": "static int counter_active(struct gcov_info *info, unsigned int type)\n{\n\treturn info->merge[type] ? 1 : 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int counter_active(struct gcov_info *info, unsigned int type)\n{\n\treturn info->merge[type] ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define GCOV_COUNTERS\t\t\t8\n#define GCOV_COUNTERS\t\t\t9\n#define GCOV_COUNTERS\t\t\t10\n#define GCOV_COUNTERS\t\t\t9\n\nstatic unsigned int num_counter_active(struct gcov_info *info)\n{\n\tunsigned int i;\n\tunsigned int result = 0;\n\n\tfor (i = 0; i < GCOV_COUNTERS; i++) {\n\t\tif (counter_active(info, i))\n\t\t\tresult++;\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "counter_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "162-165",
    "snippet": "static int counter_active(struct gcov_info *info, unsigned int type)\n{\n\treturn info->merge[type] ? 1 : 0;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic int counter_active(struct gcov_info *info, unsigned int type)\n{\n\treturn info->merge[type] ? 1 : 0;\n}"
  },
  {
    "function_name": "gcov_info_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "145-151",
    "snippet": "void gcov_info_unlink(struct gcov_info *prev, struct gcov_info *info)\n{\n\tif (prev)\n\t\tprev->next = info->next;\n\telse\n\t\tgcov_info_head = info->next;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct gcov_info *gcov_info_head;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic struct gcov_info *gcov_info_head;\n\nvoid gcov_info_unlink(struct gcov_info *prev, struct gcov_info *info)\n{\n\tif (prev)\n\t\tprev->next = info->next;\n\telse\n\t\tgcov_info_head = info->next;\n}"
  },
  {
    "function_name": "gcov_info_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "134-138",
    "snippet": "void gcov_info_link(struct gcov_info *info)\n{\n\tinfo->next = gcov_info_head;\n\tgcov_info_head = info;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct gcov_info *gcov_info_head;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic struct gcov_info *gcov_info_head;\n\nvoid gcov_info_link(struct gcov_info *info)\n{\n\tinfo->next = gcov_info_head;\n\tgcov_info_head = info;\n}"
  },
  {
    "function_name": "gcov_info_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "122-128",
    "snippet": "struct gcov_info *gcov_info_next(struct gcov_info *info)\n{\n\tif (!info)\n\t\treturn gcov_info_head;\n\n\treturn info->next;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct gcov_info *gcov_info_head;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nstatic struct gcov_info *gcov_info_head;\n\nstruct gcov_info *gcov_info_next(struct gcov_info *info)\n{\n\tif (!info)\n\t\treturn gcov_info_head;\n\n\treturn info->next;\n}"
  },
  {
    "function_name": "gcov_info_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "110-113",
    "snippet": "unsigned int gcov_info_version(struct gcov_info *info)\n{\n\treturn info->version;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nunsigned int gcov_info_version(struct gcov_info *info)\n{\n\treturn info->version;\n}"
  },
  {
    "function_name": "gcov_info_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/gcc_4_7.c",
    "lines": "101-104",
    "snippet": "const char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}",
    "includes": [
      "#include \"gcov.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gcov.h\"\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\nconst char *gcov_info_filename(struct gcov_info *info)\n{\n\treturn info->filename;\n}"
  }
]