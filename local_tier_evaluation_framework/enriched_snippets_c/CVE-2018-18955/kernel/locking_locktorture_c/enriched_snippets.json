[
  {
    "function_name": "lock_torture_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "851-1059",
    "snippet": "static int __init lock_torture_init(void)\n{\n\tint i, j;\n\tint firsterr = 0;\n\tstatic struct lock_torture_ops *torture_ops[] = {\n\t\t&lock_busted_ops,\n\t\t&spin_lock_ops, &spin_lock_irq_ops,\n\t\t&rw_lock_ops, &rw_lock_irq_ops,\n\t\t&mutex_lock_ops,\n\t\t&ww_mutex_lock_ops,\n#ifdef CONFIG_RT_MUTEXES\n\t\t&rtmutex_lock_ops,\n#endif\n\t\t&rwsem_lock_ops,\n\t\t&percpu_rwsem_lock_ops,\n\t};\n\n\tif (!torture_init_begin(torture_type, verbose))\n\t\treturn -EBUSY;\n\n\t/* Process args and tell the world that the torturer is on the job. */\n\tfor (i = 0; i < ARRAY_SIZE(torture_ops); i++) {\n\t\tcxt.cur_ops = torture_ops[i];\n\t\tif (strcmp(torture_type, cxt.cur_ops->name) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(torture_ops)) {\n\t\tpr_alert(\"lock-torture: invalid torture type: \\\"%s\\\"\\n\",\n\t\t\t torture_type);\n\t\tpr_alert(\"lock-torture types:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(torture_ops); i++)\n\t\t\tpr_alert(\" %s\", torture_ops[i]->name);\n\t\tpr_alert(\"\\n\");\n\t\tfirsterr = -EINVAL;\n\t\tgoto unwind;\n\t}\n\n\tif (nwriters_stress == 0 && nreaders_stress == 0) {\n\t\tpr_alert(\"lock-torture: must run at least one locking thread\\n\");\n\t\tfirsterr = -EINVAL;\n\t\tgoto unwind;\n\t}\n\n\tif (cxt.cur_ops->init)\n\t\tcxt.cur_ops->init();\n\n\tif (nwriters_stress >= 0)\n\t\tcxt.nrealwriters_stress = nwriters_stress;\n\telse\n\t\tcxt.nrealwriters_stress = 2 * num_online_cpus();\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tif (strncmp(torture_type, \"mutex\", 5) == 0)\n\t\tcxt.debug_lock = true;\n#endif\n#ifdef CONFIG_DEBUG_RT_MUTEXES\n\tif (strncmp(torture_type, \"rtmutex\", 7) == 0)\n\t\tcxt.debug_lock = true;\n#endif\n#ifdef CONFIG_DEBUG_SPINLOCK\n\tif ((strncmp(torture_type, \"spin\", 4) == 0) ||\n\t    (strncmp(torture_type, \"rw_lock\", 7) == 0))\n\t\tcxt.debug_lock = true;\n#endif\n\n\t/* Initialize the statistics so that each run gets its own numbers. */\n\tif (nwriters_stress) {\n\t\tlock_is_write_held = 0;\n\t\tcxt.lwsa = kmalloc_array(cxt.nrealwriters_stress,\n\t\t\t\t\t sizeof(*cxt.lwsa),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (cxt.lwsa == NULL) {\n\t\t\tVERBOSE_TOROUT_STRING(\"cxt.lwsa: Out of memory\");\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\n\t\tfor (i = 0; i < cxt.nrealwriters_stress; i++) {\n\t\t\tcxt.lwsa[i].n_lock_fail = 0;\n\t\t\tcxt.lwsa[i].n_lock_acquired = 0;\n\t\t}\n\t}\n\n\tif (cxt.cur_ops->readlock) {\n\t\tif (nreaders_stress >= 0)\n\t\t\tcxt.nrealreaders_stress = nreaders_stress;\n\t\telse {\n\t\t\t/*\n\t\t\t * By default distribute evenly the number of\n\t\t\t * readers and writers. We still run the same number\n\t\t\t * of threads as the writer-only locks default.\n\t\t\t */\n\t\t\tif (nwriters_stress < 0) /* user doesn't care */\n\t\t\t\tcxt.nrealwriters_stress = num_online_cpus();\n\t\t\tcxt.nrealreaders_stress = cxt.nrealwriters_stress;\n\t\t}\n\n\t\tif (nreaders_stress) {\n\t\t\tlock_is_read_held = 0;\n\t\t\tcxt.lrsa = kmalloc_array(cxt.nrealreaders_stress,\n\t\t\t\t\t\t sizeof(*cxt.lrsa),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (cxt.lrsa == NULL) {\n\t\t\t\tVERBOSE_TOROUT_STRING(\"cxt.lrsa: Out of memory\");\n\t\t\t\tfirsterr = -ENOMEM;\n\t\t\t\tkfree(cxt.lwsa);\n\t\t\t\tcxt.lwsa = NULL;\n\t\t\t\tgoto unwind;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < cxt.nrealreaders_stress; i++) {\n\t\t\t\tcxt.lrsa[i].n_lock_fail = 0;\n\t\t\t\tcxt.lrsa[i].n_lock_acquired = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tlock_torture_print_module_parms(cxt.cur_ops, \"Start of test\");\n\n\t/* Prepare torture context. */\n\tif (onoff_interval > 0) {\n\t\tfirsterr = torture_onoff_init(onoff_holdoff * HZ,\n\t\t\t\t\t      onoff_interval * HZ);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (shuffle_interval > 0) {\n\t\tfirsterr = torture_shuffle_init(shuffle_interval);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (shutdown_secs > 0) {\n\t\tfirsterr = torture_shutdown_init(shutdown_secs,\n\t\t\t\t\t\t lock_torture_cleanup);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (stutter > 0) {\n\t\tfirsterr = torture_stutter_init(stutter);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\n\tif (nwriters_stress) {\n\t\twriter_tasks = kcalloc(cxt.nrealwriters_stress,\n\t\t\t\t       sizeof(writer_tasks[0]),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (writer_tasks == NULL) {\n\t\t\tVERBOSE_TOROUT_ERRSTRING(\"writer_tasks: Out of memory\");\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\n\tif (cxt.cur_ops->readlock) {\n\t\treader_tasks = kcalloc(cxt.nrealreaders_stress,\n\t\t\t\t       sizeof(reader_tasks[0]),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (reader_tasks == NULL) {\n\t\t\tVERBOSE_TOROUT_ERRSTRING(\"reader_tasks: Out of memory\");\n\t\t\tkfree(writer_tasks);\n\t\t\twriter_tasks = NULL;\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\n\t/*\n\t * Create the kthreads and start torturing (oh, those poor little locks).\n\t *\n\t * TODO: Note that we interleave writers with readers, giving writers a\n\t * slight advantage, by creating its kthread first. This can be modified\n\t * for very specific needs, or even let the user choose the policy, if\n\t * ever wanted.\n\t */\n\tfor (i = 0, j = 0; i < cxt.nrealwriters_stress ||\n\t\t    j < cxt.nrealreaders_stress; i++, j++) {\n\t\tif (i >= cxt.nrealwriters_stress)\n\t\t\tgoto create_reader;\n\n\t\t/* Create writer. */\n\t\tfirsterr = torture_create_kthread(lock_torture_writer, &cxt.lwsa[i],\n\t\t\t\t\t\t  writer_tasks[i]);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\n\tcreate_reader:\n\t\tif (cxt.cur_ops->readlock == NULL || (j >= cxt.nrealreaders_stress))\n\t\t\tcontinue;\n\t\t/* Create reader. */\n\t\tfirsterr = torture_create_kthread(lock_torture_reader, &cxt.lrsa[j],\n\t\t\t\t\t\t  reader_tasks[j]);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (stat_interval > 0) {\n\t\tfirsterr = torture_create_kthread(lock_torture_stats, NULL,\n\t\t\t\t\t\t  stats_task);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\tlock_torture_cleanup();\n\treturn firsterr;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *torture_type = \"spin_lock\";",
      "static struct task_struct *stats_task;",
      "static struct task_struct **writer_tasks;",
      "static struct task_struct **reader_tasks;",
      "static bool lock_is_write_held;",
      "static bool lock_is_read_held;",
      "static void lock_torture_cleanup(void);",
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
      "static struct lock_torture_ops lock_busted_ops = {\n\t.writelock\t= torture_lock_busted_write_lock,\n\t.write_delay\t= torture_lock_busted_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_lock_busted_write_unlock,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"lock_busted\"\n};",
      "static struct lock_torture_ops spin_lock_ops = {\n\t.writelock\t= torture_spin_lock_write_lock,\n\t.write_delay\t= torture_spin_lock_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_spin_lock_write_unlock,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"spin_lock\"\n};",
      "static struct lock_torture_ops spin_lock_irq_ops = {\n\t.writelock\t= torture_spin_lock_write_lock_irq,\n\t.write_delay\t= torture_spin_lock_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_lock_spin_write_unlock_irq,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"spin_lock_irq\"\n};",
      "static struct lock_torture_ops rw_lock_ops = {\n\t.writelock\t= torture_rwlock_write_lock,\n\t.write_delay\t= torture_rwlock_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_rwlock_write_unlock,\n\t.readlock       = torture_rwlock_read_lock,\n\t.read_delay     = torture_rwlock_read_delay,\n\t.readunlock     = torture_rwlock_read_unlock,\n\t.name\t\t= \"rw_lock\"\n};",
      "static struct lock_torture_ops rw_lock_irq_ops = {\n\t.writelock\t= torture_rwlock_write_lock_irq,\n\t.write_delay\t= torture_rwlock_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_rwlock_write_unlock_irq,\n\t.readlock       = torture_rwlock_read_lock_irq,\n\t.read_delay     = torture_rwlock_read_delay,\n\t.readunlock     = torture_rwlock_read_unlock_irq,\n\t.name\t\t= \"rw_lock_irq\"\n};",
      "static struct lock_torture_ops mutex_lock_ops = {\n\t.writelock\t= torture_mutex_lock,\n\t.write_delay\t= torture_mutex_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_mutex_unlock,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"mutex_lock\"\n};",
      "static struct lock_torture_ops ww_mutex_lock_ops = {\n\t.writelock\t= torture_ww_mutex_lock,\n\t.write_delay\t= torture_mutex_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_ww_mutex_unlock,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"ww_mutex_lock\"\n};",
      "static struct lock_torture_ops rwsem_lock_ops = {\n\t.writelock\t= torture_rwsem_down_write,\n\t.write_delay\t= torture_rwsem_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_rwsem_up_write,\n\t.readlock       = torture_rwsem_down_read,\n\t.read_delay     = torture_rwsem_read_delay,\n\t.readunlock     = torture_rwsem_up_read,\n\t.name\t\t= \"rwsem_lock\"\n};",
      "static struct lock_torture_ops percpu_rwsem_lock_ops = {\n\t.init\t\t= torture_percpu_rwsem_init,\n\t.writelock\t= torture_percpu_rwsem_down_write,\n\t.write_delay\t= torture_rwsem_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_percpu_rwsem_up_write,\n\t.readlock       = torture_percpu_rwsem_down_read,\n\t.read_delay     = torture_rwsem_read_delay,\n\t.readunlock     = torture_percpu_rwsem_up_read,\n\t.name\t\t= \"percpu_rwsem_lock\"\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_torture_cleanup",
          "args": [],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "lock_torture_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
          "lines": "799-849",
          "snippet": "static void lock_torture_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\t/*\n\t * Indicates early cleanup, meaning that the test has not run,\n\t * such as when passing bogus args when loading the module. As\n\t * such, only perform the underlying torture-specific cleanups,\n\t * and avoid anything related to locktorture.\n\t */\n\tif (!cxt.lwsa && !cxt.lrsa)\n\t\tgoto end;\n\n\tif (writer_tasks) {\n\t\tfor (i = 0; i < cxt.nrealwriters_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_writer,\n\t\t\t\t\t     writer_tasks[i]);\n\t\tkfree(writer_tasks);\n\t\twriter_tasks = NULL;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < cxt.nrealreaders_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t\treader_tasks = NULL;\n\t}\n\n\ttorture_stop_kthread(lock_torture_stats, stats_task);\n\tlock_torture_stats_print();  /* -After- the stats thread is stopped! */\n\n\tif (atomic_read(&cxt.n_lock_torture_errors))\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: LOCK_HOTPLUG\");\n\telse\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: SUCCESS\");\n\n\tkfree(cxt.lwsa);\n\tkfree(cxt.lrsa);\n\nend:\n\ttorture_cleanup_end();\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/torture.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rwlock.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *stats_task;",
            "static struct task_struct **writer_tasks;",
            "static struct task_struct **reader_tasks;",
            "static void lock_torture_cleanup(void);",
            "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct task_struct *stats_task;\nstatic struct task_struct **writer_tasks;\nstatic struct task_struct **reader_tasks;\nstatic void lock_torture_cleanup(void);\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void lock_torture_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\t/*\n\t * Indicates early cleanup, meaning that the test has not run,\n\t * such as when passing bogus args when loading the module. As\n\t * such, only perform the underlying torture-specific cleanups,\n\t * and avoid anything related to locktorture.\n\t */\n\tif (!cxt.lwsa && !cxt.lrsa)\n\t\tgoto end;\n\n\tif (writer_tasks) {\n\t\tfor (i = 0; i < cxt.nrealwriters_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_writer,\n\t\t\t\t\t     writer_tasks[i]);\n\t\tkfree(writer_tasks);\n\t\twriter_tasks = NULL;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < cxt.nrealreaders_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t\treader_tasks = NULL;\n\t}\n\n\ttorture_stop_kthread(lock_torture_stats, stats_task);\n\tlock_torture_stats_print();  /* -After- the stats thread is stopped! */\n\n\tif (atomic_read(&cxt.n_lock_torture_errors))\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: LOCK_HOTPLUG\");\n\telse\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: SUCCESS\");\n\n\tkfree(cxt.lwsa);\n\tkfree(cxt.lrsa);\n\nend:\n\ttorture_cleanup_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_end",
          "args": [],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "torture_init_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "674-678",
          "snippet": "void torture_init_end(void)\n{\n\tmutex_unlock(&fullstop_mutex);\n\tregister_reboot_notifier(&torture_shutdown_nb);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(fullstop_mutex);",
            "static struct notifier_block torture_shutdown_nb = {\n\t.notifier_call = torture_shutdown_notify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(fullstop_mutex);\nstatic struct notifier_block torture_shutdown_nb = {\n\t.notifier_call = torture_shutdown_notify,\n};\n\nvoid torture_init_end(void)\n{\n\tmutex_unlock(&fullstop_mutex);\n\tregister_reboot_notifier(&torture_shutdown_nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "lock_torture_stats",
            "NULL",
            "stats_task"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "lock_torture_reader",
            "&cxt.lrsa[j]",
            "reader_tasks[j]"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "lock_torture_writer",
            "&cxt.lwsa[i]",
            "writer_tasks[i]"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "writer_tasks"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_ERRSTRING",
          "args": [
            "\"reader_tasks: Out of memory\""
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "cxt.nrealreaders_stress",
            "sizeof(reader_tasks[0])",
            "GFP_KERNEL"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_ERRSTRING",
          "args": [
            "\"writer_tasks: Out of memory\""
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "cxt.nrealwriters_stress",
            "sizeof(writer_tasks[0])",
            "GFP_KERNEL"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_stutter_init",
          "args": [
            "stutter"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "torture_stutter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "623-630",
          "snippet": "int torture_stutter_init(int s)\n{\n\tint ret;\n\n\tstutter = s;\n\tret = torture_create_kthread(torture_stutter, NULL, stutter_task);\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *stutter_task;",
            "static int stutter;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *stutter_task;\nstatic int stutter;\n\nint torture_stutter_init(int s)\n{\n\tint ret;\n\n\tstutter = s;\n\tret = torture_create_kthread(torture_stutter, NULL, stutter_task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_shutdown_init",
          "args": [
            "shutdown_secs",
            "lock_torture_cleanup"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "514-525",
          "snippet": "int torture_shutdown_init(int ssecs, void (*cleanup)(void))\n{\n\tint ret = 0;\n\n\ttorture_shutdown_hook = cleanup;\n\tif (ssecs > 0) {\n\t\tshutdown_time = ktime_add(ktime_get(), ktime_set(ssecs, 0));\n\t\tret = torture_create_kthread(torture_shutdown, NULL,\n\t\t\t\t\t     shutdown_task);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *shutdown_task;",
            "static ktime_t shutdown_time;",
            "static void (*torture_shutdown_hook)(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *shutdown_task;\nstatic ktime_t shutdown_time;\nstatic void (*torture_shutdown_hook)(void);\n\nint torture_shutdown_init(int ssecs, void (*cleanup)(void))\n{\n\tint ret = 0;\n\n\ttorture_shutdown_hook = cleanup;\n\tif (ssecs > 0) {\n\t\tshutdown_time = ktime_add(ktime_get(), ktime_set(ssecs, 0));\n\t\tret = torture_create_kthread(torture_shutdown, NULL,\n\t\t\t\t\t     shutdown_task);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_shuffle_init",
          "args": [
            "shuffle_interval"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shuffle_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "419-432",
          "snippet": "int torture_shuffle_init(long shuffint)\n{\n\tshuffle_interval = shuffint;\n\n\tshuffle_idle_cpu = -1;\n\n\tif (!alloc_cpumask_var(&shuffle_tmp_mask, GFP_KERNEL)) {\n\t\tVERBOSE_TOROUT_ERRSTRING(\"Failed to alloc mask\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Create the shuffler thread */\n\treturn torture_create_kthread(torture_shuffle, NULL, shuffler_task);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long shuffle_interval;",
            "static struct task_struct *shuffler_task;",
            "static cpumask_var_t shuffle_tmp_mask;",
            "static int shuffle_idle_cpu;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic long shuffle_interval;\nstatic struct task_struct *shuffler_task;\nstatic cpumask_var_t shuffle_tmp_mask;\nstatic int shuffle_idle_cpu;\n\nint torture_shuffle_init(long shuffint)\n{\n\tshuffle_interval = shuffint;\n\n\tshuffle_idle_cpu = -1;\n\n\tif (!alloc_cpumask_var(&shuffle_tmp_mask, GFP_KERNEL)) {\n\t\tVERBOSE_TOROUT_ERRSTRING(\"Failed to alloc mask\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Create the shuffler thread */\n\treturn torture_create_kthread(torture_shuffle, NULL, shuffler_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_onoff_init",
          "args": [
            "onoff_holdoff * HZ",
            "onoff_interval * HZ"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "torture_onoff_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "234-246",
          "snippet": "int torture_onoff_init(long ooholdoff, long oointerval)\n{\n\tint ret = 0;\n\n#ifdef CONFIG_HOTPLUG_CPU\n\tonoff_holdoff = ooholdoff;\n\tonoff_interval = oointerval;\n\tif (onoff_interval <= 0)\n\t\treturn 0;\n\tret = torture_create_kthread(torture_onoff, NULL, onoff_task);\n#endif /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_onoff_init(long ooholdoff, long oointerval)\n{\n\tint ret = 0;\n\n#ifdef CONFIG_HOTPLUG_CPU\n\tonoff_holdoff = ooholdoff;\n\tonoff_interval = oointerval;\n\tif (onoff_interval <= 0)\n\t\treturn 0;\n\tret = torture_create_kthread(torture_onoff, NULL, onoff_task);\n#endif /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_torture_print_module_parms",
          "args": [
            "cxt.cur_ops",
            "\"Start of test\""
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "lock_torture_print_module_parms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
          "lines": "787-797",
          "snippet": "static inline void\nlock_torture_print_module_parms(struct lock_torture_ops *cur_ops,\n\t\t\t\tconst char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s%s: nwriters_stress=%d nreaders_stress=%d stat_interval=%d verbose=%d shuffle_interval=%d stutter=%d shutdown_secs=%d onoff_interval=%d onoff_holdoff=%d\\n\",\n\t\t torture_type, tag, cxt.debug_lock ? \" [debug]\": \"\",\n\t\t cxt.nrealwriters_stress, cxt.nrealreaders_stress, stat_interval,\n\t\t verbose, shuffle_interval, stutter, shutdown_secs,\n\t\t onoff_interval, onoff_holdoff);\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/torture.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rwlock.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *torture_type = \"spin_lock\";",
            "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic char *torture_type = \"spin_lock\";\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic inline void\nlock_torture_print_module_parms(struct lock_torture_ops *cur_ops,\n\t\t\t\tconst char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s%s: nwriters_stress=%d nreaders_stress=%d stat_interval=%d verbose=%d shuffle_interval=%d stutter=%d shutdown_secs=%d onoff_interval=%d onoff_holdoff=%d\\n\",\n\t\t torture_type, tag, cxt.debug_lock ? \" [debug]\": \"\",\n\t\t cxt.nrealwriters_stress, cxt.nrealreaders_stress, stat_interval,\n\t\t verbose, shuffle_interval, stutter, shutdown_secs,\n\t\t onoff_interval, onoff_holdoff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"cxt.lrsa: Out of memory\""
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "cxt.nrealreaders_stress",
            "sizeof(*cxt.lrsa)",
            "GFP_KERNEL"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"cxt.lwsa: Out of memory\""
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "cxt.nrealwriters_stress",
            "sizeof(*cxt.lwsa)",
            "GFP_KERNEL"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "torture_type",
            "\"rw_lock\"",
            "7"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "torture_type",
            "\"spin\"",
            "4"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "torture_type",
            "\"rtmutex\"",
            "7"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "torture_type",
            "\"mutex\"",
            "5"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cxt.cur_ops->init",
          "args": [],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"lock-torture: must run at least one locking thread\\n\""
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"\\n\""
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\" %s\"",
            "torture_ops[i]->name"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "torture_ops"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"lock-torture types:\""
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"lock-torture: invalid torture type: \\\"%s\\\"\\n\"",
            "torture_type"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "torture_ops"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "torture_type",
            "cxt.cur_ops->name"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "torture_ops"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_begin",
          "args": [
            "torture_type",
            "verbose"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "torture_init_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "654-668",
          "snippet": "bool torture_init_begin(char *ttype, int v)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (torture_type != NULL) {\n\t\tpr_alert(\"torture_init_begin: Refusing %s init: %s running.\\n\",\n\t\t\t ttype, torture_type);\n\t\tpr_alert(\"torture_init_begin: One torture test at a time!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\treturn false;\n\t}\n\ttorture_type = ttype;\n\tverbose = v;\n\tfullstop = FULLSTOP_DONTSTOP;\n\treturn true;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static char *torture_type;",
            "static int verbose;",
            "static int fullstop = FULLSTOP_RMMOD;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic char *torture_type;\nstatic int verbose;\nstatic int fullstop = FULLSTOP_RMMOD;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nbool torture_init_begin(char *ttype, int v)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (torture_type != NULL) {\n\t\tpr_alert(\"torture_init_begin: Refusing %s init: %s running.\\n\",\n\t\t\t ttype, torture_type);\n\t\tpr_alert(\"torture_init_begin: One torture test at a time!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\treturn false;\n\t}\n\ttorture_type = ttype;\n\tverbose = v;\n\tfullstop = FULLSTOP_DONTSTOP;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic char *torture_type = \"spin_lock\";\nstatic struct task_struct *stats_task;\nstatic struct task_struct **writer_tasks;\nstatic struct task_struct **reader_tasks;\nstatic bool lock_is_write_held;\nstatic bool lock_is_read_held;\nstatic void lock_torture_cleanup(void);\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic struct lock_torture_ops lock_busted_ops = {\n\t.writelock\t= torture_lock_busted_write_lock,\n\t.write_delay\t= torture_lock_busted_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_lock_busted_write_unlock,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"lock_busted\"\n};\nstatic struct lock_torture_ops spin_lock_ops = {\n\t.writelock\t= torture_spin_lock_write_lock,\n\t.write_delay\t= torture_spin_lock_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_spin_lock_write_unlock,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"spin_lock\"\n};\nstatic struct lock_torture_ops spin_lock_irq_ops = {\n\t.writelock\t= torture_spin_lock_write_lock_irq,\n\t.write_delay\t= torture_spin_lock_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_lock_spin_write_unlock_irq,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"spin_lock_irq\"\n};\nstatic struct lock_torture_ops rw_lock_ops = {\n\t.writelock\t= torture_rwlock_write_lock,\n\t.write_delay\t= torture_rwlock_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_rwlock_write_unlock,\n\t.readlock       = torture_rwlock_read_lock,\n\t.read_delay     = torture_rwlock_read_delay,\n\t.readunlock     = torture_rwlock_read_unlock,\n\t.name\t\t= \"rw_lock\"\n};\nstatic struct lock_torture_ops rw_lock_irq_ops = {\n\t.writelock\t= torture_rwlock_write_lock_irq,\n\t.write_delay\t= torture_rwlock_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_rwlock_write_unlock_irq,\n\t.readlock       = torture_rwlock_read_lock_irq,\n\t.read_delay     = torture_rwlock_read_delay,\n\t.readunlock     = torture_rwlock_read_unlock_irq,\n\t.name\t\t= \"rw_lock_irq\"\n};\nstatic struct lock_torture_ops mutex_lock_ops = {\n\t.writelock\t= torture_mutex_lock,\n\t.write_delay\t= torture_mutex_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_mutex_unlock,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"mutex_lock\"\n};\nstatic struct lock_torture_ops ww_mutex_lock_ops = {\n\t.writelock\t= torture_ww_mutex_lock,\n\t.write_delay\t= torture_mutex_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_ww_mutex_unlock,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"ww_mutex_lock\"\n};\nstatic struct lock_torture_ops rwsem_lock_ops = {\n\t.writelock\t= torture_rwsem_down_write,\n\t.write_delay\t= torture_rwsem_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_rwsem_up_write,\n\t.readlock       = torture_rwsem_down_read,\n\t.read_delay     = torture_rwsem_read_delay,\n\t.readunlock     = torture_rwsem_up_read,\n\t.name\t\t= \"rwsem_lock\"\n};\nstatic struct lock_torture_ops percpu_rwsem_lock_ops = {\n\t.init\t\t= torture_percpu_rwsem_init,\n\t.writelock\t= torture_percpu_rwsem_down_write,\n\t.write_delay\t= torture_rwsem_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_percpu_rwsem_up_write,\n\t.readlock       = torture_percpu_rwsem_down_read,\n\t.read_delay     = torture_rwsem_read_delay,\n\t.readunlock     = torture_percpu_rwsem_up_read,\n\t.name\t\t= \"percpu_rwsem_lock\"\n};\n\nstatic int __init lock_torture_init(void)\n{\n\tint i, j;\n\tint firsterr = 0;\n\tstatic struct lock_torture_ops *torture_ops[] = {\n\t\t&lock_busted_ops,\n\t\t&spin_lock_ops, &spin_lock_irq_ops,\n\t\t&rw_lock_ops, &rw_lock_irq_ops,\n\t\t&mutex_lock_ops,\n\t\t&ww_mutex_lock_ops,\n#ifdef CONFIG_RT_MUTEXES\n\t\t&rtmutex_lock_ops,\n#endif\n\t\t&rwsem_lock_ops,\n\t\t&percpu_rwsem_lock_ops,\n\t};\n\n\tif (!torture_init_begin(torture_type, verbose))\n\t\treturn -EBUSY;\n\n\t/* Process args and tell the world that the torturer is on the job. */\n\tfor (i = 0; i < ARRAY_SIZE(torture_ops); i++) {\n\t\tcxt.cur_ops = torture_ops[i];\n\t\tif (strcmp(torture_type, cxt.cur_ops->name) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(torture_ops)) {\n\t\tpr_alert(\"lock-torture: invalid torture type: \\\"%s\\\"\\n\",\n\t\t\t torture_type);\n\t\tpr_alert(\"lock-torture types:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(torture_ops); i++)\n\t\t\tpr_alert(\" %s\", torture_ops[i]->name);\n\t\tpr_alert(\"\\n\");\n\t\tfirsterr = -EINVAL;\n\t\tgoto unwind;\n\t}\n\n\tif (nwriters_stress == 0 && nreaders_stress == 0) {\n\t\tpr_alert(\"lock-torture: must run at least one locking thread\\n\");\n\t\tfirsterr = -EINVAL;\n\t\tgoto unwind;\n\t}\n\n\tif (cxt.cur_ops->init)\n\t\tcxt.cur_ops->init();\n\n\tif (nwriters_stress >= 0)\n\t\tcxt.nrealwriters_stress = nwriters_stress;\n\telse\n\t\tcxt.nrealwriters_stress = 2 * num_online_cpus();\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tif (strncmp(torture_type, \"mutex\", 5) == 0)\n\t\tcxt.debug_lock = true;\n#endif\n#ifdef CONFIG_DEBUG_RT_MUTEXES\n\tif (strncmp(torture_type, \"rtmutex\", 7) == 0)\n\t\tcxt.debug_lock = true;\n#endif\n#ifdef CONFIG_DEBUG_SPINLOCK\n\tif ((strncmp(torture_type, \"spin\", 4) == 0) ||\n\t    (strncmp(torture_type, \"rw_lock\", 7) == 0))\n\t\tcxt.debug_lock = true;\n#endif\n\n\t/* Initialize the statistics so that each run gets its own numbers. */\n\tif (nwriters_stress) {\n\t\tlock_is_write_held = 0;\n\t\tcxt.lwsa = kmalloc_array(cxt.nrealwriters_stress,\n\t\t\t\t\t sizeof(*cxt.lwsa),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (cxt.lwsa == NULL) {\n\t\t\tVERBOSE_TOROUT_STRING(\"cxt.lwsa: Out of memory\");\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\n\t\tfor (i = 0; i < cxt.nrealwriters_stress; i++) {\n\t\t\tcxt.lwsa[i].n_lock_fail = 0;\n\t\t\tcxt.lwsa[i].n_lock_acquired = 0;\n\t\t}\n\t}\n\n\tif (cxt.cur_ops->readlock) {\n\t\tif (nreaders_stress >= 0)\n\t\t\tcxt.nrealreaders_stress = nreaders_stress;\n\t\telse {\n\t\t\t/*\n\t\t\t * By default distribute evenly the number of\n\t\t\t * readers and writers. We still run the same number\n\t\t\t * of threads as the writer-only locks default.\n\t\t\t */\n\t\t\tif (nwriters_stress < 0) /* user doesn't care */\n\t\t\t\tcxt.nrealwriters_stress = num_online_cpus();\n\t\t\tcxt.nrealreaders_stress = cxt.nrealwriters_stress;\n\t\t}\n\n\t\tif (nreaders_stress) {\n\t\t\tlock_is_read_held = 0;\n\t\t\tcxt.lrsa = kmalloc_array(cxt.nrealreaders_stress,\n\t\t\t\t\t\t sizeof(*cxt.lrsa),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (cxt.lrsa == NULL) {\n\t\t\t\tVERBOSE_TOROUT_STRING(\"cxt.lrsa: Out of memory\");\n\t\t\t\tfirsterr = -ENOMEM;\n\t\t\t\tkfree(cxt.lwsa);\n\t\t\t\tcxt.lwsa = NULL;\n\t\t\t\tgoto unwind;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < cxt.nrealreaders_stress; i++) {\n\t\t\t\tcxt.lrsa[i].n_lock_fail = 0;\n\t\t\t\tcxt.lrsa[i].n_lock_acquired = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tlock_torture_print_module_parms(cxt.cur_ops, \"Start of test\");\n\n\t/* Prepare torture context. */\n\tif (onoff_interval > 0) {\n\t\tfirsterr = torture_onoff_init(onoff_holdoff * HZ,\n\t\t\t\t\t      onoff_interval * HZ);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (shuffle_interval > 0) {\n\t\tfirsterr = torture_shuffle_init(shuffle_interval);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (shutdown_secs > 0) {\n\t\tfirsterr = torture_shutdown_init(shutdown_secs,\n\t\t\t\t\t\t lock_torture_cleanup);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (stutter > 0) {\n\t\tfirsterr = torture_stutter_init(stutter);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\n\tif (nwriters_stress) {\n\t\twriter_tasks = kcalloc(cxt.nrealwriters_stress,\n\t\t\t\t       sizeof(writer_tasks[0]),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (writer_tasks == NULL) {\n\t\t\tVERBOSE_TOROUT_ERRSTRING(\"writer_tasks: Out of memory\");\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\n\tif (cxt.cur_ops->readlock) {\n\t\treader_tasks = kcalloc(cxt.nrealreaders_stress,\n\t\t\t\t       sizeof(reader_tasks[0]),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (reader_tasks == NULL) {\n\t\t\tVERBOSE_TOROUT_ERRSTRING(\"reader_tasks: Out of memory\");\n\t\t\tkfree(writer_tasks);\n\t\t\twriter_tasks = NULL;\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\n\t/*\n\t * Create the kthreads and start torturing (oh, those poor little locks).\n\t *\n\t * TODO: Note that we interleave writers with readers, giving writers a\n\t * slight advantage, by creating its kthread first. This can be modified\n\t * for very specific needs, or even let the user choose the policy, if\n\t * ever wanted.\n\t */\n\tfor (i = 0, j = 0; i < cxt.nrealwriters_stress ||\n\t\t    j < cxt.nrealreaders_stress; i++, j++) {\n\t\tif (i >= cxt.nrealwriters_stress)\n\t\t\tgoto create_reader;\n\n\t\t/* Create writer. */\n\t\tfirsterr = torture_create_kthread(lock_torture_writer, &cxt.lwsa[i],\n\t\t\t\t\t\t  writer_tasks[i]);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\n\tcreate_reader:\n\t\tif (cxt.cur_ops->readlock == NULL || (j >= cxt.nrealreaders_stress))\n\t\t\tcontinue;\n\t\t/* Create reader. */\n\t\tfirsterr = torture_create_kthread(lock_torture_reader, &cxt.lrsa[j],\n\t\t\t\t\t\t  reader_tasks[j]);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (stat_interval > 0) {\n\t\tfirsterr = torture_create_kthread(lock_torture_stats, NULL,\n\t\t\t\t\t\t  stats_task);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\tlock_torture_cleanup();\n\treturn firsterr;\n}"
  },
  {
    "function_name": "lock_torture_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "799-849",
    "snippet": "static void lock_torture_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\t/*\n\t * Indicates early cleanup, meaning that the test has not run,\n\t * such as when passing bogus args when loading the module. As\n\t * such, only perform the underlying torture-specific cleanups,\n\t * and avoid anything related to locktorture.\n\t */\n\tif (!cxt.lwsa && !cxt.lrsa)\n\t\tgoto end;\n\n\tif (writer_tasks) {\n\t\tfor (i = 0; i < cxt.nrealwriters_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_writer,\n\t\t\t\t\t     writer_tasks[i]);\n\t\tkfree(writer_tasks);\n\t\twriter_tasks = NULL;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < cxt.nrealreaders_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t\treader_tasks = NULL;\n\t}\n\n\ttorture_stop_kthread(lock_torture_stats, stats_task);\n\tlock_torture_stats_print();  /* -After- the stats thread is stopped! */\n\n\tif (atomic_read(&cxt.n_lock_torture_errors))\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: LOCK_HOTPLUG\");\n\telse\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: SUCCESS\");\n\n\tkfree(cxt.lwsa);\n\tkfree(cxt.lrsa);\n\nend:\n\ttorture_cleanup_end();\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *stats_task;",
      "static struct task_struct **writer_tasks;",
      "static struct task_struct **reader_tasks;",
      "static void lock_torture_cleanup(void);",
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_cleanup_end",
          "args": [],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "torture_cleanup_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "715-720",
          "snippet": "void torture_cleanup_end(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\ttorture_type = NULL;\n\tmutex_unlock(&fullstop_mutex);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *torture_type;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nvoid torture_cleanup_end(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\ttorture_type = NULL;\n\tmutex_unlock(&fullstop_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cxt.lrsa"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_torture_print_module_parms",
          "args": [
            "cxt.cur_ops",
            "\"End of test: SUCCESS\""
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "lock_torture_print_module_parms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
          "lines": "787-797",
          "snippet": "static inline void\nlock_torture_print_module_parms(struct lock_torture_ops *cur_ops,\n\t\t\t\tconst char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s%s: nwriters_stress=%d nreaders_stress=%d stat_interval=%d verbose=%d shuffle_interval=%d stutter=%d shutdown_secs=%d onoff_interval=%d onoff_holdoff=%d\\n\",\n\t\t torture_type, tag, cxt.debug_lock ? \" [debug]\": \"\",\n\t\t cxt.nrealwriters_stress, cxt.nrealreaders_stress, stat_interval,\n\t\t verbose, shuffle_interval, stutter, shutdown_secs,\n\t\t onoff_interval, onoff_holdoff);\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/torture.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rwlock.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *torture_type = \"spin_lock\";",
            "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic char *torture_type = \"spin_lock\";\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic inline void\nlock_torture_print_module_parms(struct lock_torture_ops *cur_ops,\n\t\t\t\tconst char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s%s: nwriters_stress=%d nreaders_stress=%d stat_interval=%d verbose=%d shuffle_interval=%d stutter=%d shutdown_secs=%d onoff_interval=%d onoff_holdoff=%d\\n\",\n\t\t torture_type, tag, cxt.debug_lock ? \" [debug]\": \"\",\n\t\t cxt.nrealwriters_stress, cxt.nrealreaders_stress, stat_interval,\n\t\t verbose, shuffle_interval, stutter, shutdown_secs,\n\t\t onoff_interval, onoff_holdoff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_onoff_failures",
          "args": [],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "torture_onoff_failures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "283-291",
          "snippet": "bool torture_onoff_failures(void)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\treturn n_online_successes != n_online_attempts ||\n\t       n_offline_successes != n_offline_attempts;\n#else /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn false;\n#endif /* #else #ifdef CONFIG_HOTPLUG_CPU */\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool torture_onoff_failures(void)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\treturn n_online_successes != n_online_attempts ||\n\t       n_offline_successes != n_offline_attempts;\n#else /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn false;\n#endif /* #else #ifdef CONFIG_HOTPLUG_CPU */\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cxt.n_lock_torture_errors"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_torture_stats_print",
          "args": [],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "lock_torture_stats_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
          "lines": "735-766",
          "snippet": "static void lock_torture_stats_print(void)\n{\n\tint size = cxt.nrealwriters_stress * 200 + 8192;\n\tchar *buf;\n\n\tif (cxt.cur_ops->readlock)\n\t\tsize += cxt.nrealreaders_stress * 200 + 8192;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t       size);\n\t\treturn;\n\t}\n\n\t__torture_print_stats(buf, cxt.lwsa, true);\n\tpr_alert(\"%s\", buf);\n\tkfree(buf);\n\n\tif (cxt.cur_ops->readlock) {\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t\t       size);\n\t\t\treturn;\n\t\t}\n\n\t\t__torture_print_stats(buf, cxt.lrsa, false);\n\t\tpr_alert(\"%s\", buf);\n\t\tkfree(buf);\n\t}\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/torture.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rwlock.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void lock_torture_stats_print(void)\n{\n\tint size = cxt.nrealwriters_stress * 200 + 8192;\n\tchar *buf;\n\n\tif (cxt.cur_ops->readlock)\n\t\tsize += cxt.nrealreaders_stress * 200 + 8192;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t       size);\n\t\treturn;\n\t}\n\n\t__torture_print_stats(buf, cxt.lwsa, true);\n\tpr_alert(\"%s\", buf);\n\tkfree(buf);\n\n\tif (cxt.cur_ops->readlock) {\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t\t       size);\n\t\t\treturn;\n\t\t}\n\n\t\t__torture_print_stats(buf, cxt.lrsa, false);\n\t\tpr_alert(\"%s\", buf);\n\t\tkfree(buf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_stop_kthread",
          "args": [
            "lock_torture_stats",
            "stats_task"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "_torture_stop_kthread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "787-794",
          "snippet": "void _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_cleanup_begin",
          "args": [],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "torture_cleanup_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "696-712",
          "snippet": "bool torture_cleanup_begin(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\tschedule_timeout_uninterruptible(10);\n\t\treturn true;\n\t}\n\tWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\n\tmutex_unlock(&fullstop_mutex);\n\ttorture_shutdown_cleanup();\n\ttorture_shuffle_cleanup();\n\ttorture_stutter_cleanup();\n\ttorture_onoff_cleanup();\n\treturn false;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_RMMOD    2\t/* Normal rmmod of torture. */",
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_RMMOD    2\t/* Normal rmmod of torture. */\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nbool torture_cleanup_begin(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\tschedule_timeout_uninterruptible(10);\n\t\treturn true;\n\t}\n\tWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\n\tmutex_unlock(&fullstop_mutex);\n\ttorture_shutdown_cleanup();\n\ttorture_shuffle_cleanup();\n\ttorture_stutter_cleanup();\n\ttorture_onoff_cleanup();\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct task_struct *stats_task;\nstatic struct task_struct **writer_tasks;\nstatic struct task_struct **reader_tasks;\nstatic void lock_torture_cleanup(void);\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void lock_torture_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\t/*\n\t * Indicates early cleanup, meaning that the test has not run,\n\t * such as when passing bogus args when loading the module. As\n\t * such, only perform the underlying torture-specific cleanups,\n\t * and avoid anything related to locktorture.\n\t */\n\tif (!cxt.lwsa && !cxt.lrsa)\n\t\tgoto end;\n\n\tif (writer_tasks) {\n\t\tfor (i = 0; i < cxt.nrealwriters_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_writer,\n\t\t\t\t\t     writer_tasks[i]);\n\t\tkfree(writer_tasks);\n\t\twriter_tasks = NULL;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < cxt.nrealreaders_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t\treader_tasks = NULL;\n\t}\n\n\ttorture_stop_kthread(lock_torture_stats, stats_task);\n\tlock_torture_stats_print();  /* -After- the stats thread is stopped! */\n\n\tif (atomic_read(&cxt.n_lock_torture_errors))\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: LOCK_HOTPLUG\");\n\telse\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: SUCCESS\");\n\n\tkfree(cxt.lwsa);\n\tkfree(cxt.lrsa);\n\nend:\n\ttorture_cleanup_end();\n}"
  },
  {
    "function_name": "lock_torture_print_module_parms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "787-797",
    "snippet": "static inline void\nlock_torture_print_module_parms(struct lock_torture_ops *cur_ops,\n\t\t\t\tconst char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s%s: nwriters_stress=%d nreaders_stress=%d stat_interval=%d verbose=%d shuffle_interval=%d stutter=%d shutdown_secs=%d onoff_interval=%d onoff_holdoff=%d\\n\",\n\t\t torture_type, tag, cxt.debug_lock ? \" [debug]\": \"\",\n\t\t cxt.nrealwriters_stress, cxt.nrealreaders_stress, stat_interval,\n\t\t verbose, shuffle_interval, stutter, shutdown_secs,\n\t\t onoff_interval, onoff_holdoff);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *torture_type = \"spin_lock\";",
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\" TORTURE_FLAG\n\t\t \"--- %s%s: nwriters_stress=%d nreaders_stress=%d stat_interval=%d verbose=%d shuffle_interval=%d stutter=%d shutdown_secs=%d onoff_interval=%d onoff_holdoff=%d\\n\"",
            "torture_type",
            "tag",
            "cxt.debug_lock ? \" [debug]\": \"\"",
            "cxt.nrealwriters_stress",
            "cxt.nrealreaders_stress",
            "stat_interval",
            "verbose",
            "shuffle_interval",
            "stutter",
            "shutdown_secs",
            "onoff_interval",
            "onoff_holdoff"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic char *torture_type = \"spin_lock\";\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic inline void\nlock_torture_print_module_parms(struct lock_torture_ops *cur_ops,\n\t\t\t\tconst char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s%s: nwriters_stress=%d nreaders_stress=%d stat_interval=%d verbose=%d shuffle_interval=%d stutter=%d shutdown_secs=%d onoff_interval=%d onoff_holdoff=%d\\n\",\n\t\t torture_type, tag, cxt.debug_lock ? \" [debug]\": \"\",\n\t\t cxt.nrealwriters_stress, cxt.nrealreaders_stress, stat_interval,\n\t\t verbose, shuffle_interval, stutter, shutdown_secs,\n\t\t onoff_interval, onoff_holdoff);\n}"
  },
  {
    "function_name": "lock_torture_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "775-785",
    "snippet": "static int lock_torture_stats(void *arg)\n{\n\tVERBOSE_TOROUT_STRING(\"lock_torture_stats task started\");\n\tdo {\n\t\tschedule_timeout_interruptible(stat_interval * HZ);\n\t\tlock_torture_stats_print();\n\t\ttorture_shutdown_absorb(\"lock_torture_stats\");\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"lock_torture_stats\");\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"lock_torture_stats\""
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "749-759",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "736-739",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_shutdown_absorb",
          "args": [
            "\"lock_torture_stats\""
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "462-469",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_torture_stats_print",
          "args": [],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "lock_torture_stats_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
          "lines": "735-766",
          "snippet": "static void lock_torture_stats_print(void)\n{\n\tint size = cxt.nrealwriters_stress * 200 + 8192;\n\tchar *buf;\n\n\tif (cxt.cur_ops->readlock)\n\t\tsize += cxt.nrealreaders_stress * 200 + 8192;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t       size);\n\t\treturn;\n\t}\n\n\t__torture_print_stats(buf, cxt.lwsa, true);\n\tpr_alert(\"%s\", buf);\n\tkfree(buf);\n\n\tif (cxt.cur_ops->readlock) {\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t\t       size);\n\t\t\treturn;\n\t\t}\n\n\t\t__torture_print_stats(buf, cxt.lrsa, false);\n\t\tpr_alert(\"%s\", buf);\n\t\tkfree(buf);\n\t}\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/torture.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rwlock.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void lock_torture_stats_print(void)\n{\n\tint size = cxt.nrealwriters_stress * 200 + 8192;\n\tchar *buf;\n\n\tif (cxt.cur_ops->readlock)\n\t\tsize += cxt.nrealreaders_stress * 200 + 8192;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t       size);\n\t\treturn;\n\t}\n\n\t__torture_print_stats(buf, cxt.lwsa, true);\n\tpr_alert(\"%s\", buf);\n\tkfree(buf);\n\n\tif (cxt.cur_ops->readlock) {\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t\t       size);\n\t\t\treturn;\n\t\t}\n\n\t\t__torture_print_stats(buf, cxt.lrsa, false);\n\t\tpr_alert(\"%s\", buf);\n\t\tkfree(buf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "stat_interval * HZ"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1821-1825",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"lock_torture_stats task started\""
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int lock_torture_stats(void *arg)\n{\n\tVERBOSE_TOROUT_STRING(\"lock_torture_stats task started\");\n\tdo {\n\t\tschedule_timeout_interruptible(stat_interval * HZ);\n\t\tlock_torture_stats_print();\n\t\ttorture_shutdown_absorb(\"lock_torture_stats\");\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"lock_torture_stats\");\n\treturn 0;\n}"
  },
  {
    "function_name": "lock_torture_stats_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "735-766",
    "snippet": "static void lock_torture_stats_print(void)\n{\n\tint size = cxt.nrealwriters_stress * 200 + 8192;\n\tchar *buf;\n\n\tif (cxt.cur_ops->readlock)\n\t\tsize += cxt.nrealreaders_stress * 200 + 8192;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t       size);\n\t\treturn;\n\t}\n\n\t__torture_print_stats(buf, cxt.lwsa, true);\n\tpr_alert(\"%s\", buf);\n\tkfree(buf);\n\n\tif (cxt.cur_ops->readlock) {\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t\t       size);\n\t\t\treturn;\n\t\t}\n\n\t\t__torture_print_stats(buf, cxt.lrsa, false);\n\t\tpr_alert(\"%s\", buf);\n\t\tkfree(buf);\n\t}\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\"",
            "buf"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__torture_print_stats",
          "args": [
            "buf",
            "cxt.lrsa",
            "false"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "__torture_print_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
          "lines": "700-725",
          "snippet": "static void __torture_print_stats(char *page,\n\t\t\t\t  struct lock_stress_stats *statp, bool write)\n{\n\tbool fail = 0;\n\tint i, n_stress;\n\tlong max = 0, min = statp ? statp[0].n_lock_acquired : 0;\n\tlong long sum = 0;\n\n\tn_stress = write ? cxt.nrealwriters_stress : cxt.nrealreaders_stress;\n\tfor (i = 0; i < n_stress; i++) {\n\t\tif (statp[i].n_lock_fail)\n\t\t\tfail = true;\n\t\tsum += statp[i].n_lock_acquired;\n\t\tif (max < statp[i].n_lock_fail)\n\t\t\tmax = statp[i].n_lock_fail;\n\t\tif (min > statp[i].n_lock_fail)\n\t\t\tmin = statp[i].n_lock_fail;\n\t}\n\tpage += sprintf(page,\n\t\t\t\"%s:  Total: %lld  Max/Min: %ld/%ld %s  Fail: %d %s\\n\",\n\t\t\twrite ? \"Writes\" : \"Reads \",\n\t\t\tsum, max, min, max / 2 > min ? \"???\" : \"\",\n\t\t\tfail, fail ? \"!!!\" : \"\");\n\tif (fail)\n\t\tatomic_inc(&cxt.n_lock_torture_errors);\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/torture.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rwlock.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void __torture_print_stats(char *page,\n\t\t\t\t  struct lock_stress_stats *statp, bool write)\n{\n\tbool fail = 0;\n\tint i, n_stress;\n\tlong max = 0, min = statp ? statp[0].n_lock_acquired : 0;\n\tlong long sum = 0;\n\n\tn_stress = write ? cxt.nrealwriters_stress : cxt.nrealreaders_stress;\n\tfor (i = 0; i < n_stress; i++) {\n\t\tif (statp[i].n_lock_fail)\n\t\t\tfail = true;\n\t\tsum += statp[i].n_lock_acquired;\n\t\tif (max < statp[i].n_lock_fail)\n\t\t\tmax = statp[i].n_lock_fail;\n\t\tif (min > statp[i].n_lock_fail)\n\t\t\tmin = statp[i].n_lock_fail;\n\t}\n\tpage += sprintf(page,\n\t\t\t\"%s:  Total: %lld  Max/Min: %ld/%ld %s  Fail: %d %s\\n\",\n\t\t\twrite ? \"Writes\" : \"Reads \",\n\t\t\tsum, max, min, max / 2 > min ? \"???\" : \"\",\n\t\t\tfail, fail ? \"!!!\" : \"\");\n\tif (fail)\n\t\tatomic_inc(&cxt.n_lock_torture_errors);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"lock_torture_stats_print: Out of memory, need: %d\"",
            "size"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\"",
            "buf"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"lock_torture_stats_print: Out of memory, need: %d\"",
            "size"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void lock_torture_stats_print(void)\n{\n\tint size = cxt.nrealwriters_stress * 200 + 8192;\n\tchar *buf;\n\n\tif (cxt.cur_ops->readlock)\n\t\tsize += cxt.nrealreaders_stress * 200 + 8192;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t       size);\n\t\treturn;\n\t}\n\n\t__torture_print_stats(buf, cxt.lwsa, true);\n\tpr_alert(\"%s\", buf);\n\tkfree(buf);\n\n\tif (cxt.cur_ops->readlock) {\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t\t       size);\n\t\t\treturn;\n\t\t}\n\n\t\t__torture_print_stats(buf, cxt.lrsa, false);\n\t\tpr_alert(\"%s\", buf);\n\t\tkfree(buf);\n\t}\n}"
  },
  {
    "function_name": "__torture_print_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "700-725",
    "snippet": "static void __torture_print_stats(char *page,\n\t\t\t\t  struct lock_stress_stats *statp, bool write)\n{\n\tbool fail = 0;\n\tint i, n_stress;\n\tlong max = 0, min = statp ? statp[0].n_lock_acquired : 0;\n\tlong long sum = 0;\n\n\tn_stress = write ? cxt.nrealwriters_stress : cxt.nrealreaders_stress;\n\tfor (i = 0; i < n_stress; i++) {\n\t\tif (statp[i].n_lock_fail)\n\t\t\tfail = true;\n\t\tsum += statp[i].n_lock_acquired;\n\t\tif (max < statp[i].n_lock_fail)\n\t\t\tmax = statp[i].n_lock_fail;\n\t\tif (min > statp[i].n_lock_fail)\n\t\t\tmin = statp[i].n_lock_fail;\n\t}\n\tpage += sprintf(page,\n\t\t\t\"%s:  Total: %lld  Max/Min: %ld/%ld %s  Fail: %d %s\\n\",\n\t\t\twrite ? \"Writes\" : \"Reads \",\n\t\t\tsum, max, min, max / 2 > min ? \"???\" : \"\",\n\t\t\tfail, fail ? \"!!!\" : \"\");\n\tif (fail)\n\t\tatomic_inc(&cxt.n_lock_torture_errors);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&cxt.n_lock_torture_errors"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "page",
            "\"%s:  Total: %lld  Max/Min: %ld/%ld %s  Fail: %d %s\\n\"",
            "write ? \"Writes\" : \"Reads \"",
            "sum",
            "max",
            "min",
            "max / 2 > min ? \"???\" : \"\"",
            "fail",
            "fail ? \"!!!\" : \"\""
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void __torture_print_stats(char *page,\n\t\t\t\t  struct lock_stress_stats *statp, bool write)\n{\n\tbool fail = 0;\n\tint i, n_stress;\n\tlong max = 0, min = statp ? statp[0].n_lock_acquired : 0;\n\tlong long sum = 0;\n\n\tn_stress = write ? cxt.nrealwriters_stress : cxt.nrealreaders_stress;\n\tfor (i = 0; i < n_stress; i++) {\n\t\tif (statp[i].n_lock_fail)\n\t\t\tfail = true;\n\t\tsum += statp[i].n_lock_acquired;\n\t\tif (max < statp[i].n_lock_fail)\n\t\t\tmax = statp[i].n_lock_fail;\n\t\tif (min > statp[i].n_lock_fail)\n\t\t\tmin = statp[i].n_lock_fail;\n\t}\n\tpage += sprintf(page,\n\t\t\t\"%s:  Total: %lld  Max/Min: %ld/%ld %s  Fail: %d %s\\n\",\n\t\t\twrite ? \"Writes\" : \"Reads \",\n\t\t\tsum, max, min, max / 2 > min ? \"???\" : \"\",\n\t\t\tfail, fail ? \"!!!\" : \"\");\n\tif (fail)\n\t\tatomic_inc(&cxt.n_lock_torture_errors);\n}"
  },
  {
    "function_name": "lock_torture_reader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "669-695",
    "snippet": "static int lock_torture_reader(void *arg)\n{\n\tstruct lock_stress_stats *lrsp = arg;\n\tstatic DEFINE_TORTURE_RANDOM(rand);\n\n\tVERBOSE_TOROUT_STRING(\"lock_torture_reader task started\");\n\tset_user_nice(current, MAX_NICE);\n\n\tdo {\n\t\tif ((torture_random(&rand) & 0xfffff) == 0)\n\t\t\tschedule_timeout_uninterruptible(1);\n\n\t\tcxt.cur_ops->readlock();\n\t\tlock_is_read_held = 1;\n\t\tif (WARN_ON_ONCE(lock_is_write_held))\n\t\t\tlrsp->n_lock_fail++; /* rare, but... */\n\n\t\tlrsp->n_lock_acquired++;\n\t\tcxt.cur_ops->read_delay(&rand);\n\t\tlock_is_read_held = 0;\n\t\tcxt.cur_ops->readunlock();\n\n\t\tstutter_wait(\"lock_torture_reader\");\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"lock_torture_reader\");\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lock_is_write_held;",
      "static bool lock_is_read_held;",
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"lock_torture_reader\""
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "749-759",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "736-739",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"lock_torture_reader\""
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "576-594",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test))\n\t\t\t\tcond_resched();\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn !!spt;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test))\n\t\t\t\tcond_resched();\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn !!spt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cxt.cur_ops->readunlock",
          "args": [],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cxt.cur_ops->read_delay",
          "args": [
            "&rand"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "lock_is_write_held"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cxt.cur_ops->readlock",
          "args": [],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1835-1839",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "&rand"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "302-312",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3865-3917",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"lock_torture_reader task started\""
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic bool lock_is_write_held;\nstatic bool lock_is_read_held;\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic int lock_torture_reader(void *arg)\n{\n\tstruct lock_stress_stats *lrsp = arg;\n\tstatic DEFINE_TORTURE_RANDOM(rand);\n\n\tVERBOSE_TOROUT_STRING(\"lock_torture_reader task started\");\n\tset_user_nice(current, MAX_NICE);\n\n\tdo {\n\t\tif ((torture_random(&rand) & 0xfffff) == 0)\n\t\t\tschedule_timeout_uninterruptible(1);\n\n\t\tcxt.cur_ops->readlock();\n\t\tlock_is_read_held = 1;\n\t\tif (WARN_ON_ONCE(lock_is_write_held))\n\t\t\tlrsp->n_lock_fail++; /* rare, but... */\n\n\t\tlrsp->n_lock_acquired++;\n\t\tcxt.cur_ops->read_delay(&rand);\n\t\tlock_is_read_held = 0;\n\t\tcxt.cur_ops->readunlock();\n\n\t\tstutter_wait(\"lock_torture_reader\");\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"lock_torture_reader\");\n\treturn 0;\n}"
  },
  {
    "function_name": "lock_torture_writer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "632-663",
    "snippet": "static int lock_torture_writer(void *arg)\n{\n\tstruct lock_stress_stats *lwsp = arg;\n\tstatic DEFINE_TORTURE_RANDOM(rand);\n\n\tVERBOSE_TOROUT_STRING(\"lock_torture_writer task started\");\n\tset_user_nice(current, MAX_NICE);\n\n\tdo {\n\t\tif ((torture_random(&rand) & 0xfffff) == 0)\n\t\t\tschedule_timeout_uninterruptible(1);\n\n\t\tcxt.cur_ops->task_boost(&rand);\n\t\tcxt.cur_ops->writelock();\n\t\tif (WARN_ON_ONCE(lock_is_write_held))\n\t\t\tlwsp->n_lock_fail++;\n\t\tlock_is_write_held = 1;\n\t\tif (WARN_ON_ONCE(lock_is_read_held))\n\t\t\tlwsp->n_lock_fail++; /* rare, but... */\n\n\t\tlwsp->n_lock_acquired++;\n\t\tcxt.cur_ops->write_delay(&rand);\n\t\tlock_is_write_held = 0;\n\t\tcxt.cur_ops->writeunlock();\n\n\t\tstutter_wait(\"lock_torture_writer\");\n\t} while (!torture_must_stop());\n\n\tcxt.cur_ops->task_boost(NULL); /* reset prio */\n\ttorture_kthread_stopping(\"lock_torture_writer\");\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lock_is_write_held;",
      "static bool lock_is_read_held;",
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"lock_torture_writer\""
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "749-759",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cxt.cur_ops->task_boost",
          "args": [
            "NULL"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "736-739",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"lock_torture_writer\""
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "576-594",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test))\n\t\t\t\tcond_resched();\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn !!spt;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test))\n\t\t\t\tcond_resched();\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn !!spt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cxt.cur_ops->writeunlock",
          "args": [],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cxt.cur_ops->write_delay",
          "args": [
            "&rand"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "lock_is_read_held"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "lock_is_write_held"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cxt.cur_ops->writelock",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cxt.cur_ops->task_boost",
          "args": [
            "&rand"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1835-1839",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "&rand"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "302-312",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3865-3917",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"lock_torture_writer task started\""
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic bool lock_is_write_held;\nstatic bool lock_is_read_held;\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic int lock_torture_writer(void *arg)\n{\n\tstruct lock_stress_stats *lwsp = arg;\n\tstatic DEFINE_TORTURE_RANDOM(rand);\n\n\tVERBOSE_TOROUT_STRING(\"lock_torture_writer task started\");\n\tset_user_nice(current, MAX_NICE);\n\n\tdo {\n\t\tif ((torture_random(&rand) & 0xfffff) == 0)\n\t\t\tschedule_timeout_uninterruptible(1);\n\n\t\tcxt.cur_ops->task_boost(&rand);\n\t\tcxt.cur_ops->writelock();\n\t\tif (WARN_ON_ONCE(lock_is_write_held))\n\t\t\tlwsp->n_lock_fail++;\n\t\tlock_is_write_held = 1;\n\t\tif (WARN_ON_ONCE(lock_is_read_held))\n\t\t\tlwsp->n_lock_fail++; /* rare, but... */\n\n\t\tlwsp->n_lock_acquired++;\n\t\tcxt.cur_ops->write_delay(&rand);\n\t\tlock_is_write_held = 0;\n\t\tcxt.cur_ops->writeunlock();\n\n\t\tstutter_wait(\"lock_torture_writer\");\n\t} while (!torture_must_stop());\n\n\tcxt.cur_ops->task_boost(NULL); /* reset prio */\n\ttorture_kthread_stopping(\"lock_torture_writer\");\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_percpu_rwsem_up_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "611-614",
    "snippet": "static void torture_percpu_rwsem_up_read(void) __releases(pcpu_rwsem)\n{\n\tpercpu_up_read(&pcpu_rwsem);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_rw_semaphore pcpu_rwsem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_read",
          "args": [
            "&pcpu_rwsem"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_up_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "94-106",
          "snippet": "void __percpu_up_read(struct percpu_rw_semaphore *sem)\n{\n\tsmp_mb(); /* B matches C */\n\t/*\n\t * In other words, if they see our decrement (presumably to aggregate\n\t * zero, as that is the only time it matters) they will also see our\n\t * critical section.\n\t */\n\t__this_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to recheck readers_active */\n\trcuwait_wake_up(&sem->writer);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid __percpu_up_read(struct percpu_rw_semaphore *sem)\n{\n\tsmp_mb(); /* B matches C */\n\t/*\n\t * In other words, if they see our decrement (presumably to aggregate\n\t * zero, as that is the only time it matters) they will also see our\n\t * critical section.\n\t */\n\t__this_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to recheck readers_active */\n\trcuwait_wake_up(&sem->writer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "pcpu_rwsem"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore pcpu_rwsem;\n\nstatic void torture_percpu_rwsem_up_read(void) __releases(pcpu_rwsem)\n{\n\tpercpu_up_read(&pcpu_rwsem);\n}"
  },
  {
    "function_name": "torture_percpu_rwsem_down_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "605-609",
    "snippet": "static int torture_percpu_rwsem_down_read(void) __acquires(pcpu_rwsem)\n{\n\tpercpu_down_read(&pcpu_rwsem);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_rw_semaphore pcpu_rwsem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_down_read",
          "args": [
            "&pcpu_rwsem"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "pcpu_rwsem"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore pcpu_rwsem;\n\nstatic int torture_percpu_rwsem_down_read(void) __acquires(pcpu_rwsem)\n{\n\tpercpu_down_read(&pcpu_rwsem);\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_percpu_rwsem_up_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "600-603",
    "snippet": "static void torture_percpu_rwsem_up_write(void) __releases(pcpu_rwsem)\n{\n\tpercpu_up_write(&pcpu_rwsem);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_rw_semaphore pcpu_rwsem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&pcpu_rwsem"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "pcpu_rwsem"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore pcpu_rwsem;\n\nstatic void torture_percpu_rwsem_up_write(void) __releases(pcpu_rwsem)\n{\n\tpercpu_up_write(&pcpu_rwsem);\n}"
  },
  {
    "function_name": "torture_percpu_rwsem_down_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "594-598",
    "snippet": "static int torture_percpu_rwsem_down_write(void) __acquires(pcpu_rwsem)\n{\n\tpercpu_down_write(&pcpu_rwsem);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_rw_semaphore pcpu_rwsem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&pcpu_rwsem"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "pcpu_rwsem"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore pcpu_rwsem;\n\nstatic int torture_percpu_rwsem_down_write(void) __acquires(pcpu_rwsem)\n{\n\tpercpu_down_write(&pcpu_rwsem);\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_percpu_rwsem_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "589-592",
    "snippet": "void torture_percpu_rwsem_init(void)\n{\n\tBUG_ON(percpu_init_rwsem(&pcpu_rwsem));\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_rw_semaphore pcpu_rwsem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "percpu_init_rwsem(&pcpu_rwsem)"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_init_rwsem",
          "args": [
            "&pcpu_rwsem"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore pcpu_rwsem;\n\nvoid torture_percpu_rwsem_init(void)\n{\n\tBUG_ON(percpu_init_rwsem(&pcpu_rwsem));\n}"
  },
  {
    "function_name": "torture_rwsem_up_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "570-573",
    "snippet": "static void torture_rwsem_up_read(void) __releases(torture_rwsem)\n{\n\tup_read(&torture_rwsem);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(torture_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&torture_rwsem"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_up_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "94-106",
          "snippet": "void __percpu_up_read(struct percpu_rw_semaphore *sem)\n{\n\tsmp_mb(); /* B matches C */\n\t/*\n\t * In other words, if they see our decrement (presumably to aggregate\n\t * zero, as that is the only time it matters) they will also see our\n\t * critical section.\n\t */\n\t__this_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to recheck readers_active */\n\trcuwait_wake_up(&sem->writer);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid __percpu_up_read(struct percpu_rw_semaphore *sem)\n{\n\tsmp_mb(); /* B matches C */\n\t/*\n\t * In other words, if they see our decrement (presumably to aggregate\n\t * zero, as that is the only time it matters) they will also see our\n\t * critical section.\n\t */\n\t__this_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to recheck readers_active */\n\trcuwait_wake_up(&sem->writer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_rwsem"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DECLARE_RWSEM(torture_rwsem);\n\nstatic void torture_rwsem_up_read(void) __releases(torture_rwsem)\n{\n\tup_read(&torture_rwsem);\n}"
  },
  {
    "function_name": "torture_rwsem_read_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "556-568",
    "snippet": "static void torture_rwsem_read_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a long delay occasionally to force massive contention.  */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealreaders_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms * 2);\n\telse\n\t\tmdelay(longdelay_ms / 2);\n\tif (!(torture_random(trsp) % (cxt.nrealreaders_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_preempt_schedule",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "302-312",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms / 2"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms * 2"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void torture_rwsem_read_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a long delay occasionally to force massive contention.  */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealreaders_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms * 2);\n\telse\n\t\tmdelay(longdelay_ms / 2);\n\tif (!(torture_random(trsp) % (cxt.nrealreaders_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}"
  },
  {
    "function_name": "torture_rwsem_down_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "550-554",
    "snippet": "static int torture_rwsem_down_read(void) __acquires(torture_rwsem)\n{\n\tdown_read(&torture_rwsem);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(torture_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&torture_rwsem"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "down_read_non_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem.c",
          "lines": "180-186",
          "snippet": "void down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}",
          "includes": [
            "#include \"rwsem.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwsem.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_rwsem"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DECLARE_RWSEM(torture_rwsem);\n\nstatic int torture_rwsem_down_read(void) __acquires(torture_rwsem)\n{\n\tdown_read(&torture_rwsem);\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_rwsem_up_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "545-548",
    "snippet": "static void torture_rwsem_up_write(void) __releases(torture_rwsem)\n{\n\tup_write(&torture_rwsem);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(torture_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&torture_rwsem"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_rwsem"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DECLARE_RWSEM(torture_rwsem);\n\nstatic void torture_rwsem_up_write(void) __releases(torture_rwsem)\n{\n\tup_write(&torture_rwsem);\n}"
  },
  {
    "function_name": "torture_rwsem_write_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "531-543",
    "snippet": "static void torture_rwsem_write_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a long delay occasionally to force massive contention.  */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms * 10);\n\telse\n\t\tmdelay(longdelay_ms / 10);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_preempt_schedule",
          "args": [],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "302-312",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms / 10"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms * 10"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void torture_rwsem_write_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a long delay occasionally to force massive contention.  */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms * 10);\n\telse\n\t\tmdelay(longdelay_ms / 10);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}"
  },
  {
    "function_name": "torture_rwsem_down_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "525-529",
    "snippet": "static int torture_rwsem_down_write(void) __acquires(torture_rwsem)\n{\n\tdown_write(&torture_rwsem);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(torture_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&torture_rwsem"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_rwsem"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DECLARE_RWSEM(torture_rwsem);\n\nstatic int torture_rwsem_down_write(void) __acquires(torture_rwsem)\n{\n\tdown_write(&torture_rwsem);\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_rtmutex_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "507-510",
    "snippet": "static void torture_rtmutex_unlock(void) __releases(torture_rtmutex)\n{\n\trt_mutex_unlock(&torture_rtmutex);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rt_mutex_unlock",
          "args": [
            "&torture_rtmutex"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_rtmutex"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void torture_rtmutex_unlock(void) __releases(torture_rtmutex)\n{\n\trt_mutex_unlock(&torture_rtmutex);\n}"
  },
  {
    "function_name": "torture_rtmutex_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "488-505",
    "snippet": "static void torture_rtmutex_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long shortdelay_us = 2;\n\tconst unsigned long longdelay_ms = 100;\n\n\t/*\n\t * We want a short delay mostly to emulate likely code, and\n\t * we want a long delay occasionally to force massive contention.\n\t */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2 * shortdelay_us)))\n\t\tudelay(shortdelay_us);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_preempt_schedule",
          "args": [],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "302-312",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "shortdelay_us"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void torture_rtmutex_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long shortdelay_us = 2;\n\tconst unsigned long longdelay_ms = 100;\n\n\t/*\n\t * We want a short delay mostly to emulate likely code, and\n\t * we want a long delay occasionally to force massive contention.\n\t */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2 * shortdelay_us)))\n\t\tudelay(shortdelay_us);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}"
  },
  {
    "function_name": "torture_rtmutex_boost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "451-486",
    "snippet": "static void torture_rtmutex_boost(struct torture_random_state *trsp)\n{\n\tint policy;\n\tstruct sched_param param;\n\tconst unsigned int factor = 50000; /* yes, quite arbitrary */\n\n\tif (!rt_task(current)) {\n\t\t/*\n\t\t * Boost priority once every ~50k operations. When the\n\t\t * task tries to take the lock, the rtmutex it will account\n\t\t * for the new priority, and do any corresponding pi-dance.\n\t\t */\n\t\tif (trsp && !(torture_random(trsp) %\n\t\t\t      (cxt.nrealwriters_stress * factor))) {\n\t\t\tpolicy = SCHED_FIFO;\n\t\t\tparam.sched_priority = MAX_RT_PRIO - 1;\n\t\t} else /* common case, do nothing */\n\t\t\treturn;\n\t} else {\n\t\t/*\n\t\t * The task will remain boosted for another ~500k operations,\n\t\t * then restored back to its original prio, and so forth.\n\t\t *\n\t\t * When @trsp is nil, we want to force-reset the task for\n\t\t * stopping the kthread.\n\t\t */\n\t\tif (!trsp || !(torture_random(trsp) %\n\t\t\t       (cxt.nrealwriters_stress * factor * 2))) {\n\t\t\tpolicy = SCHED_NORMAL;\n\t\t\tparam.sched_priority = 0;\n\t\t} else /* common case, do nothing */\n\t\t\treturn;\n\t}\n\n\tsched_setscheduler_nocheck(current, policy, &param);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_setscheduler_nocheck",
          "args": [
            "current",
            "policy",
            "&param"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "sched_setscheduler_nocheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4416-4420",
          "snippet": "int sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "302-312",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_task",
          "args": [
            "current"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "tg_has_rt_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/rt.c",
          "lines": "2416-2432",
          "snippet": "static inline int tg_has_rt_tasks(struct task_group *tg)\n{\n\tstruct task_struct *g, *p;\n\n\t/*\n\t * Autogroups do not have RT tasks; see autogroup_create().\n\t */\n\tif (task_group_is_autogroup(tg))\n\t\treturn 0;\n\n\tfor_each_process_thread(g, p) {\n\t\tif (rt_task(p) && task_group(p) == tg)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int tg_has_rt_tasks(struct task_group *tg)\n{\n\tstruct task_struct *g, *p;\n\n\t/*\n\t * Autogroups do not have RT tasks; see autogroup_create().\n\t */\n\tif (task_group_is_autogroup(tg))\n\t\treturn 0;\n\n\tfor_each_process_thread(g, p) {\n\t\tif (rt_task(p) && task_group(p) == tg)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void torture_rtmutex_boost(struct torture_random_state *trsp)\n{\n\tint policy;\n\tstruct sched_param param;\n\tconst unsigned int factor = 50000; /* yes, quite arbitrary */\n\n\tif (!rt_task(current)) {\n\t\t/*\n\t\t * Boost priority once every ~50k operations. When the\n\t\t * task tries to take the lock, the rtmutex it will account\n\t\t * for the new priority, and do any corresponding pi-dance.\n\t\t */\n\t\tif (trsp && !(torture_random(trsp) %\n\t\t\t      (cxt.nrealwriters_stress * factor))) {\n\t\t\tpolicy = SCHED_FIFO;\n\t\t\tparam.sched_priority = MAX_RT_PRIO - 1;\n\t\t} else /* common case, do nothing */\n\t\t\treturn;\n\t} else {\n\t\t/*\n\t\t * The task will remain boosted for another ~500k operations,\n\t\t * then restored back to its original prio, and so forth.\n\t\t *\n\t\t * When @trsp is nil, we want to force-reset the task for\n\t\t * stopping the kthread.\n\t\t */\n\t\tif (!trsp || !(torture_random(trsp) %\n\t\t\t       (cxt.nrealwriters_stress * factor * 2))) {\n\t\t\tpolicy = SCHED_NORMAL;\n\t\t\tparam.sched_priority = 0;\n\t\t} else /* common case, do nothing */\n\t\t\treturn;\n\t}\n\n\tsched_setscheduler_nocheck(current, policy, &param);\n}"
  },
  {
    "function_name": "torture_rtmutex_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "445-449",
    "snippet": "static int torture_rtmutex_lock(void) __acquires(torture_rtmutex)\n{\n\trt_mutex_lock(&torture_rtmutex);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rt_mutex_lock",
          "args": [
            "&torture_rtmutex"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_rtmutex"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int torture_rtmutex_lock(void) __acquires(torture_rtmutex)\n{\n\trt_mutex_lock(&torture_rtmutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_ww_mutex_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "421-429",
    "snippet": "static void torture_ww_mutex_unlock(void)\n__releases(torture_ww_mutex_0)\n__releases(torture_ww_mutex_1)\n__releases(torture_ww_mutex_2)\n{\n\tww_mutex_unlock(&torture_ww_mutex_0);\n\tww_mutex_unlock(&torture_ww_mutex_1);\n\tww_mutex_unlock(&torture_ww_mutex_2);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "&torture_ww_mutex_2"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "728-744",
          "snippet": "void __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nvoid __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_ww_mutex_2"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_ww_mutex_1"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_ww_mutex_0"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void torture_ww_mutex_unlock(void)\n__releases(torture_ww_mutex_0)\n__releases(torture_ww_mutex_1)\n__releases(torture_ww_mutex_2)\n{\n\tww_mutex_unlock(&torture_ww_mutex_0);\n\tww_mutex_unlock(&torture_ww_mutex_1);\n\tww_mutex_unlock(&torture_ww_mutex_2);\n}"
  },
  {
    "function_name": "torture_ww_mutex_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "376-419",
    "snippet": "static int torture_ww_mutex_lock(void)\n__acquires(torture_ww_mutex_0)\n__acquires(torture_ww_mutex_1)\n__acquires(torture_ww_mutex_2)\n{\n\tLIST_HEAD(list);\n\tstruct reorder_lock {\n\t\tstruct list_head link;\n\t\tstruct ww_mutex *lock;\n\t} locks[3], *ll, *ln;\n\tstruct ww_acquire_ctx ctx;\n\n\tlocks[0].lock = &torture_ww_mutex_0;\n\tlist_add(&locks[0].link, &list);\n\n\tlocks[1].lock = &torture_ww_mutex_1;\n\tlist_add(&locks[1].link, &list);\n\n\tlocks[2].lock = &torture_ww_mutex_2;\n\tlist_add(&locks[2].link, &list);\n\n\tww_acquire_init(&ctx, &torture_ww_class);\n\n\tlist_for_each_entry(ll, &list, link) {\n\t\tint err;\n\n\t\terr = ww_mutex_lock(ll->lock, &ctx);\n\t\tif (!err)\n\t\t\tcontinue;\n\n\t\tln = ll;\n\t\tlist_for_each_entry_continue_reverse(ln, &list, link)\n\t\t\tww_mutex_unlock(ln->lock);\n\n\t\tif (err != -EDEADLK)\n\t\t\treturn err;\n\n\t\tww_mutex_lock_slow(ll->lock, &ctx);\n\t\tlist_move(&ll->link, &list);\n\t}\n\n\tww_acquire_fini(&ctx);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_WD_CLASS(torture_ww_class);",
      "static DEFINE_WW_MUTEX(torture_ww_mutex_0, &torture_ww_class);",
      "static DEFINE_WW_MUTEX(torture_ww_mutex_1, &torture_ww_class);",
      "static DEFINE_WW_MUTEX(torture_ww_mutex_2, &torture_ww_class);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ww_acquire_fini",
          "args": [
            "&ctx"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&ll->link",
            "&list"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock_slow",
          "args": [
            "ll->lock",
            "&ctx"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_lock_slowpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1348-1353",
          "snippet": "__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0, NULL,\n\t\t\t       _RET_IP_, ctx);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\n__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0, NULL,\n\t\t\t       _RET_IP_, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "ln->lock"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "728-744",
          "snippet": "void __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nvoid __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue_reverse",
          "args": [
            "ln",
            "&list",
            "link"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "ll->lock",
            "&ctx"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1406-1418",
          "snippet": "int __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nint __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ll",
            "&list",
            "link"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_acquire_init",
          "args": [
            "&ctx",
            "&torture_ww_class"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&locks[2].link",
            "&list"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_ww_mutex_2"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_ww_mutex_1"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_ww_mutex_0"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(torture_ww_class);\nstatic DEFINE_WW_MUTEX(torture_ww_mutex_0, &torture_ww_class);\nstatic DEFINE_WW_MUTEX(torture_ww_mutex_1, &torture_ww_class);\nstatic DEFINE_WW_MUTEX(torture_ww_mutex_2, &torture_ww_class);\n\nstatic int torture_ww_mutex_lock(void)\n__acquires(torture_ww_mutex_0)\n__acquires(torture_ww_mutex_1)\n__acquires(torture_ww_mutex_2)\n{\n\tLIST_HEAD(list);\n\tstruct reorder_lock {\n\t\tstruct list_head link;\n\t\tstruct ww_mutex *lock;\n\t} locks[3], *ll, *ln;\n\tstruct ww_acquire_ctx ctx;\n\n\tlocks[0].lock = &torture_ww_mutex_0;\n\tlist_add(&locks[0].link, &list);\n\n\tlocks[1].lock = &torture_ww_mutex_1;\n\tlist_add(&locks[1].link, &list);\n\n\tlocks[2].lock = &torture_ww_mutex_2;\n\tlist_add(&locks[2].link, &list);\n\n\tww_acquire_init(&ctx, &torture_ww_class);\n\n\tlist_for_each_entry(ll, &list, link) {\n\t\tint err;\n\n\t\terr = ww_mutex_lock(ll->lock, &ctx);\n\t\tif (!err)\n\t\t\tcontinue;\n\n\t\tln = ll;\n\t\tlist_for_each_entry_continue_reverse(ln, &list, link)\n\t\t\tww_mutex_unlock(ln->lock);\n\n\t\tif (err != -EDEADLK)\n\t\t\treturn err;\n\n\t\tww_mutex_lock_slow(ll->lock, &ctx);\n\t\tlist_move(&ll->link, &list);\n\t}\n\n\tww_acquire_fini(&ctx);\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_mutex_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "354-357",
    "snippet": "static void torture_mutex_unlock(void) __releases(torture_mutex)\n{\n\tmutex_unlock(&torture_mutex);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(torture_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&torture_mutex"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_mutex"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(torture_mutex);\n\nstatic void torture_mutex_unlock(void) __releases(torture_mutex)\n{\n\tmutex_unlock(&torture_mutex);\n}"
  },
  {
    "function_name": "torture_mutex_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "340-352",
    "snippet": "static void torture_mutex_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a long delay occasionally to force massive contention.  */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms * 5);\n\telse\n\t\tmdelay(longdelay_ms / 5);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_preempt_schedule",
          "args": [],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "302-312",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms / 5"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms * 5"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void torture_mutex_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a long delay occasionally to force massive contention.  */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms * 5);\n\telse\n\t\tmdelay(longdelay_ms / 5);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}"
  },
  {
    "function_name": "torture_mutex_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "334-338",
    "snippet": "static int torture_mutex_lock(void) __acquires(torture_mutex)\n{\n\tmutex_lock(&torture_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(torture_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&torture_mutex"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_mutex"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(torture_mutex);\n\nstatic int torture_mutex_lock(void) __acquires(torture_mutex)\n{\n\tmutex_lock(&torture_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_rwlock_read_unlock_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "315-319",
    "snippet": "static void torture_rwlock_read_unlock_irq(void)\n__releases(torture_rwlock)\n{\n\tread_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
      "static DEFINE_RWLOCK(torture_rwlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&torture_rwlock",
            "cxt.cur_ops->flags"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_read_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "254-257",
          "snippet": "void __lockfunc _raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_read_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_read_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_rwlock"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic void torture_rwlock_read_unlock_irq(void)\n__releases(torture_rwlock)\n{\n\tread_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);\n}"
  },
  {
    "function_name": "torture_rwlock_read_lock_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "306-313",
    "snippet": "static int torture_rwlock_read_lock_irq(void) __acquires(torture_rwlock)\n{\n\tunsigned long flags;\n\n\tread_lock_irqsave(&torture_rwlock, flags);\n\tcxt.cur_ops->flags = flags;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
      "static DEFINE_RWLOCK(torture_rwlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&torture_rwlock",
            "flags"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_rwlock"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic int torture_rwlock_read_lock_irq(void) __acquires(torture_rwlock)\n{\n\tunsigned long flags;\n\n\tread_lock_irqsave(&torture_rwlock, flags);\n\tcxt.cur_ops->flags = flags;\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_rwlock_write_unlock_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "300-304",
    "snippet": "static void torture_rwlock_write_unlock_irq(void)\n__releases(torture_rwlock)\n{\n\twrite_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
      "static DEFINE_RWLOCK(torture_rwlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&torture_rwlock",
            "cxt.cur_ops->flags"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "326-329",
          "snippet": "void __lockfunc _raw_write_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_write_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_write_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_rwlock"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic void torture_rwlock_write_unlock_irq(void)\n__releases(torture_rwlock)\n{\n\twrite_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);\n}"
  },
  {
    "function_name": "torture_rwlock_write_lock_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "291-298",
    "snippet": "static int torture_rwlock_write_lock_irq(void) __acquires(torture_rwlock)\n{\n\tunsigned long flags;\n\n\twrite_lock_irqsave(&torture_rwlock, flags);\n\tcxt.cur_ops->flags = flags;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
      "static DEFINE_RWLOCK(torture_rwlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&torture_rwlock",
            "flags"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_rwlock"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic int torture_rwlock_write_lock_irq(void) __acquires(torture_rwlock)\n{\n\tunsigned long flags;\n\n\twrite_lock_irqsave(&torture_rwlock, flags);\n\tcxt.cur_ops->flags = flags;\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_rwlock_read_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "275-278",
    "snippet": "static void torture_rwlock_read_unlock(void) __releases(torture_rwlock)\n{\n\tread_unlock(&torture_rwlock);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(torture_rwlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&torture_rwlock"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_read_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "270-273",
          "snippet": "void __lockfunc _raw_read_unlock_bh(rwlock_t *lock)\n{\n\t__raw_read_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_read_unlock_bh(rwlock_t *lock)\n{\n\t__raw_read_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_rwlock"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic void torture_rwlock_read_unlock(void) __releases(torture_rwlock)\n{\n\tread_unlock(&torture_rwlock);\n}"
  },
  {
    "function_name": "torture_rwlock_read_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "260-273",
    "snippet": "static void torture_rwlock_read_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long shortdelay_us = 10;\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a short delay mostly to emulate likely code, and\n\t * we want a long delay occasionally to force massive contention.\n\t */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealreaders_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\telse\n\t\tudelay(shortdelay_us);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "shortdelay_us"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "302-312",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void torture_rwlock_read_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long shortdelay_us = 10;\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a short delay mostly to emulate likely code, and\n\t * we want a long delay occasionally to force massive contention.\n\t */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealreaders_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\telse\n\t\tudelay(shortdelay_us);\n}"
  },
  {
    "function_name": "torture_rwlock_read_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "254-258",
    "snippet": "static int torture_rwlock_read_lock(void) __acquires(torture_rwlock)\n{\n\tread_lock(&torture_rwlock);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(torture_rwlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&torture_rwlock"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_read_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "238-241",
          "snippet": "void __lockfunc _raw_read_lock_bh(rwlock_t *lock)\n{\n\t__raw_read_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_read_lock_bh(rwlock_t *lock)\n{\n\t__raw_read_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_rwlock"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic int torture_rwlock_read_lock(void) __acquires(torture_rwlock)\n{\n\tread_lock(&torture_rwlock);\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_rwlock_write_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "249-252",
    "snippet": "static void torture_rwlock_write_unlock(void) __releases(torture_rwlock)\n{\n\twrite_unlock(&torture_rwlock);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(torture_rwlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&torture_rwlock"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "342-345",
          "snippet": "void __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_bh(rwlock_t *lock)\n{\n\t__raw_write_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_rwlock"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic void torture_rwlock_write_unlock(void) __releases(torture_rwlock)\n{\n\twrite_unlock(&torture_rwlock);\n}"
  },
  {
    "function_name": "torture_rwlock_write_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "234-247",
    "snippet": "static void torture_rwlock_write_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long shortdelay_us = 2;\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a short delay mostly to emulate likely code, and\n\t * we want a long delay occasionally to force massive contention.\n\t */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\telse\n\t\tudelay(shortdelay_us);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "shortdelay_us"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "302-312",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void torture_rwlock_write_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long shortdelay_us = 2;\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a short delay mostly to emulate likely code, and\n\t * we want a long delay occasionally to force massive contention.\n\t */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\telse\n\t\tudelay(shortdelay_us);\n}"
  },
  {
    "function_name": "torture_rwlock_write_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "228-232",
    "snippet": "static int torture_rwlock_write_lock(void) __acquires(torture_rwlock)\n{\n\twrite_lock(&torture_rwlock);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(torture_rwlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&torture_rwlock"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "310-313",
          "snippet": "void __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_lock_bh(rwlock_t *lock)\n{\n\t__raw_write_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_rwlock"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic int torture_rwlock_write_lock(void) __acquires(torture_rwlock)\n{\n\twrite_lock(&torture_rwlock);\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_lock_spin_write_unlock_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "209-213",
    "snippet": "static void torture_lock_spin_write_unlock_irq(void)\n__releases(torture_spinlock)\n{\n\tspin_unlock_irqrestore(&torture_spinlock, cxt.cur_ops->flags);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
      "static DEFINE_SPINLOCK(torture_spinlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&torture_spinlock",
            "cxt.cur_ops->flags"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_spinlock"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic DEFINE_SPINLOCK(torture_spinlock);\n\nstatic void torture_lock_spin_write_unlock_irq(void)\n__releases(torture_spinlock)\n{\n\tspin_unlock_irqrestore(&torture_spinlock, cxt.cur_ops->flags);\n}"
  },
  {
    "function_name": "torture_spin_lock_write_lock_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "199-207",
    "snippet": "static int torture_spin_lock_write_lock_irq(void)\n__acquires(torture_spinlock)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&torture_spinlock, flags);\n\tcxt.cur_ops->flags = flags;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
      "static DEFINE_SPINLOCK(torture_spinlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&torture_spinlock",
            "flags"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_spinlock"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic DEFINE_SPINLOCK(torture_spinlock);\n\nstatic int torture_spin_lock_write_lock_irq(void)\n__acquires(torture_spinlock)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&torture_spinlock, flags);\n\tcxt.cur_ops->flags = flags;\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_spin_lock_write_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "183-186",
    "snippet": "static void torture_spin_lock_write_unlock(void) __releases(torture_spinlock)\n{\n\tspin_unlock(&torture_spinlock);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(torture_spinlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&torture_spinlock"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_spinlock"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(torture_spinlock);\n\nstatic void torture_spin_lock_write_unlock(void) __releases(torture_spinlock)\n{\n\tspin_unlock(&torture_spinlock);\n}"
  },
  {
    "function_name": "torture_spin_lock_write_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "165-181",
    "snippet": "static void torture_spin_lock_write_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long shortdelay_us = 2;\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a short delay mostly to emulate likely code, and\n\t * we want a long delay occasionally to force massive contention.\n\t */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2 * shortdelay_us)))\n\t\tudelay(shortdelay_us);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_preempt_schedule",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "302-312",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "shortdelay_us"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void torture_spin_lock_write_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long shortdelay_us = 2;\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a short delay mostly to emulate likely code, and\n\t * we want a long delay occasionally to force massive contention.\n\t */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2 * shortdelay_us)))\n\t\tudelay(shortdelay_us);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}"
  },
  {
    "function_name": "torture_spin_lock_write_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "159-163",
    "snippet": "static int torture_spin_lock_write_lock(void) __acquires(torture_spinlock)\n{\n\tspin_lock(&torture_spinlock);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(torture_spinlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&torture_spinlock"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "torture_spin_lock_write_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
          "lines": "165-181",
          "snippet": "static void torture_spin_lock_write_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long shortdelay_us = 2;\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a short delay mostly to emulate likely code, and\n\t * we want a long delay occasionally to force massive contention.\n\t */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2 * shortdelay_us)))\n\t\tudelay(shortdelay_us);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/torture.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rwlock.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void torture_spin_lock_write_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long shortdelay_us = 2;\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a short delay mostly to emulate likely code, and\n\t * we want a long delay occasionally to force massive contention.\n\t */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2 * shortdelay_us)))\n\t\tudelay(shortdelay_us);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_spinlock"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(torture_spinlock);\n\nstatic int torture_spin_lock_write_lock(void) __acquires(torture_spinlock)\n{\n\tspin_lock(&torture_spinlock);\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_boost_dummy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "141-144",
    "snippet": "static void torture_boost_dummy(struct torture_random_state *trsp)\n{\n\t/* Only rtmutexes care about priority */\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void torture_boost_dummy(struct torture_random_state *trsp)\n{\n\t/* Only rtmutexes care about priority */\n}"
  },
  {
    "function_name": "torture_lock_busted_write_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "136-139",
    "snippet": "static void torture_lock_busted_write_unlock(void)\n{\n\t  /* BUGGY, do not use in real life!!! */\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void torture_lock_busted_write_unlock(void)\n{\n\t  /* BUGGY, do not use in real life!!! */\n}"
  },
  {
    "function_name": "torture_lock_busted_write_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "124-134",
    "snippet": "static void torture_lock_busted_write_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a long delay occasionally to force massive contention.  */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_preempt_schedule",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "302-312",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void torture_lock_busted_write_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a long delay occasionally to force massive contention.  */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}"
  },
  {
    "function_name": "torture_lock_busted_write_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/locktorture.c",
    "lines": "119-122",
    "snippet": "static int torture_lock_busted_write_lock(void)\n{\n\treturn 0;  /* BUGGY, do not use in real life!!! */\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/torture.h>",
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/rwlock.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/torture.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/rwlock.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int torture_lock_busted_write_lock(void)\n{\n\treturn 0;  /* BUGGY, do not use in real life!!! */\n}"
  }
]