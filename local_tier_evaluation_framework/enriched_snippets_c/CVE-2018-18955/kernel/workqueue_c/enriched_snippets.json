[
  {
    "function_name": "workqueue_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5767-5816",
    "snippet": "int __init workqueue_init(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct worker_pool *pool;\n\tint cpu, bkt;\n\n\t/*\n\t * It'd be simpler to initialize NUMA in workqueue_init_early() but\n\t * CPU to node mapping may not be available that early on some\n\t * archs such as power and arm64.  As per-cpu pools created\n\t * previously could be missing node hint and unbound pools NUMA\n\t * affinity, fix them up.\n\t *\n\t * Also, while iterating workqueues, create rescuers if requested.\n\t */\n\twq_numa_init();\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\t\tpool->node = cpu_to_node(cpu);\n\t\t}\n\t}\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\twq_update_unbound_numa(wq, smp_processor_id(), true);\n\t\tWARN(init_rescuer(wq),\n\t\t     \"workqueue: failed to create early rescuer for %s\",\n\t\t     wq->name);\n\t}\n\n\tmutex_unlock(&wq_pool_mutex);\n\n\t/* create the initial workers */\n\tfor_each_online_cpu(cpu) {\n\t\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\t\tpool->flags &= ~POOL_DISASSOCIATED;\n\t\t\tBUG_ON(!create_worker(pool));\n\t\t}\n\t}\n\n\thash_for_each(unbound_pool_hash, bkt, pool, hash_node)\n\t\tBUG_ON(!create_worker(pool));\n\n\twq_online = true;\n\twq_watchdog_init();\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool wq_online;",
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static LIST_HEAD(workqueues);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wq_watchdog_init",
          "args": [],
          "line": 5813
        },
        "resolved": true,
        "details": {
          "function_name": "wq_watchdog_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5631-5631",
          "snippet": "static inline void wq_watchdog_init(void) { }",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void wq_watchdog_init(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!create_worker(pool)"
          ],
          "line": 5810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_worker",
          "args": [
            "pool"
          ],
          "line": 5810
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_create_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1961-1990",
          "snippet": "static void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\tspin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\tspin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\tspin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\tspin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_for_each",
          "args": [
            "unbound_pool_hash",
            "bkt",
            "pool",
            "hash_node"
          ],
          "line": 5809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!create_worker(pool)"
          ],
          "line": 5805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu_worker_pool",
          "args": [
            "pool",
            "cpu"
          ],
          "line": 5803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5799
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "init_rescuer(wq)",
            "\"workqueue: failed to create early rescuer for %s\"",
            "wq->name"
          ],
          "line": 5794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rescuer",
          "args": [
            "wq"
          ],
          "line": 5794
        },
        "resolved": true,
        "details": {
          "function_name": "init_rescuer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4020-4045",
          "snippet": "static int init_rescuer(struct workqueue_struct *wq)\n{\n\tstruct worker *rescuer;\n\tint ret;\n\n\tif (!(wq->flags & WQ_MEM_RECLAIM))\n\t\treturn 0;\n\n\trescuer = alloc_worker(NUMA_NO_NODE);\n\tif (!rescuer)\n\t\treturn -ENOMEM;\n\n\trescuer->rescue_wq = wq;\n\trescuer->task = kthread_create(rescuer_thread, rescuer, \"%s\", wq->name);\n\tret = PTR_ERR_OR_ZERO(rescuer->task);\n\tif (ret) {\n\t\tkfree(rescuer);\n\t\treturn ret;\n\t}\n\n\twq->rescuer = rescuer;\n\tkthread_bind_mask(rescuer->task, cpu_possible_mask);\n\twake_up_process(rescuer->task);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int init_rescuer(struct workqueue_struct *wq)\n{\n\tstruct worker *rescuer;\n\tint ret;\n\n\tif (!(wq->flags & WQ_MEM_RECLAIM))\n\t\treturn 0;\n\n\trescuer = alloc_worker(NUMA_NO_NODE);\n\tif (!rescuer)\n\t\treturn -ENOMEM;\n\n\trescuer->rescue_wq = wq;\n\trescuer->task = kthread_create(rescuer_thread, rescuer, \"%s\", wq->name);\n\tret = PTR_ERR_OR_ZERO(rescuer->task);\n\tif (ret) {\n\t\tkfree(rescuer);\n\t\treturn ret;\n\t}\n\n\twq->rescuer = rescuer;\n\tkthread_bind_mask(rescuer->task, cpu_possible_mask);\n\twake_up_process(rescuer->task);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_update_unbound_numa",
          "args": [
            "wq",
            "smp_processor_id()",
            "true"
          ],
          "line": 5793
        },
        "resolved": true,
        "details": {
          "function_name": "wq_update_unbound_numa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3906-3967",
          "snippet": "static void wq_update_unbound_numa(struct workqueue_struct *wq, int cpu,\n\t\t\t\t   bool online)\n{\n\tint node = cpu_to_node(cpu);\n\tint cpu_off = online ? -1 : cpu;\n\tstruct pool_workqueue *old_pwq = NULL, *pwq;\n\tstruct workqueue_attrs *target_attrs;\n\tcpumask_t *cpumask;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (!wq_numa_enabled || !(wq->flags & WQ_UNBOUND) ||\n\t    wq->unbound_attrs->no_numa)\n\t\treturn;\n\n\t/*\n\t * We don't wanna alloc/free wq_attrs for each wq for each CPU.\n\t * Let's use a preallocated one.  The following buf is protected by\n\t * CPU hotplug exclusion.\n\t */\n\ttarget_attrs = wq_update_unbound_numa_attrs_buf;\n\tcpumask = target_attrs->cpumask;\n\n\tcopy_workqueue_attrs(target_attrs, wq->unbound_attrs);\n\tpwq = unbound_pwq_by_node(wq, node);\n\n\t/*\n\t * Let's determine what needs to be done.  If the target cpumask is\n\t * different from the default pwq's, we need to compare it to @pwq's\n\t * and create a new one if they don't match.  If the target cpumask\n\t * equals the default pwq's, the default pwq should be used.\n\t */\n\tif (wq_calc_node_cpumask(wq->dfl_pwq->pool->attrs, node, cpu_off, cpumask)) {\n\t\tif (cpumask_equal(cpumask, pwq->pool->attrs->cpumask))\n\t\t\treturn;\n\t} else {\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* create a new pwq */\n\tpwq = alloc_unbound_pwq(wq, target_attrs);\n\tif (!pwq) {\n\t\tpr_warn(\"workqueue: allocation failed while updating NUMA affinity of \\\"%s\\\"\\n\",\n\t\t\twq->name);\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* Install the new pwq. */\n\tmutex_lock(&wq->mutex);\n\told_pwq = numa_pwq_tbl_install(wq, node, pwq);\n\tgoto out_unlock;\n\nuse_dfl_pwq:\n\tmutex_lock(&wq->mutex);\n\tspin_lock_irq(&wq->dfl_pwq->pool->lock);\n\tget_pwq(wq->dfl_pwq);\n\tspin_unlock_irq(&wq->dfl_pwq->pool->lock);\n\told_pwq = numa_pwq_tbl_install(wq, node, wq->dfl_pwq);\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n\tput_pwq_unlocked(old_pwq);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_numa_enabled;",
            "static struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;",
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_numa_enabled;\nstatic struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void wq_update_unbound_numa(struct workqueue_struct *wq, int cpu,\n\t\t\t\t   bool online)\n{\n\tint node = cpu_to_node(cpu);\n\tint cpu_off = online ? -1 : cpu;\n\tstruct pool_workqueue *old_pwq = NULL, *pwq;\n\tstruct workqueue_attrs *target_attrs;\n\tcpumask_t *cpumask;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (!wq_numa_enabled || !(wq->flags & WQ_UNBOUND) ||\n\t    wq->unbound_attrs->no_numa)\n\t\treturn;\n\n\t/*\n\t * We don't wanna alloc/free wq_attrs for each wq for each CPU.\n\t * Let's use a preallocated one.  The following buf is protected by\n\t * CPU hotplug exclusion.\n\t */\n\ttarget_attrs = wq_update_unbound_numa_attrs_buf;\n\tcpumask = target_attrs->cpumask;\n\n\tcopy_workqueue_attrs(target_attrs, wq->unbound_attrs);\n\tpwq = unbound_pwq_by_node(wq, node);\n\n\t/*\n\t * Let's determine what needs to be done.  If the target cpumask is\n\t * different from the default pwq's, we need to compare it to @pwq's\n\t * and create a new one if they don't match.  If the target cpumask\n\t * equals the default pwq's, the default pwq should be used.\n\t */\n\tif (wq_calc_node_cpumask(wq->dfl_pwq->pool->attrs, node, cpu_off, cpumask)) {\n\t\tif (cpumask_equal(cpumask, pwq->pool->attrs->cpumask))\n\t\t\treturn;\n\t} else {\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* create a new pwq */\n\tpwq = alloc_unbound_pwq(wq, target_attrs);\n\tif (!pwq) {\n\t\tpr_warn(\"workqueue: allocation failed while updating NUMA affinity of \\\"%s\\\"\\n\",\n\t\t\twq->name);\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* Install the new pwq. */\n\tmutex_lock(&wq->mutex);\n\told_pwq = numa_pwq_tbl_install(wq, node, pwq);\n\tgoto out_unlock;\n\nuse_dfl_pwq:\n\tmutex_lock(&wq->mutex);\n\tspin_lock_irq(&wq->dfl_pwq->pool->lock);\n\tget_pwq(wq->dfl_pwq);\n\tspin_unlock_irq(&wq->dfl_pwq->pool->lock);\n\told_pwq = numa_pwq_tbl_install(wq, node, wq->dfl_pwq);\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n\tput_pwq_unlocked(old_pwq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 5793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "wq",
            "&workqueues",
            "list"
          ],
          "line": 5792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 5788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu_worker_pool",
          "args": [
            "pool",
            "cpu"
          ],
          "line": 5787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5784
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_numa_init",
          "args": [],
          "line": 5782
        },
        "resolved": true,
        "details": {
          "function_name": "wq_numa_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5635-5675",
          "snippet": "static void __init wq_numa_init(void)\n{\n\tcpumask_var_t *tbl;\n\tint node, cpu;\n\n\tif (num_possible_nodes() <= 1)\n\t\treturn;\n\n\tif (wq_disable_numa) {\n\t\tpr_info(\"workqueue: NUMA affinity support disabled\\n\");\n\t\treturn;\n\t}\n\n\twq_update_unbound_numa_attrs_buf = alloc_workqueue_attrs(GFP_KERNEL);\n\tBUG_ON(!wq_update_unbound_numa_attrs_buf);\n\n\t/*\n\t * We want masks of possible CPUs of each node which isn't readily\n\t * available.  Build one from cpu_to_node() which should have been\n\t * fully initialized by now.\n\t */\n\ttbl = kcalloc(nr_node_ids, sizeof(tbl[0]), GFP_KERNEL);\n\tBUG_ON(!tbl);\n\n\tfor_each_node(node)\n\t\tBUG_ON(!zalloc_cpumask_var_node(&tbl[node], GFP_KERNEL,\n\t\t\t\tnode_online(node) ? node : NUMA_NO_NODE));\n\n\tfor_each_possible_cpu(cpu) {\n\t\tnode = cpu_to_node(cpu);\n\t\tif (WARN_ON(node == NUMA_NO_NODE)) {\n\t\t\tpr_warn(\"workqueue: NUMA node mapping not available for cpu%d, disabling NUMA support\\n\", cpu);\n\t\t\t/* happens iff arch is bonkers, let's just proceed */\n\t\t\treturn;\n\t\t}\n\t\tcpumask_set_cpu(cpu, tbl[node]);\n\t}\n\n\twq_numa_possible_cpumask = tbl;\n\twq_numa_enabled = true;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t *wq_numa_possible_cpumask;",
            "static bool wq_disable_numa;",
            "static bool wq_numa_enabled;",
            "static struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t *wq_numa_possible_cpumask;\nstatic bool wq_disable_numa;\nstatic bool wq_numa_enabled;\nstatic struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;\n\nstatic void __init wq_numa_init(void)\n{\n\tcpumask_var_t *tbl;\n\tint node, cpu;\n\n\tif (num_possible_nodes() <= 1)\n\t\treturn;\n\n\tif (wq_disable_numa) {\n\t\tpr_info(\"workqueue: NUMA affinity support disabled\\n\");\n\t\treturn;\n\t}\n\n\twq_update_unbound_numa_attrs_buf = alloc_workqueue_attrs(GFP_KERNEL);\n\tBUG_ON(!wq_update_unbound_numa_attrs_buf);\n\n\t/*\n\t * We want masks of possible CPUs of each node which isn't readily\n\t * available.  Build one from cpu_to_node() which should have been\n\t * fully initialized by now.\n\t */\n\ttbl = kcalloc(nr_node_ids, sizeof(tbl[0]), GFP_KERNEL);\n\tBUG_ON(!tbl);\n\n\tfor_each_node(node)\n\t\tBUG_ON(!zalloc_cpumask_var_node(&tbl[node], GFP_KERNEL,\n\t\t\t\tnode_online(node) ? node : NUMA_NO_NODE));\n\n\tfor_each_possible_cpu(cpu) {\n\t\tnode = cpu_to_node(cpu);\n\t\tif (WARN_ON(node == NUMA_NO_NODE)) {\n\t\t\tpr_warn(\"workqueue: NUMA node mapping not available for cpu%d, disabling NUMA support\\n\", cpu);\n\t\t\t/* happens iff arch is bonkers, let's just proceed */\n\t\t\treturn;\n\t\t}\n\t\tcpumask_set_cpu(cpu, tbl[node]);\n\t}\n\n\twq_numa_possible_cpumask = tbl;\n\twq_numa_enabled = true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nint __init workqueue_init(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct worker_pool *pool;\n\tint cpu, bkt;\n\n\t/*\n\t * It'd be simpler to initialize NUMA in workqueue_init_early() but\n\t * CPU to node mapping may not be available that early on some\n\t * archs such as power and arm64.  As per-cpu pools created\n\t * previously could be missing node hint and unbound pools NUMA\n\t * affinity, fix them up.\n\t *\n\t * Also, while iterating workqueues, create rescuers if requested.\n\t */\n\twq_numa_init();\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\t\tpool->node = cpu_to_node(cpu);\n\t\t}\n\t}\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\twq_update_unbound_numa(wq, smp_processor_id(), true);\n\t\tWARN(init_rescuer(wq),\n\t\t     \"workqueue: failed to create early rescuer for %s\",\n\t\t     wq->name);\n\t}\n\n\tmutex_unlock(&wq_pool_mutex);\n\n\t/* create the initial workers */\n\tfor_each_online_cpu(cpu) {\n\t\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\t\tpool->flags &= ~POOL_DISASSOCIATED;\n\t\t\tBUG_ON(!create_worker(pool));\n\t\t}\n\t}\n\n\thash_for_each(unbound_pool_hash, bkt, pool, hash_node)\n\t\tBUG_ON(!create_worker(pool));\n\n\twq_online = true;\n\twq_watchdog_init();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "workqueue_init_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5687-5756",
    "snippet": "int __init workqueue_init_early(void)\n{\n\tint std_nice[NR_STD_WORKER_POOLS] = { 0, HIGHPRI_NICE_LEVEL };\n\tint hk_flags = HK_FLAG_DOMAIN | HK_FLAG_WQ;\n\tint i, cpu;\n\n\tWARN_ON(__alignof__(struct pool_workqueue) < __alignof__(long long));\n\n\tBUG_ON(!alloc_cpumask_var(&wq_unbound_cpumask, GFP_KERNEL));\n\tcpumask_copy(wq_unbound_cpumask, housekeeping_cpumask(hk_flags));\n\n\tpwq_cache = KMEM_CACHE(pool_workqueue, SLAB_PANIC);\n\n\t/* initialize CPU pools */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct worker_pool *pool;\n\n\t\ti = 0;\n\t\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\t\tBUG_ON(init_worker_pool(pool));\n\t\t\tpool->cpu = cpu;\n\t\t\tcpumask_copy(pool->attrs->cpumask, cpumask_of(cpu));\n\t\t\tpool->attrs->nice = std_nice[i++];\n\t\t\tpool->node = cpu_to_node(cpu);\n\n\t\t\t/* alloc pool ID */\n\t\t\tmutex_lock(&wq_pool_mutex);\n\t\t\tBUG_ON(worker_pool_assign_id(pool));\n\t\t\tmutex_unlock(&wq_pool_mutex);\n\t\t}\n\t}\n\n\t/* create default unbound and ordered wq attrs */\n\tfor (i = 0; i < NR_STD_WORKER_POOLS; i++) {\n\t\tstruct workqueue_attrs *attrs;\n\n\t\tBUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));\n\t\tattrs->nice = std_nice[i];\n\t\tunbound_std_wq_attrs[i] = attrs;\n\n\t\t/*\n\t\t * An ordered wq should have only one pwq as ordering is\n\t\t * guaranteed by max_active which is enforced by pwqs.\n\t\t * Turn off NUMA so that dfl_pwq is used for all nodes.\n\t\t */\n\t\tBUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));\n\t\tattrs->nice = std_nice[i];\n\t\tattrs->no_numa = true;\n\t\tordered_wq_attrs[i] = attrs;\n\t}\n\n\tsystem_wq = alloc_workqueue(\"events\", 0, 0);\n\tsystem_highpri_wq = alloc_workqueue(\"events_highpri\", WQ_HIGHPRI, 0);\n\tsystem_long_wq = alloc_workqueue(\"events_long\", 0, 0);\n\tsystem_unbound_wq = alloc_workqueue(\"events_unbound\", WQ_UNBOUND,\n\t\t\t\t\t    WQ_UNBOUND_MAX_ACTIVE);\n\tsystem_freezable_wq = alloc_workqueue(\"events_freezable\",\n\t\t\t\t\t      WQ_FREEZABLE, 0);\n\tsystem_power_efficient_wq = alloc_workqueue(\"events_power_efficient\",\n\t\t\t\t\t      WQ_POWER_EFFICIENT, 0);\n\tsystem_freezable_power_efficient_wq = alloc_workqueue(\"events_freezable_power_efficient\",\n\t\t\t\t\t      WQ_FREEZABLE | WQ_POWER_EFFICIENT,\n\t\t\t\t\t      0);\n\tBUG_ON(!system_wq || !system_highpri_wq || !system_long_wq ||\n\t       !system_unbound_wq || !system_freezable_wq ||\n\t       !system_power_efficient_wq ||\n\t       !system_freezable_power_efficient_wq);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *pwq_cache;",
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static cpumask_var_t wq_unbound_cpumask;",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];",
      "static struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];",
      "struct workqueue_struct *system_highpri_wq",
      "struct workqueue_struct *system_long_wq",
      "struct workqueue_struct *system_unbound_wq",
      "struct workqueue_struct *system_freezable_wq",
      "struct workqueue_struct *system_power_efficient_wq",
      "struct workqueue_struct *system_freezable_power_efficient_wq",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!system_wq || !system_highpri_wq || !system_long_wq ||\n\t       !system_unbound_wq || !system_freezable_wq ||\n\t       !system_power_efficient_wq ||\n\t       !system_freezable_power_efficient_wq"
          ],
          "line": 5750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"events_freezable_power_efficient\"",
            "WQ_FREEZABLE | WQ_POWER_EFFICIENT",
            "0"
          ],
          "line": 5747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"events_power_efficient\"",
            "WQ_POWER_EFFICIENT",
            "0"
          ],
          "line": 5745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"events_freezable\"",
            "WQ_FREEZABLE",
            "0"
          ],
          "line": 5743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"events_unbound\"",
            "WQ_UNBOUND",
            "WQ_UNBOUND_MAX_ACTIVE"
          ],
          "line": 5741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"events_long\"",
            "0",
            "0"
          ],
          "line": 5740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"events_highpri\"",
            "WQ_HIGHPRI",
            "0"
          ],
          "line": 5739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"events\"",
            "0",
            "0"
          ],
          "line": 5738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(attrs = alloc_workqueue_attrs(GFP_KERNEL))"
          ],
          "line": 5732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue_attrs",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 5732
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3226-3241",
          "snippet": "struct workqueue_attrs *alloc_workqueue_attrs(gfp_t gfp_mask)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), gfp_mask);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, gfp_mask))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct workqueue_attrs *alloc_workqueue_attrs(gfp_t gfp_mask)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), gfp_mask);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, gfp_mask))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(attrs = alloc_workqueue_attrs(GFP_KERNEL))"
          ],
          "line": 5723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5715
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "worker_pool_assign_id(pool)"
          ],
          "line": 5714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "worker_pool_assign_id",
          "args": [
            "pool"
          ],
          "line": 5714
        },
        "resolved": true,
        "details": {
          "function_name": "worker_pool_assign_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "533-546",
          "snippet": "static int worker_pool_assign_id(struct worker_pool *pool)\n{\n\tint ret;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tret = idr_alloc(&worker_pool_idr, pool, 0, WORK_OFFQ_POOL_NONE,\n\t\t\tGFP_KERNEL);\n\tif (ret >= 0) {\n\t\tpool->id = ret;\n\t\treturn 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static DEFINE_IDR(worker_pool_idr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic DEFINE_IDR(worker_pool_idr);\n\nstatic int worker_pool_assign_id(struct worker_pool *pool)\n{\n\tint ret;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tret = idr_alloc(&worker_pool_idr, pool, 0, WORK_OFFQ_POOL_NONE,\n\t\t\tGFP_KERNEL);\n\tif (ret >= 0) {\n\t\tpool->id = ret;\n\t\treturn 0;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5713
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 5710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "pool->attrs->cpumask",
            "cpumask_of(cpu)"
          ],
          "line": 5708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 5708
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/hw_breakpoint.c",
          "lines": "134-139",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "init_worker_pool(pool)"
          ],
          "line": 5706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_worker_pool",
          "args": [
            "pool"
          ],
          "line": 5706
        },
        "resolved": true,
        "details": {
          "function_name": "init_worker_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3288-3315",
          "snippet": "static int init_worker_pool(struct worker_pool *pool)\n{\n\tspin_lock_init(&pool->lock);\n\tpool->id = -1;\n\tpool->cpu = -1;\n\tpool->node = NUMA_NO_NODE;\n\tpool->flags |= POOL_DISASSOCIATED;\n\tpool->watchdog_ts = jiffies;\n\tINIT_LIST_HEAD(&pool->worklist);\n\tINIT_LIST_HEAD(&pool->idle_list);\n\thash_init(pool->busy_hash);\n\n\ttimer_setup(&pool->idle_timer, idle_worker_timeout, TIMER_DEFERRABLE);\n\n\ttimer_setup(&pool->mayday_timer, pool_mayday_timeout, 0);\n\n\tINIT_LIST_HEAD(&pool->workers);\n\n\tida_init(&pool->worker_ida);\n\tINIT_HLIST_NODE(&pool->hash_node);\n\tpool->refcnt = 1;\n\n\t/* shouldn't fail above this point */\n\tpool->attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!pool->attrs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic int init_worker_pool(struct worker_pool *pool)\n{\n\tspin_lock_init(&pool->lock);\n\tpool->id = -1;\n\tpool->cpu = -1;\n\tpool->node = NUMA_NO_NODE;\n\tpool->flags |= POOL_DISASSOCIATED;\n\tpool->watchdog_ts = jiffies;\n\tINIT_LIST_HEAD(&pool->worklist);\n\tINIT_LIST_HEAD(&pool->idle_list);\n\thash_init(pool->busy_hash);\n\n\ttimer_setup(&pool->idle_timer, idle_worker_timeout, TIMER_DEFERRABLE);\n\n\ttimer_setup(&pool->mayday_timer, pool_mayday_timeout, 0);\n\n\tINIT_LIST_HEAD(&pool->workers);\n\n\tida_init(&pool->worker_ida);\n\tINIT_HLIST_NODE(&pool->hash_node);\n\tpool->refcnt = 1;\n\n\t/* shouldn't fail above this point */\n\tpool->attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!pool->attrs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu_worker_pool",
          "args": [
            "pool",
            "cpu"
          ],
          "line": 5705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "pool_workqueue",
            "SLAB_PANIC"
          ],
          "line": 5698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "wq_unbound_cpumask",
            "housekeeping_cpumask(hk_flags)"
          ],
          "line": 5696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "housekeeping_cpumask",
          "args": [
            "hk_flags"
          ],
          "line": 5696
        },
        "resolved": true,
        "details": {
          "function_name": "housekeeping_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/isolation.c",
          "lines": "25-31",
          "snippet": "const struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overriden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t housekeeping_mask;",
            "static unsigned int housekeeping_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t housekeeping_mask;\nstatic unsigned int housekeeping_flags;\n\nconst struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overriden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!alloc_cpumask_var(&wq_unbound_cpumask, GFP_KERNEL)"
          ],
          "line": 5695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&wq_unbound_cpumask",
            "GFP_KERNEL"
          ],
          "line": 5695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "__alignof__(struct pool_workqueue) < __alignof__(long long)"
          ],
          "line": 5693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *pwq_cache;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic cpumask_var_t wq_unbound_cpumask;\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];\nstatic struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];\nstruct workqueue_struct *system_highpri_wq;\nstruct workqueue_struct *system_long_wq;\nstruct workqueue_struct *system_unbound_wq;\nstruct workqueue_struct *system_freezable_wq;\nstruct workqueue_struct *system_power_efficient_wq;\nstruct workqueue_struct *system_freezable_power_efficient_wq;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nint __init workqueue_init_early(void)\n{\n\tint std_nice[NR_STD_WORKER_POOLS] = { 0, HIGHPRI_NICE_LEVEL };\n\tint hk_flags = HK_FLAG_DOMAIN | HK_FLAG_WQ;\n\tint i, cpu;\n\n\tWARN_ON(__alignof__(struct pool_workqueue) < __alignof__(long long));\n\n\tBUG_ON(!alloc_cpumask_var(&wq_unbound_cpumask, GFP_KERNEL));\n\tcpumask_copy(wq_unbound_cpumask, housekeeping_cpumask(hk_flags));\n\n\tpwq_cache = KMEM_CACHE(pool_workqueue, SLAB_PANIC);\n\n\t/* initialize CPU pools */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct worker_pool *pool;\n\n\t\ti = 0;\n\t\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\t\tBUG_ON(init_worker_pool(pool));\n\t\t\tpool->cpu = cpu;\n\t\t\tcpumask_copy(pool->attrs->cpumask, cpumask_of(cpu));\n\t\t\tpool->attrs->nice = std_nice[i++];\n\t\t\tpool->node = cpu_to_node(cpu);\n\n\t\t\t/* alloc pool ID */\n\t\t\tmutex_lock(&wq_pool_mutex);\n\t\t\tBUG_ON(worker_pool_assign_id(pool));\n\t\t\tmutex_unlock(&wq_pool_mutex);\n\t\t}\n\t}\n\n\t/* create default unbound and ordered wq attrs */\n\tfor (i = 0; i < NR_STD_WORKER_POOLS; i++) {\n\t\tstruct workqueue_attrs *attrs;\n\n\t\tBUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));\n\t\tattrs->nice = std_nice[i];\n\t\tunbound_std_wq_attrs[i] = attrs;\n\n\t\t/*\n\t\t * An ordered wq should have only one pwq as ordering is\n\t\t * guaranteed by max_active which is enforced by pwqs.\n\t\t * Turn off NUMA so that dfl_pwq is used for all nodes.\n\t\t */\n\t\tBUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));\n\t\tattrs->nice = std_nice[i];\n\t\tattrs->no_numa = true;\n\t\tordered_wq_attrs[i] = attrs;\n\t}\n\n\tsystem_wq = alloc_workqueue(\"events\", 0, 0);\n\tsystem_highpri_wq = alloc_workqueue(\"events_highpri\", WQ_HIGHPRI, 0);\n\tsystem_long_wq = alloc_workqueue(\"events_long\", 0, 0);\n\tsystem_unbound_wq = alloc_workqueue(\"events_unbound\", WQ_UNBOUND,\n\t\t\t\t\t    WQ_UNBOUND_MAX_ACTIVE);\n\tsystem_freezable_wq = alloc_workqueue(\"events_freezable\",\n\t\t\t\t\t      WQ_FREEZABLE, 0);\n\tsystem_power_efficient_wq = alloc_workqueue(\"events_power_efficient\",\n\t\t\t\t\t      WQ_POWER_EFFICIENT, 0);\n\tsystem_freezable_power_efficient_wq = alloc_workqueue(\"events_freezable_power_efficient\",\n\t\t\t\t\t      WQ_FREEZABLE | WQ_POWER_EFFICIENT,\n\t\t\t\t\t      0);\n\tBUG_ON(!system_wq || !system_highpri_wq || !system_long_wq ||\n\t       !system_unbound_wq || !system_freezable_wq ||\n\t       !system_power_efficient_wq ||\n\t       !system_freezable_power_efficient_wq);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "wq_numa_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5635-5675",
    "snippet": "static void __init wq_numa_init(void)\n{\n\tcpumask_var_t *tbl;\n\tint node, cpu;\n\n\tif (num_possible_nodes() <= 1)\n\t\treturn;\n\n\tif (wq_disable_numa) {\n\t\tpr_info(\"workqueue: NUMA affinity support disabled\\n\");\n\t\treturn;\n\t}\n\n\twq_update_unbound_numa_attrs_buf = alloc_workqueue_attrs(GFP_KERNEL);\n\tBUG_ON(!wq_update_unbound_numa_attrs_buf);\n\n\t/*\n\t * We want masks of possible CPUs of each node which isn't readily\n\t * available.  Build one from cpu_to_node() which should have been\n\t * fully initialized by now.\n\t */\n\ttbl = kcalloc(nr_node_ids, sizeof(tbl[0]), GFP_KERNEL);\n\tBUG_ON(!tbl);\n\n\tfor_each_node(node)\n\t\tBUG_ON(!zalloc_cpumask_var_node(&tbl[node], GFP_KERNEL,\n\t\t\t\tnode_online(node) ? node : NUMA_NO_NODE));\n\n\tfor_each_possible_cpu(cpu) {\n\t\tnode = cpu_to_node(cpu);\n\t\tif (WARN_ON(node == NUMA_NO_NODE)) {\n\t\t\tpr_warn(\"workqueue: NUMA node mapping not available for cpu%d, disabling NUMA support\\n\", cpu);\n\t\t\t/* happens iff arch is bonkers, let's just proceed */\n\t\t\treturn;\n\t\t}\n\t\tcpumask_set_cpu(cpu, tbl[node]);\n\t}\n\n\twq_numa_possible_cpumask = tbl;\n\twq_numa_enabled = true;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t *wq_numa_possible_cpumask;",
      "static bool wq_disable_numa;",
      "static bool wq_numa_enabled;",
      "static struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "tbl[node]"
          ],
          "line": 5670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"workqueue: NUMA node mapping not available for cpu%d, disabling NUMA support\\n\"",
            "cpu"
          ],
          "line": 5666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "node == NUMA_NO_NODE"
          ],
          "line": 5665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 5664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var_node",
          "args": [
            "&tbl[node]",
            "GFP_KERNEL",
            "node_online(node) ? node : NUMA_NO_NODE"
          ],
          "line": 5660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "node"
          ],
          "line": 5661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!tbl"
          ],
          "line": 5657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_node_ids",
            "sizeof(tbl[0])",
            "GFP_KERNEL"
          ],
          "line": 5656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!wq_update_unbound_numa_attrs_buf"
          ],
          "line": 5649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue_attrs",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 5648
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3226-3241",
          "snippet": "struct workqueue_attrs *alloc_workqueue_attrs(gfp_t gfp_mask)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), gfp_mask);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, gfp_mask))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct workqueue_attrs *alloc_workqueue_attrs(gfp_t gfp_mask)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), gfp_mask);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, gfp_mask))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"workqueue: NUMA affinity support disabled\\n\""
          ],
          "line": 5644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_nodes",
          "args": [],
          "line": 5640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t *wq_numa_possible_cpumask;\nstatic bool wq_disable_numa;\nstatic bool wq_numa_enabled;\nstatic struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;\n\nstatic void __init wq_numa_init(void)\n{\n\tcpumask_var_t *tbl;\n\tint node, cpu;\n\n\tif (num_possible_nodes() <= 1)\n\t\treturn;\n\n\tif (wq_disable_numa) {\n\t\tpr_info(\"workqueue: NUMA affinity support disabled\\n\");\n\t\treturn;\n\t}\n\n\twq_update_unbound_numa_attrs_buf = alloc_workqueue_attrs(GFP_KERNEL);\n\tBUG_ON(!wq_update_unbound_numa_attrs_buf);\n\n\t/*\n\t * We want masks of possible CPUs of each node which isn't readily\n\t * available.  Build one from cpu_to_node() which should have been\n\t * fully initialized by now.\n\t */\n\ttbl = kcalloc(nr_node_ids, sizeof(tbl[0]), GFP_KERNEL);\n\tBUG_ON(!tbl);\n\n\tfor_each_node(node)\n\t\tBUG_ON(!zalloc_cpumask_var_node(&tbl[node], GFP_KERNEL,\n\t\t\t\tnode_online(node) ? node : NUMA_NO_NODE));\n\n\tfor_each_possible_cpu(cpu) {\n\t\tnode = cpu_to_node(cpu);\n\t\tif (WARN_ON(node == NUMA_NO_NODE)) {\n\t\t\tpr_warn(\"workqueue: NUMA node mapping not available for cpu%d, disabling NUMA support\\n\", cpu);\n\t\t\t/* happens iff arch is bonkers, let's just proceed */\n\t\t\treturn;\n\t\t}\n\t\tcpumask_set_cpu(cpu, tbl[node]);\n\t}\n\n\twq_numa_possible_cpumask = tbl;\n\twq_numa_enabled = true;\n}"
  },
  {
    "function_name": "wq_watchdog_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5631-5631",
    "snippet": "static inline void wq_watchdog_init(void) { }",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void wq_watchdog_init(void) { }"
  },
  {
    "function_name": "wq_watchdog_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5623-5627",
    "snippet": "static void wq_watchdog_init(void)\n{\n\ttimer_setup(&wq_watchdog_timer, wq_watchdog_timer_fn, TIMER_DEFERRABLE);\n\twq_watchdog_set_thresh(wq_watchdog_thresh);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wq_watchdog_set_thresh",
          "args": [
            "wq_watchdog_thresh"
          ],
          "line": 5626
        },
        "resolved": true,
        "details": {
          "function_name": "wq_watchdog_set_thresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5585-5595",
          "snippet": "static void wq_watchdog_set_thresh(unsigned long thresh)\n{\n\twq_watchdog_thresh = 0;\n\tdel_timer_sync(&wq_watchdog_timer);\n\n\tif (thresh) {\n\t\twq_watchdog_thresh = thresh;\n\t\twq_watchdog_reset_touched();\n\t\tmod_timer(&wq_watchdog_timer, jiffies + thresh * HZ);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void wq_watchdog_set_thresh(unsigned long thresh)\n{\n\twq_watchdog_thresh = 0;\n\tdel_timer_sync(&wq_watchdog_timer);\n\n\tif (thresh) {\n\t\twq_watchdog_thresh = thresh;\n\t\twq_watchdog_reset_touched();\n\t\tmod_timer(&wq_watchdog_timer, jiffies + thresh * HZ);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_setup",
          "args": [
            "&wq_watchdog_timer",
            "wq_watchdog_timer_fn",
            "TIMER_DEFERRABLE"
          ],
          "line": 5625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void wq_watchdog_init(void)\n{\n\ttimer_setup(&wq_watchdog_timer, wq_watchdog_timer_fn, TIMER_DEFERRABLE);\n\twq_watchdog_set_thresh(wq_watchdog_thresh);\n}"
  },
  {
    "function_name": "wq_watchdog_param_set_thresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5597-5613",
    "snippet": "static int wq_watchdog_param_set_thresh(const char *val,\n\t\t\t\t\tconst struct kernel_param *kp)\n{\n\tunsigned long thresh;\n\tint ret;\n\n\tret = kstrtoul(val, 0, &thresh);\n\tif (ret)\n\t\treturn ret;\n\n\tif (system_wq)\n\t\twq_watchdog_set_thresh(thresh);\n\telse\n\t\twq_watchdog_thresh = thresh;\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wq_watchdog_set_thresh",
          "args": [
            "thresh"
          ],
          "line": 5608
        },
        "resolved": true,
        "details": {
          "function_name": "wq_watchdog_set_thresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5585-5595",
          "snippet": "static void wq_watchdog_set_thresh(unsigned long thresh)\n{\n\twq_watchdog_thresh = 0;\n\tdel_timer_sync(&wq_watchdog_timer);\n\n\tif (thresh) {\n\t\twq_watchdog_thresh = thresh;\n\t\twq_watchdog_reset_touched();\n\t\tmod_timer(&wq_watchdog_timer, jiffies + thresh * HZ);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void wq_watchdog_set_thresh(unsigned long thresh)\n{\n\twq_watchdog_thresh = 0;\n\tdel_timer_sync(&wq_watchdog_timer);\n\n\tif (thresh) {\n\t\twq_watchdog_thresh = thresh;\n\t\twq_watchdog_reset_touched();\n\t\tmod_timer(&wq_watchdog_timer, jiffies + thresh * HZ);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "val",
            "0",
            "&thresh"
          ],
          "line": 5603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int wq_watchdog_param_set_thresh(const char *val,\n\t\t\t\t\tconst struct kernel_param *kp)\n{\n\tunsigned long thresh;\n\tint ret;\n\n\tret = kstrtoul(val, 0, &thresh);\n\tif (ret)\n\t\treturn ret;\n\n\tif (system_wq)\n\t\twq_watchdog_set_thresh(thresh);\n\telse\n\t\twq_watchdog_thresh = thresh;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "wq_watchdog_set_thresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5585-5595",
    "snippet": "static void wq_watchdog_set_thresh(unsigned long thresh)\n{\n\twq_watchdog_thresh = 0;\n\tdel_timer_sync(&wq_watchdog_timer);\n\n\tif (thresh) {\n\t\twq_watchdog_thresh = thresh;\n\t\twq_watchdog_reset_touched();\n\t\tmod_timer(&wq_watchdog_timer, jiffies + thresh * HZ);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&wq_watchdog_timer",
            "jiffies + thresh * HZ"
          ],
          "line": 5593
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1100-1103",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_watchdog_reset_touched",
          "args": [],
          "line": 5592
        },
        "resolved": true,
        "details": {
          "function_name": "wq_watchdog_reset_touched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5514-5521",
          "snippet": "static void wq_watchdog_reset_touched(void)\n{\n\tint cpu;\n\n\twq_watchdog_touched = jiffies;\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void wq_watchdog_reset_touched(void)\n{\n\tint cpu;\n\n\twq_watchdog_touched = jiffies;\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&wq_watchdog_timer"
          ],
          "line": 5588
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1273-1298",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void wq_watchdog_set_thresh(unsigned long thresh)\n{\n\twq_watchdog_thresh = 0;\n\tdel_timer_sync(&wq_watchdog_timer);\n\n\tif (thresh) {\n\t\twq_watchdog_thresh = thresh;\n\t\twq_watchdog_reset_touched();\n\t\tmod_timer(&wq_watchdog_timer, jiffies + thresh * HZ);\n\t}\n}"
  },
  {
    "function_name": "wq_watchdog_touch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5577-5583",
    "snippet": "notrace void wq_watchdog_touch(int cpu)\n{\n\tif (cpu >= 0)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n\telse\n\t\twq_watchdog_touched = jiffies;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "wq_watchdog_touched_cpu",
            "cpu"
          ],
          "line": 5580
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nnotrace void wq_watchdog_touch(int cpu)\n{\n\tif (cpu >= 0)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n\telse\n\t\twq_watchdog_touched = jiffies;\n}"
  },
  {
    "function_name": "wq_watchdog_timer_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5523-5575",
    "snippet": "static void wq_watchdog_timer_fn(struct timer_list *unused)\n{\n\tunsigned long thresh = READ_ONCE(wq_watchdog_thresh) * HZ;\n\tbool lockup_detected = false;\n\tstruct worker_pool *pool;\n\tint pi;\n\n\tif (!thresh)\n\t\treturn;\n\n\trcu_read_lock();\n\n\tfor_each_pool(pool, pi) {\n\t\tunsigned long pool_ts, touched, ts;\n\n\t\tif (list_empty(&pool->worklist))\n\t\t\tcontinue;\n\n\t\t/* get the latest of pool and touched timestamps */\n\t\tpool_ts = READ_ONCE(pool->watchdog_ts);\n\t\ttouched = READ_ONCE(wq_watchdog_touched);\n\n\t\tif (time_after(pool_ts, touched))\n\t\t\tts = pool_ts;\n\t\telse\n\t\t\tts = touched;\n\n\t\tif (pool->cpu >= 0) {\n\t\t\tunsigned long cpu_touched =\n\t\t\t\tREAD_ONCE(per_cpu(wq_watchdog_touched_cpu,\n\t\t\t\t\t\t  pool->cpu));\n\t\t\tif (time_after(cpu_touched, ts))\n\t\t\t\tts = cpu_touched;\n\t\t}\n\n\t\t/* did we stall? */\n\t\tif (time_after(jiffies, ts + thresh)) {\n\t\t\tlockup_detected = true;\n\t\t\tpr_emerg(\"BUG: workqueue lockup - pool\");\n\t\t\tpr_cont_pool_info(pool);\n\t\t\tpr_cont(\" stuck for %us!\\n\",\n\t\t\t\tjiffies_to_msecs(jiffies - pool_ts) / 1000);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tif (lockup_detected)\n\t\tshow_workqueue_state();\n\n\twq_watchdog_reset_touched();\n\tmod_timer(&wq_watchdog_timer, jiffies + thresh);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&wq_watchdog_timer",
            "jiffies + thresh"
          ],
          "line": 5574
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1100-1103",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_watchdog_reset_touched",
          "args": [],
          "line": 5573
        },
        "resolved": true,
        "details": {
          "function_name": "wq_watchdog_reset_touched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5514-5521",
          "snippet": "static void wq_watchdog_reset_touched(void)\n{\n\tint cpu;\n\n\twq_watchdog_touched = jiffies;\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void wq_watchdog_reset_touched(void)\n{\n\tint cpu;\n\n\twq_watchdog_touched = jiffies;\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_workqueue_state",
          "args": [],
          "line": 5571
        },
        "resolved": true,
        "details": {
          "function_name": "show_workqueue_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4530-4603",
          "snippet": "void show_workqueue_state(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct worker_pool *pool;\n\tunsigned long flags;\n\tint pi;\n\n\trcu_read_lock_sched();\n\n\tpr_info(\"Showing busy workqueues and worker pools:\\n\");\n\n\tlist_for_each_entry_rcu(wq, &workqueues, list) {\n\t\tstruct pool_workqueue *pwq;\n\t\tbool idle = true;\n\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tif (pwq->nr_active || !list_empty(&pwq->delayed_works)) {\n\t\t\t\tidle = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idle)\n\t\t\tcontinue;\n\n\t\tpr_info(\"workqueue %s: flags=0x%x\\n\", wq->name, wq->flags);\n\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\t\t\tif (pwq->nr_active || !list_empty(&pwq->delayed_works))\n\t\t\t\tshow_pwq(pwq);\n\t\t\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n\t\t\t/*\n\t\t\t * We could be printing a lot from atomic context, e.g.\n\t\t\t * sysrq-t -> show_workqueue_state(). Avoid triggering\n\t\t\t * hard lockup.\n\t\t\t */\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t}\n\n\tfor_each_pool(pool, pi) {\n\t\tstruct worker *worker;\n\t\tbool first = true;\n\n\t\tspin_lock_irqsave(&pool->lock, flags);\n\t\tif (pool->nr_workers == pool->nr_idle)\n\t\t\tgoto next_pool;\n\n\t\tpr_info(\"pool %d:\", pool->id);\n\t\tpr_cont_pool_info(pool);\n\t\tpr_cont(\" hung=%us workers=%d\",\n\t\t\tjiffies_to_msecs(jiffies - pool->watchdog_ts) / 1000,\n\t\t\tpool->nr_workers);\n\t\tif (pool->manager)\n\t\t\tpr_cont(\" manager: %d\",\n\t\t\t\ttask_pid_nr(pool->manager->task));\n\t\tlist_for_each_entry(worker, &pool->idle_list, entry) {\n\t\t\tpr_cont(\" %s%d\", first ? \"idle: \" : \"\",\n\t\t\t\ttask_pid_nr(worker->task));\n\t\t\tfirst = false;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\tnext_pool:\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t/*\n\t\t * We could be printing a lot from atomic context, e.g.\n\t\t * sysrq-t -> show_workqueue_state(). Avoid triggering\n\t\t * hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t}\n\n\trcu_read_unlock_sched();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid show_workqueue_state(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct worker_pool *pool;\n\tunsigned long flags;\n\tint pi;\n\n\trcu_read_lock_sched();\n\n\tpr_info(\"Showing busy workqueues and worker pools:\\n\");\n\n\tlist_for_each_entry_rcu(wq, &workqueues, list) {\n\t\tstruct pool_workqueue *pwq;\n\t\tbool idle = true;\n\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tif (pwq->nr_active || !list_empty(&pwq->delayed_works)) {\n\t\t\t\tidle = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idle)\n\t\t\tcontinue;\n\n\t\tpr_info(\"workqueue %s: flags=0x%x\\n\", wq->name, wq->flags);\n\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\t\t\tif (pwq->nr_active || !list_empty(&pwq->delayed_works))\n\t\t\t\tshow_pwq(pwq);\n\t\t\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n\t\t\t/*\n\t\t\t * We could be printing a lot from atomic context, e.g.\n\t\t\t * sysrq-t -> show_workqueue_state(). Avoid triggering\n\t\t\t * hard lockup.\n\t\t\t */\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t}\n\n\tfor_each_pool(pool, pi) {\n\t\tstruct worker *worker;\n\t\tbool first = true;\n\n\t\tspin_lock_irqsave(&pool->lock, flags);\n\t\tif (pool->nr_workers == pool->nr_idle)\n\t\t\tgoto next_pool;\n\n\t\tpr_info(\"pool %d:\", pool->id);\n\t\tpr_cont_pool_info(pool);\n\t\tpr_cont(\" hung=%us workers=%d\",\n\t\t\tjiffies_to_msecs(jiffies - pool->watchdog_ts) / 1000,\n\t\t\tpool->nr_workers);\n\t\tif (pool->manager)\n\t\t\tpr_cont(\" manager: %d\",\n\t\t\t\ttask_pid_nr(pool->manager->task));\n\t\tlist_for_each_entry(worker, &pool->idle_list, entry) {\n\t\t\tpr_cont(\" %s%d\", first ? \"idle: \" : \"\",\n\t\t\t\ttask_pid_nr(worker->task));\n\t\t\tfirst = false;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\tnext_pool:\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t/*\n\t\t * We could be printing a lot from atomic context, e.g.\n\t\t * sysrq-t -> show_workqueue_state(). Avoid triggering\n\t\t * hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t}\n\n\trcu_read_unlock_sched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 5568
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" stuck for %us!\\n\"",
            "jiffies_to_msecs(jiffies - pool_ts) / 1000"
          ],
          "line": 5563
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4439-4451",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jiffies_to_msecs",
          "args": [
            "jiffies - pool_ts"
          ],
          "line": 5564
        },
        "resolved": true,
        "details": {
          "function_name": "jiffies_to_msecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "311-325",
          "snippet": "unsigned int jiffies_to_msecs(const unsigned long j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>\n\t       HZ_TO_MSEC_SHR32;\n# else\n\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n# endif\n#endif\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned int jiffies_to_msecs(const unsigned long j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>\n\t       HZ_TO_MSEC_SHR32;\n# else\n\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n# endif\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont_pool_info",
          "args": [
            "pool"
          ],
          "line": 5562
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_emerg",
          "args": [
            "\"BUG: workqueue lockup - pool\""
          ],
          "line": 5561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "ts + thresh"
          ],
          "line": 5559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "cpu_touched",
            "ts"
          ],
          "line": 5554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "per_cpu(wq_watchdog_touched_cpu,\n\t\t\t\t\t\t  pool->cpu)"
          ],
          "line": 5552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "wq_watchdog_touched_cpu",
            "pool->cpu"
          ],
          "line": 5552
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "pool_ts",
            "touched"
          ],
          "line": 5545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "wq_watchdog_touched"
          ],
          "line": 5543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "pool->watchdog_ts"
          ],
          "line": 5542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pool->worklist"
          ],
          "line": 5538
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pool",
          "args": [
            "pool",
            "pi"
          ],
          "line": 5535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 5533
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "wq_watchdog_thresh"
          ],
          "line": 5525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wq_watchdog_timer_fn(struct timer_list *unused)\n{\n\tunsigned long thresh = READ_ONCE(wq_watchdog_thresh) * HZ;\n\tbool lockup_detected = false;\n\tstruct worker_pool *pool;\n\tint pi;\n\n\tif (!thresh)\n\t\treturn;\n\n\trcu_read_lock();\n\n\tfor_each_pool(pool, pi) {\n\t\tunsigned long pool_ts, touched, ts;\n\n\t\tif (list_empty(&pool->worklist))\n\t\t\tcontinue;\n\n\t\t/* get the latest of pool and touched timestamps */\n\t\tpool_ts = READ_ONCE(pool->watchdog_ts);\n\t\ttouched = READ_ONCE(wq_watchdog_touched);\n\n\t\tif (time_after(pool_ts, touched))\n\t\t\tts = pool_ts;\n\t\telse\n\t\t\tts = touched;\n\n\t\tif (pool->cpu >= 0) {\n\t\t\tunsigned long cpu_touched =\n\t\t\t\tREAD_ONCE(per_cpu(wq_watchdog_touched_cpu,\n\t\t\t\t\t\t  pool->cpu));\n\t\t\tif (time_after(cpu_touched, ts))\n\t\t\t\tts = cpu_touched;\n\t\t}\n\n\t\t/* did we stall? */\n\t\tif (time_after(jiffies, ts + thresh)) {\n\t\t\tlockup_detected = true;\n\t\t\tpr_emerg(\"BUG: workqueue lockup - pool\");\n\t\t\tpr_cont_pool_info(pool);\n\t\t\tpr_cont(\" stuck for %us!\\n\",\n\t\t\t\tjiffies_to_msecs(jiffies - pool_ts) / 1000);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tif (lockup_detected)\n\t\tshow_workqueue_state();\n\n\twq_watchdog_reset_touched();\n\tmod_timer(&wq_watchdog_timer, jiffies + thresh);\n}"
  },
  {
    "function_name": "wq_watchdog_reset_touched",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5514-5521",
    "snippet": "static void wq_watchdog_reset_touched(void)\n{\n\tint cpu;\n\n\twq_watchdog_touched = jiffies;\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void wq_watchdog_reset_touched(void)\n{\n\tint cpu;\n\n\twq_watchdog_touched = jiffies;\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(wq_watchdog_touched_cpu, cpu) = jiffies;\n}"
  },
  {
    "function_name": "workqueue_sysfs_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5486-5486",
    "snippet": "static void workqueue_sysfs_unregister(struct workqueue_struct *wq)\t{ }",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq)\t{ }"
  },
  {
    "function_name": "workqueue_sysfs_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5475-5484",
    "snippet": "static void workqueue_sysfs_unregister(struct workqueue_struct *wq)\n{\n\tstruct wq_device *wq_dev = wq->wq_dev;\n\n\tif (!wq->wq_dev)\n\t\treturn;\n\n\twq->wq_dev = NULL;\n\tdevice_unregister(&wq_dev->dev);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_unregister",
          "args": [
            "&wq_dev->dev"
          ],
          "line": 5483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq)\n{\n\tstruct wq_device *wq_dev = wq->wq_dev;\n\n\tif (!wq->wq_dev)\n\t\treturn;\n\n\twq->wq_dev = NULL;\n\tdevice_unregister(&wq_dev->dev);\n}"
  },
  {
    "function_name": "workqueue_sysfs_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5416-5467",
    "snippet": "int workqueue_sysfs_register(struct workqueue_struct *wq)\n{\n\tstruct wq_device *wq_dev;\n\tint ret;\n\n\t/*\n\t * Adjusting max_active or creating new pwqs by applying\n\t * attributes breaks ordering guarantee.  Disallow exposing ordered\n\t * workqueues.\n\t */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn -EINVAL;\n\n\twq->wq_dev = wq_dev = kzalloc(sizeof(*wq_dev), GFP_KERNEL);\n\tif (!wq_dev)\n\t\treturn -ENOMEM;\n\n\twq_dev->wq = wq;\n\twq_dev->dev.bus = &wq_subsys;\n\twq_dev->dev.release = wq_device_release;\n\tdev_set_name(&wq_dev->dev, \"%s\", wq->name);\n\n\t/*\n\t * unbound_attrs are created separately.  Suppress uevent until\n\t * everything is ready.\n\t */\n\tdev_set_uevent_suppress(&wq_dev->dev, true);\n\n\tret = device_register(&wq_dev->dev);\n\tif (ret) {\n\t\tput_device(&wq_dev->dev);\n\t\twq->wq_dev = NULL;\n\t\treturn ret;\n\t}\n\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tstruct device_attribute *attr;\n\n\t\tfor (attr = wq_sysfs_unbound_attrs; attr->attr.name; attr++) {\n\t\t\tret = device_create_file(&wq_dev->dev, attr);\n\t\t\tif (ret) {\n\t\t\t\tdevice_unregister(&wq_dev->dev);\n\t\t\t\twq->wq_dev = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_set_uevent_suppress(&wq_dev->dev, false);\n\tkobject_uevent(&wq_dev->dev.kobj, KOBJ_ADD);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(workqueues);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_uevent",
          "args": [
            "&wq_dev->dev.kobj",
            "KOBJ_ADD"
          ],
          "line": 5465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_set_uevent_suppress",
          "args": [
            "&wq_dev->dev",
            "false"
          ],
          "line": 5464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_unregister",
          "args": [
            "&wq_dev->dev"
          ],
          "line": 5457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_create_file",
          "args": [
            "&wq_dev->dev",
            "attr"
          ],
          "line": 5455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_device",
          "args": [
            "&wq_dev->dev"
          ],
          "line": 5446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_register",
          "args": [
            "&wq_dev->dev"
          ],
          "line": 5444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_set_uevent_suppress",
          "args": [
            "&wq_dev->dev",
            "true"
          ],
          "line": 5442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_set_name",
          "args": [
            "&wq_dev->dev",
            "\"%s\"",
            "wq->name"
          ],
          "line": 5436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*wq_dev)",
            "GFP_KERNEL"
          ],
          "line": 5429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "wq->flags & __WQ_ORDERED_EXPLICIT"
          ],
          "line": 5426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nint workqueue_sysfs_register(struct workqueue_struct *wq)\n{\n\tstruct wq_device *wq_dev;\n\tint ret;\n\n\t/*\n\t * Adjusting max_active or creating new pwqs by applying\n\t * attributes breaks ordering guarantee.  Disallow exposing ordered\n\t * workqueues.\n\t */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn -EINVAL;\n\n\twq->wq_dev = wq_dev = kzalloc(sizeof(*wq_dev), GFP_KERNEL);\n\tif (!wq_dev)\n\t\treturn -ENOMEM;\n\n\twq_dev->wq = wq;\n\twq_dev->dev.bus = &wq_subsys;\n\twq_dev->dev.release = wq_device_release;\n\tdev_set_name(&wq_dev->dev, \"%s\", wq->name);\n\n\t/*\n\t * unbound_attrs are created separately.  Suppress uevent until\n\t * everything is ready.\n\t */\n\tdev_set_uevent_suppress(&wq_dev->dev, true);\n\n\tret = device_register(&wq_dev->dev);\n\tif (ret) {\n\t\tput_device(&wq_dev->dev);\n\t\twq->wq_dev = NULL;\n\t\treturn ret;\n\t}\n\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tstruct device_attribute *attr;\n\n\t\tfor (attr = wq_sysfs_unbound_attrs; attr->attr.name; attr++) {\n\t\t\tret = device_create_file(&wq_dev->dev, attr);\n\t\t\tif (ret) {\n\t\t\t\tdevice_unregister(&wq_dev->dev);\n\t\t\t\twq->wq_dev = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_set_uevent_suppress(&wq_dev->dev, false);\n\tkobject_uevent(&wq_dev->dev.kobj, KOBJ_ADD);\n\treturn 0;\n}"
  },
  {
    "function_name": "wq_device_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5394-5399",
    "snippet": "static void wq_device_release(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\tkfree(wq_dev);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wq_dev"
          ],
          "line": 5398
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structwq_device",
            "dev"
          ],
          "line": 5396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void wq_device_release(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\tkfree(wq_dev);\n}"
  },
  {
    "function_name": "wq_sysfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5382-5391",
    "snippet": "static int __init wq_sysfs_init(void)\n{\n\tint err;\n\n\terr = subsys_virtual_register(&wq_subsys, NULL);\n\tif (err)\n\t\treturn err;\n\n\treturn device_create_file(wq_subsys.dev_root, &wq_sysfs_cpumask_attr);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_create_file",
          "args": [
            "wq_subsys.dev_root",
            "&wq_sysfs_cpumask_attr"
          ],
          "line": 5390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "subsys_virtual_register",
          "args": [
            "&wq_subsys",
            "NULL"
          ],
          "line": 5386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int __init wq_sysfs_init(void)\n{\n\tint err;\n\n\terr = subsys_virtual_register(&wq_subsys, NULL);\n\tif (err)\n\t\treturn err;\n\n\treturn device_create_file(wq_subsys.dev_root, &wq_sysfs_cpumask_attr);\n}"
  },
  {
    "function_name": "wq_unbound_cpumask_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5361-5376",
    "snippet": "static ssize_t wq_unbound_cpumask_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tcpumask_var_t cpumask;\n\tint ret;\n\n\tif (!zalloc_cpumask_var(&cpumask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tret = cpumask_parse(buf, cpumask);\n\tif (!ret)\n\t\tret = workqueue_set_unbound_cpumask(cpumask);\n\n\tfree_cpumask_var(cpumask);\n\treturn ret ? ret : count;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cpumask"
          ],
          "line": 5374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "workqueue_set_unbound_cpumask",
          "args": [
            "cpumask"
          ],
          "line": 5372
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_unbound_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5085-5117",
          "snippet": "int workqueue_set_unbound_cpumask(cpumask_var_t cpumask)\n{\n\tint ret = -EINVAL;\n\tcpumask_var_t saved_cpumask;\n\n\tif (!zalloc_cpumask_var(&saved_cpumask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Not excluding isolated cpus on purpose.\n\t * If the user wishes to include them, we allow that.\n\t */\n\tcpumask_and(cpumask, cpumask, cpu_possible_mask);\n\tif (!cpumask_empty(cpumask)) {\n\t\tapply_wqattrs_lock();\n\n\t\t/* save the old wq_unbound_cpumask. */\n\t\tcpumask_copy(saved_cpumask, wq_unbound_cpumask);\n\n\t\t/* update wq_unbound_cpumask at first and apply it to wqs. */\n\t\tcpumask_copy(wq_unbound_cpumask, cpumask);\n\t\tret = workqueue_apply_unbound_cpumask();\n\n\t\t/* restore the wq_unbound_cpumask when failed. */\n\t\tif (ret < 0)\n\t\t\tcpumask_copy(wq_unbound_cpumask, saved_cpumask);\n\n\t\tapply_wqattrs_unlock();\n\t}\n\n\tfree_cpumask_var(saved_cpumask);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t wq_unbound_cpumask;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t wq_unbound_cpumask;\n\nint workqueue_set_unbound_cpumask(cpumask_var_t cpumask)\n{\n\tint ret = -EINVAL;\n\tcpumask_var_t saved_cpumask;\n\n\tif (!zalloc_cpumask_var(&saved_cpumask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Not excluding isolated cpus on purpose.\n\t * If the user wishes to include them, we allow that.\n\t */\n\tcpumask_and(cpumask, cpumask, cpu_possible_mask);\n\tif (!cpumask_empty(cpumask)) {\n\t\tapply_wqattrs_lock();\n\n\t\t/* save the old wq_unbound_cpumask. */\n\t\tcpumask_copy(saved_cpumask, wq_unbound_cpumask);\n\n\t\t/* update wq_unbound_cpumask at first and apply it to wqs. */\n\t\tcpumask_copy(wq_unbound_cpumask, cpumask);\n\t\tret = workqueue_apply_unbound_cpumask();\n\n\t\t/* restore the wq_unbound_cpumask when failed. */\n\t\tif (ret < 0)\n\t\t\tcpumask_copy(wq_unbound_cpumask, saved_cpumask);\n\n\t\tapply_wqattrs_unlock();\n\t}\n\n\tfree_cpumask_var(saved_cpumask);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_parse",
          "args": [
            "buf",
            "cpumask"
          ],
          "line": 5370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&cpumask",
            "GFP_KERNEL"
          ],
          "line": 5367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic ssize_t wq_unbound_cpumask_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tcpumask_var_t cpumask;\n\tint ret;\n\n\tif (!zalloc_cpumask_var(&cpumask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tret = cpumask_parse(buf, cpumask);\n\tif (!ret)\n\t\tret = workqueue_set_unbound_cpumask(cpumask);\n\n\tfree_cpumask_var(cpumask);\n\treturn ret ? ret : count;\n}"
  },
  {
    "function_name": "wq_unbound_cpumask_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5348-5359",
    "snippet": "static ssize_t wq_unbound_cpumask_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tint written;\n\n\tmutex_lock(&wq_pool_mutex);\n\twritten = scnprintf(buf, PAGE_SIZE, \"%*pb\\n\",\n\t\t\t    cpumask_pr_args(wq_unbound_cpumask));\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn written;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static cpumask_var_t wq_unbound_cpumask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5356
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%*pb\\n\"",
            "cpumask_pr_args(wq_unbound_cpumask)"
          ],
          "line": 5354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "wq_unbound_cpumask"
          ],
          "line": 5355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5353
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic cpumask_var_t wq_unbound_cpumask;\n\nstatic ssize_t wq_unbound_cpumask_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tint written;\n\n\tmutex_lock(&wq_pool_mutex);\n\twritten = scnprintf(buf, PAGE_SIZE, \"%*pb\\n\",\n\t\t\t    cpumask_pr_args(wq_unbound_cpumask));\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn written;\n}"
  },
  {
    "function_name": "wq_numa_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5310-5333",
    "snippet": "static ssize_t wq_numa_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tstruct workqueue_attrs *attrs;\n\tint v, ret = -ENOMEM;\n\n\tapply_wqattrs_lock();\n\n\tattrs = wq_sysfs_prep_attrs(wq);\n\tif (!attrs)\n\t\tgoto out_unlock;\n\n\tret = -EINVAL;\n\tif (sscanf(buf, \"%d\", &v) == 1) {\n\t\tattrs->no_numa = !v;\n\t\tret = apply_workqueue_attrs_locked(wq, attrs);\n\t}\n\nout_unlock:\n\tapply_wqattrs_unlock();\n\tfree_workqueue_attrs(attrs);\n\treturn ret ?: count;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_workqueue_attrs",
          "args": [
            "attrs"
          ],
          "line": 5331
        },
        "resolved": true,
        "details": {
          "function_name": "free_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3209-3215",
          "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_unlock",
          "args": [],
          "line": 5330
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3821-3825",
          "snippet": "static void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tput_online_cpus();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\n\nstatic void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tput_online_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_workqueue_attrs_locked",
          "args": [
            "wq",
            "attrs"
          ],
          "line": 5326
        },
        "resolved": true,
        "details": {
          "function_name": "apply_workqueue_attrs_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3827-3853",
          "snippet": "static int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%d\"",
            "&v"
          ],
          "line": 5324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wq_sysfs_prep_attrs",
          "args": [
            "wq"
          ],
          "line": 5319
        },
        "resolved": true,
        "details": {
          "function_name": "wq_sysfs_prep_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5220-5232",
          "snippet": "static struct workqueue_attrs *wq_sysfs_prep_attrs(struct workqueue_struct *wq)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tattrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!attrs)\n\t\treturn NULL;\n\n\tcopy_workqueue_attrs(attrs, wq->unbound_attrs);\n\treturn attrs;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_attrs *wq_sysfs_prep_attrs(struct workqueue_struct *wq)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tattrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!attrs)\n\t\treturn NULL;\n\n\tcopy_workqueue_attrs(attrs, wq->unbound_attrs);\n\treturn attrs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_lock",
          "args": [],
          "line": 5317
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3814-3819",
          "snippet": "static void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tget_online_cpus();\n\tmutex_lock(&wq_pool_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\n\nstatic void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tget_online_cpus();\n\tmutex_lock(&wq_pool_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5313
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5140-5145",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic ssize_t wq_numa_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tstruct workqueue_attrs *attrs;\n\tint v, ret = -ENOMEM;\n\n\tapply_wqattrs_lock();\n\n\tattrs = wq_sysfs_prep_attrs(wq);\n\tif (!attrs)\n\t\tgoto out_unlock;\n\n\tret = -EINVAL;\n\tif (sscanf(buf, \"%d\", &v) == 1) {\n\t\tattrs->no_numa = !v;\n\t\tret = apply_workqueue_attrs_locked(wq, attrs);\n\t}\n\nout_unlock:\n\tapply_wqattrs_unlock();\n\tfree_workqueue_attrs(attrs);\n\treturn ret ?: count;\n}"
  },
  {
    "function_name": "wq_numa_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5296-5308",
    "snippet": "static ssize_t wq_numa_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tint written;\n\n\tmutex_lock(&wq->mutex);\n\twritten = scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\t    !wq->unbound_attrs->no_numa);\n\tmutex_unlock(&wq->mutex);\n\n\treturn written;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq->mutex"
          ],
          "line": 5305
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%d\\n\"",
            "!wq->unbound_attrs->no_numa"
          ],
          "line": 5303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 5302
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5299
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5140-5145",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic ssize_t wq_numa_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tint written;\n\n\tmutex_lock(&wq->mutex);\n\twritten = scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\t    !wq->unbound_attrs->no_numa);\n\tmutex_unlock(&wq->mutex);\n\n\treturn written;\n}"
  },
  {
    "function_name": "wq_cpumask_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5272-5294",
    "snippet": "static ssize_t wq_cpumask_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tstruct workqueue_attrs *attrs;\n\tint ret = -ENOMEM;\n\n\tapply_wqattrs_lock();\n\n\tattrs = wq_sysfs_prep_attrs(wq);\n\tif (!attrs)\n\t\tgoto out_unlock;\n\n\tret = cpumask_parse(buf, attrs->cpumask);\n\tif (!ret)\n\t\tret = apply_workqueue_attrs_locked(wq, attrs);\n\nout_unlock:\n\tapply_wqattrs_unlock();\n\tfree_workqueue_attrs(attrs);\n\treturn ret ?: count;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_workqueue_attrs",
          "args": [
            "attrs"
          ],
          "line": 5292
        },
        "resolved": true,
        "details": {
          "function_name": "free_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3209-3215",
          "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_unlock",
          "args": [],
          "line": 5291
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3821-3825",
          "snippet": "static void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tput_online_cpus();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\n\nstatic void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tput_online_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_workqueue_attrs_locked",
          "args": [
            "wq",
            "attrs"
          ],
          "line": 5288
        },
        "resolved": true,
        "details": {
          "function_name": "apply_workqueue_attrs_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3827-3853",
          "snippet": "static int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_parse",
          "args": [
            "buf",
            "attrs->cpumask"
          ],
          "line": 5286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wq_sysfs_prep_attrs",
          "args": [
            "wq"
          ],
          "line": 5282
        },
        "resolved": true,
        "details": {
          "function_name": "wq_sysfs_prep_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5220-5232",
          "snippet": "static struct workqueue_attrs *wq_sysfs_prep_attrs(struct workqueue_struct *wq)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tattrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!attrs)\n\t\treturn NULL;\n\n\tcopy_workqueue_attrs(attrs, wq->unbound_attrs);\n\treturn attrs;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_attrs *wq_sysfs_prep_attrs(struct workqueue_struct *wq)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tattrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!attrs)\n\t\treturn NULL;\n\n\tcopy_workqueue_attrs(attrs, wq->unbound_attrs);\n\treturn attrs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_lock",
          "args": [],
          "line": 5280
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3814-3819",
          "snippet": "static void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tget_online_cpus();\n\tmutex_lock(&wq_pool_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\n\nstatic void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tget_online_cpus();\n\tmutex_lock(&wq_pool_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5276
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5140-5145",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic ssize_t wq_cpumask_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tstruct workqueue_attrs *attrs;\n\tint ret = -ENOMEM;\n\n\tapply_wqattrs_lock();\n\n\tattrs = wq_sysfs_prep_attrs(wq);\n\tif (!attrs)\n\t\tgoto out_unlock;\n\n\tret = cpumask_parse(buf, attrs->cpumask);\n\tif (!ret)\n\t\tret = apply_workqueue_attrs_locked(wq, attrs);\n\nout_unlock:\n\tapply_wqattrs_unlock();\n\tfree_workqueue_attrs(attrs);\n\treturn ret ?: count;\n}"
  },
  {
    "function_name": "wq_cpumask_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5259-5270",
    "snippet": "static ssize_t wq_cpumask_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tint written;\n\n\tmutex_lock(&wq->mutex);\n\twritten = scnprintf(buf, PAGE_SIZE, \"%*pb\\n\",\n\t\t\t    cpumask_pr_args(wq->unbound_attrs->cpumask));\n\tmutex_unlock(&wq->mutex);\n\treturn written;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq->mutex"
          ],
          "line": 5268
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%*pb\\n\"",
            "cpumask_pr_args(wq->unbound_attrs->cpumask)"
          ],
          "line": 5266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "wq->unbound_attrs->cpumask"
          ],
          "line": 5267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 5265
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5262
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5140-5145",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic ssize_t wq_cpumask_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tint written;\n\n\tmutex_lock(&wq->mutex);\n\twritten = scnprintf(buf, PAGE_SIZE, \"%*pb\\n\",\n\t\t\t    cpumask_pr_args(wq->unbound_attrs->cpumask));\n\tmutex_unlock(&wq->mutex);\n\treturn written;\n}"
  },
  {
    "function_name": "wq_nice_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5234-5257",
    "snippet": "static ssize_t wq_nice_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tstruct workqueue_attrs *attrs;\n\tint ret = -ENOMEM;\n\n\tapply_wqattrs_lock();\n\n\tattrs = wq_sysfs_prep_attrs(wq);\n\tif (!attrs)\n\t\tgoto out_unlock;\n\n\tif (sscanf(buf, \"%d\", &attrs->nice) == 1 &&\n\t    attrs->nice >= MIN_NICE && attrs->nice <= MAX_NICE)\n\t\tret = apply_workqueue_attrs_locked(wq, attrs);\n\telse\n\t\tret = -EINVAL;\n\nout_unlock:\n\tapply_wqattrs_unlock();\n\tfree_workqueue_attrs(attrs);\n\treturn ret ?: count;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_workqueue_attrs",
          "args": [
            "attrs"
          ],
          "line": 5255
        },
        "resolved": true,
        "details": {
          "function_name": "free_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3209-3215",
          "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_unlock",
          "args": [],
          "line": 5254
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3821-3825",
          "snippet": "static void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tput_online_cpus();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\n\nstatic void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tput_online_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_workqueue_attrs_locked",
          "args": [
            "wq",
            "attrs"
          ],
          "line": 5249
        },
        "resolved": true,
        "details": {
          "function_name": "apply_workqueue_attrs_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3827-3853",
          "snippet": "static int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%d\"",
            "&attrs->nice"
          ],
          "line": 5247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wq_sysfs_prep_attrs",
          "args": [
            "wq"
          ],
          "line": 5243
        },
        "resolved": true,
        "details": {
          "function_name": "wq_sysfs_prep_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5220-5232",
          "snippet": "static struct workqueue_attrs *wq_sysfs_prep_attrs(struct workqueue_struct *wq)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tattrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!attrs)\n\t\treturn NULL;\n\n\tcopy_workqueue_attrs(attrs, wq->unbound_attrs);\n\treturn attrs;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_attrs *wq_sysfs_prep_attrs(struct workqueue_struct *wq)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tattrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!attrs)\n\t\treturn NULL;\n\n\tcopy_workqueue_attrs(attrs, wq->unbound_attrs);\n\treturn attrs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_lock",
          "args": [],
          "line": 5241
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3814-3819",
          "snippet": "static void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tget_online_cpus();\n\tmutex_lock(&wq_pool_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\n\nstatic void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tget_online_cpus();\n\tmutex_lock(&wq_pool_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5237
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5140-5145",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic ssize_t wq_nice_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tstruct workqueue_attrs *attrs;\n\tint ret = -ENOMEM;\n\n\tapply_wqattrs_lock();\n\n\tattrs = wq_sysfs_prep_attrs(wq);\n\tif (!attrs)\n\t\tgoto out_unlock;\n\n\tif (sscanf(buf, \"%d\", &attrs->nice) == 1 &&\n\t    attrs->nice >= MIN_NICE && attrs->nice <= MAX_NICE)\n\t\tret = apply_workqueue_attrs_locked(wq, attrs);\n\telse\n\t\tret = -EINVAL;\n\nout_unlock:\n\tapply_wqattrs_unlock();\n\tfree_workqueue_attrs(attrs);\n\treturn ret ?: count;\n}"
  },
  {
    "function_name": "wq_sysfs_prep_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5220-5232",
    "snippet": "static struct workqueue_attrs *wq_sysfs_prep_attrs(struct workqueue_struct *wq)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tattrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!attrs)\n\t\treturn NULL;\n\n\tcopy_workqueue_attrs(attrs, wq->unbound_attrs);\n\treturn attrs;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_workqueue_attrs",
          "args": [
            "attrs",
            "wq->unbound_attrs"
          ],
          "line": 5230
        },
        "resolved": true,
        "details": {
          "function_name": "copy_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3243-3254",
          "snippet": "static void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_workqueue_attrs",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 5226
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3226-3241",
          "snippet": "struct workqueue_attrs *alloc_workqueue_attrs(gfp_t gfp_mask)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), gfp_mask);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, gfp_mask))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct workqueue_attrs *alloc_workqueue_attrs(gfp_t gfp_mask)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), gfp_mask);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, gfp_mask))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_attrs *wq_sysfs_prep_attrs(struct workqueue_struct *wq)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tattrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!attrs)\n\t\treturn NULL;\n\n\tcopy_workqueue_attrs(attrs, wq->unbound_attrs);\n\treturn attrs;\n}"
  },
  {
    "function_name": "wq_nice_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5206-5217",
    "snippet": "static ssize_t wq_nice_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tint written;\n\n\tmutex_lock(&wq->mutex);\n\twritten = scnprintf(buf, PAGE_SIZE, \"%d\\n\", wq->unbound_attrs->nice);\n\tmutex_unlock(&wq->mutex);\n\n\treturn written;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq->mutex"
          ],
          "line": 5214
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%d\\n\"",
            "wq->unbound_attrs->nice"
          ],
          "line": 5213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 5212
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5209
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5140-5145",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic ssize_t wq_nice_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tint written;\n\n\tmutex_lock(&wq->mutex);\n\twritten = scnprintf(buf, PAGE_SIZE, \"%d\\n\", wq->unbound_attrs->nice);\n\tmutex_unlock(&wq->mutex);\n\n\treturn written;\n}"
  },
  {
    "function_name": "wq_pool_ids_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5186-5204",
    "snippet": "static ssize_t wq_pool_ids_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tconst char *delim = \"\";\n\tint node, written = 0;\n\n\trcu_read_lock_sched();\n\tfor_each_node(node) {\n\t\twritten += scnprintf(buf + written, PAGE_SIZE - written,\n\t\t\t\t     \"%s%d:%d\", delim, node,\n\t\t\t\t     unbound_pwq_by_node(wq, node)->pool->id);\n\t\tdelim = \" \";\n\t}\n\twritten += scnprintf(buf + written, PAGE_SIZE - written, \"\\n\");\n\trcu_read_unlock_sched();\n\n\treturn written;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 5201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf + written",
            "PAGE_SIZE - written",
            "\"\\n\""
          ],
          "line": 5200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf + written",
            "PAGE_SIZE - written",
            "\"%s%d:%d\"",
            "delim",
            "node",
            "unbound_pwq_by_node(wq, node)->pool->id"
          ],
          "line": 5195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unbound_pwq_by_node",
          "args": [
            "wq",
            "node"
          ],
          "line": 5197
        },
        "resolved": true,
        "details": {
          "function_name": "unbound_pwq_by_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "560-575",
          "snippet": "static struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 5193
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "106-119",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5189
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5140-5145",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic ssize_t wq_pool_ids_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tconst char *delim = \"\";\n\tint node, written = 0;\n\n\trcu_read_lock_sched();\n\tfor_each_node(node) {\n\t\twritten += scnprintf(buf + written, PAGE_SIZE - written,\n\t\t\t\t     \"%s%d:%d\", delim, node,\n\t\t\t\t     unbound_pwq_by_node(wq, node)->pool->id);\n\t\tdelim = \" \";\n\t}\n\twritten += scnprintf(buf + written, PAGE_SIZE - written, \"\\n\");\n\trcu_read_unlock_sched();\n\n\treturn written;\n}"
  },
  {
    "function_name": "max_active_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5164-5176",
    "snippet": "static ssize_t max_active_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tint val;\n\n\tif (sscanf(buf, \"%d\", &val) != 1 || val <= 0)\n\t\treturn -EINVAL;\n\n\tworkqueue_set_max_active(wq, val);\n\treturn count;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "workqueue_set_max_active",
          "args": [
            "wq",
            "val"
          ],
          "line": 5174
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4232-4251",
          "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%d\"",
            "&val"
          ],
          "line": 5171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5168
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5140-5145",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic ssize_t max_active_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tint val;\n\n\tif (sscanf(buf, \"%d\", &val) != 1 || val <= 0)\n\t\treturn -EINVAL;\n\n\tworkqueue_set_max_active(wq, val);\n\treturn count;\n}"
  },
  {
    "function_name": "max_active_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5156-5162",
    "snippet": "static ssize_t max_active_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", wq->saved_max_active);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%d\\n\"",
            "wq->saved_max_active"
          ],
          "line": 5161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5159
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5140-5145",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic ssize_t max_active_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", wq->saved_max_active);\n}"
  },
  {
    "function_name": "per_cpu_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5147-5153",
    "snippet": "static ssize_t per_cpu_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", (bool)!(wq->flags & WQ_UNBOUND));\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%d\\n\"",
            "(bool)!(wq->flags & WQ_UNBOUND)"
          ],
          "line": 5152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_to_wq",
          "args": [
            "dev"
          ],
          "line": 5150
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_wq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5140-5145",
          "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic ssize_t per_cpu_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", (bool)!(wq->flags & WQ_UNBOUND));\n}"
  },
  {
    "function_name": "dev_to_wq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5140-5145",
    "snippet": "static struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structwq_device",
            "dev"
          ],
          "line": 5142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct workqueue_struct *dev_to_wq(struct device *dev)\n{\n\tstruct wq_device *wq_dev = container_of(dev, struct wq_device, dev);\n\n\treturn wq_dev->wq;\n}"
  },
  {
    "function_name": "workqueue_set_unbound_cpumask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5085-5117",
    "snippet": "int workqueue_set_unbound_cpumask(cpumask_var_t cpumask)\n{\n\tint ret = -EINVAL;\n\tcpumask_var_t saved_cpumask;\n\n\tif (!zalloc_cpumask_var(&saved_cpumask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Not excluding isolated cpus on purpose.\n\t * If the user wishes to include them, we allow that.\n\t */\n\tcpumask_and(cpumask, cpumask, cpu_possible_mask);\n\tif (!cpumask_empty(cpumask)) {\n\t\tapply_wqattrs_lock();\n\n\t\t/* save the old wq_unbound_cpumask. */\n\t\tcpumask_copy(saved_cpumask, wq_unbound_cpumask);\n\n\t\t/* update wq_unbound_cpumask at first and apply it to wqs. */\n\t\tcpumask_copy(wq_unbound_cpumask, cpumask);\n\t\tret = workqueue_apply_unbound_cpumask();\n\n\t\t/* restore the wq_unbound_cpumask when failed. */\n\t\tif (ret < 0)\n\t\t\tcpumask_copy(wq_unbound_cpumask, saved_cpumask);\n\n\t\tapply_wqattrs_unlock();\n\t}\n\n\tfree_cpumask_var(saved_cpumask);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t wq_unbound_cpumask;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "saved_cpumask"
          ],
          "line": 5115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_unlock",
          "args": [],
          "line": 5112
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3821-3825",
          "snippet": "static void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tput_online_cpus();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\n\nstatic void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tput_online_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "wq_unbound_cpumask",
            "saved_cpumask"
          ],
          "line": 5110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "workqueue_apply_unbound_cpumask",
          "args": [],
          "line": 5106
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_apply_unbound_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5039-5071",
          "snippet": "static int workqueue_apply_unbound_cpumask(void)\n{\n\tLIST_HEAD(ctxs);\n\tint ret = 0;\n\tstruct workqueue_struct *wq;\n\tstruct apply_wqattrs_ctx *ctx, *n;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tif (!(wq->flags & WQ_UNBOUND))\n\t\t\tcontinue;\n\t\t/* creating multiple pwqs breaks ordering guarantee */\n\t\tif (wq->flags & __WQ_ORDERED)\n\t\t\tcontinue;\n\n\t\tctx = apply_wqattrs_prepare(wq, wq->unbound_attrs);\n\t\tif (!ctx) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&ctx->list, &ctxs);\n\t}\n\n\tlist_for_each_entry_safe(ctx, n, &ctxs, list) {\n\t\tif (!ret)\n\t\t\tapply_wqattrs_commit(ctx);\n\t\tapply_wqattrs_cleanup(ctx);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int workqueue_apply_unbound_cpumask(void)\n{\n\tLIST_HEAD(ctxs);\n\tint ret = 0;\n\tstruct workqueue_struct *wq;\n\tstruct apply_wqattrs_ctx *ctx, *n;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tif (!(wq->flags & WQ_UNBOUND))\n\t\t\tcontinue;\n\t\t/* creating multiple pwqs breaks ordering guarantee */\n\t\tif (wq->flags & __WQ_ORDERED)\n\t\t\tcontinue;\n\n\t\tctx = apply_wqattrs_prepare(wq, wq->unbound_attrs);\n\t\tif (!ctx) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&ctx->list, &ctxs);\n\t}\n\n\tlist_for_each_entry_safe(ctx, n, &ctxs, list) {\n\t\tif (!ret)\n\t\t\tapply_wqattrs_commit(ctx);\n\t\tapply_wqattrs_cleanup(ctx);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "wq_unbound_cpumask",
            "cpumask"
          ],
          "line": 5105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "saved_cpumask",
            "wq_unbound_cpumask"
          ],
          "line": 5102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_lock",
          "args": [],
          "line": 5099
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3814-3819",
          "snippet": "static void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tget_online_cpus();\n\tmutex_lock(&wq_pool_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\n\nstatic void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tget_online_cpus();\n\tmutex_lock(&wq_pool_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cpumask"
          ],
          "line": 5098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "cpumask",
            "cpumask",
            "cpu_possible_mask"
          ],
          "line": 5097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&saved_cpumask",
            "GFP_KERNEL"
          ],
          "line": 5090
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t wq_unbound_cpumask;\n\nint workqueue_set_unbound_cpumask(cpumask_var_t cpumask)\n{\n\tint ret = -EINVAL;\n\tcpumask_var_t saved_cpumask;\n\n\tif (!zalloc_cpumask_var(&saved_cpumask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Not excluding isolated cpus on purpose.\n\t * If the user wishes to include them, we allow that.\n\t */\n\tcpumask_and(cpumask, cpumask, cpu_possible_mask);\n\tif (!cpumask_empty(cpumask)) {\n\t\tapply_wqattrs_lock();\n\n\t\t/* save the old wq_unbound_cpumask. */\n\t\tcpumask_copy(saved_cpumask, wq_unbound_cpumask);\n\n\t\t/* update wq_unbound_cpumask at first and apply it to wqs. */\n\t\tcpumask_copy(wq_unbound_cpumask, cpumask);\n\t\tret = workqueue_apply_unbound_cpumask();\n\n\t\t/* restore the wq_unbound_cpumask when failed. */\n\t\tif (ret < 0)\n\t\t\tcpumask_copy(wq_unbound_cpumask, saved_cpumask);\n\n\t\tapply_wqattrs_unlock();\n\t}\n\n\tfree_cpumask_var(saved_cpumask);\n\treturn ret;\n}"
  },
  {
    "function_name": "workqueue_apply_unbound_cpumask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5039-5071",
    "snippet": "static int workqueue_apply_unbound_cpumask(void)\n{\n\tLIST_HEAD(ctxs);\n\tint ret = 0;\n\tstruct workqueue_struct *wq;\n\tstruct apply_wqattrs_ctx *ctx, *n;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tif (!(wq->flags & WQ_UNBOUND))\n\t\t\tcontinue;\n\t\t/* creating multiple pwqs breaks ordering guarantee */\n\t\tif (wq->flags & __WQ_ORDERED)\n\t\t\tcontinue;\n\n\t\tctx = apply_wqattrs_prepare(wq, wq->unbound_attrs);\n\t\tif (!ctx) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&ctx->list, &ctxs);\n\t}\n\n\tlist_for_each_entry_safe(ctx, n, &ctxs, list) {\n\t\tif (!ret)\n\t\t\tapply_wqattrs_commit(ctx);\n\t\tapply_wqattrs_cleanup(ctx);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static LIST_HEAD(workqueues);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply_wqattrs_cleanup",
          "args": [
            "ctx"
          ],
          "line": 5067
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3706-3719",
          "snippet": "static void apply_wqattrs_cleanup(struct apply_wqattrs_ctx *ctx)\n{\n\tif (ctx) {\n\t\tint node;\n\n\t\tfor_each_node(node)\n\t\t\tput_pwq_unlocked(ctx->pwq_tbl[node]);\n\t\tput_pwq_unlocked(ctx->dfl_pwq);\n\n\t\tfree_workqueue_attrs(ctx->attrs);\n\n\t\tkfree(ctx);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void apply_wqattrs_cleanup(struct apply_wqattrs_ctx *ctx)\n{\n\tif (ctx) {\n\t\tint node;\n\n\t\tfor_each_node(node)\n\t\t\tput_pwq_unlocked(ctx->pwq_tbl[node]);\n\t\tput_pwq_unlocked(ctx->dfl_pwq);\n\n\t\tfree_workqueue_attrs(ctx->attrs);\n\n\t\tkfree(ctx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_commit",
          "args": [
            "ctx"
          ],
          "line": 5066
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3793-3812",
          "snippet": "static void apply_wqattrs_commit(struct apply_wqattrs_ctx *ctx)\n{\n\tint node;\n\n\t/* all pwqs have been created successfully, let's install'em */\n\tmutex_lock(&ctx->wq->mutex);\n\n\tcopy_workqueue_attrs(ctx->wq->unbound_attrs, ctx->attrs);\n\n\t/* save the previous pwq and install the new one */\n\tfor_each_node(node)\n\t\tctx->pwq_tbl[node] = numa_pwq_tbl_install(ctx->wq, node,\n\t\t\t\t\t\t\t  ctx->pwq_tbl[node]);\n\n\t/* @dfl_pwq might not have been used, ensure it's linked */\n\tlink_pwq(ctx->dfl_pwq);\n\tswap(ctx->wq->dfl_pwq, ctx->dfl_pwq);\n\n\tmutex_unlock(&ctx->wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void apply_wqattrs_commit(struct apply_wqattrs_ctx *ctx)\n{\n\tint node;\n\n\t/* all pwqs have been created successfully, let's install'em */\n\tmutex_lock(&ctx->wq->mutex);\n\n\tcopy_workqueue_attrs(ctx->wq->unbound_attrs, ctx->attrs);\n\n\t/* save the previous pwq and install the new one */\n\tfor_each_node(node)\n\t\tctx->pwq_tbl[node] = numa_pwq_tbl_install(ctx->wq, node,\n\t\t\t\t\t\t\t  ctx->pwq_tbl[node]);\n\n\t/* @dfl_pwq might not have been used, ensure it's linked */\n\tlink_pwq(ctx->dfl_pwq);\n\tswap(ctx->wq->dfl_pwq, ctx->dfl_pwq);\n\n\tmutex_unlock(&ctx->wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ctx",
            "n",
            "&ctxs",
            "list"
          ],
          "line": 5064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ctx->list",
            "&ctxs"
          ],
          "line": 5061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_prepare",
          "args": [
            "wq",
            "wq->unbound_attrs"
          ],
          "line": 5055
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3722-3790",
          "snippet": "static struct apply_wqattrs_ctx *\napply_wqattrs_prepare(struct workqueue_struct *wq,\n\t\t      const struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\tstruct workqueue_attrs *new_attrs, *tmp_attrs;\n\tint node;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tctx = kzalloc(struct_size(ctx, pwq_tbl, nr_node_ids), GFP_KERNEL);\n\n\tnew_attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\ttmp_attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!ctx || !new_attrs || !tmp_attrs)\n\t\tgoto out_free;\n\n\t/*\n\t * Calculate the attrs of the default pwq.\n\t * If the user configured cpumask doesn't overlap with the\n\t * wq_unbound_cpumask, we fallback to the wq_unbound_cpumask.\n\t */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, wq_unbound_cpumask);\n\tif (unlikely(cpumask_empty(new_attrs->cpumask)))\n\t\tcpumask_copy(new_attrs->cpumask, wq_unbound_cpumask);\n\n\t/*\n\t * We may create multiple pwqs with differing cpumasks.  Make a\n\t * copy of @new_attrs which will be modified and used to obtain\n\t * pools.\n\t */\n\tcopy_workqueue_attrs(tmp_attrs, new_attrs);\n\n\t/*\n\t * If something goes wrong during CPU up/down, we'll fall back to\n\t * the default pwq covering whole @attrs->cpumask.  Always create\n\t * it even if we don't use it immediately.\n\t */\n\tctx->dfl_pwq = alloc_unbound_pwq(wq, new_attrs);\n\tif (!ctx->dfl_pwq)\n\t\tgoto out_free;\n\n\tfor_each_node(node) {\n\t\tif (wq_calc_node_cpumask(new_attrs, node, -1, tmp_attrs->cpumask)) {\n\t\t\tctx->pwq_tbl[node] = alloc_unbound_pwq(wq, tmp_attrs);\n\t\t\tif (!ctx->pwq_tbl[node])\n\t\t\t\tgoto out_free;\n\t\t} else {\n\t\t\tctx->dfl_pwq->refcnt++;\n\t\t\tctx->pwq_tbl[node] = ctx->dfl_pwq;\n\t\t}\n\t}\n\n\t/* save the user configured attrs and sanitize it. */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, cpu_possible_mask);\n\tctx->attrs = new_attrs;\n\n\tctx->wq = wq;\n\tfree_workqueue_attrs(tmp_attrs);\n\treturn ctx;\n\nout_free:\n\tfree_workqueue_attrs(tmp_attrs);\n\tfree_workqueue_attrs(new_attrs);\n\tapply_wqattrs_cleanup(ctx);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static cpumask_var_t wq_unbound_cpumask;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic cpumask_var_t wq_unbound_cpumask;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct apply_wqattrs_ctx *\napply_wqattrs_prepare(struct workqueue_struct *wq,\n\t\t      const struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\tstruct workqueue_attrs *new_attrs, *tmp_attrs;\n\tint node;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tctx = kzalloc(struct_size(ctx, pwq_tbl, nr_node_ids), GFP_KERNEL);\n\n\tnew_attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\ttmp_attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!ctx || !new_attrs || !tmp_attrs)\n\t\tgoto out_free;\n\n\t/*\n\t * Calculate the attrs of the default pwq.\n\t * If the user configured cpumask doesn't overlap with the\n\t * wq_unbound_cpumask, we fallback to the wq_unbound_cpumask.\n\t */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, wq_unbound_cpumask);\n\tif (unlikely(cpumask_empty(new_attrs->cpumask)))\n\t\tcpumask_copy(new_attrs->cpumask, wq_unbound_cpumask);\n\n\t/*\n\t * We may create multiple pwqs with differing cpumasks.  Make a\n\t * copy of @new_attrs which will be modified and used to obtain\n\t * pools.\n\t */\n\tcopy_workqueue_attrs(tmp_attrs, new_attrs);\n\n\t/*\n\t * If something goes wrong during CPU up/down, we'll fall back to\n\t * the default pwq covering whole @attrs->cpumask.  Always create\n\t * it even if we don't use it immediately.\n\t */\n\tctx->dfl_pwq = alloc_unbound_pwq(wq, new_attrs);\n\tif (!ctx->dfl_pwq)\n\t\tgoto out_free;\n\n\tfor_each_node(node) {\n\t\tif (wq_calc_node_cpumask(new_attrs, node, -1, tmp_attrs->cpumask)) {\n\t\t\tctx->pwq_tbl[node] = alloc_unbound_pwq(wq, tmp_attrs);\n\t\t\tif (!ctx->pwq_tbl[node])\n\t\t\t\tgoto out_free;\n\t\t} else {\n\t\t\tctx->dfl_pwq->refcnt++;\n\t\t\tctx->pwq_tbl[node] = ctx->dfl_pwq;\n\t\t}\n\t}\n\n\t/* save the user configured attrs and sanitize it. */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, cpu_possible_mask);\n\tctx->attrs = new_attrs;\n\n\tctx->wq = wq;\n\tfree_workqueue_attrs(tmp_attrs);\n\treturn ctx;\n\nout_free:\n\tfree_workqueue_attrs(tmp_attrs);\n\tfree_workqueue_attrs(new_attrs);\n\tapply_wqattrs_cleanup(ctx);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "wq",
            "&workqueues",
            "list"
          ],
          "line": 5048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "ctxs"
          ],
          "line": 5041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int workqueue_apply_unbound_cpumask(void)\n{\n\tLIST_HEAD(ctxs);\n\tint ret = 0;\n\tstruct workqueue_struct *wq;\n\tstruct apply_wqattrs_ctx *ctx, *n;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tif (!(wq->flags & WQ_UNBOUND))\n\t\t\tcontinue;\n\t\t/* creating multiple pwqs breaks ordering guarantee */\n\t\tif (wq->flags & __WQ_ORDERED)\n\t\t\tcontinue;\n\n\t\tctx = apply_wqattrs_prepare(wq, wq->unbound_attrs);\n\t\tif (!ctx) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&ctx->list, &ctxs);\n\t}\n\n\tlist_for_each_entry_safe(ctx, n, &ctxs, list) {\n\t\tif (!ret)\n\t\t\tapply_wqattrs_commit(ctx);\n\t\tapply_wqattrs_cleanup(ctx);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "thaw_workqueues",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "5014-5036",
    "snippet": "void thaw_workqueues(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tif (!workqueue_freezing)\n\t\tgoto out_unlock;\n\n\tworkqueue_freezing = false;\n\n\t/* restore max_active and repopulate worklist */\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tmutex_lock(&wq->mutex);\n\t\tfor_each_pwq(pwq, wq)\n\t\t\tpwq_adjust_max_active(pwq);\n\t\tmutex_unlock(&wq->mutex);\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq_pool_mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static LIST_HEAD(workqueues);",
      "static bool workqueue_freezing;",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5035
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwq_adjust_max_active",
          "args": [
            "pwq"
          ],
          "line": 5030
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_adjust_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3524-3562",
          "snippet": "static void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->delayed_works) &&\n\t\t       pwq->nr_active < pwq->max_active)\n\t\t\tpwq_activate_first_delayed(pwq);\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped.  It's a slow path.  Do it always.\n\t\t */\n\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool workqueue_freezing;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->delayed_works) &&\n\t\t       pwq->nr_active < pwq->max_active)\n\t\t\tpwq_activate_first_delayed(pwq);\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped.  It's a slow path.  Do it always.\n\t\t */\n\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 5029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 5028
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "wq",
            "&workqueues",
            "list"
          ],
          "line": 5027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid thaw_workqueues(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tif (!workqueue_freezing)\n\t\tgoto out_unlock;\n\n\tworkqueue_freezing = false;\n\n\t/* restore max_active and repopulate worklist */\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tmutex_lock(&wq->mutex);\n\t\tfor_each_pwq(pwq, wq)\n\t\t\tpwq_adjust_max_active(pwq);\n\t\tmutex_unlock(&wq->mutex);\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq_pool_mutex);\n}"
  },
  {
    "function_name": "freeze_workqueues_busy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4972-5003",
    "snippet": "bool freeze_workqueues_busy(void)\n{\n\tbool busy = false;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tWARN_ON_ONCE(!workqueue_freezing);\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tif (!(wq->flags & WQ_FREEZABLE))\n\t\t\tcontinue;\n\t\t/*\n\t\t * nr_active is monotonically decreasing.  It's safe\n\t\t * to peek without lock.\n\t\t */\n\t\trcu_read_lock_sched();\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tWARN_ON_ONCE(pwq->nr_active < 0);\n\t\t\tif (pwq->nr_active) {\n\t\t\t\tbusy = true;\n\t\t\t\trcu_read_unlock_sched();\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock_sched();\n\t}\nout_unlock:\n\tmutex_unlock(&wq_pool_mutex);\n\treturn busy;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static LIST_HEAD(workqueues);",
      "static bool workqueue_freezing;",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 5001
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 4998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 4994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pwq->nr_active < 0"
          ],
          "line": 4991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 4990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 4989
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "106-119",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "wq",
            "&workqueues",
            "list"
          ],
          "line": 4982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!workqueue_freezing"
          ],
          "line": 4980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 4978
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool freeze_workqueues_busy(void)\n{\n\tbool busy = false;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tWARN_ON_ONCE(!workqueue_freezing);\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tif (!(wq->flags & WQ_FREEZABLE))\n\t\t\tcontinue;\n\t\t/*\n\t\t * nr_active is monotonically decreasing.  It's safe\n\t\t * to peek without lock.\n\t\t */\n\t\trcu_read_lock_sched();\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tWARN_ON_ONCE(pwq->nr_active < 0);\n\t\t\tif (pwq->nr_active) {\n\t\t\t\tbusy = true;\n\t\t\t\trcu_read_unlock_sched();\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock_sched();\n\t}\nout_unlock:\n\tmutex_unlock(&wq_pool_mutex);\n\treturn busy;\n}"
  },
  {
    "function_name": "freeze_workqueues_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4939-4957",
    "snippet": "void freeze_workqueues_begin(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tWARN_ON_ONCE(workqueue_freezing);\n\tworkqueue_freezing = true;\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tmutex_lock(&wq->mutex);\n\t\tfor_each_pwq(pwq, wq)\n\t\t\tpwq_adjust_max_active(pwq);\n\t\tmutex_unlock(&wq->mutex);\n\t}\n\n\tmutex_unlock(&wq_pool_mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static LIST_HEAD(workqueues);",
      "static bool workqueue_freezing;",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 4956
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwq_adjust_max_active",
          "args": [
            "pwq"
          ],
          "line": 4952
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_adjust_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3524-3562",
          "snippet": "static void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->delayed_works) &&\n\t\t       pwq->nr_active < pwq->max_active)\n\t\t\tpwq_activate_first_delayed(pwq);\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped.  It's a slow path.  Do it always.\n\t\t */\n\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool workqueue_freezing;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->delayed_works) &&\n\t\t       pwq->nr_active < pwq->max_active)\n\t\t\tpwq_activate_first_delayed(pwq);\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped.  It's a slow path.  Do it always.\n\t\t */\n\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 4951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 4950
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "wq",
            "&workqueues",
            "list"
          ],
          "line": 4949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "workqueue_freezing"
          ],
          "line": 4946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid freeze_workqueues_begin(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tWARN_ON_ONCE(workqueue_freezing);\n\tworkqueue_freezing = true;\n\n\tlist_for_each_entry(wq, &workqueues, list) {\n\t\tmutex_lock(&wq->mutex);\n\t\tfor_each_pwq(pwq, wq)\n\t\t\tpwq_adjust_max_active(pwq);\n\t\tmutex_unlock(&wq->mutex);\n\t}\n\n\tmutex_unlock(&wq_pool_mutex);\n}"
  },
  {
    "function_name": "work_on_cpu_safe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4914-4923",
    "snippet": "long work_on_cpu_safe(int cpu, long (*fn)(void *), void *arg)\n{\n\tlong ret = -ENODEV;\n\n\tget_online_cpus();\n\tif (cpu_online(cpu))\n\t\tret = work_on_cpu(cpu, fn, arg);\n\tput_online_cpus();\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 4921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_on_cpu",
          "args": [
            "cpu",
            "fn",
            "arg"
          ],
          "line": 4920
        },
        "resolved": true,
        "details": {
          "function_name": "work_on_cpu_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4914-4923",
          "snippet": "long work_on_cpu_safe(int cpu, long (*fn)(void *), void *arg)\n{\n\tlong ret = -ENODEV;\n\n\tget_online_cpus();\n\tif (cpu_online(cpu))\n\t\tret = work_on_cpu(cpu, fn, arg);\n\tput_online_cpus();\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 4919
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 4918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nlong work_on_cpu_safe(int cpu, long (*fn)(void *), void *arg)\n{\n\tlong ret = -ENODEV;\n\n\tget_online_cpus();\n\tif (cpu_online(cpu))\n\t\tret = work_on_cpu(cpu, fn, arg);\n\tput_online_cpus();\n\treturn ret;\n}"
  },
  {
    "function_name": "work_on_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4891-4900",
    "snippet": "long work_on_cpu(int cpu, long (*fn)(void *), void *arg)\n{\n\tstruct work_for_cpu wfc = { .fn = fn, .arg = arg };\n\n\tINIT_WORK_ONSTACK(&wfc.work, work_for_cpu_fn);\n\tschedule_work_on(cpu, &wfc.work);\n\tflush_work(&wfc.work);\n\tdestroy_work_on_stack(&wfc.work);\n\treturn wfc.ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_work_on_stack",
          "args": [
            "&wfc.work"
          ],
          "line": 4898
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_work_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "508-511",
          "snippet": "void destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&wfc.work"
          ],
          "line": 4897
        },
        "resolved": true,
        "details": {
          "function_name": "flush_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2936-2939",
          "snippet": "bool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_work_on",
          "args": [
            "cpu",
            "&wfc.work"
          ],
          "line": 4896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK_ONSTACK",
          "args": [
            "&wfc.work",
            "work_for_cpu_fn"
          ],
          "line": 4895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nlong work_on_cpu(int cpu, long (*fn)(void *), void *arg)\n{\n\tstruct work_for_cpu wfc = { .fn = fn, .arg = arg };\n\n\tINIT_WORK_ONSTACK(&wfc.work, work_for_cpu_fn);\n\tschedule_work_on(cpu, &wfc.work);\n\tflush_work(&wfc.work);\n\tdestroy_work_on_stack(&wfc.work);\n\treturn wfc.ret;\n}"
  },
  {
    "function_name": "work_for_cpu_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4873-4878",
    "snippet": "static void work_for_cpu_fn(struct work_struct *work)\n{\n\tstruct work_for_cpu *wfc = container_of(work, struct work_for_cpu, work);\n\n\twfc->ret = wfc->fn(wfc->arg);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wfc->fn",
          "args": [
            "wfc->arg"
          ],
          "line": 4877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structwork_for_cpu",
            "work"
          ],
          "line": 4875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void work_for_cpu_fn(struct work_struct *work)\n{\n\tstruct work_for_cpu *wfc = container_of(work, struct work_for_cpu, work);\n\n\twfc->ret = wfc->fn(wfc->arg);\n}"
  },
  {
    "function_name": "workqueue_offline_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4847-4864",
    "snippet": "int workqueue_offline_cpu(unsigned int cpu)\n{\n\tstruct workqueue_struct *wq;\n\n\t/* unbinding per-cpu workers should happen on the local CPU */\n\tif (WARN_ON(cpu != smp_processor_id()))\n\t\treturn -1;\n\n\tunbind_workers(cpu);\n\n\t/* update NUMA affinity of unbound workqueues */\n\tmutex_lock(&wq_pool_mutex);\n\tlist_for_each_entry(wq, &workqueues, list)\n\t\twq_update_unbound_numa(wq, cpu, false);\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static LIST_HEAD(workqueues);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 4861
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_update_unbound_numa",
          "args": [
            "wq",
            "cpu",
            "false"
          ],
          "line": 4860
        },
        "resolved": true,
        "details": {
          "function_name": "wq_update_unbound_numa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3906-3967",
          "snippet": "static void wq_update_unbound_numa(struct workqueue_struct *wq, int cpu,\n\t\t\t\t   bool online)\n{\n\tint node = cpu_to_node(cpu);\n\tint cpu_off = online ? -1 : cpu;\n\tstruct pool_workqueue *old_pwq = NULL, *pwq;\n\tstruct workqueue_attrs *target_attrs;\n\tcpumask_t *cpumask;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (!wq_numa_enabled || !(wq->flags & WQ_UNBOUND) ||\n\t    wq->unbound_attrs->no_numa)\n\t\treturn;\n\n\t/*\n\t * We don't wanna alloc/free wq_attrs for each wq for each CPU.\n\t * Let's use a preallocated one.  The following buf is protected by\n\t * CPU hotplug exclusion.\n\t */\n\ttarget_attrs = wq_update_unbound_numa_attrs_buf;\n\tcpumask = target_attrs->cpumask;\n\n\tcopy_workqueue_attrs(target_attrs, wq->unbound_attrs);\n\tpwq = unbound_pwq_by_node(wq, node);\n\n\t/*\n\t * Let's determine what needs to be done.  If the target cpumask is\n\t * different from the default pwq's, we need to compare it to @pwq's\n\t * and create a new one if they don't match.  If the target cpumask\n\t * equals the default pwq's, the default pwq should be used.\n\t */\n\tif (wq_calc_node_cpumask(wq->dfl_pwq->pool->attrs, node, cpu_off, cpumask)) {\n\t\tif (cpumask_equal(cpumask, pwq->pool->attrs->cpumask))\n\t\t\treturn;\n\t} else {\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* create a new pwq */\n\tpwq = alloc_unbound_pwq(wq, target_attrs);\n\tif (!pwq) {\n\t\tpr_warn(\"workqueue: allocation failed while updating NUMA affinity of \\\"%s\\\"\\n\",\n\t\t\twq->name);\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* Install the new pwq. */\n\tmutex_lock(&wq->mutex);\n\told_pwq = numa_pwq_tbl_install(wq, node, pwq);\n\tgoto out_unlock;\n\nuse_dfl_pwq:\n\tmutex_lock(&wq->mutex);\n\tspin_lock_irq(&wq->dfl_pwq->pool->lock);\n\tget_pwq(wq->dfl_pwq);\n\tspin_unlock_irq(&wq->dfl_pwq->pool->lock);\n\told_pwq = numa_pwq_tbl_install(wq, node, wq->dfl_pwq);\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n\tput_pwq_unlocked(old_pwq);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_numa_enabled;",
            "static struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;",
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_numa_enabled;\nstatic struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void wq_update_unbound_numa(struct workqueue_struct *wq, int cpu,\n\t\t\t\t   bool online)\n{\n\tint node = cpu_to_node(cpu);\n\tint cpu_off = online ? -1 : cpu;\n\tstruct pool_workqueue *old_pwq = NULL, *pwq;\n\tstruct workqueue_attrs *target_attrs;\n\tcpumask_t *cpumask;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (!wq_numa_enabled || !(wq->flags & WQ_UNBOUND) ||\n\t    wq->unbound_attrs->no_numa)\n\t\treturn;\n\n\t/*\n\t * We don't wanna alloc/free wq_attrs for each wq for each CPU.\n\t * Let's use a preallocated one.  The following buf is protected by\n\t * CPU hotplug exclusion.\n\t */\n\ttarget_attrs = wq_update_unbound_numa_attrs_buf;\n\tcpumask = target_attrs->cpumask;\n\n\tcopy_workqueue_attrs(target_attrs, wq->unbound_attrs);\n\tpwq = unbound_pwq_by_node(wq, node);\n\n\t/*\n\t * Let's determine what needs to be done.  If the target cpumask is\n\t * different from the default pwq's, we need to compare it to @pwq's\n\t * and create a new one if they don't match.  If the target cpumask\n\t * equals the default pwq's, the default pwq should be used.\n\t */\n\tif (wq_calc_node_cpumask(wq->dfl_pwq->pool->attrs, node, cpu_off, cpumask)) {\n\t\tif (cpumask_equal(cpumask, pwq->pool->attrs->cpumask))\n\t\t\treturn;\n\t} else {\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* create a new pwq */\n\tpwq = alloc_unbound_pwq(wq, target_attrs);\n\tif (!pwq) {\n\t\tpr_warn(\"workqueue: allocation failed while updating NUMA affinity of \\\"%s\\\"\\n\",\n\t\t\twq->name);\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* Install the new pwq. */\n\tmutex_lock(&wq->mutex);\n\told_pwq = numa_pwq_tbl_install(wq, node, pwq);\n\tgoto out_unlock;\n\nuse_dfl_pwq:\n\tmutex_lock(&wq->mutex);\n\tspin_lock_irq(&wq->dfl_pwq->pool->lock);\n\tget_pwq(wq->dfl_pwq);\n\tspin_unlock_irq(&wq->dfl_pwq->pool->lock);\n\told_pwq = numa_pwq_tbl_install(wq, node, wq->dfl_pwq);\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n\tput_pwq_unlocked(old_pwq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "wq",
            "&workqueues",
            "list"
          ],
          "line": 4859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 4858
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unbind_workers",
          "args": [
            "cpu"
          ],
          "line": 4855
        },
        "resolved": true,
        "details": {
          "function_name": "unbind_workers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4661-4712",
          "snippet": "static void unbind_workers(int cpu)\n{\n\tstruct worker_pool *pool;\n\tstruct worker *worker;\n\n\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\tmutex_lock(&wq_pool_attach_mutex);\n\t\tspin_lock_irq(&pool->lock);\n\n\t\t/*\n\t\t * We've blocked all attach/detach operations. Make all workers\n\t\t * unbound and set DISASSOCIATED.  Before this, all workers\n\t\t * except for the ones which are still executing works from\n\t\t * before the last CPU down must be on the cpu.  After\n\t\t * this, they may become diasporas.\n\t\t */\n\t\tfor_each_pool_worker(worker, pool)\n\t\t\tworker->flags |= WORKER_UNBOUND;\n\n\t\tpool->flags |= POOL_DISASSOCIATED;\n\n\t\tspin_unlock_irq(&pool->lock);\n\t\tmutex_unlock(&wq_pool_attach_mutex);\n\n\t\t/*\n\t\t * Call schedule() so that we cross rq->lock and thus can\n\t\t * guarantee sched callbacks see the %WORKER_UNBOUND flag.\n\t\t * This is necessary as scheduler callbacks may be invoked\n\t\t * from other cpus.\n\t\t */\n\t\tschedule();\n\n\t\t/*\n\t\t * Sched callbacks are disabled now.  Zap nr_running.\n\t\t * After this, nr_running stays zero and need_more_worker()\n\t\t * and keep_working() are always true as long as the\n\t\t * worklist is not empty.  This pool now behaves as an\n\t\t * unbound (in terms of concurrency management) pool which\n\t\t * are served by workers tied to the pool.\n\t\t */\n\t\tatomic_set(&pool->nr_running, 0);\n\n\t\t/*\n\t\t * With concurrency management just turned off, a busy\n\t\t * worker blocking could lead to lengthy stalls.  Kick off\n\t\t * unbound chain execution of currently pending work items.\n\t\t */\n\t\tspin_lock_irq(&pool->lock);\n\t\twake_up_worker(pool);\n\t\tspin_unlock_irq(&pool->lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void unbind_workers(int cpu)\n{\n\tstruct worker_pool *pool;\n\tstruct worker *worker;\n\n\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\tmutex_lock(&wq_pool_attach_mutex);\n\t\tspin_lock_irq(&pool->lock);\n\n\t\t/*\n\t\t * We've blocked all attach/detach operations. Make all workers\n\t\t * unbound and set DISASSOCIATED.  Before this, all workers\n\t\t * except for the ones which are still executing works from\n\t\t * before the last CPU down must be on the cpu.  After\n\t\t * this, they may become diasporas.\n\t\t */\n\t\tfor_each_pool_worker(worker, pool)\n\t\t\tworker->flags |= WORKER_UNBOUND;\n\n\t\tpool->flags |= POOL_DISASSOCIATED;\n\n\t\tspin_unlock_irq(&pool->lock);\n\t\tmutex_unlock(&wq_pool_attach_mutex);\n\n\t\t/*\n\t\t * Call schedule() so that we cross rq->lock and thus can\n\t\t * guarantee sched callbacks see the %WORKER_UNBOUND flag.\n\t\t * This is necessary as scheduler callbacks may be invoked\n\t\t * from other cpus.\n\t\t */\n\t\tschedule();\n\n\t\t/*\n\t\t * Sched callbacks are disabled now.  Zap nr_running.\n\t\t * After this, nr_running stays zero and need_more_worker()\n\t\t * and keep_working() are always true as long as the\n\t\t * worklist is not empty.  This pool now behaves as an\n\t\t * unbound (in terms of concurrency management) pool which\n\t\t * are served by workers tied to the pool.\n\t\t */\n\t\tatomic_set(&pool->nr_running, 0);\n\n\t\t/*\n\t\t * With concurrency management just turned off, a busy\n\t\t * worker blocking could lead to lengthy stalls.  Kick off\n\t\t * unbound chain execution of currently pending work items.\n\t\t */\n\t\tspin_lock_irq(&pool->lock);\n\t\twake_up_worker(pool);\n\t\tspin_unlock_irq(&pool->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cpu != smp_processor_id()"
          ],
          "line": 4852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 4852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nint workqueue_offline_cpu(unsigned int cpu)\n{\n\tstruct workqueue_struct *wq;\n\n\t/* unbinding per-cpu workers should happen on the local CPU */\n\tif (WARN_ON(cpu != smp_processor_id()))\n\t\treturn -1;\n\n\tunbind_workers(cpu);\n\n\t/* update NUMA affinity of unbound workqueues */\n\tmutex_lock(&wq_pool_mutex);\n\tlist_for_each_entry(wq, &workqueues, list)\n\t\twq_update_unbound_numa(wq, cpu, false);\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "workqueue_online_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4820-4845",
    "snippet": "int workqueue_online_cpu(unsigned int cpu)\n{\n\tstruct worker_pool *pool;\n\tstruct workqueue_struct *wq;\n\tint pi;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tfor_each_pool(pool, pi) {\n\t\tmutex_lock(&wq_pool_attach_mutex);\n\n\t\tif (pool->cpu == cpu)\n\t\t\trebind_workers(pool);\n\t\telse if (pool->cpu < 0)\n\t\t\trestore_unbound_workers_cpumask(pool, cpu);\n\n\t\tmutex_unlock(&wq_pool_attach_mutex);\n\t}\n\n\t/* update NUMA affinity of unbound workqueues */\n\tlist_for_each_entry(wq, &workqueues, list)\n\t\twq_update_unbound_numa(wq, cpu, true);\n\n\tmutex_unlock(&wq_pool_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static DEFINE_MUTEX(wq_pool_attach_mutex);",
      "static LIST_HEAD(workqueues);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 4843
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_update_unbound_numa",
          "args": [
            "wq",
            "cpu",
            "true"
          ],
          "line": 4841
        },
        "resolved": true,
        "details": {
          "function_name": "wq_update_unbound_numa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3906-3967",
          "snippet": "static void wq_update_unbound_numa(struct workqueue_struct *wq, int cpu,\n\t\t\t\t   bool online)\n{\n\tint node = cpu_to_node(cpu);\n\tint cpu_off = online ? -1 : cpu;\n\tstruct pool_workqueue *old_pwq = NULL, *pwq;\n\tstruct workqueue_attrs *target_attrs;\n\tcpumask_t *cpumask;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (!wq_numa_enabled || !(wq->flags & WQ_UNBOUND) ||\n\t    wq->unbound_attrs->no_numa)\n\t\treturn;\n\n\t/*\n\t * We don't wanna alloc/free wq_attrs for each wq for each CPU.\n\t * Let's use a preallocated one.  The following buf is protected by\n\t * CPU hotplug exclusion.\n\t */\n\ttarget_attrs = wq_update_unbound_numa_attrs_buf;\n\tcpumask = target_attrs->cpumask;\n\n\tcopy_workqueue_attrs(target_attrs, wq->unbound_attrs);\n\tpwq = unbound_pwq_by_node(wq, node);\n\n\t/*\n\t * Let's determine what needs to be done.  If the target cpumask is\n\t * different from the default pwq's, we need to compare it to @pwq's\n\t * and create a new one if they don't match.  If the target cpumask\n\t * equals the default pwq's, the default pwq should be used.\n\t */\n\tif (wq_calc_node_cpumask(wq->dfl_pwq->pool->attrs, node, cpu_off, cpumask)) {\n\t\tif (cpumask_equal(cpumask, pwq->pool->attrs->cpumask))\n\t\t\treturn;\n\t} else {\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* create a new pwq */\n\tpwq = alloc_unbound_pwq(wq, target_attrs);\n\tif (!pwq) {\n\t\tpr_warn(\"workqueue: allocation failed while updating NUMA affinity of \\\"%s\\\"\\n\",\n\t\t\twq->name);\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* Install the new pwq. */\n\tmutex_lock(&wq->mutex);\n\told_pwq = numa_pwq_tbl_install(wq, node, pwq);\n\tgoto out_unlock;\n\nuse_dfl_pwq:\n\tmutex_lock(&wq->mutex);\n\tspin_lock_irq(&wq->dfl_pwq->pool->lock);\n\tget_pwq(wq->dfl_pwq);\n\tspin_unlock_irq(&wq->dfl_pwq->pool->lock);\n\told_pwq = numa_pwq_tbl_install(wq, node, wq->dfl_pwq);\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n\tput_pwq_unlocked(old_pwq);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_numa_enabled;",
            "static struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;",
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_numa_enabled;\nstatic struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void wq_update_unbound_numa(struct workqueue_struct *wq, int cpu,\n\t\t\t\t   bool online)\n{\n\tint node = cpu_to_node(cpu);\n\tint cpu_off = online ? -1 : cpu;\n\tstruct pool_workqueue *old_pwq = NULL, *pwq;\n\tstruct workqueue_attrs *target_attrs;\n\tcpumask_t *cpumask;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (!wq_numa_enabled || !(wq->flags & WQ_UNBOUND) ||\n\t    wq->unbound_attrs->no_numa)\n\t\treturn;\n\n\t/*\n\t * We don't wanna alloc/free wq_attrs for each wq for each CPU.\n\t * Let's use a preallocated one.  The following buf is protected by\n\t * CPU hotplug exclusion.\n\t */\n\ttarget_attrs = wq_update_unbound_numa_attrs_buf;\n\tcpumask = target_attrs->cpumask;\n\n\tcopy_workqueue_attrs(target_attrs, wq->unbound_attrs);\n\tpwq = unbound_pwq_by_node(wq, node);\n\n\t/*\n\t * Let's determine what needs to be done.  If the target cpumask is\n\t * different from the default pwq's, we need to compare it to @pwq's\n\t * and create a new one if they don't match.  If the target cpumask\n\t * equals the default pwq's, the default pwq should be used.\n\t */\n\tif (wq_calc_node_cpumask(wq->dfl_pwq->pool->attrs, node, cpu_off, cpumask)) {\n\t\tif (cpumask_equal(cpumask, pwq->pool->attrs->cpumask))\n\t\t\treturn;\n\t} else {\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* create a new pwq */\n\tpwq = alloc_unbound_pwq(wq, target_attrs);\n\tif (!pwq) {\n\t\tpr_warn(\"workqueue: allocation failed while updating NUMA affinity of \\\"%s\\\"\\n\",\n\t\t\twq->name);\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* Install the new pwq. */\n\tmutex_lock(&wq->mutex);\n\told_pwq = numa_pwq_tbl_install(wq, node, pwq);\n\tgoto out_unlock;\n\nuse_dfl_pwq:\n\tmutex_lock(&wq->mutex);\n\tspin_lock_irq(&wq->dfl_pwq->pool->lock);\n\tget_pwq(wq->dfl_pwq);\n\tspin_unlock_irq(&wq->dfl_pwq->pool->lock);\n\told_pwq = numa_pwq_tbl_install(wq, node, wq->dfl_pwq);\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n\tput_pwq_unlocked(old_pwq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "wq",
            "&workqueues",
            "list"
          ],
          "line": 4840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_unbound_workers_cpumask",
          "args": [
            "pool",
            "cpu"
          ],
          "line": 4834
        },
        "resolved": true,
        "details": {
          "function_name": "restore_unbound_workers_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4789-4805",
          "snippet": "static void restore_unbound_workers_cpumask(struct worker_pool *pool, int cpu)\n{\n\tstatic cpumask_t cpumask;\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_attach_mutex);\n\n\t/* is @cpu allowed for @pool? */\n\tif (!cpumask_test_cpu(cpu, pool->attrs->cpumask))\n\t\treturn;\n\n\tcpumask_and(&cpumask, pool->attrs->cpumask, cpu_online_mask);\n\n\t/* as we're called from CPU_ONLINE, the following shouldn't fail */\n\tfor_each_pool_worker(worker, pool)\n\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task, &cpumask) < 0);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void restore_unbound_workers_cpumask(struct worker_pool *pool, int cpu)\n{\n\tstatic cpumask_t cpumask;\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_attach_mutex);\n\n\t/* is @cpu allowed for @pool? */\n\tif (!cpumask_test_cpu(cpu, pool->attrs->cpumask))\n\t\treturn;\n\n\tcpumask_and(&cpumask, pool->attrs->cpumask, cpu_online_mask);\n\n\t/* as we're called from CPU_ONLINE, the following shouldn't fail */\n\tfor_each_pool_worker(worker, pool)\n\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task, &cpumask) < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rebind_workers",
          "args": [
            "pool"
          ],
          "line": 4832
        },
        "resolved": true,
        "details": {
          "function_name": "rebind_workers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4720-4777",
          "snippet": "static void rebind_workers(struct worker_pool *pool)\n{\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_attach_mutex);\n\n\t/*\n\t * Restore CPU affinity of all workers.  As all idle workers should\n\t * be on the run-queue of the associated CPU before any local\n\t * wake-ups for concurrency management happen, restore CPU affinity\n\t * of all workers first and then clear UNBOUND.  As we're called\n\t * from CPU_ONLINE, the following shouldn't fail.\n\t */\n\tfor_each_pool_worker(worker, pool)\n\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task,\n\t\t\t\t\t\t  pool->attrs->cpumask) < 0);\n\n\tspin_lock_irq(&pool->lock);\n\n\tpool->flags &= ~POOL_DISASSOCIATED;\n\n\tfor_each_pool_worker(worker, pool) {\n\t\tunsigned int worker_flags = worker->flags;\n\n\t\t/*\n\t\t * A bound idle worker should actually be on the runqueue\n\t\t * of the associated CPU for local wake-ups targeting it to\n\t\t * work.  Kick all idle workers so that they migrate to the\n\t\t * associated CPU.  Doing this in the same loop as\n\t\t * replacing UNBOUND with REBOUND is safe as no worker will\n\t\t * be bound before @pool->lock is released.\n\t\t */\n\t\tif (worker_flags & WORKER_IDLE)\n\t\t\twake_up_process(worker->task);\n\n\t\t/*\n\t\t * We want to clear UNBOUND but can't directly call\n\t\t * worker_clr_flags() or adjust nr_running.  Atomically\n\t\t * replace UNBOUND with another NOT_RUNNING flag REBOUND.\n\t\t * @worker will clear REBOUND using worker_clr_flags() when\n\t\t * it initiates the next execution cycle thus restoring\n\t\t * concurrency management.  Note that when or whether\n\t\t * @worker clears REBOUND doesn't affect correctness.\n\t\t *\n\t\t * WRITE_ONCE() is necessary because @worker->flags may be\n\t\t * tested without holding any lock in\n\t\t * wq_worker_waking_up().  Without it, NOT_RUNNING test may\n\t\t * fail incorrectly leading to premature concurrency\n\t\t * management operations.\n\t\t */\n\t\tWARN_ON_ONCE(!(worker_flags & WORKER_UNBOUND));\n\t\tworker_flags |= WORKER_REBOUND;\n\t\tworker_flags &= ~WORKER_UNBOUND;\n\t\tWRITE_ONCE(worker->flags, worker_flags);\n\t}\n\n\tspin_unlock_irq(&pool->lock);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void rebind_workers(struct worker_pool *pool)\n{\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_attach_mutex);\n\n\t/*\n\t * Restore CPU affinity of all workers.  As all idle workers should\n\t * be on the run-queue of the associated CPU before any local\n\t * wake-ups for concurrency management happen, restore CPU affinity\n\t * of all workers first and then clear UNBOUND.  As we're called\n\t * from CPU_ONLINE, the following shouldn't fail.\n\t */\n\tfor_each_pool_worker(worker, pool)\n\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task,\n\t\t\t\t\t\t  pool->attrs->cpumask) < 0);\n\n\tspin_lock_irq(&pool->lock);\n\n\tpool->flags &= ~POOL_DISASSOCIATED;\n\n\tfor_each_pool_worker(worker, pool) {\n\t\tunsigned int worker_flags = worker->flags;\n\n\t\t/*\n\t\t * A bound idle worker should actually be on the runqueue\n\t\t * of the associated CPU for local wake-ups targeting it to\n\t\t * work.  Kick all idle workers so that they migrate to the\n\t\t * associated CPU.  Doing this in the same loop as\n\t\t * replacing UNBOUND with REBOUND is safe as no worker will\n\t\t * be bound before @pool->lock is released.\n\t\t */\n\t\tif (worker_flags & WORKER_IDLE)\n\t\t\twake_up_process(worker->task);\n\n\t\t/*\n\t\t * We want to clear UNBOUND but can't directly call\n\t\t * worker_clr_flags() or adjust nr_running.  Atomically\n\t\t * replace UNBOUND with another NOT_RUNNING flag REBOUND.\n\t\t * @worker will clear REBOUND using worker_clr_flags() when\n\t\t * it initiates the next execution cycle thus restoring\n\t\t * concurrency management.  Note that when or whether\n\t\t * @worker clears REBOUND doesn't affect correctness.\n\t\t *\n\t\t * WRITE_ONCE() is necessary because @worker->flags may be\n\t\t * tested without holding any lock in\n\t\t * wq_worker_waking_up().  Without it, NOT_RUNNING test may\n\t\t * fail incorrectly leading to premature concurrency\n\t\t * management operations.\n\t\t */\n\t\tWARN_ON_ONCE(!(worker_flags & WORKER_UNBOUND));\n\t\tworker_flags |= WORKER_REBOUND;\n\t\tworker_flags &= ~WORKER_UNBOUND;\n\t\tWRITE_ONCE(worker->flags, worker_flags);\n\t}\n\n\tspin_unlock_irq(&pool->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 4829
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pool",
          "args": [
            "pool",
            "pi"
          ],
          "line": 4828
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nint workqueue_online_cpu(unsigned int cpu)\n{\n\tstruct worker_pool *pool;\n\tstruct workqueue_struct *wq;\n\tint pi;\n\n\tmutex_lock(&wq_pool_mutex);\n\n\tfor_each_pool(pool, pi) {\n\t\tmutex_lock(&wq_pool_attach_mutex);\n\n\t\tif (pool->cpu == cpu)\n\t\t\trebind_workers(pool);\n\t\telse if (pool->cpu < 0)\n\t\t\trestore_unbound_workers_cpumask(pool, cpu);\n\n\t\tmutex_unlock(&wq_pool_attach_mutex);\n\t}\n\n\t/* update NUMA affinity of unbound workqueues */\n\tlist_for_each_entry(wq, &workqueues, list)\n\t\twq_update_unbound_numa(wq, cpu, true);\n\n\tmutex_unlock(&wq_pool_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "workqueue_prepare_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4807-4818",
    "snippet": "int workqueue_prepare_cpu(unsigned int cpu)\n{\n\tstruct worker_pool *pool;\n\n\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\tif (pool->nr_workers)\n\t\t\tcontinue;\n\t\tif (!create_worker(pool))\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_worker",
          "args": [
            "pool"
          ],
          "line": 4814
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_create_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1961-1990",
          "snippet": "static void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\tspin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\tspin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\tspin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\tspin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu_worker_pool",
          "args": [
            "pool",
            "cpu"
          ],
          "line": 4811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nint workqueue_prepare_cpu(unsigned int cpu)\n{\n\tstruct worker_pool *pool;\n\n\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\tif (pool->nr_workers)\n\t\t\tcontinue;\n\t\tif (!create_worker(pool))\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "restore_unbound_workers_cpumask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4789-4805",
    "snippet": "static void restore_unbound_workers_cpumask(struct worker_pool *pool, int cpu)\n{\n\tstatic cpumask_t cpumask;\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_attach_mutex);\n\n\t/* is @cpu allowed for @pool? */\n\tif (!cpumask_test_cpu(cpu, pool->attrs->cpumask))\n\t\treturn;\n\n\tcpumask_and(&cpumask, pool->attrs->cpumask, cpu_online_mask);\n\n\t/* as we're called from CPU_ONLINE, the following shouldn't fail */\n\tfor_each_pool_worker(worker, pool)\n\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task, &cpumask) < 0);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_attach_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "set_cpus_allowed_ptr(worker->task, &cpumask) < 0"
          ],
          "line": 4804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "worker->task",
            "&cpumask"
          ],
          "line": 4804
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1126-1129",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, false);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pool_worker",
          "args": [
            "worker",
            "pool"
          ],
          "line": 4803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "&cpumask",
            "pool->attrs->cpumask",
            "cpu_online_mask"
          ],
          "line": 4800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "pool->attrs->cpumask"
          ],
          "line": 4797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 4794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void restore_unbound_workers_cpumask(struct worker_pool *pool, int cpu)\n{\n\tstatic cpumask_t cpumask;\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_attach_mutex);\n\n\t/* is @cpu allowed for @pool? */\n\tif (!cpumask_test_cpu(cpu, pool->attrs->cpumask))\n\t\treturn;\n\n\tcpumask_and(&cpumask, pool->attrs->cpumask, cpu_online_mask);\n\n\t/* as we're called from CPU_ONLINE, the following shouldn't fail */\n\tfor_each_pool_worker(worker, pool)\n\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task, &cpumask) < 0);\n}"
  },
  {
    "function_name": "rebind_workers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4720-4777",
    "snippet": "static void rebind_workers(struct worker_pool *pool)\n{\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_attach_mutex);\n\n\t/*\n\t * Restore CPU affinity of all workers.  As all idle workers should\n\t * be on the run-queue of the associated CPU before any local\n\t * wake-ups for concurrency management happen, restore CPU affinity\n\t * of all workers first and then clear UNBOUND.  As we're called\n\t * from CPU_ONLINE, the following shouldn't fail.\n\t */\n\tfor_each_pool_worker(worker, pool)\n\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task,\n\t\t\t\t\t\t  pool->attrs->cpumask) < 0);\n\n\tspin_lock_irq(&pool->lock);\n\n\tpool->flags &= ~POOL_DISASSOCIATED;\n\n\tfor_each_pool_worker(worker, pool) {\n\t\tunsigned int worker_flags = worker->flags;\n\n\t\t/*\n\t\t * A bound idle worker should actually be on the runqueue\n\t\t * of the associated CPU for local wake-ups targeting it to\n\t\t * work.  Kick all idle workers so that they migrate to the\n\t\t * associated CPU.  Doing this in the same loop as\n\t\t * replacing UNBOUND with REBOUND is safe as no worker will\n\t\t * be bound before @pool->lock is released.\n\t\t */\n\t\tif (worker_flags & WORKER_IDLE)\n\t\t\twake_up_process(worker->task);\n\n\t\t/*\n\t\t * We want to clear UNBOUND but can't directly call\n\t\t * worker_clr_flags() or adjust nr_running.  Atomically\n\t\t * replace UNBOUND with another NOT_RUNNING flag REBOUND.\n\t\t * @worker will clear REBOUND using worker_clr_flags() when\n\t\t * it initiates the next execution cycle thus restoring\n\t\t * concurrency management.  Note that when or whether\n\t\t * @worker clears REBOUND doesn't affect correctness.\n\t\t *\n\t\t * WRITE_ONCE() is necessary because @worker->flags may be\n\t\t * tested without holding any lock in\n\t\t * wq_worker_waking_up().  Without it, NOT_RUNNING test may\n\t\t * fail incorrectly leading to premature concurrency\n\t\t * management operations.\n\t\t */\n\t\tWARN_ON_ONCE(!(worker_flags & WORKER_UNBOUND));\n\t\tworker_flags |= WORKER_REBOUND;\n\t\tworker_flags &= ~WORKER_UNBOUND;\n\t\tWRITE_ONCE(worker->flags, worker_flags);\n\t}\n\n\tspin_unlock_irq(&pool->lock);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_attach_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 4776
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "worker->flags",
            "worker_flags"
          ],
          "line": 4773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(worker_flags & WORKER_UNBOUND)"
          ],
          "line": 4770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "worker->task"
          ],
          "line": 4753
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pool_worker",
          "args": [
            "worker",
            "pool"
          ],
          "line": 4741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 4737
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "set_cpus_allowed_ptr(worker->task,\n\t\t\t\t\t\t  pool->attrs->cpumask) < 0"
          ],
          "line": 4734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "worker->task",
            "pool->attrs->cpumask"
          ],
          "line": 4734
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1126-1129",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, false);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pool_worker",
          "args": [
            "worker",
            "pool"
          ],
          "line": 4733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 4724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void rebind_workers(struct worker_pool *pool)\n{\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_attach_mutex);\n\n\t/*\n\t * Restore CPU affinity of all workers.  As all idle workers should\n\t * be on the run-queue of the associated CPU before any local\n\t * wake-ups for concurrency management happen, restore CPU affinity\n\t * of all workers first and then clear UNBOUND.  As we're called\n\t * from CPU_ONLINE, the following shouldn't fail.\n\t */\n\tfor_each_pool_worker(worker, pool)\n\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(worker->task,\n\t\t\t\t\t\t  pool->attrs->cpumask) < 0);\n\n\tspin_lock_irq(&pool->lock);\n\n\tpool->flags &= ~POOL_DISASSOCIATED;\n\n\tfor_each_pool_worker(worker, pool) {\n\t\tunsigned int worker_flags = worker->flags;\n\n\t\t/*\n\t\t * A bound idle worker should actually be on the runqueue\n\t\t * of the associated CPU for local wake-ups targeting it to\n\t\t * work.  Kick all idle workers so that they migrate to the\n\t\t * associated CPU.  Doing this in the same loop as\n\t\t * replacing UNBOUND with REBOUND is safe as no worker will\n\t\t * be bound before @pool->lock is released.\n\t\t */\n\t\tif (worker_flags & WORKER_IDLE)\n\t\t\twake_up_process(worker->task);\n\n\t\t/*\n\t\t * We want to clear UNBOUND but can't directly call\n\t\t * worker_clr_flags() or adjust nr_running.  Atomically\n\t\t * replace UNBOUND with another NOT_RUNNING flag REBOUND.\n\t\t * @worker will clear REBOUND using worker_clr_flags() when\n\t\t * it initiates the next execution cycle thus restoring\n\t\t * concurrency management.  Note that when or whether\n\t\t * @worker clears REBOUND doesn't affect correctness.\n\t\t *\n\t\t * WRITE_ONCE() is necessary because @worker->flags may be\n\t\t * tested without holding any lock in\n\t\t * wq_worker_waking_up().  Without it, NOT_RUNNING test may\n\t\t * fail incorrectly leading to premature concurrency\n\t\t * management operations.\n\t\t */\n\t\tWARN_ON_ONCE(!(worker_flags & WORKER_UNBOUND));\n\t\tworker_flags |= WORKER_REBOUND;\n\t\tworker_flags &= ~WORKER_UNBOUND;\n\t\tWRITE_ONCE(worker->flags, worker_flags);\n\t}\n\n\tspin_unlock_irq(&pool->lock);\n}"
  },
  {
    "function_name": "unbind_workers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4661-4712",
    "snippet": "static void unbind_workers(int cpu)\n{\n\tstruct worker_pool *pool;\n\tstruct worker *worker;\n\n\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\tmutex_lock(&wq_pool_attach_mutex);\n\t\tspin_lock_irq(&pool->lock);\n\n\t\t/*\n\t\t * We've blocked all attach/detach operations. Make all workers\n\t\t * unbound and set DISASSOCIATED.  Before this, all workers\n\t\t * except for the ones which are still executing works from\n\t\t * before the last CPU down must be on the cpu.  After\n\t\t * this, they may become diasporas.\n\t\t */\n\t\tfor_each_pool_worker(worker, pool)\n\t\t\tworker->flags |= WORKER_UNBOUND;\n\n\t\tpool->flags |= POOL_DISASSOCIATED;\n\n\t\tspin_unlock_irq(&pool->lock);\n\t\tmutex_unlock(&wq_pool_attach_mutex);\n\n\t\t/*\n\t\t * Call schedule() so that we cross rq->lock and thus can\n\t\t * guarantee sched callbacks see the %WORKER_UNBOUND flag.\n\t\t * This is necessary as scheduler callbacks may be invoked\n\t\t * from other cpus.\n\t\t */\n\t\tschedule();\n\n\t\t/*\n\t\t * Sched callbacks are disabled now.  Zap nr_running.\n\t\t * After this, nr_running stays zero and need_more_worker()\n\t\t * and keep_working() are always true as long as the\n\t\t * worklist is not empty.  This pool now behaves as an\n\t\t * unbound (in terms of concurrency management) pool which\n\t\t * are served by workers tied to the pool.\n\t\t */\n\t\tatomic_set(&pool->nr_running, 0);\n\n\t\t/*\n\t\t * With concurrency management just turned off, a busy\n\t\t * worker blocking could lead to lengthy stalls.  Kick off\n\t\t * unbound chain execution of currently pending work items.\n\t\t */\n\t\tspin_lock_irq(&pool->lock);\n\t\twake_up_worker(pool);\n\t\tspin_unlock_irq(&pool->lock);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_attach_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 4710
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_worker",
          "args": [
            "pool"
          ],
          "line": 4709
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 4708
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&pool->nr_running",
            "0"
          ],
          "line": 4701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 4691
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 4683
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pool_worker",
          "args": [
            "worker",
            "pool"
          ],
          "line": 4677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 4667
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu_worker_pool",
          "args": [
            "pool",
            "cpu"
          ],
          "line": 4666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void unbind_workers(int cpu)\n{\n\tstruct worker_pool *pool;\n\tstruct worker *worker;\n\n\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\tmutex_lock(&wq_pool_attach_mutex);\n\t\tspin_lock_irq(&pool->lock);\n\n\t\t/*\n\t\t * We've blocked all attach/detach operations. Make all workers\n\t\t * unbound and set DISASSOCIATED.  Before this, all workers\n\t\t * except for the ones which are still executing works from\n\t\t * before the last CPU down must be on the cpu.  After\n\t\t * this, they may become diasporas.\n\t\t */\n\t\tfor_each_pool_worker(worker, pool)\n\t\t\tworker->flags |= WORKER_UNBOUND;\n\n\t\tpool->flags |= POOL_DISASSOCIATED;\n\n\t\tspin_unlock_irq(&pool->lock);\n\t\tmutex_unlock(&wq_pool_attach_mutex);\n\n\t\t/*\n\t\t * Call schedule() so that we cross rq->lock and thus can\n\t\t * guarantee sched callbacks see the %WORKER_UNBOUND flag.\n\t\t * This is necessary as scheduler callbacks may be invoked\n\t\t * from other cpus.\n\t\t */\n\t\tschedule();\n\n\t\t/*\n\t\t * Sched callbacks are disabled now.  Zap nr_running.\n\t\t * After this, nr_running stays zero and need_more_worker()\n\t\t * and keep_working() are always true as long as the\n\t\t * worklist is not empty.  This pool now behaves as an\n\t\t * unbound (in terms of concurrency management) pool which\n\t\t * are served by workers tied to the pool.\n\t\t */\n\t\tatomic_set(&pool->nr_running, 0);\n\n\t\t/*\n\t\t * With concurrency management just turned off, a busy\n\t\t * worker blocking could lead to lengthy stalls.  Kick off\n\t\t * unbound chain execution of currently pending work items.\n\t\t */\n\t\tspin_lock_irq(&pool->lock);\n\t\twake_up_worker(pool);\n\t\tspin_unlock_irq(&pool->lock);\n\t}\n}"
  },
  {
    "function_name": "wq_worker_comm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4606-4642",
    "snippet": "void wq_worker_comm(char *buf, size_t size, struct task_struct *task)\n{\n\tint off;\n\n\t/* always show the actual comm */\n\toff = strscpy(buf, task->comm, size);\n\tif (off < 0)\n\t\treturn;\n\n\t/* stabilize PF_WQ_WORKER and worker pool association */\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\tif (task->flags & PF_WQ_WORKER) {\n\t\tstruct worker *worker = kthread_data(task);\n\t\tstruct worker_pool *pool = worker->pool;\n\n\t\tif (pool) {\n\t\t\tspin_lock_irq(&pool->lock);\n\t\t\t/*\n\t\t\t * ->desc tracks information (wq name or\n\t\t\t * set_worker_desc()) for the latest execution.  If\n\t\t\t * current, prepend '+', otherwise '-'.\n\t\t\t */\n\t\t\tif (worker->desc[0] != '\\0') {\n\t\t\t\tif (worker->current_work)\n\t\t\t\t\tscnprintf(buf + off, size - off, \"+%s\",\n\t\t\t\t\t\t  worker->desc);\n\t\t\t\telse\n\t\t\t\t\tscnprintf(buf + off, size - off, \"-%s\",\n\t\t\t\t\t\t  worker->desc);\n\t\t\t}\n\t\t\tspin_unlock_irq(&pool->lock);\n\t\t}\n\t}\n\n\tmutex_unlock(&wq_pool_attach_mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_attach_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 4641
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 4637
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf + off",
            "size - off",
            "\"-%s\"",
            "worker->desc"
          ],
          "line": 4634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf + off",
            "size - off",
            "\"+%s\"",
            "worker->desc"
          ],
          "line": 4631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 4623
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_data",
          "args": [
            "task"
          ],
          "line": 4619
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "154-157",
          "snippet": "void *kthread_data(struct task_struct *task)\n{\n\treturn to_kthread(task)->data;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nvoid *kthread_data(struct task_struct *task)\n{\n\treturn to_kthread(task)->data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 4616
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "buf",
            "task->comm",
            "size"
          ],
          "line": 4611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid wq_worker_comm(char *buf, size_t size, struct task_struct *task)\n{\n\tint off;\n\n\t/* always show the actual comm */\n\toff = strscpy(buf, task->comm, size);\n\tif (off < 0)\n\t\treturn;\n\n\t/* stabilize PF_WQ_WORKER and worker pool association */\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\tif (task->flags & PF_WQ_WORKER) {\n\t\tstruct worker *worker = kthread_data(task);\n\t\tstruct worker_pool *pool = worker->pool;\n\n\t\tif (pool) {\n\t\t\tspin_lock_irq(&pool->lock);\n\t\t\t/*\n\t\t\t * ->desc tracks information (wq name or\n\t\t\t * set_worker_desc()) for the latest execution.  If\n\t\t\t * current, prepend '+', otherwise '-'.\n\t\t\t */\n\t\t\tif (worker->desc[0] != '\\0') {\n\t\t\t\tif (worker->current_work)\n\t\t\t\t\tscnprintf(buf + off, size - off, \"+%s\",\n\t\t\t\t\t\t  worker->desc);\n\t\t\t\telse\n\t\t\t\t\tscnprintf(buf + off, size - off, \"-%s\",\n\t\t\t\t\t\t  worker->desc);\n\t\t\t}\n\t\t\tspin_unlock_irq(&pool->lock);\n\t\t}\n\t}\n\n\tmutex_unlock(&wq_pool_attach_mutex);\n}"
  },
  {
    "function_name": "show_workqueue_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4530-4603",
    "snippet": "void show_workqueue_state(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct worker_pool *pool;\n\tunsigned long flags;\n\tint pi;\n\n\trcu_read_lock_sched();\n\n\tpr_info(\"Showing busy workqueues and worker pools:\\n\");\n\n\tlist_for_each_entry_rcu(wq, &workqueues, list) {\n\t\tstruct pool_workqueue *pwq;\n\t\tbool idle = true;\n\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tif (pwq->nr_active || !list_empty(&pwq->delayed_works)) {\n\t\t\t\tidle = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idle)\n\t\t\tcontinue;\n\n\t\tpr_info(\"workqueue %s: flags=0x%x\\n\", wq->name, wq->flags);\n\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\t\t\tif (pwq->nr_active || !list_empty(&pwq->delayed_works))\n\t\t\t\tshow_pwq(pwq);\n\t\t\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n\t\t\t/*\n\t\t\t * We could be printing a lot from atomic context, e.g.\n\t\t\t * sysrq-t -> show_workqueue_state(). Avoid triggering\n\t\t\t * hard lockup.\n\t\t\t */\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t}\n\n\tfor_each_pool(pool, pi) {\n\t\tstruct worker *worker;\n\t\tbool first = true;\n\n\t\tspin_lock_irqsave(&pool->lock, flags);\n\t\tif (pool->nr_workers == pool->nr_idle)\n\t\t\tgoto next_pool;\n\n\t\tpr_info(\"pool %d:\", pool->id);\n\t\tpr_cont_pool_info(pool);\n\t\tpr_cont(\" hung=%us workers=%d\",\n\t\t\tjiffies_to_msecs(jiffies - pool->watchdog_ts) / 1000,\n\t\t\tpool->nr_workers);\n\t\tif (pool->manager)\n\t\t\tpr_cont(\" manager: %d\",\n\t\t\t\ttask_pid_nr(pool->manager->task));\n\t\tlist_for_each_entry(worker, &pool->idle_list, entry) {\n\t\t\tpr_cont(\" %s%d\", first ? \"idle: \" : \"\",\n\t\t\t\ttask_pid_nr(worker->task));\n\t\t\tfirst = false;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\tnext_pool:\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t/*\n\t\t * We could be printing a lot from atomic context, e.g.\n\t\t * sysrq-t -> show_workqueue_state(). Avoid triggering\n\t\t * hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t}\n\n\trcu_read_unlock_sched();\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(workqueues);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 4602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 4599
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 4593
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 4591
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" %s%d\"",
            "first ? \"idle: \" : \"\"",
            "task_pid_nr(worker->task)"
          ],
          "line": 4587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "worker->task"
          ],
          "line": 4588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "worker",
            "&pool->idle_list",
            "entry"
          ],
          "line": 4586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" manager: %d\"",
            "task_pid_nr(pool->manager->task)"
          ],
          "line": 4584
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4439-4451",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "pool->manager->task"
          ],
          "line": 4585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" hung=%us workers=%d\"",
            "jiffies_to_msecs(jiffies - pool->watchdog_ts) / 1000",
            "pool->nr_workers"
          ],
          "line": 4580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jiffies_to_msecs",
          "args": [
            "jiffies - pool->watchdog_ts"
          ],
          "line": 4581
        },
        "resolved": true,
        "details": {
          "function_name": "jiffies_to_msecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "311-325",
          "snippet": "unsigned int jiffies_to_msecs(const unsigned long j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>\n\t       HZ_TO_MSEC_SHR32;\n# else\n\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n# endif\n#endif\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned int jiffies_to_msecs(const unsigned long j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>\n\t       HZ_TO_MSEC_SHR32;\n# else\n\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n# endif\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"pool %d:\"",
            "pool->id"
          ],
          "line": 4578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pool->lock",
            "flags"
          ],
          "line": 4574
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pool",
          "args": [
            "pool",
            "pi"
          ],
          "line": 4570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_pwq",
          "args": [
            "pwq"
          ],
          "line": 4559
        },
        "resolved": true,
        "details": {
          "function_name": "show_pwq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4453-4522",
          "snippet": "static void show_pwq(struct pool_workqueue *pwq)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\tstruct work_struct *work;\n\tstruct worker *worker;\n\tbool has_in_flight = false, has_pending = false;\n\tint bkt;\n\n\tpr_info(\"  pwq %d:\", pool->id);\n\tpr_cont_pool_info(pool);\n\n\tpr_cont(\" active=%d/%d%s\\n\", pwq->nr_active, pwq->max_active,\n\t\t!list_empty(&pwq->mayday_node) ? \" MAYDAY\" : \"\");\n\n\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\tif (worker->current_pwq == pwq) {\n\t\t\thas_in_flight = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_in_flight) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    in-flight:\");\n\t\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\t\tif (worker->current_pwq != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont(\"%s %d%s:%pf\", comma ? \",\" : \"\",\n\t\t\t\ttask_pid_nr(worker->task),\n\t\t\t\tworker == pwq->wq->rescuer ? \"(RESCUER)\" : \"\",\n\t\t\t\tworker->current_func);\n\t\t\tlist_for_each_entry(work, &worker->scheduled, entry)\n\t\t\t\tpr_cont_work(false, work);\n\t\t\tcomma = true;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\tif (get_work_pwq(work) == pwq) {\n\t\t\thas_pending = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_pending) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    pending:\");\n\t\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\t\tif (get_work_pwq(work) != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tif (!list_empty(&pwq->delayed_works)) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    delayed:\");\n\t\tlist_for_each_entry(work, &pwq->delayed_works, entry) {\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void show_pwq(struct pool_workqueue *pwq)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\tstruct work_struct *work;\n\tstruct worker *worker;\n\tbool has_in_flight = false, has_pending = false;\n\tint bkt;\n\n\tpr_info(\"  pwq %d:\", pool->id);\n\tpr_cont_pool_info(pool);\n\n\tpr_cont(\" active=%d/%d%s\\n\", pwq->nr_active, pwq->max_active,\n\t\t!list_empty(&pwq->mayday_node) ? \" MAYDAY\" : \"\");\n\n\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\tif (worker->current_pwq == pwq) {\n\t\t\thas_in_flight = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_in_flight) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    in-flight:\");\n\t\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\t\tif (worker->current_pwq != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont(\"%s %d%s:%pf\", comma ? \",\" : \"\",\n\t\t\t\ttask_pid_nr(worker->task),\n\t\t\t\tworker == pwq->wq->rescuer ? \"(RESCUER)\" : \"\",\n\t\t\t\tworker->current_func);\n\t\t\tlist_for_each_entry(work, &worker->scheduled, entry)\n\t\t\t\tpr_cont_work(false, work);\n\t\t\tcomma = true;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\tif (get_work_pwq(work) == pwq) {\n\t\t\thas_pending = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_pending) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    pending:\");\n\t\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\t\tif (get_work_pwq(work) != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tif (!list_empty(&pwq->delayed_works)) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    delayed:\");\n\t\tlist_for_each_entry(work, &pwq->delayed_works, entry) {\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->delayed_works"
          ],
          "line": 4558
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 4556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"workqueue %s: flags=0x%x\\n\"",
            "wq->name",
            "wq->flags"
          ],
          "line": 4554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 4545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "wq",
            "&workqueues",
            "list"
          ],
          "line": 4541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Showing busy workqueues and worker pools:\\n\""
          ],
          "line": 4539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 4537
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "106-119",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid show_workqueue_state(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct worker_pool *pool;\n\tunsigned long flags;\n\tint pi;\n\n\trcu_read_lock_sched();\n\n\tpr_info(\"Showing busy workqueues and worker pools:\\n\");\n\n\tlist_for_each_entry_rcu(wq, &workqueues, list) {\n\t\tstruct pool_workqueue *pwq;\n\t\tbool idle = true;\n\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tif (pwq->nr_active || !list_empty(&pwq->delayed_works)) {\n\t\t\t\tidle = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idle)\n\t\t\tcontinue;\n\n\t\tpr_info(\"workqueue %s: flags=0x%x\\n\", wq->name, wq->flags);\n\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\t\t\tif (pwq->nr_active || !list_empty(&pwq->delayed_works))\n\t\t\t\tshow_pwq(pwq);\n\t\t\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n\t\t\t/*\n\t\t\t * We could be printing a lot from atomic context, e.g.\n\t\t\t * sysrq-t -> show_workqueue_state(). Avoid triggering\n\t\t\t * hard lockup.\n\t\t\t */\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t}\n\n\tfor_each_pool(pool, pi) {\n\t\tstruct worker *worker;\n\t\tbool first = true;\n\n\t\tspin_lock_irqsave(&pool->lock, flags);\n\t\tif (pool->nr_workers == pool->nr_idle)\n\t\t\tgoto next_pool;\n\n\t\tpr_info(\"pool %d:\", pool->id);\n\t\tpr_cont_pool_info(pool);\n\t\tpr_cont(\" hung=%us workers=%d\",\n\t\t\tjiffies_to_msecs(jiffies - pool->watchdog_ts) / 1000,\n\t\t\tpool->nr_workers);\n\t\tif (pool->manager)\n\t\t\tpr_cont(\" manager: %d\",\n\t\t\t\ttask_pid_nr(pool->manager->task));\n\t\tlist_for_each_entry(worker, &pool->idle_list, entry) {\n\t\t\tpr_cont(\" %s%d\", first ? \"idle: \" : \"\",\n\t\t\t\ttask_pid_nr(worker->task));\n\t\t\tfirst = false;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\tnext_pool:\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t/*\n\t\t * We could be printing a lot from atomic context, e.g.\n\t\t * sysrq-t -> show_workqueue_state(). Avoid triggering\n\t\t * hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t}\n\n\trcu_read_unlock_sched();\n}"
  },
  {
    "function_name": "show_pwq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4453-4522",
    "snippet": "static void show_pwq(struct pool_workqueue *pwq)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\tstruct work_struct *work;\n\tstruct worker *worker;\n\tbool has_in_flight = false, has_pending = false;\n\tint bkt;\n\n\tpr_info(\"  pwq %d:\", pool->id);\n\tpr_cont_pool_info(pool);\n\n\tpr_cont(\" active=%d/%d%s\\n\", pwq->nr_active, pwq->max_active,\n\t\t!list_empty(&pwq->mayday_node) ? \" MAYDAY\" : \"\");\n\n\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\tif (worker->current_pwq == pwq) {\n\t\t\thas_in_flight = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_in_flight) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    in-flight:\");\n\t\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\t\tif (worker->current_pwq != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont(\"%s %d%s:%pf\", comma ? \",\" : \"\",\n\t\t\t\ttask_pid_nr(worker->task),\n\t\t\t\tworker == pwq->wq->rescuer ? \"(RESCUER)\" : \"\",\n\t\t\t\tworker->current_func);\n\t\t\tlist_for_each_entry(work, &worker->scheduled, entry)\n\t\t\t\tpr_cont_work(false, work);\n\t\t\tcomma = true;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\tif (get_work_pwq(work) == pwq) {\n\t\t\thas_pending = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_pending) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    pending:\");\n\t\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\t\tif (get_work_pwq(work) != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tif (!list_empty(&pwq->delayed_works)) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    delayed:\");\n\t\tlist_for_each_entry(work, &pwq->delayed_works, entry) {\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 4520
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 4518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont_work",
          "args": [
            "comma",
            "work"
          ],
          "line": 4517
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4439-4451",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "work",
            "&pwq->delayed_works",
            "entry"
          ],
          "line": 4516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"    delayed:\""
          ],
          "line": 4515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->delayed_works"
          ],
          "line": 4512
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 4507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_work_pwq",
          "args": [
            "work"
          ],
          "line": 4503
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pwq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "682-690",
          "snippet": "static struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "work",
            "&pool->worklist",
            "entry"
          ],
          "line": 4502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"    pending:\""
          ],
          "line": 4501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "work",
            "&pool->worklist",
            "entry"
          ],
          "line": 4492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "work",
            "&worker->scheduled",
            "entry"
          ],
          "line": 4485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s %d%s:%pf\"",
            "comma ? \",\" : \"\"",
            "task_pid_nr(worker->task)",
            "worker == pwq->wq->rescuer ? \"(RESCUER)\" : \"\"",
            "worker->current_func"
          ],
          "line": 4481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "worker->task"
          ],
          "line": 4482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_for_each",
          "args": [
            "pool->busy_hash",
            "bkt",
            "worker",
            "hentry"
          ],
          "line": 4477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"    in-flight:\""
          ],
          "line": 4476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_for_each",
          "args": [
            "pool->busy_hash",
            "bkt",
            "worker",
            "hentry"
          ],
          "line": 4467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" active=%d/%d%s\\n\"",
            "pwq->nr_active",
            "pwq->max_active",
            "!list_empty(&pwq->mayday_node) ? \" MAYDAY\" : \"\""
          ],
          "line": 4464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"  pwq %d:\"",
            "pool->id"
          ],
          "line": 4461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void show_pwq(struct pool_workqueue *pwq)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\tstruct work_struct *work;\n\tstruct worker *worker;\n\tbool has_in_flight = false, has_pending = false;\n\tint bkt;\n\n\tpr_info(\"  pwq %d:\", pool->id);\n\tpr_cont_pool_info(pool);\n\n\tpr_cont(\" active=%d/%d%s\\n\", pwq->nr_active, pwq->max_active,\n\t\t!list_empty(&pwq->mayday_node) ? \" MAYDAY\" : \"\");\n\n\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\tif (worker->current_pwq == pwq) {\n\t\t\thas_in_flight = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_in_flight) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    in-flight:\");\n\t\thash_for_each(pool->busy_hash, bkt, worker, hentry) {\n\t\t\tif (worker->current_pwq != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont(\"%s %d%s:%pf\", comma ? \",\" : \"\",\n\t\t\t\ttask_pid_nr(worker->task),\n\t\t\t\tworker == pwq->wq->rescuer ? \"(RESCUER)\" : \"\",\n\t\t\t\tworker->current_func);\n\t\t\tlist_for_each_entry(work, &worker->scheduled, entry)\n\t\t\t\tpr_cont_work(false, work);\n\t\t\tcomma = true;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\tif (get_work_pwq(work) == pwq) {\n\t\t\thas_pending = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (has_pending) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    pending:\");\n\t\tlist_for_each_entry(work, &pool->worklist, entry) {\n\t\t\tif (get_work_pwq(work) != pwq)\n\t\t\t\tcontinue;\n\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n\n\tif (!list_empty(&pwq->delayed_works)) {\n\t\tbool comma = false;\n\n\t\tpr_info(\"    delayed:\");\n\t\tlist_for_each_entry(work, &pwq->delayed_works, entry) {\n\t\t\tpr_cont_work(comma, work);\n\t\t\tcomma = !(*work_data_bits(work) & WORK_STRUCT_LINKED);\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "pr_cont_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4439-4451",
    "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s %pf\"",
            "comma ? \",\" : \"\"",
            "work->func"
          ],
          "line": 4449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s BAR(%d)\"",
            "comma ? \",\" : \"\"",
            "task_pid_nr(barr->task)"
          ],
          "line": 4446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "barr->task"
          ],
          "line": 4447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structwq_barrier",
            "work"
          ],
          "line": 4444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}"
  },
  {
    "function_name": "pr_cont_pool_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4431-4437",
    "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" flags=0x%x nice=%d\"",
            "pool->flags",
            "pool->attrs->nice"
          ],
          "line": 4436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" node=%d\"",
            "pool->node"
          ],
          "line": 4435
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4439-4451",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" cpus=%*pbl\"",
            "nr_cpumask_bits",
            "pool->attrs->cpumask"
          ],
          "line": 4433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
  },
  {
    "function_name": "print_worker_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4395-4429",
    "snippet": "void print_worker_info(const char *log_lvl, struct task_struct *task)\n{\n\twork_func_t *fn = NULL;\n\tchar name[WQ_NAME_LEN] = { };\n\tchar desc[WORKER_DESC_LEN] = { };\n\tstruct pool_workqueue *pwq = NULL;\n\tstruct workqueue_struct *wq = NULL;\n\tstruct worker *worker;\n\n\tif (!(task->flags & PF_WQ_WORKER))\n\t\treturn;\n\n\t/*\n\t * This function is called without any synchronization and @task\n\t * could be in any state.  Be careful with dereferences.\n\t */\n\tworker = kthread_probe_data(task);\n\n\t/*\n\t * Carefully copy the associated workqueue's workfn, name and desc.\n\t * Keep the original last '\\0' in case the original is garbage.\n\t */\n\tprobe_kernel_read(&fn, &worker->current_func, sizeof(fn));\n\tprobe_kernel_read(&pwq, &worker->current_pwq, sizeof(pwq));\n\tprobe_kernel_read(&wq, &pwq->wq, sizeof(wq));\n\tprobe_kernel_read(name, wq->name, sizeof(name) - 1);\n\tprobe_kernel_read(desc, worker->desc, sizeof(desc) - 1);\n\n\tif (fn || name[0] || desc[0]) {\n\t\tprintk(\"%sWorkqueue: %s %pf\", log_lvl, name, fn);\n\t\tif (strcmp(name, desc))\n\t\t\tpr_cont(\" (%s)\", desc);\n\t\tpr_cont(\"\\n\");\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 4427
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" (%s)\"",
            "desc"
          ],
          "line": 4426
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4439-4451",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "desc"
          ],
          "line": 4425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%sWorkqueue: %s %pf\"",
            "log_lvl",
            "name",
            "fn"
          ],
          "line": 4424
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "desc",
            "worker->desc",
            "sizeof(desc) - 1"
          ],
          "line": 4421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "name",
            "wq->name",
            "sizeof(name) - 1"
          ],
          "line": 4420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "&wq",
            "&pwq->wq",
            "sizeof(wq)"
          ],
          "line": 4419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "&pwq",
            "&worker->current_pwq",
            "sizeof(pwq)"
          ],
          "line": 4418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "&fn",
            "&worker->current_func",
            "sizeof(fn)"
          ],
          "line": 4417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_probe_data",
          "args": [
            "task"
          ],
          "line": 4411
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_probe_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "168-175",
          "snippet": "void *kthread_probe_data(struct task_struct *task)\n{\n\tstruct kthread *kthread = to_kthread(task);\n\tvoid *data = NULL;\n\n\tprobe_kernel_read(&data, &kthread->data, sizeof(data));\n\treturn data;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nvoid *kthread_probe_data(struct task_struct *task)\n{\n\tstruct kthread *kthread = to_kthread(task);\n\tvoid *data = NULL;\n\n\tprobe_kernel_read(&data, &kthread->data, sizeof(data));\n\treturn data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid print_worker_info(const char *log_lvl, struct task_struct *task)\n{\n\twork_func_t *fn = NULL;\n\tchar name[WQ_NAME_LEN] = { };\n\tchar desc[WORKER_DESC_LEN] = { };\n\tstruct pool_workqueue *pwq = NULL;\n\tstruct workqueue_struct *wq = NULL;\n\tstruct worker *worker;\n\n\tif (!(task->flags & PF_WQ_WORKER))\n\t\treturn;\n\n\t/*\n\t * This function is called without any synchronization and @task\n\t * could be in any state.  Be careful with dereferences.\n\t */\n\tworker = kthread_probe_data(task);\n\n\t/*\n\t * Carefully copy the associated workqueue's workfn, name and desc.\n\t * Keep the original last '\\0' in case the original is garbage.\n\t */\n\tprobe_kernel_read(&fn, &worker->current_func, sizeof(fn));\n\tprobe_kernel_read(&pwq, &worker->current_pwq, sizeof(pwq));\n\tprobe_kernel_read(&wq, &pwq->wq, sizeof(wq));\n\tprobe_kernel_read(name, wq->name, sizeof(name) - 1);\n\tprobe_kernel_read(desc, worker->desc, sizeof(desc) - 1);\n\n\tif (fn || name[0] || desc[0]) {\n\t\tprintk(\"%sWorkqueue: %s %pf\", log_lvl, name, fn);\n\t\tif (strcmp(name, desc))\n\t\t\tpr_cont(\" (%s)\", desc);\n\t\tpr_cont(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "set_worker_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4369-4379",
    "snippet": "void set_worker_desc(const char *fmt, ...)\n{\n\tstruct worker *worker = current_wq_worker();\n\tva_list args;\n\n\tif (worker) {\n\t\tva_start(args, fmt);\n\t\tvsnprintf(worker->desc, sizeof(worker->desc), fmt, args);\n\t\tva_end(args);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 4377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "worker->desc",
            "sizeof(worker->desc)",
            "fmt",
            "args"
          ],
          "line": 4376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 4375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_wq_worker",
          "args": [],
          "line": 4371
        },
        "resolved": true,
        "details": {
          "function_name": "current_wq_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue_internal.h",
          "lines": "61-66",
          "snippet": "static inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/preempt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/preempt.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n\nstatic inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid set_worker_desc(const char *fmt, ...)\n{\n\tstruct worker *worker = current_wq_worker();\n\tva_list args;\n\n\tif (worker) {\n\t\tva_start(args, fmt);\n\t\tvsnprintf(worker->desc, sizeof(worker->desc), fmt, args);\n\t\tva_end(args);\n\t}\n}"
  },
  {
    "function_name": "work_busy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4336-4356",
    "snippet": "unsigned int work_busy(struct work_struct *work)\n{\n\tstruct worker_pool *pool;\n\tunsigned long flags;\n\tunsigned int ret = 0;\n\n\tif (work_pending(work))\n\t\tret |= WORK_BUSY_PENDING;\n\n\tlocal_irq_save(flags);\n\tpool = get_work_pool(work);\n\tif (pool) {\n\t\tspin_lock(&pool->lock);\n\t\tif (find_worker_executing_work(pool, work))\n\t\t\tret |= WORK_BUSY_RUNNING;\n\t\tspin_unlock(&pool->lock);\n\t}\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 4353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 4351
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_worker_executing_work",
          "args": [
            "pool",
            "work"
          ],
          "line": 4349
        },
        "resolved": true,
        "details": {
          "function_name": "find_worker_executing_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "999-1011",
          "snippet": "static struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 4348
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_work_pool",
          "args": [
            "work"
          ],
          "line": 4346
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pool_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "732-741",
          "snippet": "static int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 4345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_pending",
          "args": [
            "work"
          ],
          "line": 4342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nunsigned int work_busy(struct work_struct *work)\n{\n\tstruct worker_pool *pool;\n\tunsigned long flags;\n\tunsigned int ret = 0;\n\n\tif (work_pending(work))\n\t\tret |= WORK_BUSY_PENDING;\n\n\tlocal_irq_save(flags);\n\tpool = get_work_pool(work);\n\tif (pool) {\n\t\tspin_lock(&pool->lock);\n\t\tif (find_worker_executing_work(pool, work))\n\t\t\tret |= WORK_BUSY_RUNNING;\n\t\tspin_unlock(&pool->lock);\n\t}\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "workqueue_congested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4303-4322",
    "snippet": "bool workqueue_congested(int cpu, struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tbool ret;\n\n\trcu_read_lock_sched();\n\n\tif (cpu == WORK_CPU_UNBOUND)\n\t\tcpu = smp_processor_id();\n\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\telse\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\n\tret = !list_empty(&pwq->delayed_works);\n\trcu_read_unlock_sched();\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 4319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->delayed_works"
          ],
          "line": 4318
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unbound_pwq_by_node",
          "args": [
            "wq",
            "cpu_to_node(cpu)"
          ],
          "line": 4316
        },
        "resolved": true,
        "details": {
          "function_name": "unbound_pwq_by_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "560-575",
          "snippet": "static struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 4316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "wq->cpu_pwqs",
            "cpu"
          ],
          "line": 4314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 4311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 4308
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "106-119",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool workqueue_congested(int cpu, struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tbool ret;\n\n\trcu_read_lock_sched();\n\n\tif (cpu == WORK_CPU_UNBOUND)\n\t\tcpu = smp_processor_id();\n\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\telse\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\n\tret = !list_empty(&pwq->delayed_works);\n\trcu_read_unlock_sched();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "current_is_workqueue_rescuer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4278-4283",
    "snippet": "bool current_is_workqueue_rescuer(void)\n{\n\tstruct worker *worker = current_wq_worker();\n\n\treturn worker && worker->rescue_wq;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_wq_worker",
          "args": [],
          "line": 4280
        },
        "resolved": true,
        "details": {
          "function_name": "current_wq_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue_internal.h",
          "lines": "61-66",
          "snippet": "static inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/preempt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/preempt.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n\nstatic inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool current_is_workqueue_rescuer(void)\n{\n\tstruct worker *worker = current_wq_worker();\n\n\treturn worker && worker->rescue_wq;\n}"
  },
  {
    "function_name": "current_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4262-4267",
    "snippet": "struct work_struct *current_work(void)\n{\n\tstruct worker *worker = current_wq_worker();\n\n\treturn worker ? worker->current_work : NULL;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_wq_worker",
          "args": [],
          "line": 4264
        },
        "resolved": true,
        "details": {
          "function_name": "current_wq_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue_internal.h",
          "lines": "61-66",
          "snippet": "static inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/preempt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/preempt.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n\nstatic inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct work_struct *current_work(void)\n{\n\tstruct worker *worker = current_wq_worker();\n\n\treturn worker ? worker->current_work : NULL;\n}"
  },
  {
    "function_name": "workqueue_set_max_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4232-4251",
    "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(workqueues);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq->mutex"
          ],
          "line": 4250
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwq_adjust_max_active",
          "args": [
            "pwq"
          ],
          "line": 4248
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_adjust_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3524-3562",
          "snippet": "static void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->delayed_works) &&\n\t\t       pwq->nr_active < pwq->max_active)\n\t\t\tpwq_activate_first_delayed(pwq);\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped.  It's a slow path.  Do it always.\n\t\t */\n\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool workqueue_freezing;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->delayed_works) &&\n\t\t       pwq->nr_active < pwq->max_active)\n\t\t\tpwq_activate_first_delayed(pwq);\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped.  It's a slow path.  Do it always.\n\t\t */\n\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 4247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 4242
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_clamp_max_active",
          "args": [
            "max_active",
            "wq->flags",
            "wq->name"
          ],
          "line": 4240
        },
        "resolved": true,
        "details": {
          "function_name": "wq_clamp_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4004-4014",
          "snippet": "static int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "wq->flags & __WQ_ORDERED_EXPLICIT"
          ],
          "line": 4237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
  },
  {
    "function_name": "destroy_workqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4149-4219",
    "snippet": "void destroy_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tint node;\n\n\t/* drain it before proceeding with destruction */\n\tdrain_workqueue(wq);\n\n\t/* sanity checks */\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq) {\n\t\tint i;\n\n\t\tfor (i = 0; i < WORK_NR_COLORS; i++) {\n\t\t\tif (WARN_ON(pwq->nr_in_flight[i])) {\n\t\t\t\tmutex_unlock(&wq->mutex);\n\t\t\t\tshow_workqueue_state();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (WARN_ON((pwq != wq->dfl_pwq) && (pwq->refcnt > 1)) ||\n\t\t    WARN_ON(pwq->nr_active) ||\n\t\t    WARN_ON(!list_empty(&pwq->delayed_works))) {\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t\tshow_workqueue_state();\n\t\t\treturn;\n\t\t}\n\t}\n\tmutex_unlock(&wq->mutex);\n\n\t/*\n\t * wq list is used to freeze wq, remove from list after\n\t * flushing is complete in case freeze races us.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\tlist_del_rcu(&wq->list);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tworkqueue_sysfs_unregister(wq);\n\n\tif (wq->rescuer)\n\t\tkthread_stop(wq->rescuer->task);\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\t/*\n\t\t * The base ref is never dropped on per-cpu pwqs.  Directly\n\t\t * schedule RCU free.\n\t\t */\n\t\tcall_rcu_sched(&wq->rcu, rcu_free_wq);\n\t} else {\n\t\t/*\n\t\t * We're the sole accessor of @wq at this point.  Directly\n\t\t * access numa_pwq_tbl[] and dfl_pwq to put the base refs.\n\t\t * @wq will be freed when the last pwq is released.\n\t\t */\n\t\tfor_each_node(node) {\n\t\t\tpwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\t\t\tRCU_INIT_POINTER(wq->numa_pwq_tbl[node], NULL);\n\t\t\tput_pwq_unlocked(pwq);\n\t\t}\n\n\t\t/*\n\t\t * Put dfl_pwq.  @wq may be freed any time after dfl_pwq is\n\t\t * put.  Don't access it afterwards.\n\t\t */\n\t\tpwq = wq->dfl_pwq;\n\t\twq->dfl_pwq = NULL;\n\t\tput_pwq_unlocked(pwq);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pwq_unlocked",
          "args": [
            "pwq"
          ],
          "line": 4217
        },
        "resolved": true,
        "details": {
          "function_name": "put_pwq_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1099-1110",
          "snippet": "static void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are sched-RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\tspin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\tspin_unlock_irq(&pwq->pool->lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are sched-RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\tspin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\tspin_unlock_irq(&pwq->pool->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "wq->numa_pwq_tbl[node]",
            "NULL"
          ],
          "line": 4207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "wq->numa_pwq_tbl[node]"
          ],
          "line": 4206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu_sched",
          "args": [
            "&wq->rcu",
            "rcu_free_wq"
          ],
          "line": 4198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "wq->rescuer->task"
          ],
          "line": 4191
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "538-556",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = k->exit_code;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = k->exit_code;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "workqueue_sysfs_unregister",
          "args": [
            "wq"
          ],
          "line": 4188
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_sysfs_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5486-5486",
          "snippet": "static void workqueue_sysfs_unregister(struct workqueue_struct *wq)\t{ }",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq)\t{ }"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 4186
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&wq->list"
          ],
          "line": 4185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 4184
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_workqueue_state",
          "args": [],
          "line": 4174
        },
        "resolved": true,
        "details": {
          "function_name": "show_workqueue_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4530-4603",
          "snippet": "void show_workqueue_state(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct worker_pool *pool;\n\tunsigned long flags;\n\tint pi;\n\n\trcu_read_lock_sched();\n\n\tpr_info(\"Showing busy workqueues and worker pools:\\n\");\n\n\tlist_for_each_entry_rcu(wq, &workqueues, list) {\n\t\tstruct pool_workqueue *pwq;\n\t\tbool idle = true;\n\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tif (pwq->nr_active || !list_empty(&pwq->delayed_works)) {\n\t\t\t\tidle = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idle)\n\t\t\tcontinue;\n\n\t\tpr_info(\"workqueue %s: flags=0x%x\\n\", wq->name, wq->flags);\n\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\t\t\tif (pwq->nr_active || !list_empty(&pwq->delayed_works))\n\t\t\t\tshow_pwq(pwq);\n\t\t\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n\t\t\t/*\n\t\t\t * We could be printing a lot from atomic context, e.g.\n\t\t\t * sysrq-t -> show_workqueue_state(). Avoid triggering\n\t\t\t * hard lockup.\n\t\t\t */\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t}\n\n\tfor_each_pool(pool, pi) {\n\t\tstruct worker *worker;\n\t\tbool first = true;\n\n\t\tspin_lock_irqsave(&pool->lock, flags);\n\t\tif (pool->nr_workers == pool->nr_idle)\n\t\t\tgoto next_pool;\n\n\t\tpr_info(\"pool %d:\", pool->id);\n\t\tpr_cont_pool_info(pool);\n\t\tpr_cont(\" hung=%us workers=%d\",\n\t\t\tjiffies_to_msecs(jiffies - pool->watchdog_ts) / 1000,\n\t\t\tpool->nr_workers);\n\t\tif (pool->manager)\n\t\t\tpr_cont(\" manager: %d\",\n\t\t\t\ttask_pid_nr(pool->manager->task));\n\t\tlist_for_each_entry(worker, &pool->idle_list, entry) {\n\t\t\tpr_cont(\" %s%d\", first ? \"idle: \" : \"\",\n\t\t\t\ttask_pid_nr(worker->task));\n\t\t\tfirst = false;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\tnext_pool:\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t/*\n\t\t * We could be printing a lot from atomic context, e.g.\n\t\t * sysrq-t -> show_workqueue_state(). Avoid triggering\n\t\t * hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t}\n\n\trcu_read_unlock_sched();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid show_workqueue_state(void)\n{\n\tstruct workqueue_struct *wq;\n\tstruct worker_pool *pool;\n\tunsigned long flags;\n\tint pi;\n\n\trcu_read_lock_sched();\n\n\tpr_info(\"Showing busy workqueues and worker pools:\\n\");\n\n\tlist_for_each_entry_rcu(wq, &workqueues, list) {\n\t\tstruct pool_workqueue *pwq;\n\t\tbool idle = true;\n\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tif (pwq->nr_active || !list_empty(&pwq->delayed_works)) {\n\t\t\t\tidle = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (idle)\n\t\t\tcontinue;\n\n\t\tpr_info(\"workqueue %s: flags=0x%x\\n\", wq->name, wq->flags);\n\n\t\tfor_each_pwq(pwq, wq) {\n\t\t\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\t\t\tif (pwq->nr_active || !list_empty(&pwq->delayed_works))\n\t\t\t\tshow_pwq(pwq);\n\t\t\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n\t\t\t/*\n\t\t\t * We could be printing a lot from atomic context, e.g.\n\t\t\t * sysrq-t -> show_workqueue_state(). Avoid triggering\n\t\t\t * hard lockup.\n\t\t\t */\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t}\n\n\tfor_each_pool(pool, pi) {\n\t\tstruct worker *worker;\n\t\tbool first = true;\n\n\t\tspin_lock_irqsave(&pool->lock, flags);\n\t\tif (pool->nr_workers == pool->nr_idle)\n\t\t\tgoto next_pool;\n\n\t\tpr_info(\"pool %d:\", pool->id);\n\t\tpr_cont_pool_info(pool);\n\t\tpr_cont(\" hung=%us workers=%d\",\n\t\t\tjiffies_to_msecs(jiffies - pool->watchdog_ts) / 1000,\n\t\t\tpool->nr_workers);\n\t\tif (pool->manager)\n\t\t\tpr_cont(\" manager: %d\",\n\t\t\t\ttask_pid_nr(pool->manager->task));\n\t\tlist_for_each_entry(worker, &pool->idle_list, entry) {\n\t\t\tpr_cont(\" %s%d\", first ? \"idle: \" : \"\",\n\t\t\t\ttask_pid_nr(worker->task));\n\t\t\tfirst = false;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\tnext_pool:\n\t\tspin_unlock_irqrestore(&pool->lock, flags);\n\t\t/*\n\t\t * We could be printing a lot from atomic context, e.g.\n\t\t * sysrq-t -> show_workqueue_state(). Avoid triggering\n\t\t * hard lockup.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t}\n\n\trcu_read_unlock_sched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&pwq->delayed_works)"
          ],
          "line": 4172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->delayed_works"
          ],
          "line": 4172
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "pwq->nr_active"
          ],
          "line": 4171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "(pwq != wq->dfl_pwq) && (pwq->refcnt > 1)"
          ],
          "line": 4170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "pwq->nr_in_flight[i]"
          ],
          "line": 4163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 4159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drain_workqueue",
          "args": [
            "wq"
          ],
          "line": 4155
        },
        "resolved": true,
        "details": {
          "function_name": "drain_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2805-2846",
          "snippet": "void drain_workqueue(struct workqueue_struct *wq)\n{\n\tunsigned int flush_cnt = 0;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * __queue_work() needs to test whether there are drainers, is much\n\t * hotter than drain_workqueue() and already looks at @wq->flags.\n\t * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.\n\t */\n\tmutex_lock(&wq->mutex);\n\tif (!wq->nr_drainers++)\n\t\twq->flags |= __WQ_DRAINING;\n\tmutex_unlock(&wq->mutex);\nreflush:\n\tflush_workqueue(wq);\n\n\tmutex_lock(&wq->mutex);\n\n\tfor_each_pwq(pwq, wq) {\n\t\tbool drained;\n\n\t\tspin_lock_irq(&pwq->pool->lock);\n\t\tdrained = !pwq->nr_active && list_empty(&pwq->delayed_works);\n\t\tspin_unlock_irq(&pwq->pool->lock);\n\n\t\tif (drained)\n\t\t\tcontinue;\n\n\t\tif (++flush_cnt == 10 ||\n\t\t    (flush_cnt % 100 == 0 && flush_cnt <= 1000))\n\t\t\tpr_warn(\"workqueue %s: drain_workqueue() isn't complete after %u tries\\n\",\n\t\t\t\twq->name, flush_cnt);\n\n\t\tmutex_unlock(&wq->mutex);\n\t\tgoto reflush;\n\t}\n\n\tif (!--wq->nr_drainers)\n\t\twq->flags &= ~__WQ_DRAINING;\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid drain_workqueue(struct workqueue_struct *wq)\n{\n\tunsigned int flush_cnt = 0;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * __queue_work() needs to test whether there are drainers, is much\n\t * hotter than drain_workqueue() and already looks at @wq->flags.\n\t * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.\n\t */\n\tmutex_lock(&wq->mutex);\n\tif (!wq->nr_drainers++)\n\t\twq->flags |= __WQ_DRAINING;\n\tmutex_unlock(&wq->mutex);\nreflush:\n\tflush_workqueue(wq);\n\n\tmutex_lock(&wq->mutex);\n\n\tfor_each_pwq(pwq, wq) {\n\t\tbool drained;\n\n\t\tspin_lock_irq(&pwq->pool->lock);\n\t\tdrained = !pwq->nr_active && list_empty(&pwq->delayed_works);\n\t\tspin_unlock_irq(&pwq->pool->lock);\n\n\t\tif (drained)\n\t\t\tcontinue;\n\n\t\tif (++flush_cnt == 10 ||\n\t\t    (flush_cnt % 100 == 0 && flush_cnt <= 1000))\n\t\t\tpr_warn(\"workqueue %s: drain_workqueue() isn't complete after %u tries\\n\",\n\t\t\t\twq->name, flush_cnt);\n\n\t\tmutex_unlock(&wq->mutex);\n\t\tgoto reflush;\n\t}\n\n\tif (!--wq->nr_drainers)\n\t\twq->flags &= ~__WQ_DRAINING;\n\tmutex_unlock(&wq->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid destroy_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tint node;\n\n\t/* drain it before proceeding with destruction */\n\tdrain_workqueue(wq);\n\n\t/* sanity checks */\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq) {\n\t\tint i;\n\n\t\tfor (i = 0; i < WORK_NR_COLORS; i++) {\n\t\t\tif (WARN_ON(pwq->nr_in_flight[i])) {\n\t\t\t\tmutex_unlock(&wq->mutex);\n\t\t\t\tshow_workqueue_state();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (WARN_ON((pwq != wq->dfl_pwq) && (pwq->refcnt > 1)) ||\n\t\t    WARN_ON(pwq->nr_active) ||\n\t\t    WARN_ON(!list_empty(&pwq->delayed_works))) {\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t\tshow_workqueue_state();\n\t\t\treturn;\n\t\t}\n\t}\n\tmutex_unlock(&wq->mutex);\n\n\t/*\n\t * wq list is used to freeze wq, remove from list after\n\t * flushing is complete in case freeze races us.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\tlist_del_rcu(&wq->list);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tworkqueue_sysfs_unregister(wq);\n\n\tif (wq->rescuer)\n\t\tkthread_stop(wq->rescuer->task);\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\t/*\n\t\t * The base ref is never dropped on per-cpu pwqs.  Directly\n\t\t * schedule RCU free.\n\t\t */\n\t\tcall_rcu_sched(&wq->rcu, rcu_free_wq);\n\t} else {\n\t\t/*\n\t\t * We're the sole accessor of @wq at this point.  Directly\n\t\t * access numa_pwq_tbl[] and dfl_pwq to put the base refs.\n\t\t * @wq will be freed when the last pwq is released.\n\t\t */\n\t\tfor_each_node(node) {\n\t\t\tpwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\t\t\tRCU_INIT_POINTER(wq->numa_pwq_tbl[node], NULL);\n\t\t\tput_pwq_unlocked(pwq);\n\t\t}\n\n\t\t/*\n\t\t * Put dfl_pwq.  @wq may be freed any time after dfl_pwq is\n\t\t * put.  Don't access it afterwards.\n\t\t */\n\t\tpwq = wq->dfl_pwq;\n\t\twq->dfl_pwq = NULL;\n\t\tput_pwq_unlocked(pwq);\n\t}\n}"
  },
  {
    "function_name": "__alloc_workqueue_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4047-4140",
    "snippet": "struct workqueue_struct *__alloc_workqueue_key(const char *fmt,\n\t\t\t\t\t       unsigned int flags,\n\t\t\t\t\t       int max_active,\n\t\t\t\t\t       struct lock_class_key *key,\n\t\t\t\t\t       const char *lock_name, ...)\n{\n\tsize_t tbl_size = 0;\n\tva_list args;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * Unbound && max_active == 1 used to imply ordered, which is no\n\t * longer the case on NUMA machines due to per-node pools.  While\n\t * alloc_ordered_workqueue() is the right way to create an ordered\n\t * workqueue, keep the previous behavior to avoid subtle breakages\n\t * on NUMA.\n\t */\n\tif ((flags & WQ_UNBOUND) && max_active == 1)\n\t\tflags |= __WQ_ORDERED;\n\n\t/* see the comment above the definition of WQ_POWER_EFFICIENT */\n\tif ((flags & WQ_POWER_EFFICIENT) && wq_power_efficient)\n\t\tflags |= WQ_UNBOUND;\n\n\t/* allocate wq and format name */\n\tif (flags & WQ_UNBOUND)\n\t\ttbl_size = nr_node_ids * sizeof(wq->numa_pwq_tbl[0]);\n\n\twq = kzalloc(sizeof(*wq) + tbl_size, GFP_KERNEL);\n\tif (!wq)\n\t\treturn NULL;\n\n\tif (flags & WQ_UNBOUND) {\n\t\twq->unbound_attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\t\tif (!wq->unbound_attrs)\n\t\t\tgoto err_free_wq;\n\t}\n\n\tva_start(args, lock_name);\n\tvsnprintf(wq->name, sizeof(wq->name), fmt, args);\n\tva_end(args);\n\n\tmax_active = max_active ?: WQ_DFL_ACTIVE;\n\tmax_active = wq_clamp_max_active(max_active, flags, wq->name);\n\n\t/* init wq */\n\twq->flags = flags;\n\twq->saved_max_active = max_active;\n\tmutex_init(&wq->mutex);\n\tatomic_set(&wq->nr_pwqs_to_flush, 0);\n\tINIT_LIST_HEAD(&wq->pwqs);\n\tINIT_LIST_HEAD(&wq->flusher_queue);\n\tINIT_LIST_HEAD(&wq->flusher_overflow);\n\tINIT_LIST_HEAD(&wq->maydays);\n\n\tlockdep_init_map(&wq->lockdep_map, lock_name, key, 0);\n\tINIT_LIST_HEAD(&wq->list);\n\n\tif (alloc_and_link_pwqs(wq) < 0)\n\t\tgoto err_free_wq;\n\n\tif (wq_online && init_rescuer(wq) < 0)\n\t\tgoto err_destroy;\n\n\tif ((wq->flags & WQ_SYSFS) && workqueue_sysfs_register(wq))\n\t\tgoto err_destroy;\n\n\t/*\n\t * wq_pool_mutex protects global freeze state and workqueues list.\n\t * Grab it, adjust max_active and add the new @wq to workqueues\n\t * list.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\tmutex_unlock(&wq->mutex);\n\n\tlist_add_tail_rcu(&wq->list, &workqueues);\n\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn wq;\n\nerr_free_wq:\n\tfree_workqueue_attrs(wq->unbound_attrs);\n\tkfree(wq);\n\treturn NULL;\nerr_destroy:\n\tdestroy_workqueue(wq);\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool wq_power_efficient = IS_ENABLED(CONFIG_WQ_POWER_EFFICIENT_DEFAULT);",
      "static bool wq_online;",
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static LIST_HEAD(workqueues);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "wq"
          ],
          "line": 4138
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4149-4219",
          "snippet": "void destroy_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tint node;\n\n\t/* drain it before proceeding with destruction */\n\tdrain_workqueue(wq);\n\n\t/* sanity checks */\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq) {\n\t\tint i;\n\n\t\tfor (i = 0; i < WORK_NR_COLORS; i++) {\n\t\t\tif (WARN_ON(pwq->nr_in_flight[i])) {\n\t\t\t\tmutex_unlock(&wq->mutex);\n\t\t\t\tshow_workqueue_state();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (WARN_ON((pwq != wq->dfl_pwq) && (pwq->refcnt > 1)) ||\n\t\t    WARN_ON(pwq->nr_active) ||\n\t\t    WARN_ON(!list_empty(&pwq->delayed_works))) {\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t\tshow_workqueue_state();\n\t\t\treturn;\n\t\t}\n\t}\n\tmutex_unlock(&wq->mutex);\n\n\t/*\n\t * wq list is used to freeze wq, remove from list after\n\t * flushing is complete in case freeze races us.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\tlist_del_rcu(&wq->list);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tworkqueue_sysfs_unregister(wq);\n\n\tif (wq->rescuer)\n\t\tkthread_stop(wq->rescuer->task);\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\t/*\n\t\t * The base ref is never dropped on per-cpu pwqs.  Directly\n\t\t * schedule RCU free.\n\t\t */\n\t\tcall_rcu_sched(&wq->rcu, rcu_free_wq);\n\t} else {\n\t\t/*\n\t\t * We're the sole accessor of @wq at this point.  Directly\n\t\t * access numa_pwq_tbl[] and dfl_pwq to put the base refs.\n\t\t * @wq will be freed when the last pwq is released.\n\t\t */\n\t\tfor_each_node(node) {\n\t\t\tpwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\t\t\tRCU_INIT_POINTER(wq->numa_pwq_tbl[node], NULL);\n\t\t\tput_pwq_unlocked(pwq);\n\t\t}\n\n\t\t/*\n\t\t * Put dfl_pwq.  @wq may be freed any time after dfl_pwq is\n\t\t * put.  Don't access it afterwards.\n\t\t */\n\t\tpwq = wq->dfl_pwq;\n\t\twq->dfl_pwq = NULL;\n\t\tput_pwq_unlocked(pwq);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid destroy_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tint node;\n\n\t/* drain it before proceeding with destruction */\n\tdrain_workqueue(wq);\n\n\t/* sanity checks */\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq) {\n\t\tint i;\n\n\t\tfor (i = 0; i < WORK_NR_COLORS; i++) {\n\t\t\tif (WARN_ON(pwq->nr_in_flight[i])) {\n\t\t\t\tmutex_unlock(&wq->mutex);\n\t\t\t\tshow_workqueue_state();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (WARN_ON((pwq != wq->dfl_pwq) && (pwq->refcnt > 1)) ||\n\t\t    WARN_ON(pwq->nr_active) ||\n\t\t    WARN_ON(!list_empty(&pwq->delayed_works))) {\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t\tshow_workqueue_state();\n\t\t\treturn;\n\t\t}\n\t}\n\tmutex_unlock(&wq->mutex);\n\n\t/*\n\t * wq list is used to freeze wq, remove from list after\n\t * flushing is complete in case freeze races us.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\tlist_del_rcu(&wq->list);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tworkqueue_sysfs_unregister(wq);\n\n\tif (wq->rescuer)\n\t\tkthread_stop(wq->rescuer->task);\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\t/*\n\t\t * The base ref is never dropped on per-cpu pwqs.  Directly\n\t\t * schedule RCU free.\n\t\t */\n\t\tcall_rcu_sched(&wq->rcu, rcu_free_wq);\n\t} else {\n\t\t/*\n\t\t * We're the sole accessor of @wq at this point.  Directly\n\t\t * access numa_pwq_tbl[] and dfl_pwq to put the base refs.\n\t\t * @wq will be freed when the last pwq is released.\n\t\t */\n\t\tfor_each_node(node) {\n\t\t\tpwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\t\t\tRCU_INIT_POINTER(wq->numa_pwq_tbl[node], NULL);\n\t\t\tput_pwq_unlocked(pwq);\n\t\t}\n\n\t\t/*\n\t\t * Put dfl_pwq.  @wq may be freed any time after dfl_pwq is\n\t\t * put.  Don't access it afterwards.\n\t\t */\n\t\tpwq = wq->dfl_pwq;\n\t\twq->dfl_pwq = NULL;\n\t\tput_pwq_unlocked(pwq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wq"
          ],
          "line": 4135
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_workqueue_attrs",
          "args": [
            "wq->unbound_attrs"
          ],
          "line": 4134
        },
        "resolved": true,
        "details": {
          "function_name": "free_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3209-3215",
          "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 4129
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&wq->list",
            "&workqueues"
          ],
          "line": 4127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwq_adjust_max_active",
          "args": [
            "pwq"
          ],
          "line": 4124
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_adjust_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3524-3562",
          "snippet": "static void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->delayed_works) &&\n\t\t       pwq->nr_active < pwq->max_active)\n\t\t\tpwq_activate_first_delayed(pwq);\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped.  It's a slow path.  Do it always.\n\t\t */\n\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool workqueue_freezing;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->delayed_works) &&\n\t\t       pwq->nr_active < pwq->max_active)\n\t\t\tpwq_activate_first_delayed(pwq);\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped.  It's a slow path.  Do it always.\n\t\t */\n\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 4123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 4122
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "workqueue_sysfs_register",
          "args": [
            "wq"
          ],
          "line": 4112
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_sysfs_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5416-5467",
          "snippet": "int workqueue_sysfs_register(struct workqueue_struct *wq)\n{\n\tstruct wq_device *wq_dev;\n\tint ret;\n\n\t/*\n\t * Adjusting max_active or creating new pwqs by applying\n\t * attributes breaks ordering guarantee.  Disallow exposing ordered\n\t * workqueues.\n\t */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn -EINVAL;\n\n\twq->wq_dev = wq_dev = kzalloc(sizeof(*wq_dev), GFP_KERNEL);\n\tif (!wq_dev)\n\t\treturn -ENOMEM;\n\n\twq_dev->wq = wq;\n\twq_dev->dev.bus = &wq_subsys;\n\twq_dev->dev.release = wq_device_release;\n\tdev_set_name(&wq_dev->dev, \"%s\", wq->name);\n\n\t/*\n\t * unbound_attrs are created separately.  Suppress uevent until\n\t * everything is ready.\n\t */\n\tdev_set_uevent_suppress(&wq_dev->dev, true);\n\n\tret = device_register(&wq_dev->dev);\n\tif (ret) {\n\t\tput_device(&wq_dev->dev);\n\t\twq->wq_dev = NULL;\n\t\treturn ret;\n\t}\n\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tstruct device_attribute *attr;\n\n\t\tfor (attr = wq_sysfs_unbound_attrs; attr->attr.name; attr++) {\n\t\t\tret = device_create_file(&wq_dev->dev, attr);\n\t\t\tif (ret) {\n\t\t\t\tdevice_unregister(&wq_dev->dev);\n\t\t\t\twq->wq_dev = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_set_uevent_suppress(&wq_dev->dev, false);\n\tkobject_uevent(&wq_dev->dev.kobj, KOBJ_ADD);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nint workqueue_sysfs_register(struct workqueue_struct *wq)\n{\n\tstruct wq_device *wq_dev;\n\tint ret;\n\n\t/*\n\t * Adjusting max_active or creating new pwqs by applying\n\t * attributes breaks ordering guarantee.  Disallow exposing ordered\n\t * workqueues.\n\t */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn -EINVAL;\n\n\twq->wq_dev = wq_dev = kzalloc(sizeof(*wq_dev), GFP_KERNEL);\n\tif (!wq_dev)\n\t\treturn -ENOMEM;\n\n\twq_dev->wq = wq;\n\twq_dev->dev.bus = &wq_subsys;\n\twq_dev->dev.release = wq_device_release;\n\tdev_set_name(&wq_dev->dev, \"%s\", wq->name);\n\n\t/*\n\t * unbound_attrs are created separately.  Suppress uevent until\n\t * everything is ready.\n\t */\n\tdev_set_uevent_suppress(&wq_dev->dev, true);\n\n\tret = device_register(&wq_dev->dev);\n\tif (ret) {\n\t\tput_device(&wq_dev->dev);\n\t\twq->wq_dev = NULL;\n\t\treturn ret;\n\t}\n\n\tif (wq->flags & WQ_UNBOUND) {\n\t\tstruct device_attribute *attr;\n\n\t\tfor (attr = wq_sysfs_unbound_attrs; attr->attr.name; attr++) {\n\t\t\tret = device_create_file(&wq_dev->dev, attr);\n\t\t\tif (ret) {\n\t\t\t\tdevice_unregister(&wq_dev->dev);\n\t\t\t\twq->wq_dev = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_set_uevent_suppress(&wq_dev->dev, false);\n\tkobject_uevent(&wq_dev->dev.kobj, KOBJ_ADD);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rescuer",
          "args": [
            "wq"
          ],
          "line": 4109
        },
        "resolved": true,
        "details": {
          "function_name": "init_rescuer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4020-4045",
          "snippet": "static int init_rescuer(struct workqueue_struct *wq)\n{\n\tstruct worker *rescuer;\n\tint ret;\n\n\tif (!(wq->flags & WQ_MEM_RECLAIM))\n\t\treturn 0;\n\n\trescuer = alloc_worker(NUMA_NO_NODE);\n\tif (!rescuer)\n\t\treturn -ENOMEM;\n\n\trescuer->rescue_wq = wq;\n\trescuer->task = kthread_create(rescuer_thread, rescuer, \"%s\", wq->name);\n\tret = PTR_ERR_OR_ZERO(rescuer->task);\n\tif (ret) {\n\t\tkfree(rescuer);\n\t\treturn ret;\n\t}\n\n\twq->rescuer = rescuer;\n\tkthread_bind_mask(rescuer->task, cpu_possible_mask);\n\twake_up_process(rescuer->task);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int init_rescuer(struct workqueue_struct *wq)\n{\n\tstruct worker *rescuer;\n\tint ret;\n\n\tif (!(wq->flags & WQ_MEM_RECLAIM))\n\t\treturn 0;\n\n\trescuer = alloc_worker(NUMA_NO_NODE);\n\tif (!rescuer)\n\t\treturn -ENOMEM;\n\n\trescuer->rescue_wq = wq;\n\trescuer->task = kthread_create(rescuer_thread, rescuer, \"%s\", wq->name);\n\tret = PTR_ERR_OR_ZERO(rescuer->task);\n\tif (ret) {\n\t\tkfree(rescuer);\n\t\treturn ret;\n\t}\n\n\twq->rescuer = rescuer;\n\tkthread_bind_mask(rescuer->task, cpu_possible_mask);\n\twake_up_process(rescuer->task);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_and_link_pwqs",
          "args": [
            "wq"
          ],
          "line": 4106
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_link_pwqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3969-4002",
          "snippet": "static int alloc_and_link_pwqs(struct workqueue_struct *wq)\n{\n\tbool highpri = wq->flags & WQ_HIGHPRI;\n\tint cpu, ret;\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq->cpu_pwqs = alloc_percpu(struct pool_workqueue);\n\t\tif (!wq->cpu_pwqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct pool_workqueue *pwq =\n\t\t\t\tper_cpu_ptr(wq->cpu_pwqs, cpu);\n\t\t\tstruct worker_pool *cpu_pools =\n\t\t\t\tper_cpu(cpu_worker_pools, cpu);\n\n\t\t\tinit_pwq(pwq, wq, &cpu_pools[highpri]);\n\n\t\t\tmutex_lock(&wq->mutex);\n\t\t\tlink_pwq(pwq);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t\treturn 0;\n\t} else if (wq->flags & __WQ_ORDERED) {\n\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);\n\t\t/* there should only be single pwq for ordering guarantee */\n\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),\n\t\t     \"ordering guarantee broken for workqueue %s\\n\", wq->name);\n\t\treturn ret;\n\t} else {\n\t\treturn apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];",
            "static struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];\nstatic struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int alloc_and_link_pwqs(struct workqueue_struct *wq)\n{\n\tbool highpri = wq->flags & WQ_HIGHPRI;\n\tint cpu, ret;\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq->cpu_pwqs = alloc_percpu(struct pool_workqueue);\n\t\tif (!wq->cpu_pwqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct pool_workqueue *pwq =\n\t\t\t\tper_cpu_ptr(wq->cpu_pwqs, cpu);\n\t\t\tstruct worker_pool *cpu_pools =\n\t\t\t\tper_cpu(cpu_worker_pools, cpu);\n\n\t\t\tinit_pwq(pwq, wq, &cpu_pools[highpri]);\n\n\t\t\tmutex_lock(&wq->mutex);\n\t\t\tlink_pwq(pwq);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t\treturn 0;\n\t} else if (wq->flags & __WQ_ORDERED) {\n\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);\n\t\t/* there should only be single pwq for ordering guarantee */\n\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),\n\t\t     \"ordering guarantee broken for workqueue %s\\n\", wq->name);\n\t\treturn ret;\n\t} else {\n\t\treturn apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&wq->list"
          ],
          "line": 4104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_init_map",
          "args": [
            "&wq->lockdep_map",
            "lock_name",
            "key",
            "0"
          ],
          "line": 4103
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_init_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3148-3152",
          "snippet": "void lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&wq->maydays"
          ],
          "line": 4101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&wq->flusher_overflow"
          ],
          "line": 4100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&wq->flusher_queue"
          ],
          "line": 4099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&wq->pwqs"
          ],
          "line": 4098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&wq->nr_pwqs_to_flush",
            "0"
          ],
          "line": 4097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&wq->mutex"
          ],
          "line": 4096
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1604-1612",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_clamp_max_active",
          "args": [
            "max_active",
            "flags",
            "wq->name"
          ],
          "line": 4091
        },
        "resolved": true,
        "details": {
          "function_name": "wq_clamp_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4004-4014",
          "snippet": "static int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 4088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "wq->name",
            "sizeof(wq->name)",
            "fmt",
            "args"
          ],
          "line": 4087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "lock_name"
          ],
          "line": 4086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue_attrs",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 4081
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3226-3241",
          "snippet": "struct workqueue_attrs *alloc_workqueue_attrs(gfp_t gfp_mask)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), gfp_mask);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, gfp_mask))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct workqueue_attrs *alloc_workqueue_attrs(gfp_t gfp_mask)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), gfp_mask);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, gfp_mask))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*wq) + tbl_size",
            "GFP_KERNEL"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_power_efficient = IS_ENABLED(CONFIG_WQ_POWER_EFFICIENT_DEFAULT);\nstatic bool wq_online;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstruct workqueue_struct *__alloc_workqueue_key(const char *fmt,\n\t\t\t\t\t       unsigned int flags,\n\t\t\t\t\t       int max_active,\n\t\t\t\t\t       struct lock_class_key *key,\n\t\t\t\t\t       const char *lock_name, ...)\n{\n\tsize_t tbl_size = 0;\n\tva_list args;\n\tstruct workqueue_struct *wq;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * Unbound && max_active == 1 used to imply ordered, which is no\n\t * longer the case on NUMA machines due to per-node pools.  While\n\t * alloc_ordered_workqueue() is the right way to create an ordered\n\t * workqueue, keep the previous behavior to avoid subtle breakages\n\t * on NUMA.\n\t */\n\tif ((flags & WQ_UNBOUND) && max_active == 1)\n\t\tflags |= __WQ_ORDERED;\n\n\t/* see the comment above the definition of WQ_POWER_EFFICIENT */\n\tif ((flags & WQ_POWER_EFFICIENT) && wq_power_efficient)\n\t\tflags |= WQ_UNBOUND;\n\n\t/* allocate wq and format name */\n\tif (flags & WQ_UNBOUND)\n\t\ttbl_size = nr_node_ids * sizeof(wq->numa_pwq_tbl[0]);\n\n\twq = kzalloc(sizeof(*wq) + tbl_size, GFP_KERNEL);\n\tif (!wq)\n\t\treturn NULL;\n\n\tif (flags & WQ_UNBOUND) {\n\t\twq->unbound_attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\t\tif (!wq->unbound_attrs)\n\t\t\tgoto err_free_wq;\n\t}\n\n\tva_start(args, lock_name);\n\tvsnprintf(wq->name, sizeof(wq->name), fmt, args);\n\tva_end(args);\n\n\tmax_active = max_active ?: WQ_DFL_ACTIVE;\n\tmax_active = wq_clamp_max_active(max_active, flags, wq->name);\n\n\t/* init wq */\n\twq->flags = flags;\n\twq->saved_max_active = max_active;\n\tmutex_init(&wq->mutex);\n\tatomic_set(&wq->nr_pwqs_to_flush, 0);\n\tINIT_LIST_HEAD(&wq->pwqs);\n\tINIT_LIST_HEAD(&wq->flusher_queue);\n\tINIT_LIST_HEAD(&wq->flusher_overflow);\n\tINIT_LIST_HEAD(&wq->maydays);\n\n\tlockdep_init_map(&wq->lockdep_map, lock_name, key, 0);\n\tINIT_LIST_HEAD(&wq->list);\n\n\tif (alloc_and_link_pwqs(wq) < 0)\n\t\tgoto err_free_wq;\n\n\tif (wq_online && init_rescuer(wq) < 0)\n\t\tgoto err_destroy;\n\n\tif ((wq->flags & WQ_SYSFS) && workqueue_sysfs_register(wq))\n\t\tgoto err_destroy;\n\n\t/*\n\t * wq_pool_mutex protects global freeze state and workqueues list.\n\t * Grab it, adjust max_active and add the new @wq to workqueues\n\t * list.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\tmutex_unlock(&wq->mutex);\n\n\tlist_add_tail_rcu(&wq->list, &workqueues);\n\n\tmutex_unlock(&wq_pool_mutex);\n\n\treturn wq;\n\nerr_free_wq:\n\tfree_workqueue_attrs(wq->unbound_attrs);\n\tkfree(wq);\n\treturn NULL;\nerr_destroy:\n\tdestroy_workqueue(wq);\n\treturn NULL;\n}"
  },
  {
    "function_name": "init_rescuer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4020-4045",
    "snippet": "static int init_rescuer(struct workqueue_struct *wq)\n{\n\tstruct worker *rescuer;\n\tint ret;\n\n\tif (!(wq->flags & WQ_MEM_RECLAIM))\n\t\treturn 0;\n\n\trescuer = alloc_worker(NUMA_NO_NODE);\n\tif (!rescuer)\n\t\treturn -ENOMEM;\n\n\trescuer->rescue_wq = wq;\n\trescuer->task = kthread_create(rescuer_thread, rescuer, \"%s\", wq->name);\n\tret = PTR_ERR_OR_ZERO(rescuer->task);\n\tif (ret) {\n\t\tkfree(rescuer);\n\t\treturn ret;\n\t}\n\n\twq->rescuer = rescuer;\n\tkthread_bind_mask(rescuer->task, cpu_possible_mask);\n\twake_up_process(rescuer->task);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "rescuer->task"
          ],
          "line": 4042
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_bind_mask",
          "args": [
            "rescuer->task",
            "cpu_possible_mask"
          ],
          "line": 4041
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_bind_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "407-410",
          "snippet": "void kthread_bind_mask(struct task_struct *p, const struct cpumask *mask)\n{\n\t__kthread_bind_mask(p, mask, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_bind_mask(struct task_struct *p, const struct cpumask *mask)\n{\n\t__kthread_bind_mask(p, mask, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rescuer"
          ],
          "line": 4036
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR_OR_ZERO",
          "args": [
            "rescuer->task"
          ],
          "line": 4034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_create",
          "args": [
            "rescuer_thread",
            "rescuer",
            "\"%s\"",
            "wq->name"
          ],
          "line": 4033
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_create_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "716-727",
          "snippet": "struct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
            "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\n\nstruct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_worker",
          "args": [
            "NUMA_NO_NODE"
          ],
          "line": 4028
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1700-1713",
          "snippet": "static struct worker *alloc_worker(int node)\n{\n\tstruct worker *worker;\n\n\tworker = kzalloc_node(sizeof(*worker), GFP_KERNEL, node);\n\tif (worker) {\n\t\tINIT_LIST_HEAD(&worker->entry);\n\t\tINIT_LIST_HEAD(&worker->scheduled);\n\t\tINIT_LIST_HEAD(&worker->node);\n\t\t/* on creation a worker is in !idle && prep state */\n\t\tworker->flags = WORKER_PREP;\n\t}\n\treturn worker;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct worker *alloc_worker(int node)\n{\n\tstruct worker *worker;\n\n\tworker = kzalloc_node(sizeof(*worker), GFP_KERNEL, node);\n\tif (worker) {\n\t\tINIT_LIST_HEAD(&worker->entry);\n\t\tINIT_LIST_HEAD(&worker->scheduled);\n\t\tINIT_LIST_HEAD(&worker->node);\n\t\t/* on creation a worker is in !idle && prep state */\n\t\tworker->flags = WORKER_PREP;\n\t}\n\treturn worker;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int init_rescuer(struct workqueue_struct *wq)\n{\n\tstruct worker *rescuer;\n\tint ret;\n\n\tif (!(wq->flags & WQ_MEM_RECLAIM))\n\t\treturn 0;\n\n\trescuer = alloc_worker(NUMA_NO_NODE);\n\tif (!rescuer)\n\t\treturn -ENOMEM;\n\n\trescuer->rescue_wq = wq;\n\trescuer->task = kthread_create(rescuer_thread, rescuer, \"%s\", wq->name);\n\tret = PTR_ERR_OR_ZERO(rescuer->task);\n\tif (ret) {\n\t\tkfree(rescuer);\n\t\treturn ret;\n\t}\n\n\twq->rescuer = rescuer;\n\tkthread_bind_mask(rescuer->task, cpu_possible_mask);\n\twake_up_process(rescuer->task);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "wq_clamp_max_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "4004-4014",
    "snippet": "static int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clamp_val",
          "args": [
            "max_active",
            "1",
            "lim"
          ],
          "line": 4013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\"",
            "max_active",
            "name",
            "1",
            "lim"
          ],
          "line": 4010
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}"
  },
  {
    "function_name": "alloc_and_link_pwqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3969-4002",
    "snippet": "static int alloc_and_link_pwqs(struct workqueue_struct *wq)\n{\n\tbool highpri = wq->flags & WQ_HIGHPRI;\n\tint cpu, ret;\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq->cpu_pwqs = alloc_percpu(struct pool_workqueue);\n\t\tif (!wq->cpu_pwqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct pool_workqueue *pwq =\n\t\t\t\tper_cpu_ptr(wq->cpu_pwqs, cpu);\n\t\t\tstruct worker_pool *cpu_pools =\n\t\t\t\tper_cpu(cpu_worker_pools, cpu);\n\n\t\t\tinit_pwq(pwq, wq, &cpu_pools[highpri]);\n\n\t\t\tmutex_lock(&wq->mutex);\n\t\t\tlink_pwq(pwq);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t\treturn 0;\n\t} else if (wq->flags & __WQ_ORDERED) {\n\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);\n\t\t/* there should only be single pwq for ordering guarantee */\n\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),\n\t\t     \"ordering guarantee broken for workqueue %s\\n\", wq->name);\n\t\treturn ret;\n\t} else {\n\t\treturn apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];",
      "static struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply_workqueue_attrs",
          "args": [
            "wq",
            "unbound_std_wq_attrs[highpri]"
          ],
          "line": 4000
        },
        "resolved": true,
        "details": {
          "function_name": "apply_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3871-3881",
          "snippet": "int apply_workqueue_attrs(struct workqueue_struct *wq,\n\t\t\t  const struct workqueue_attrs *attrs)\n{\n\tint ret;\n\n\tapply_wqattrs_lock();\n\tret = apply_workqueue_attrs_locked(wq, attrs);\n\tapply_wqattrs_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nint apply_workqueue_attrs(struct workqueue_struct *wq,\n\t\t\t  const struct workqueue_attrs *attrs)\n{\n\tint ret;\n\n\tapply_wqattrs_lock();\n\tret = apply_workqueue_attrs_locked(wq, attrs);\n\tapply_wqattrs_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node)",
            "\"ordering guarantee broken for workqueue %s\\n\"",
            "wq->name"
          ],
          "line": 3995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq->mutex"
          ],
          "line": 3989
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_pwq",
          "args": [
            "pwq"
          ],
          "line": 3988
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_link_pwqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3969-4002",
          "snippet": "static int alloc_and_link_pwqs(struct workqueue_struct *wq)\n{\n\tbool highpri = wq->flags & WQ_HIGHPRI;\n\tint cpu, ret;\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq->cpu_pwqs = alloc_percpu(struct pool_workqueue);\n\t\tif (!wq->cpu_pwqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct pool_workqueue *pwq =\n\t\t\t\tper_cpu_ptr(wq->cpu_pwqs, cpu);\n\t\t\tstruct worker_pool *cpu_pools =\n\t\t\t\tper_cpu(cpu_worker_pools, cpu);\n\n\t\t\tinit_pwq(pwq, wq, &cpu_pools[highpri]);\n\n\t\t\tmutex_lock(&wq->mutex);\n\t\t\tlink_pwq(pwq);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t\treturn 0;\n\t} else if (wq->flags & __WQ_ORDERED) {\n\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);\n\t\t/* there should only be single pwq for ordering guarantee */\n\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),\n\t\t     \"ordering guarantee broken for workqueue %s\\n\", wq->name);\n\t\treturn ret;\n\t} else {\n\t\treturn apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 3987
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_pwq",
          "args": [
            "pwq",
            "wq",
            "&cpu_pools[highpri]"
          ],
          "line": 3985
        },
        "resolved": true,
        "details": {
          "function_name": "init_pwq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3565-3580",
          "snippet": "static void init_pwq(struct pool_workqueue *pwq, struct workqueue_struct *wq,\n\t\t     struct worker_pool *pool)\n{\n\tBUG_ON((unsigned long)pwq & WORK_STRUCT_FLAG_MASK);\n\n\tmemset(pwq, 0, sizeof(*pwq));\n\n\tpwq->pool = pool;\n\tpwq->wq = wq;\n\tpwq->flush_color = -1;\n\tpwq->refcnt = 1;\n\tINIT_LIST_HEAD(&pwq->delayed_works);\n\tINIT_LIST_HEAD(&pwq->pwqs_node);\n\tINIT_LIST_HEAD(&pwq->mayday_node);\n\tINIT_WORK(&pwq->unbound_release_work, pwq_unbound_release_workfn);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void init_pwq(struct pool_workqueue *pwq, struct workqueue_struct *wq,\n\t\t     struct worker_pool *pool)\n{\n\tBUG_ON((unsigned long)pwq & WORK_STRUCT_FLAG_MASK);\n\n\tmemset(pwq, 0, sizeof(*pwq));\n\n\tpwq->pool = pool;\n\tpwq->wq = wq;\n\tpwq->flush_color = -1;\n\tpwq->refcnt = 1;\n\tINIT_LIST_HEAD(&pwq->delayed_works);\n\tINIT_LIST_HEAD(&pwq->pwqs_node);\n\tINIT_LIST_HEAD(&pwq->mayday_node);\n\tINIT_WORK(&pwq->unbound_release_work, pwq_unbound_release_workfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cpu_worker_pools",
            "cpu"
          ],
          "line": 3983
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "wq->cpu_pwqs",
            "cpu"
          ],
          "line": 3981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structpool_workqueue"
          ],
          "line": 3975
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "37-54",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];\nstatic struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int alloc_and_link_pwqs(struct workqueue_struct *wq)\n{\n\tbool highpri = wq->flags & WQ_HIGHPRI;\n\tint cpu, ret;\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq->cpu_pwqs = alloc_percpu(struct pool_workqueue);\n\t\tif (!wq->cpu_pwqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct pool_workqueue *pwq =\n\t\t\t\tper_cpu_ptr(wq->cpu_pwqs, cpu);\n\t\t\tstruct worker_pool *cpu_pools =\n\t\t\t\tper_cpu(cpu_worker_pools, cpu);\n\n\t\t\tinit_pwq(pwq, wq, &cpu_pools[highpri]);\n\n\t\t\tmutex_lock(&wq->mutex);\n\t\t\tlink_pwq(pwq);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t\treturn 0;\n\t} else if (wq->flags & __WQ_ORDERED) {\n\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);\n\t\t/* there should only be single pwq for ordering guarantee */\n\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),\n\t\t     \"ordering guarantee broken for workqueue %s\\n\", wq->name);\n\t\treturn ret;\n\t} else {\n\t\treturn apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);\n\t}\n}"
  },
  {
    "function_name": "wq_update_unbound_numa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3906-3967",
    "snippet": "static void wq_update_unbound_numa(struct workqueue_struct *wq, int cpu,\n\t\t\t\t   bool online)\n{\n\tint node = cpu_to_node(cpu);\n\tint cpu_off = online ? -1 : cpu;\n\tstruct pool_workqueue *old_pwq = NULL, *pwq;\n\tstruct workqueue_attrs *target_attrs;\n\tcpumask_t *cpumask;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (!wq_numa_enabled || !(wq->flags & WQ_UNBOUND) ||\n\t    wq->unbound_attrs->no_numa)\n\t\treturn;\n\n\t/*\n\t * We don't wanna alloc/free wq_attrs for each wq for each CPU.\n\t * Let's use a preallocated one.  The following buf is protected by\n\t * CPU hotplug exclusion.\n\t */\n\ttarget_attrs = wq_update_unbound_numa_attrs_buf;\n\tcpumask = target_attrs->cpumask;\n\n\tcopy_workqueue_attrs(target_attrs, wq->unbound_attrs);\n\tpwq = unbound_pwq_by_node(wq, node);\n\n\t/*\n\t * Let's determine what needs to be done.  If the target cpumask is\n\t * different from the default pwq's, we need to compare it to @pwq's\n\t * and create a new one if they don't match.  If the target cpumask\n\t * equals the default pwq's, the default pwq should be used.\n\t */\n\tif (wq_calc_node_cpumask(wq->dfl_pwq->pool->attrs, node, cpu_off, cpumask)) {\n\t\tif (cpumask_equal(cpumask, pwq->pool->attrs->cpumask))\n\t\t\treturn;\n\t} else {\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* create a new pwq */\n\tpwq = alloc_unbound_pwq(wq, target_attrs);\n\tif (!pwq) {\n\t\tpr_warn(\"workqueue: allocation failed while updating NUMA affinity of \\\"%s\\\"\\n\",\n\t\t\twq->name);\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* Install the new pwq. */\n\tmutex_lock(&wq->mutex);\n\told_pwq = numa_pwq_tbl_install(wq, node, pwq);\n\tgoto out_unlock;\n\nuse_dfl_pwq:\n\tmutex_lock(&wq->mutex);\n\tspin_lock_irq(&wq->dfl_pwq->pool->lock);\n\tget_pwq(wq->dfl_pwq);\n\tspin_unlock_irq(&wq->dfl_pwq->pool->lock);\n\told_pwq = numa_pwq_tbl_install(wq, node, wq->dfl_pwq);\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n\tput_pwq_unlocked(old_pwq);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool wq_numa_enabled;",
      "static struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;",
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pwq_unlocked",
          "args": [
            "old_pwq"
          ],
          "line": 3966
        },
        "resolved": true,
        "details": {
          "function_name": "put_pwq_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1099-1110",
          "snippet": "static void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are sched-RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\tspin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\tspin_unlock_irq(&pwq->pool->lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are sched-RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\tspin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\tspin_unlock_irq(&pwq->pool->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq->mutex"
          ],
          "line": 3965
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_pwq_tbl_install",
          "args": [
            "wq",
            "node",
            "wq->dfl_pwq"
          ],
          "line": 3963
        },
        "resolved": true,
        "details": {
          "function_name": "numa_pwq_tbl_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3679-3694",
          "snippet": "static struct pool_workqueue *numa_pwq_tbl_install(struct workqueue_struct *wq,\n\t\t\t\t\t\t   int node,\n\t\t\t\t\t\t   struct pool_workqueue *pwq)\n{\n\tstruct pool_workqueue *old_pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* link_pwq() can handle duplicate calls */\n\tlink_pwq(pwq);\n\n\told_pwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\trcu_assign_pointer(wq->numa_pwq_tbl[node], pwq);\n\treturn old_pwq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct pool_workqueue *numa_pwq_tbl_install(struct workqueue_struct *wq,\n\t\t\t\t\t\t   int node,\n\t\t\t\t\t\t   struct pool_workqueue *pwq)\n{\n\tstruct pool_workqueue *old_pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* link_pwq() can handle duplicate calls */\n\tlink_pwq(pwq);\n\n\told_pwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\trcu_assign_pointer(wq->numa_pwq_tbl[node], pwq);\n\treturn old_pwq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&wq->dfl_pwq->pool->lock"
          ],
          "line": 3962
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pwq",
          "args": [
            "wq->dfl_pwq"
          ],
          "line": 3961
        },
        "resolved": true,
        "details": {
          "function_name": "get_pwq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1061-1066",
          "snippet": "static void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&wq->dfl_pwq->pool->lock"
          ],
          "line": 3960
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 3959
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"workqueue: allocation failed while updating NUMA affinity of \\\"%s\\\"\\n\"",
            "wq->name"
          ],
          "line": 3948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_unbound_pwq",
          "args": [
            "wq",
            "target_attrs"
          ],
          "line": 3946
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_unbound_pwq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3604-3624",
          "snippet": "static struct pool_workqueue *alloc_unbound_pwq(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tpool = get_unbound_pool(attrs);\n\tif (!pool)\n\t\treturn NULL;\n\n\tpwq = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL, pool->node);\n\tif (!pwq) {\n\t\tput_unbound_pool(pool);\n\t\treturn NULL;\n\t}\n\n\tinit_pwq(pwq, wq, pool);\n\treturn pwq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *pwq_cache;",
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *pwq_cache;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct pool_workqueue *alloc_unbound_pwq(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tpool = get_unbound_pool(attrs);\n\tif (!pool)\n\t\treturn NULL;\n\n\tpwq = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL, pool->node);\n\tif (!pwq) {\n\t\tput_unbound_pool(pool);\n\t\treturn NULL;\n\t}\n\n\tinit_pwq(pwq, wq, pool);\n\treturn pwq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "cpumask",
            "pwq->pool->attrs->cpumask"
          ],
          "line": 3939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wq_calc_node_cpumask",
          "args": [
            "wq->dfl_pwq->pool->attrs",
            "node",
            "cpu_off",
            "cpumask"
          ],
          "line": 3938
        },
        "resolved": true,
        "details": {
          "function_name": "wq_calc_node_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3648-3676",
          "snippet": "static bool wq_calc_node_cpumask(const struct workqueue_attrs *attrs, int node,\n\t\t\t\t int cpu_going_down, cpumask_t *cpumask)\n{\n\tif (!wq_numa_enabled || attrs->no_numa)\n\t\tgoto use_dfl;\n\n\t/* does @node have any online CPUs @attrs wants? */\n\tcpumask_and(cpumask, cpumask_of_node(node), attrs->cpumask);\n\tif (cpu_going_down >= 0)\n\t\tcpumask_clear_cpu(cpu_going_down, cpumask);\n\n\tif (cpumask_empty(cpumask))\n\t\tgoto use_dfl;\n\n\t/* yeap, return possible CPUs in @node that @attrs wants */\n\tcpumask_and(cpumask, attrs->cpumask, wq_numa_possible_cpumask[node]);\n\n\tif (cpumask_empty(cpumask)) {\n\t\tpr_warn_once(\"WARNING: workqueue cpumask: online intersect > \"\n\t\t\t\t\"possible intersect\\n\");\n\t\treturn false;\n\t}\n\n\treturn !cpumask_equal(cpumask, attrs->cpumask);\n\nuse_dfl:\n\tcpumask_copy(cpumask, attrs->cpumask);\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t *wq_numa_possible_cpumask;",
            "static bool wq_numa_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t *wq_numa_possible_cpumask;\nstatic bool wq_numa_enabled;\n\nstatic bool wq_calc_node_cpumask(const struct workqueue_attrs *attrs, int node,\n\t\t\t\t int cpu_going_down, cpumask_t *cpumask)\n{\n\tif (!wq_numa_enabled || attrs->no_numa)\n\t\tgoto use_dfl;\n\n\t/* does @node have any online CPUs @attrs wants? */\n\tcpumask_and(cpumask, cpumask_of_node(node), attrs->cpumask);\n\tif (cpu_going_down >= 0)\n\t\tcpumask_clear_cpu(cpu_going_down, cpumask);\n\n\tif (cpumask_empty(cpumask))\n\t\tgoto use_dfl;\n\n\t/* yeap, return possible CPUs in @node that @attrs wants */\n\tcpumask_and(cpumask, attrs->cpumask, wq_numa_possible_cpumask[node]);\n\n\tif (cpumask_empty(cpumask)) {\n\t\tpr_warn_once(\"WARNING: workqueue cpumask: online intersect > \"\n\t\t\t\t\"possible intersect\\n\");\n\t\treturn false;\n\t}\n\n\treturn !cpumask_equal(cpumask, attrs->cpumask);\n\nuse_dfl:\n\tcpumask_copy(cpumask, attrs->cpumask);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unbound_pwq_by_node",
          "args": [
            "wq",
            "node"
          ],
          "line": 3930
        },
        "resolved": true,
        "details": {
          "function_name": "unbound_pwq_by_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "560-575",
          "snippet": "static struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_workqueue_attrs",
          "args": [
            "target_attrs",
            "wq->unbound_attrs"
          ],
          "line": 3929
        },
        "resolved": true,
        "details": {
          "function_name": "copy_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3243-3254",
          "snippet": "static void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 3915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 3909
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_numa_enabled;\nstatic struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void wq_update_unbound_numa(struct workqueue_struct *wq, int cpu,\n\t\t\t\t   bool online)\n{\n\tint node = cpu_to_node(cpu);\n\tint cpu_off = online ? -1 : cpu;\n\tstruct pool_workqueue *old_pwq = NULL, *pwq;\n\tstruct workqueue_attrs *target_attrs;\n\tcpumask_t *cpumask;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (!wq_numa_enabled || !(wq->flags & WQ_UNBOUND) ||\n\t    wq->unbound_attrs->no_numa)\n\t\treturn;\n\n\t/*\n\t * We don't wanna alloc/free wq_attrs for each wq for each CPU.\n\t * Let's use a preallocated one.  The following buf is protected by\n\t * CPU hotplug exclusion.\n\t */\n\ttarget_attrs = wq_update_unbound_numa_attrs_buf;\n\tcpumask = target_attrs->cpumask;\n\n\tcopy_workqueue_attrs(target_attrs, wq->unbound_attrs);\n\tpwq = unbound_pwq_by_node(wq, node);\n\n\t/*\n\t * Let's determine what needs to be done.  If the target cpumask is\n\t * different from the default pwq's, we need to compare it to @pwq's\n\t * and create a new one if they don't match.  If the target cpumask\n\t * equals the default pwq's, the default pwq should be used.\n\t */\n\tif (wq_calc_node_cpumask(wq->dfl_pwq->pool->attrs, node, cpu_off, cpumask)) {\n\t\tif (cpumask_equal(cpumask, pwq->pool->attrs->cpumask))\n\t\t\treturn;\n\t} else {\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* create a new pwq */\n\tpwq = alloc_unbound_pwq(wq, target_attrs);\n\tif (!pwq) {\n\t\tpr_warn(\"workqueue: allocation failed while updating NUMA affinity of \\\"%s\\\"\\n\",\n\t\t\twq->name);\n\t\tgoto use_dfl_pwq;\n\t}\n\n\t/* Install the new pwq. */\n\tmutex_lock(&wq->mutex);\n\told_pwq = numa_pwq_tbl_install(wq, node, pwq);\n\tgoto out_unlock;\n\nuse_dfl_pwq:\n\tmutex_lock(&wq->mutex);\n\tspin_lock_irq(&wq->dfl_pwq->pool->lock);\n\tget_pwq(wq->dfl_pwq);\n\tspin_unlock_irq(&wq->dfl_pwq->pool->lock);\n\told_pwq = numa_pwq_tbl_install(wq, node, wq->dfl_pwq);\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n\tput_pwq_unlocked(old_pwq);\n}"
  },
  {
    "function_name": "apply_workqueue_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3871-3881",
    "snippet": "int apply_workqueue_attrs(struct workqueue_struct *wq,\n\t\t\t  const struct workqueue_attrs *attrs)\n{\n\tint ret;\n\n\tapply_wqattrs_lock();\n\tret = apply_workqueue_attrs_locked(wq, attrs);\n\tapply_wqattrs_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply_wqattrs_unlock",
          "args": [],
          "line": 3878
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3821-3825",
          "snippet": "static void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tput_online_cpus();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\n\nstatic void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tput_online_cpus();\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_workqueue_attrs_locked",
          "args": [
            "wq",
            "attrs"
          ],
          "line": 3877
        },
        "resolved": true,
        "details": {
          "function_name": "apply_workqueue_attrs_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3827-3853",
          "snippet": "static int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_lock",
          "args": [],
          "line": 3876
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3814-3819",
          "snippet": "static void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tget_online_cpus();\n\tmutex_lock(&wq_pool_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\n\nstatic void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tget_online_cpus();\n\tmutex_lock(&wq_pool_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nint apply_workqueue_attrs(struct workqueue_struct *wq,\n\t\t\t  const struct workqueue_attrs *attrs)\n{\n\tint ret;\n\n\tapply_wqattrs_lock();\n\tret = apply_workqueue_attrs_locked(wq, attrs);\n\tapply_wqattrs_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "apply_workqueue_attrs_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3827-3853",
    "snippet": "static int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(workqueues);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply_wqattrs_cleanup",
          "args": [
            "ctx"
          ],
          "line": 3850
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3706-3719",
          "snippet": "static void apply_wqattrs_cleanup(struct apply_wqattrs_ctx *ctx)\n{\n\tif (ctx) {\n\t\tint node;\n\n\t\tfor_each_node(node)\n\t\t\tput_pwq_unlocked(ctx->pwq_tbl[node]);\n\t\tput_pwq_unlocked(ctx->dfl_pwq);\n\n\t\tfree_workqueue_attrs(ctx->attrs);\n\n\t\tkfree(ctx);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void apply_wqattrs_cleanup(struct apply_wqattrs_ctx *ctx)\n{\n\tif (ctx) {\n\t\tint node;\n\n\t\tfor_each_node(node)\n\t\t\tput_pwq_unlocked(ctx->pwq_tbl[node]);\n\t\tput_pwq_unlocked(ctx->dfl_pwq);\n\n\t\tfree_workqueue_attrs(ctx->attrs);\n\n\t\tkfree(ctx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_commit",
          "args": [
            "ctx"
          ],
          "line": 3849
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3793-3812",
          "snippet": "static void apply_wqattrs_commit(struct apply_wqattrs_ctx *ctx)\n{\n\tint node;\n\n\t/* all pwqs have been created successfully, let's install'em */\n\tmutex_lock(&ctx->wq->mutex);\n\n\tcopy_workqueue_attrs(ctx->wq->unbound_attrs, ctx->attrs);\n\n\t/* save the previous pwq and install the new one */\n\tfor_each_node(node)\n\t\tctx->pwq_tbl[node] = numa_pwq_tbl_install(ctx->wq, node,\n\t\t\t\t\t\t\t  ctx->pwq_tbl[node]);\n\n\t/* @dfl_pwq might not have been used, ensure it's linked */\n\tlink_pwq(ctx->dfl_pwq);\n\tswap(ctx->wq->dfl_pwq, ctx->dfl_pwq);\n\n\tmutex_unlock(&ctx->wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void apply_wqattrs_commit(struct apply_wqattrs_ctx *ctx)\n{\n\tint node;\n\n\t/* all pwqs have been created successfully, let's install'em */\n\tmutex_lock(&ctx->wq->mutex);\n\n\tcopy_workqueue_attrs(ctx->wq->unbound_attrs, ctx->attrs);\n\n\t/* save the previous pwq and install the new one */\n\tfor_each_node(node)\n\t\tctx->pwq_tbl[node] = numa_pwq_tbl_install(ctx->wq, node,\n\t\t\t\t\t\t\t  ctx->pwq_tbl[node]);\n\n\t/* @dfl_pwq might not have been used, ensure it's linked */\n\tlink_pwq(ctx->dfl_pwq);\n\tswap(ctx->wq->dfl_pwq, ctx->dfl_pwq);\n\n\tmutex_unlock(&ctx->wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apply_wqattrs_prepare",
          "args": [
            "wq",
            "attrs"
          ],
          "line": 3844
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3722-3790",
          "snippet": "static struct apply_wqattrs_ctx *\napply_wqattrs_prepare(struct workqueue_struct *wq,\n\t\t      const struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\tstruct workqueue_attrs *new_attrs, *tmp_attrs;\n\tint node;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tctx = kzalloc(struct_size(ctx, pwq_tbl, nr_node_ids), GFP_KERNEL);\n\n\tnew_attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\ttmp_attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!ctx || !new_attrs || !tmp_attrs)\n\t\tgoto out_free;\n\n\t/*\n\t * Calculate the attrs of the default pwq.\n\t * If the user configured cpumask doesn't overlap with the\n\t * wq_unbound_cpumask, we fallback to the wq_unbound_cpumask.\n\t */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, wq_unbound_cpumask);\n\tif (unlikely(cpumask_empty(new_attrs->cpumask)))\n\t\tcpumask_copy(new_attrs->cpumask, wq_unbound_cpumask);\n\n\t/*\n\t * We may create multiple pwqs with differing cpumasks.  Make a\n\t * copy of @new_attrs which will be modified and used to obtain\n\t * pools.\n\t */\n\tcopy_workqueue_attrs(tmp_attrs, new_attrs);\n\n\t/*\n\t * If something goes wrong during CPU up/down, we'll fall back to\n\t * the default pwq covering whole @attrs->cpumask.  Always create\n\t * it even if we don't use it immediately.\n\t */\n\tctx->dfl_pwq = alloc_unbound_pwq(wq, new_attrs);\n\tif (!ctx->dfl_pwq)\n\t\tgoto out_free;\n\n\tfor_each_node(node) {\n\t\tif (wq_calc_node_cpumask(new_attrs, node, -1, tmp_attrs->cpumask)) {\n\t\t\tctx->pwq_tbl[node] = alloc_unbound_pwq(wq, tmp_attrs);\n\t\t\tif (!ctx->pwq_tbl[node])\n\t\t\t\tgoto out_free;\n\t\t} else {\n\t\t\tctx->dfl_pwq->refcnt++;\n\t\t\tctx->pwq_tbl[node] = ctx->dfl_pwq;\n\t\t}\n\t}\n\n\t/* save the user configured attrs and sanitize it. */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, cpu_possible_mask);\n\tctx->attrs = new_attrs;\n\n\tctx->wq = wq;\n\tfree_workqueue_attrs(tmp_attrs);\n\treturn ctx;\n\nout_free:\n\tfree_workqueue_attrs(tmp_attrs);\n\tfree_workqueue_attrs(new_attrs);\n\tapply_wqattrs_cleanup(ctx);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static cpumask_var_t wq_unbound_cpumask;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic cpumask_var_t wq_unbound_cpumask;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct apply_wqattrs_ctx *\napply_wqattrs_prepare(struct workqueue_struct *wq,\n\t\t      const struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\tstruct workqueue_attrs *new_attrs, *tmp_attrs;\n\tint node;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tctx = kzalloc(struct_size(ctx, pwq_tbl, nr_node_ids), GFP_KERNEL);\n\n\tnew_attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\ttmp_attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!ctx || !new_attrs || !tmp_attrs)\n\t\tgoto out_free;\n\n\t/*\n\t * Calculate the attrs of the default pwq.\n\t * If the user configured cpumask doesn't overlap with the\n\t * wq_unbound_cpumask, we fallback to the wq_unbound_cpumask.\n\t */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, wq_unbound_cpumask);\n\tif (unlikely(cpumask_empty(new_attrs->cpumask)))\n\t\tcpumask_copy(new_attrs->cpumask, wq_unbound_cpumask);\n\n\t/*\n\t * We may create multiple pwqs with differing cpumasks.  Make a\n\t * copy of @new_attrs which will be modified and used to obtain\n\t * pools.\n\t */\n\tcopy_workqueue_attrs(tmp_attrs, new_attrs);\n\n\t/*\n\t * If something goes wrong during CPU up/down, we'll fall back to\n\t * the default pwq covering whole @attrs->cpumask.  Always create\n\t * it even if we don't use it immediately.\n\t */\n\tctx->dfl_pwq = alloc_unbound_pwq(wq, new_attrs);\n\tif (!ctx->dfl_pwq)\n\t\tgoto out_free;\n\n\tfor_each_node(node) {\n\t\tif (wq_calc_node_cpumask(new_attrs, node, -1, tmp_attrs->cpumask)) {\n\t\t\tctx->pwq_tbl[node] = alloc_unbound_pwq(wq, tmp_attrs);\n\t\t\tif (!ctx->pwq_tbl[node])\n\t\t\t\tgoto out_free;\n\t\t} else {\n\t\t\tctx->dfl_pwq->refcnt++;\n\t\t\tctx->pwq_tbl[node] = ctx->dfl_pwq;\n\t\t}\n\t}\n\n\t/* save the user configured attrs and sanitize it. */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, cpu_possible_mask);\n\tctx->attrs = new_attrs;\n\n\tctx->wq = wq;\n\tfree_workqueue_attrs(tmp_attrs);\n\treturn ctx;\n\nout_free:\n\tfree_workqueue_attrs(tmp_attrs);\n\tfree_workqueue_attrs(new_attrs);\n\tapply_wqattrs_cleanup(ctx);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "wq->flags & __WQ_ORDERED_EXPLICIT"
          ],
          "line": 3838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wq->pwqs"
          ],
          "line": 3837
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(wq->flags & WQ_UNBOUND)"
          ],
          "line": 3833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int apply_workqueue_attrs_locked(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\n\t/* only unbound workqueues can change attributes */\n\tif (WARN_ON(!(wq->flags & WQ_UNBOUND)))\n\t\treturn -EINVAL;\n\n\t/* creating multiple pwqs breaks ordering guarantee */\n\tif (!list_empty(&wq->pwqs)) {\n\t\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\t\treturn -EINVAL;\n\n\t\twq->flags &= ~__WQ_ORDERED;\n\t}\n\n\tctx = apply_wqattrs_prepare(wq, attrs);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\t/* the ctx has been prepared successfully, let's commit it */\n\tapply_wqattrs_commit(ctx);\n\tapply_wqattrs_cleanup(ctx);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "apply_wqattrs_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3821-3825",
    "snippet": "static void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tput_online_cpus();\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 3824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 3823
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\n\nstatic void apply_wqattrs_unlock(void)\n{\n\tmutex_unlock(&wq_pool_mutex);\n\tput_online_cpus();\n}"
  },
  {
    "function_name": "apply_wqattrs_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3814-3819",
    "snippet": "static void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tget_online_cpus();\n\tmutex_lock(&wq_pool_mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 3818
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 3817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\n\nstatic void apply_wqattrs_lock(void)\n{\n\t/* CPUs should stay stable across pwq creations and installations */\n\tget_online_cpus();\n\tmutex_lock(&wq_pool_mutex);\n}"
  },
  {
    "function_name": "apply_wqattrs_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3793-3812",
    "snippet": "static void apply_wqattrs_commit(struct apply_wqattrs_ctx *ctx)\n{\n\tint node;\n\n\t/* all pwqs have been created successfully, let's install'em */\n\tmutex_lock(&ctx->wq->mutex);\n\n\tcopy_workqueue_attrs(ctx->wq->unbound_attrs, ctx->attrs);\n\n\t/* save the previous pwq and install the new one */\n\tfor_each_node(node)\n\t\tctx->pwq_tbl[node] = numa_pwq_tbl_install(ctx->wq, node,\n\t\t\t\t\t\t\t  ctx->pwq_tbl[node]);\n\n\t/* @dfl_pwq might not have been used, ensure it's linked */\n\tlink_pwq(ctx->dfl_pwq);\n\tswap(ctx->wq->dfl_pwq, ctx->dfl_pwq);\n\n\tmutex_unlock(&ctx->wq->mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ctx->wq->mutex"
          ],
          "line": 3811
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "ctx->wq->dfl_pwq",
            "ctx->dfl_pwq"
          ],
          "line": 3809
        },
        "resolved": true,
        "details": {
          "function_name": "get_swap_reader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/swap.c",
          "lines": "963-1008",
          "snippet": "static int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kmalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(tmp, 0, sizeof(*tmp));\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/ktime.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/atomic.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/lzo.h>",
            "#include <linux/slab.h>",
            "#include <linux/pm.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/device.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct swsusp_header *swsusp_header;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/ktime.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/vmalloc.h>\n#include <linux/lzo.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/device.h>\n#include <linux/genhd.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic struct swsusp_header *swsusp_header;\n\nstatic int get_swap_reader(struct swap_map_handle *handle,\n\t\tunsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_page_list *tmp, *last;\n\tsector_t offset;\n\n\t*flags_p = swsusp_header->flags;\n\n\tif (!swsusp_header->image) /* how can this happen? */\n\t\treturn -EINVAL;\n\n\thandle->cur = NULL;\n\tlast = handle->maps = NULL;\n\toffset = swsusp_header->image;\n\twhile (offset) {\n\t\ttmp = kmalloc(sizeof(*handle->maps), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(tmp, 0, sizeof(*tmp));\n\t\tif (!handle->maps)\n\t\t\thandle->maps = tmp;\n\t\tif (last)\n\t\t\tlast->next = tmp;\n\t\tlast = tmp;\n\n\t\ttmp->map = (struct swap_map_page *)\n\t\t\t   __get_free_page(GFP_NOIO | __GFP_HIGH);\n\t\tif (!tmp->map) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\terror = hib_submit_io(REQ_OP_READ, 0, offset, tmp->map, NULL);\n\t\tif (error) {\n\t\t\trelease_swap_reader(handle);\n\t\t\treturn error;\n\t\t}\n\t\toffset = tmp->map->next_swap;\n\t}\n\thandle->k = 0;\n\thandle->cur = handle->maps->map;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_pwq",
          "args": [
            "ctx->dfl_pwq"
          ],
          "line": 3808
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_link_pwqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3969-4002",
          "snippet": "static int alloc_and_link_pwqs(struct workqueue_struct *wq)\n{\n\tbool highpri = wq->flags & WQ_HIGHPRI;\n\tint cpu, ret;\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq->cpu_pwqs = alloc_percpu(struct pool_workqueue);\n\t\tif (!wq->cpu_pwqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct pool_workqueue *pwq =\n\t\t\t\tper_cpu_ptr(wq->cpu_pwqs, cpu);\n\t\t\tstruct worker_pool *cpu_pools =\n\t\t\t\tper_cpu(cpu_worker_pools, cpu);\n\n\t\t\tinit_pwq(pwq, wq, &cpu_pools[highpri]);\n\n\t\t\tmutex_lock(&wq->mutex);\n\t\t\tlink_pwq(pwq);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t\treturn 0;\n\t} else if (wq->flags & __WQ_ORDERED) {\n\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);\n\t\t/* there should only be single pwq for ordering guarantee */\n\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),\n\t\t     \"ordering guarantee broken for workqueue %s\\n\", wq->name);\n\t\treturn ret;\n\t} else {\n\t\treturn apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];",
            "static struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];\nstatic struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int alloc_and_link_pwqs(struct workqueue_struct *wq)\n{\n\tbool highpri = wq->flags & WQ_HIGHPRI;\n\tint cpu, ret;\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq->cpu_pwqs = alloc_percpu(struct pool_workqueue);\n\t\tif (!wq->cpu_pwqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct pool_workqueue *pwq =\n\t\t\t\tper_cpu_ptr(wq->cpu_pwqs, cpu);\n\t\t\tstruct worker_pool *cpu_pools =\n\t\t\t\tper_cpu(cpu_worker_pools, cpu);\n\n\t\t\tinit_pwq(pwq, wq, &cpu_pools[highpri]);\n\n\t\t\tmutex_lock(&wq->mutex);\n\t\t\tlink_pwq(pwq);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t\treturn 0;\n\t} else if (wq->flags & __WQ_ORDERED) {\n\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);\n\t\t/* there should only be single pwq for ordering guarantee */\n\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),\n\t\t     \"ordering guarantee broken for workqueue %s\\n\", wq->name);\n\t\treturn ret;\n\t} else {\n\t\treturn apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "numa_pwq_tbl_install",
          "args": [
            "ctx->wq",
            "node",
            "ctx->pwq_tbl[node]"
          ],
          "line": 3804
        },
        "resolved": true,
        "details": {
          "function_name": "numa_pwq_tbl_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3679-3694",
          "snippet": "static struct pool_workqueue *numa_pwq_tbl_install(struct workqueue_struct *wq,\n\t\t\t\t\t\t   int node,\n\t\t\t\t\t\t   struct pool_workqueue *pwq)\n{\n\tstruct pool_workqueue *old_pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* link_pwq() can handle duplicate calls */\n\tlink_pwq(pwq);\n\n\told_pwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\trcu_assign_pointer(wq->numa_pwq_tbl[node], pwq);\n\treturn old_pwq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct pool_workqueue *numa_pwq_tbl_install(struct workqueue_struct *wq,\n\t\t\t\t\t\t   int node,\n\t\t\t\t\t\t   struct pool_workqueue *pwq)\n{\n\tstruct pool_workqueue *old_pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* link_pwq() can handle duplicate calls */\n\tlink_pwq(pwq);\n\n\told_pwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\trcu_assign_pointer(wq->numa_pwq_tbl[node], pwq);\n\treturn old_pwq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_workqueue_attrs",
          "args": [
            "ctx->wq->unbound_attrs",
            "ctx->attrs"
          ],
          "line": 3800
        },
        "resolved": true,
        "details": {
          "function_name": "copy_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3243-3254",
          "snippet": "static void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ctx->wq->mutex"
          ],
          "line": 3798
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void apply_wqattrs_commit(struct apply_wqattrs_ctx *ctx)\n{\n\tint node;\n\n\t/* all pwqs have been created successfully, let's install'em */\n\tmutex_lock(&ctx->wq->mutex);\n\n\tcopy_workqueue_attrs(ctx->wq->unbound_attrs, ctx->attrs);\n\n\t/* save the previous pwq and install the new one */\n\tfor_each_node(node)\n\t\tctx->pwq_tbl[node] = numa_pwq_tbl_install(ctx->wq, node,\n\t\t\t\t\t\t\t  ctx->pwq_tbl[node]);\n\n\t/* @dfl_pwq might not have been used, ensure it's linked */\n\tlink_pwq(ctx->dfl_pwq);\n\tswap(ctx->wq->dfl_pwq, ctx->dfl_pwq);\n\n\tmutex_unlock(&ctx->wq->mutex);\n}"
  },
  {
    "function_name": "apply_wqattrs_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3722-3790",
    "snippet": "static struct apply_wqattrs_ctx *\napply_wqattrs_prepare(struct workqueue_struct *wq,\n\t\t      const struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\tstruct workqueue_attrs *new_attrs, *tmp_attrs;\n\tint node;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tctx = kzalloc(struct_size(ctx, pwq_tbl, nr_node_ids), GFP_KERNEL);\n\n\tnew_attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\ttmp_attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!ctx || !new_attrs || !tmp_attrs)\n\t\tgoto out_free;\n\n\t/*\n\t * Calculate the attrs of the default pwq.\n\t * If the user configured cpumask doesn't overlap with the\n\t * wq_unbound_cpumask, we fallback to the wq_unbound_cpumask.\n\t */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, wq_unbound_cpumask);\n\tif (unlikely(cpumask_empty(new_attrs->cpumask)))\n\t\tcpumask_copy(new_attrs->cpumask, wq_unbound_cpumask);\n\n\t/*\n\t * We may create multiple pwqs with differing cpumasks.  Make a\n\t * copy of @new_attrs which will be modified and used to obtain\n\t * pools.\n\t */\n\tcopy_workqueue_attrs(tmp_attrs, new_attrs);\n\n\t/*\n\t * If something goes wrong during CPU up/down, we'll fall back to\n\t * the default pwq covering whole @attrs->cpumask.  Always create\n\t * it even if we don't use it immediately.\n\t */\n\tctx->dfl_pwq = alloc_unbound_pwq(wq, new_attrs);\n\tif (!ctx->dfl_pwq)\n\t\tgoto out_free;\n\n\tfor_each_node(node) {\n\t\tif (wq_calc_node_cpumask(new_attrs, node, -1, tmp_attrs->cpumask)) {\n\t\t\tctx->pwq_tbl[node] = alloc_unbound_pwq(wq, tmp_attrs);\n\t\t\tif (!ctx->pwq_tbl[node])\n\t\t\t\tgoto out_free;\n\t\t} else {\n\t\t\tctx->dfl_pwq->refcnt++;\n\t\t\tctx->pwq_tbl[node] = ctx->dfl_pwq;\n\t\t}\n\t}\n\n\t/* save the user configured attrs and sanitize it. */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, cpu_possible_mask);\n\tctx->attrs = new_attrs;\n\n\tctx->wq = wq;\n\tfree_workqueue_attrs(tmp_attrs);\n\treturn ctx;\n\nout_free:\n\tfree_workqueue_attrs(tmp_attrs);\n\tfree_workqueue_attrs(new_attrs);\n\tapply_wqattrs_cleanup(ctx);\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static cpumask_var_t wq_unbound_cpumask;",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apply_wqattrs_cleanup",
          "args": [
            "ctx"
          ],
          "line": 3788
        },
        "resolved": true,
        "details": {
          "function_name": "apply_wqattrs_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3706-3719",
          "snippet": "static void apply_wqattrs_cleanup(struct apply_wqattrs_ctx *ctx)\n{\n\tif (ctx) {\n\t\tint node;\n\n\t\tfor_each_node(node)\n\t\t\tput_pwq_unlocked(ctx->pwq_tbl[node]);\n\t\tput_pwq_unlocked(ctx->dfl_pwq);\n\n\t\tfree_workqueue_attrs(ctx->attrs);\n\n\t\tkfree(ctx);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void apply_wqattrs_cleanup(struct apply_wqattrs_ctx *ctx)\n{\n\tif (ctx) {\n\t\tint node;\n\n\t\tfor_each_node(node)\n\t\t\tput_pwq_unlocked(ctx->pwq_tbl[node]);\n\t\tput_pwq_unlocked(ctx->dfl_pwq);\n\n\t\tfree_workqueue_attrs(ctx->attrs);\n\n\t\tkfree(ctx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_workqueue_attrs",
          "args": [
            "new_attrs"
          ],
          "line": 3787
        },
        "resolved": true,
        "details": {
          "function_name": "free_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3209-3215",
          "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "new_attrs->cpumask",
            "new_attrs->cpumask",
            "cpu_possible_mask"
          ],
          "line": 3778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_workqueue_attrs",
          "args": [
            "new_attrs",
            "attrs"
          ],
          "line": 3777
        },
        "resolved": true,
        "details": {
          "function_name": "copy_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3243-3254",
          "snippet": "static void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_unbound_pwq",
          "args": [
            "wq",
            "tmp_attrs"
          ],
          "line": 3767
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_unbound_pwq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3604-3624",
          "snippet": "static struct pool_workqueue *alloc_unbound_pwq(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tpool = get_unbound_pool(attrs);\n\tif (!pool)\n\t\treturn NULL;\n\n\tpwq = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL, pool->node);\n\tif (!pwq) {\n\t\tput_unbound_pool(pool);\n\t\treturn NULL;\n\t}\n\n\tinit_pwq(pwq, wq, pool);\n\treturn pwq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *pwq_cache;",
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *pwq_cache;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct pool_workqueue *alloc_unbound_pwq(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tpool = get_unbound_pool(attrs);\n\tif (!pool)\n\t\treturn NULL;\n\n\tpwq = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL, pool->node);\n\tif (!pwq) {\n\t\tput_unbound_pool(pool);\n\t\treturn NULL;\n\t}\n\n\tinit_pwq(pwq, wq, pool);\n\treturn pwq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wq_calc_node_cpumask",
          "args": [
            "new_attrs",
            "node",
            "-1",
            "tmp_attrs->cpumask"
          ],
          "line": 3766
        },
        "resolved": true,
        "details": {
          "function_name": "wq_calc_node_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3648-3676",
          "snippet": "static bool wq_calc_node_cpumask(const struct workqueue_attrs *attrs, int node,\n\t\t\t\t int cpu_going_down, cpumask_t *cpumask)\n{\n\tif (!wq_numa_enabled || attrs->no_numa)\n\t\tgoto use_dfl;\n\n\t/* does @node have any online CPUs @attrs wants? */\n\tcpumask_and(cpumask, cpumask_of_node(node), attrs->cpumask);\n\tif (cpu_going_down >= 0)\n\t\tcpumask_clear_cpu(cpu_going_down, cpumask);\n\n\tif (cpumask_empty(cpumask))\n\t\tgoto use_dfl;\n\n\t/* yeap, return possible CPUs in @node that @attrs wants */\n\tcpumask_and(cpumask, attrs->cpumask, wq_numa_possible_cpumask[node]);\n\n\tif (cpumask_empty(cpumask)) {\n\t\tpr_warn_once(\"WARNING: workqueue cpumask: online intersect > \"\n\t\t\t\t\"possible intersect\\n\");\n\t\treturn false;\n\t}\n\n\treturn !cpumask_equal(cpumask, attrs->cpumask);\n\nuse_dfl:\n\tcpumask_copy(cpumask, attrs->cpumask);\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t *wq_numa_possible_cpumask;",
            "static bool wq_numa_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t *wq_numa_possible_cpumask;\nstatic bool wq_numa_enabled;\n\nstatic bool wq_calc_node_cpumask(const struct workqueue_attrs *attrs, int node,\n\t\t\t\t int cpu_going_down, cpumask_t *cpumask)\n{\n\tif (!wq_numa_enabled || attrs->no_numa)\n\t\tgoto use_dfl;\n\n\t/* does @node have any online CPUs @attrs wants? */\n\tcpumask_and(cpumask, cpumask_of_node(node), attrs->cpumask);\n\tif (cpu_going_down >= 0)\n\t\tcpumask_clear_cpu(cpu_going_down, cpumask);\n\n\tif (cpumask_empty(cpumask))\n\t\tgoto use_dfl;\n\n\t/* yeap, return possible CPUs in @node that @attrs wants */\n\tcpumask_and(cpumask, attrs->cpumask, wq_numa_possible_cpumask[node]);\n\n\tif (cpumask_empty(cpumask)) {\n\t\tpr_warn_once(\"WARNING: workqueue cpumask: online intersect > \"\n\t\t\t\t\"possible intersect\\n\");\n\t\treturn false;\n\t}\n\n\treturn !cpumask_equal(cpumask, attrs->cpumask);\n\nuse_dfl:\n\tcpumask_copy(cpumask, attrs->cpumask);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "new_attrs->cpumask",
            "wq_unbound_cpumask"
          ],
          "line": 3747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cpumask_empty(new_attrs->cpumask)"
          ],
          "line": 3746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "new_attrs->cpumask"
          ],
          "line": 3746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "new_attrs->cpumask",
            "new_attrs->cpumask",
            "wq_unbound_cpumask"
          ],
          "line": 3745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_workqueue_attrs",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 3735
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3226-3241",
          "snippet": "struct workqueue_attrs *alloc_workqueue_attrs(gfp_t gfp_mask)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), gfp_mask);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, gfp_mask))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct workqueue_attrs *alloc_workqueue_attrs(gfp_t gfp_mask)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), gfp_mask);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, gfp_mask))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "struct_size(ctx, pwq_tbl, nr_node_ids)",
            "GFP_KERNEL"
          ],
          "line": 3732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "ctx",
            "pwq_tbl",
            "nr_node_ids"
          ],
          "line": 3732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 3730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic cpumask_var_t wq_unbound_cpumask;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct apply_wqattrs_ctx *\napply_wqattrs_prepare(struct workqueue_struct *wq,\n\t\t      const struct workqueue_attrs *attrs)\n{\n\tstruct apply_wqattrs_ctx *ctx;\n\tstruct workqueue_attrs *new_attrs, *tmp_attrs;\n\tint node;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tctx = kzalloc(struct_size(ctx, pwq_tbl, nr_node_ids), GFP_KERNEL);\n\n\tnew_attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\ttmp_attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!ctx || !new_attrs || !tmp_attrs)\n\t\tgoto out_free;\n\n\t/*\n\t * Calculate the attrs of the default pwq.\n\t * If the user configured cpumask doesn't overlap with the\n\t * wq_unbound_cpumask, we fallback to the wq_unbound_cpumask.\n\t */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, wq_unbound_cpumask);\n\tif (unlikely(cpumask_empty(new_attrs->cpumask)))\n\t\tcpumask_copy(new_attrs->cpumask, wq_unbound_cpumask);\n\n\t/*\n\t * We may create multiple pwqs with differing cpumasks.  Make a\n\t * copy of @new_attrs which will be modified and used to obtain\n\t * pools.\n\t */\n\tcopy_workqueue_attrs(tmp_attrs, new_attrs);\n\n\t/*\n\t * If something goes wrong during CPU up/down, we'll fall back to\n\t * the default pwq covering whole @attrs->cpumask.  Always create\n\t * it even if we don't use it immediately.\n\t */\n\tctx->dfl_pwq = alloc_unbound_pwq(wq, new_attrs);\n\tif (!ctx->dfl_pwq)\n\t\tgoto out_free;\n\n\tfor_each_node(node) {\n\t\tif (wq_calc_node_cpumask(new_attrs, node, -1, tmp_attrs->cpumask)) {\n\t\t\tctx->pwq_tbl[node] = alloc_unbound_pwq(wq, tmp_attrs);\n\t\t\tif (!ctx->pwq_tbl[node])\n\t\t\t\tgoto out_free;\n\t\t} else {\n\t\t\tctx->dfl_pwq->refcnt++;\n\t\t\tctx->pwq_tbl[node] = ctx->dfl_pwq;\n\t\t}\n\t}\n\n\t/* save the user configured attrs and sanitize it. */\n\tcopy_workqueue_attrs(new_attrs, attrs);\n\tcpumask_and(new_attrs->cpumask, new_attrs->cpumask, cpu_possible_mask);\n\tctx->attrs = new_attrs;\n\n\tctx->wq = wq;\n\tfree_workqueue_attrs(tmp_attrs);\n\treturn ctx;\n\nout_free:\n\tfree_workqueue_attrs(tmp_attrs);\n\tfree_workqueue_attrs(new_attrs);\n\tapply_wqattrs_cleanup(ctx);\n\treturn NULL;\n}"
  },
  {
    "function_name": "apply_wqattrs_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3706-3719",
    "snippet": "static void apply_wqattrs_cleanup(struct apply_wqattrs_ctx *ctx)\n{\n\tif (ctx) {\n\t\tint node;\n\n\t\tfor_each_node(node)\n\t\t\tput_pwq_unlocked(ctx->pwq_tbl[node]);\n\t\tput_pwq_unlocked(ctx->dfl_pwq);\n\n\t\tfree_workqueue_attrs(ctx->attrs);\n\n\t\tkfree(ctx);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx"
          ],
          "line": 3717
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_workqueue_attrs",
          "args": [
            "ctx->attrs"
          ],
          "line": 3715
        },
        "resolved": true,
        "details": {
          "function_name": "free_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3209-3215",
          "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pwq_unlocked",
          "args": [
            "ctx->dfl_pwq"
          ],
          "line": 3713
        },
        "resolved": true,
        "details": {
          "function_name": "put_pwq_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1099-1110",
          "snippet": "static void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are sched-RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\tspin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\tspin_unlock_irq(&pwq->pool->lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are sched-RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\tspin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\tspin_unlock_irq(&pwq->pool->lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void apply_wqattrs_cleanup(struct apply_wqattrs_ctx *ctx)\n{\n\tif (ctx) {\n\t\tint node;\n\n\t\tfor_each_node(node)\n\t\t\tput_pwq_unlocked(ctx->pwq_tbl[node]);\n\t\tput_pwq_unlocked(ctx->dfl_pwq);\n\n\t\tfree_workqueue_attrs(ctx->attrs);\n\n\t\tkfree(ctx);\n\t}\n}"
  },
  {
    "function_name": "numa_pwq_tbl_install",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3679-3694",
    "snippet": "static struct pool_workqueue *numa_pwq_tbl_install(struct workqueue_struct *wq,\n\t\t\t\t\t\t   int node,\n\t\t\t\t\t\t   struct pool_workqueue *pwq)\n{\n\tstruct pool_workqueue *old_pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* link_pwq() can handle duplicate calls */\n\tlink_pwq(pwq);\n\n\told_pwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\trcu_assign_pointer(wq->numa_pwq_tbl[node], pwq);\n\treturn old_pwq;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "wq->numa_pwq_tbl[node]",
            "pwq"
          ],
          "line": 3692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "wq->numa_pwq_tbl[node]"
          ],
          "line": 3691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_pwq",
          "args": [
            "pwq"
          ],
          "line": 3689
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_and_link_pwqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3969-4002",
          "snippet": "static int alloc_and_link_pwqs(struct workqueue_struct *wq)\n{\n\tbool highpri = wq->flags & WQ_HIGHPRI;\n\tint cpu, ret;\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq->cpu_pwqs = alloc_percpu(struct pool_workqueue);\n\t\tif (!wq->cpu_pwqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct pool_workqueue *pwq =\n\t\t\t\tper_cpu_ptr(wq->cpu_pwqs, cpu);\n\t\t\tstruct worker_pool *cpu_pools =\n\t\t\t\tper_cpu(cpu_worker_pools, cpu);\n\n\t\t\tinit_pwq(pwq, wq, &cpu_pools[highpri]);\n\n\t\t\tmutex_lock(&wq->mutex);\n\t\t\tlink_pwq(pwq);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t\treturn 0;\n\t} else if (wq->flags & __WQ_ORDERED) {\n\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);\n\t\t/* there should only be single pwq for ordering guarantee */\n\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),\n\t\t     \"ordering guarantee broken for workqueue %s\\n\", wq->name);\n\t\treturn ret;\n\t} else {\n\t\treturn apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];",
            "static struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic struct workqueue_attrs *unbound_std_wq_attrs[NR_STD_WORKER_POOLS];\nstatic struct workqueue_attrs *ordered_wq_attrs[NR_STD_WORKER_POOLS];\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int alloc_and_link_pwqs(struct workqueue_struct *wq)\n{\n\tbool highpri = wq->flags & WQ_HIGHPRI;\n\tint cpu, ret;\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq->cpu_pwqs = alloc_percpu(struct pool_workqueue);\n\t\tif (!wq->cpu_pwqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct pool_workqueue *pwq =\n\t\t\t\tper_cpu_ptr(wq->cpu_pwqs, cpu);\n\t\t\tstruct worker_pool *cpu_pools =\n\t\t\t\tper_cpu(cpu_worker_pools, cpu);\n\n\t\t\tinit_pwq(pwq, wq, &cpu_pools[highpri]);\n\n\t\t\tmutex_lock(&wq->mutex);\n\t\t\tlink_pwq(pwq);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t\treturn 0;\n\t} else if (wq->flags & __WQ_ORDERED) {\n\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);\n\t\t/* there should only be single pwq for ordering guarantee */\n\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),\n\t\t     \"ordering guarantee broken for workqueue %s\\n\", wq->name);\n\t\treturn ret;\n\t} else {\n\t\treturn apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq->mutex"
          ],
          "line": 3686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 3685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct pool_workqueue *numa_pwq_tbl_install(struct workqueue_struct *wq,\n\t\t\t\t\t\t   int node,\n\t\t\t\t\t\t   struct pool_workqueue *pwq)\n{\n\tstruct pool_workqueue *old_pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* link_pwq() can handle duplicate calls */\n\tlink_pwq(pwq);\n\n\told_pwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\trcu_assign_pointer(wq->numa_pwq_tbl[node], pwq);\n\treturn old_pwq;\n}"
  },
  {
    "function_name": "wq_calc_node_cpumask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3648-3676",
    "snippet": "static bool wq_calc_node_cpumask(const struct workqueue_attrs *attrs, int node,\n\t\t\t\t int cpu_going_down, cpumask_t *cpumask)\n{\n\tif (!wq_numa_enabled || attrs->no_numa)\n\t\tgoto use_dfl;\n\n\t/* does @node have any online CPUs @attrs wants? */\n\tcpumask_and(cpumask, cpumask_of_node(node), attrs->cpumask);\n\tif (cpu_going_down >= 0)\n\t\tcpumask_clear_cpu(cpu_going_down, cpumask);\n\n\tif (cpumask_empty(cpumask))\n\t\tgoto use_dfl;\n\n\t/* yeap, return possible CPUs in @node that @attrs wants */\n\tcpumask_and(cpumask, attrs->cpumask, wq_numa_possible_cpumask[node]);\n\n\tif (cpumask_empty(cpumask)) {\n\t\tpr_warn_once(\"WARNING: workqueue cpumask: online intersect > \"\n\t\t\t\t\"possible intersect\\n\");\n\t\treturn false;\n\t}\n\n\treturn !cpumask_equal(cpumask, attrs->cpumask);\n\nuse_dfl:\n\tcpumask_copy(cpumask, attrs->cpumask);\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t *wq_numa_possible_cpumask;",
      "static bool wq_numa_enabled;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "cpumask",
            "attrs->cpumask"
          ],
          "line": 3674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "cpumask",
            "attrs->cpumask"
          ],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"WARNING: workqueue cpumask: online intersect > \"\n\t\t\t\t\"possible intersect\\n\""
          ],
          "line": 3666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cpumask"
          ],
          "line": 3665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "cpumask",
            "attrs->cpumask",
            "wq_numa_possible_cpumask[node]"
          ],
          "line": 3663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cpumask"
          ],
          "line": 3659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu_going_down",
            "cpumask"
          ],
          "line": 3657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "cpumask",
            "cpumask_of_node(node)",
            "attrs->cpumask"
          ],
          "line": 3655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "node"
          ],
          "line": 3655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t *wq_numa_possible_cpumask;\nstatic bool wq_numa_enabled;\n\nstatic bool wq_calc_node_cpumask(const struct workqueue_attrs *attrs, int node,\n\t\t\t\t int cpu_going_down, cpumask_t *cpumask)\n{\n\tif (!wq_numa_enabled || attrs->no_numa)\n\t\tgoto use_dfl;\n\n\t/* does @node have any online CPUs @attrs wants? */\n\tcpumask_and(cpumask, cpumask_of_node(node), attrs->cpumask);\n\tif (cpu_going_down >= 0)\n\t\tcpumask_clear_cpu(cpu_going_down, cpumask);\n\n\tif (cpumask_empty(cpumask))\n\t\tgoto use_dfl;\n\n\t/* yeap, return possible CPUs in @node that @attrs wants */\n\tcpumask_and(cpumask, attrs->cpumask, wq_numa_possible_cpumask[node]);\n\n\tif (cpumask_empty(cpumask)) {\n\t\tpr_warn_once(\"WARNING: workqueue cpumask: online intersect > \"\n\t\t\t\t\"possible intersect\\n\");\n\t\treturn false;\n\t}\n\n\treturn !cpumask_equal(cpumask, attrs->cpumask);\n\nuse_dfl:\n\tcpumask_copy(cpumask, attrs->cpumask);\n\treturn false;\n}"
  },
  {
    "function_name": "alloc_unbound_pwq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3604-3624",
    "snippet": "static struct pool_workqueue *alloc_unbound_pwq(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tpool = get_unbound_pool(attrs);\n\tif (!pool)\n\t\treturn NULL;\n\n\tpwq = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL, pool->node);\n\tif (!pwq) {\n\t\tput_unbound_pool(pool);\n\t\treturn NULL;\n\t}\n\n\tinit_pwq(pwq, wq, pool);\n\treturn pwq;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *pwq_cache;",
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_pwq",
          "args": [
            "pwq",
            "wq",
            "pool"
          ],
          "line": 3622
        },
        "resolved": true,
        "details": {
          "function_name": "init_pwq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3565-3580",
          "snippet": "static void init_pwq(struct pool_workqueue *pwq, struct workqueue_struct *wq,\n\t\t     struct worker_pool *pool)\n{\n\tBUG_ON((unsigned long)pwq & WORK_STRUCT_FLAG_MASK);\n\n\tmemset(pwq, 0, sizeof(*pwq));\n\n\tpwq->pool = pool;\n\tpwq->wq = wq;\n\tpwq->flush_color = -1;\n\tpwq->refcnt = 1;\n\tINIT_LIST_HEAD(&pwq->delayed_works);\n\tINIT_LIST_HEAD(&pwq->pwqs_node);\n\tINIT_LIST_HEAD(&pwq->mayday_node);\n\tINIT_WORK(&pwq->unbound_release_work, pwq_unbound_release_workfn);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void init_pwq(struct pool_workqueue *pwq, struct workqueue_struct *wq,\n\t\t     struct worker_pool *pool)\n{\n\tBUG_ON((unsigned long)pwq & WORK_STRUCT_FLAG_MASK);\n\n\tmemset(pwq, 0, sizeof(*pwq));\n\n\tpwq->pool = pool;\n\tpwq->wq = wq;\n\tpwq->flush_color = -1;\n\tpwq->refcnt = 1;\n\tINIT_LIST_HEAD(&pwq->delayed_works);\n\tINIT_LIST_HEAD(&pwq->pwqs_node);\n\tINIT_LIST_HEAD(&pwq->mayday_node);\n\tINIT_WORK(&pwq->unbound_release_work, pwq_unbound_release_workfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_unbound_pool",
          "args": [
            "pool"
          ],
          "line": 3618
        },
        "resolved": true,
        "details": {
          "function_name": "put_unbound_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3351-3400",
          "snippet": "static void put_unbound_pool(struct worker_pool *pool)\n{\n\tDECLARE_COMPLETION_ONSTACK(detach_completion);\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (--pool->refcnt)\n\t\treturn;\n\n\t/* sanity checks */\n\tif (WARN_ON(!(pool->cpu < 0)) ||\n\t    WARN_ON(!list_empty(&pool->worklist)))\n\t\treturn;\n\n\t/* release id and unhash */\n\tif (pool->id >= 0)\n\t\tidr_remove(&worker_pool_idr, pool->id);\n\thash_del(&pool->hash_node);\n\n\t/*\n\t * Become the manager and destroy all workers.  This prevents\n\t * @pool's workers from blocking on attach_mutex.  We're the last\n\t * manager and @pool gets freed with the flag set.\n\t */\n\tspin_lock_irq(&pool->lock);\n\twait_event_lock_irq(wq_manager_wait,\n\t\t\t    !(pool->flags & POOL_MANAGER_ACTIVE), pool->lock);\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\n\twhile ((worker = first_idle_worker(pool)))\n\t\tdestroy_worker(worker);\n\tWARN_ON(pool->nr_workers || pool->nr_idle);\n\tspin_unlock_irq(&pool->lock);\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (!list_empty(&pool->workers))\n\t\tpool->detach_completion = &detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\tif (pool->detach_completion)\n\t\twait_for_completion(pool->detach_completion);\n\n\t/* shut down the timers */\n\tdel_timer_sync(&pool->idle_timer);\n\tdel_timer_sync(&pool->mayday_timer);\n\n\t/* sched-RCU protected to allow dereferences from get_work_pool() */\n\tcall_rcu_sched(&pool->rcu, rcu_free_pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static DECLARE_WAIT_QUEUE_HEAD(wq_manager_wait);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static DEFINE_IDR(worker_pool_idr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DECLARE_WAIT_QUEUE_HEAD(wq_manager_wait);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic DEFINE_IDR(worker_pool_idr);\n\nstatic void put_unbound_pool(struct worker_pool *pool)\n{\n\tDECLARE_COMPLETION_ONSTACK(detach_completion);\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (--pool->refcnt)\n\t\treturn;\n\n\t/* sanity checks */\n\tif (WARN_ON(!(pool->cpu < 0)) ||\n\t    WARN_ON(!list_empty(&pool->worklist)))\n\t\treturn;\n\n\t/* release id and unhash */\n\tif (pool->id >= 0)\n\t\tidr_remove(&worker_pool_idr, pool->id);\n\thash_del(&pool->hash_node);\n\n\t/*\n\t * Become the manager and destroy all workers.  This prevents\n\t * @pool's workers from blocking on attach_mutex.  We're the last\n\t * manager and @pool gets freed with the flag set.\n\t */\n\tspin_lock_irq(&pool->lock);\n\twait_event_lock_irq(wq_manager_wait,\n\t\t\t    !(pool->flags & POOL_MANAGER_ACTIVE), pool->lock);\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\n\twhile ((worker = first_idle_worker(pool)))\n\t\tdestroy_worker(worker);\n\tWARN_ON(pool->nr_workers || pool->nr_idle);\n\tspin_unlock_irq(&pool->lock);\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (!list_empty(&pool->workers))\n\t\tpool->detach_completion = &detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\tif (pool->detach_completion)\n\t\twait_for_completion(pool->detach_completion);\n\n\t/* shut down the timers */\n\tdel_timer_sync(&pool->idle_timer);\n\tdel_timer_sync(&pool->mayday_timer);\n\n\t/* sched-RCU protected to allow dereferences from get_work_pool() */\n\tcall_rcu_sched(&pool->rcu, rcu_free_pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc_node",
          "args": [
            "pwq_cache",
            "GFP_KERNEL",
            "pool->node"
          ],
          "line": 3616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unbound_pool",
          "args": [
            "attrs"
          ],
          "line": 3612
        },
        "resolved": true,
        "details": {
          "function_name": "get_unbound_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3416-3474",
          "snippet": "static struct worker_pool *get_unbound_pool(const struct workqueue_attrs *attrs)\n{\n\tu32 hash = wqattrs_hash(attrs);\n\tstruct worker_pool *pool;\n\tint node;\n\tint target_node = NUMA_NO_NODE;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\t/* do we already have a matching pool? */\n\thash_for_each_possible(unbound_pool_hash, pool, hash_node, hash) {\n\t\tif (wqattrs_equal(pool->attrs, attrs)) {\n\t\t\tpool->refcnt++;\n\t\t\treturn pool;\n\t\t}\n\t}\n\n\t/* if cpumask is contained inside a NUMA node, we belong to that node */\n\tif (wq_numa_enabled) {\n\t\tfor_each_node(node) {\n\t\t\tif (cpumask_subset(attrs->cpumask,\n\t\t\t\t\t   wq_numa_possible_cpumask[node])) {\n\t\t\t\ttarget_node = node;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* nope, create a new one */\n\tpool = kzalloc_node(sizeof(*pool), GFP_KERNEL, target_node);\n\tif (!pool || init_worker_pool(pool) < 0)\n\t\tgoto fail;\n\n\tlockdep_set_subclass(&pool->lock, 1);\t/* see put_pwq() */\n\tcopy_workqueue_attrs(pool->attrs, attrs);\n\tpool->node = target_node;\n\n\t/*\n\t * no_numa isn't a worker_pool attribute, always clear it.  See\n\t * 'struct workqueue_attrs' comments for detail.\n\t */\n\tpool->attrs->no_numa = false;\n\n\tif (worker_pool_assign_id(pool) < 0)\n\t\tgoto fail;\n\n\t/* create and start the initial worker */\n\tif (wq_online && !create_worker(pool))\n\t\tgoto fail;\n\n\t/* install */\n\thash_add(unbound_pool_hash, &pool->hash_node, hash);\n\n\treturn pool;\nfail:\n\tif (pool)\n\t\tput_unbound_pool(pool);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t *wq_numa_possible_cpumask;",
            "static bool wq_online;",
            "static bool wq_numa_enabled;",
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t *wq_numa_possible_cpumask;\nstatic bool wq_online;\nstatic bool wq_numa_enabled;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic struct worker_pool *get_unbound_pool(const struct workqueue_attrs *attrs)\n{\n\tu32 hash = wqattrs_hash(attrs);\n\tstruct worker_pool *pool;\n\tint node;\n\tint target_node = NUMA_NO_NODE;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\t/* do we already have a matching pool? */\n\thash_for_each_possible(unbound_pool_hash, pool, hash_node, hash) {\n\t\tif (wqattrs_equal(pool->attrs, attrs)) {\n\t\t\tpool->refcnt++;\n\t\t\treturn pool;\n\t\t}\n\t}\n\n\t/* if cpumask is contained inside a NUMA node, we belong to that node */\n\tif (wq_numa_enabled) {\n\t\tfor_each_node(node) {\n\t\t\tif (cpumask_subset(attrs->cpumask,\n\t\t\t\t\t   wq_numa_possible_cpumask[node])) {\n\t\t\t\ttarget_node = node;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* nope, create a new one */\n\tpool = kzalloc_node(sizeof(*pool), GFP_KERNEL, target_node);\n\tif (!pool || init_worker_pool(pool) < 0)\n\t\tgoto fail;\n\n\tlockdep_set_subclass(&pool->lock, 1);\t/* see put_pwq() */\n\tcopy_workqueue_attrs(pool->attrs, attrs);\n\tpool->node = target_node;\n\n\t/*\n\t * no_numa isn't a worker_pool attribute, always clear it.  See\n\t * 'struct workqueue_attrs' comments for detail.\n\t */\n\tpool->attrs->no_numa = false;\n\n\tif (worker_pool_assign_id(pool) < 0)\n\t\tgoto fail;\n\n\t/* create and start the initial worker */\n\tif (wq_online && !create_worker(pool))\n\t\tgoto fail;\n\n\t/* install */\n\thash_add(unbound_pool_hash, &pool->hash_node, hash);\n\n\treturn pool;\nfail:\n\tif (pool)\n\t\tput_unbound_pool(pool);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 3610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *pwq_cache;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct pool_workqueue *alloc_unbound_pwq(struct workqueue_struct *wq,\n\t\t\t\t\tconst struct workqueue_attrs *attrs)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tpool = get_unbound_pool(attrs);\n\tif (!pool)\n\t\treturn NULL;\n\n\tpwq = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL, pool->node);\n\tif (!pwq) {\n\t\tput_unbound_pool(pool);\n\t\treturn NULL;\n\t}\n\n\tinit_pwq(pwq, wq, pool);\n\treturn pwq;\n}"
  },
  {
    "function_name": "link_pwq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3583-3601",
    "snippet": "static void link_pwq(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* may be called multiple times, ignore if already linked */\n\tif (!list_empty(&pwq->pwqs_node))\n\t\treturn;\n\n\t/* set the matching work_color */\n\tpwq->work_color = wq->work_color;\n\n\t/* sync max_active to the current setting */\n\tpwq_adjust_max_active(pwq);\n\n\t/* link in @pwq */\n\tlist_add_rcu(&pwq->pwqs_node, &wq->pwqs);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&pwq->pwqs_node",
            "&wq->pwqs"
          ],
          "line": 3600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwq_adjust_max_active",
          "args": [
            "pwq"
          ],
          "line": 3597
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_adjust_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3524-3562",
          "snippet": "static void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->delayed_works) &&\n\t\t       pwq->nr_active < pwq->max_active)\n\t\t\tpwq_activate_first_delayed(pwq);\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped.  It's a slow path.  Do it always.\n\t\t */\n\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool workqueue_freezing;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->delayed_works) &&\n\t\t       pwq->nr_active < pwq->max_active)\n\t\t\tpwq_activate_first_delayed(pwq);\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped.  It's a slow path.  Do it always.\n\t\t */\n\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->pwqs_node"
          ],
          "line": 3590
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq->mutex"
          ],
          "line": 3587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void link_pwq(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* may be called multiple times, ignore if already linked */\n\tif (!list_empty(&pwq->pwqs_node))\n\t\treturn;\n\n\t/* set the matching work_color */\n\tpwq->work_color = wq->work_color;\n\n\t/* sync max_active to the current setting */\n\tpwq_adjust_max_active(pwq);\n\n\t/* link in @pwq */\n\tlist_add_rcu(&pwq->pwqs_node, &wq->pwqs);\n}"
  },
  {
    "function_name": "init_pwq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3565-3580",
    "snippet": "static void init_pwq(struct pool_workqueue *pwq, struct workqueue_struct *wq,\n\t\t     struct worker_pool *pool)\n{\n\tBUG_ON((unsigned long)pwq & WORK_STRUCT_FLAG_MASK);\n\n\tmemset(pwq, 0, sizeof(*pwq));\n\n\tpwq->pool = pool;\n\tpwq->wq = wq;\n\tpwq->flush_color = -1;\n\tpwq->refcnt = 1;\n\tINIT_LIST_HEAD(&pwq->delayed_works);\n\tINIT_LIST_HEAD(&pwq->pwqs_node);\n\tINIT_LIST_HEAD(&pwq->mayday_node);\n\tINIT_WORK(&pwq->unbound_release_work, pwq_unbound_release_workfn);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&pwq->unbound_release_work",
            "pwq_unbound_release_workfn"
          ],
          "line": 3579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pwq->mayday_node"
          ],
          "line": 3578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pwq->pwqs_node"
          ],
          "line": 3577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pwq->delayed_works"
          ],
          "line": 3576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pwq",
            "0",
            "sizeof(*pwq)"
          ],
          "line": 3570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(unsigned long)pwq & WORK_STRUCT_FLAG_MASK"
          ],
          "line": 3568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void init_pwq(struct pool_workqueue *pwq, struct workqueue_struct *wq,\n\t\t     struct worker_pool *pool)\n{\n\tBUG_ON((unsigned long)pwq & WORK_STRUCT_FLAG_MASK);\n\n\tmemset(pwq, 0, sizeof(*pwq));\n\n\tpwq->pool = pool;\n\tpwq->wq = wq;\n\tpwq->flush_color = -1;\n\tpwq->refcnt = 1;\n\tINIT_LIST_HEAD(&pwq->delayed_works);\n\tINIT_LIST_HEAD(&pwq->pwqs_node);\n\tINIT_LIST_HEAD(&pwq->mayday_node);\n\tINIT_WORK(&pwq->unbound_release_work, pwq_unbound_release_workfn);\n}"
  },
  {
    "function_name": "pwq_adjust_max_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3524-3562",
    "snippet": "static void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->delayed_works) &&\n\t\t       pwq->nr_active < pwq->max_active)\n\t\t\tpwq_activate_first_delayed(pwq);\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped.  It's a slow path.  Do it always.\n\t\t */\n\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool workqueue_freezing;",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&pwq->pool->lock",
            "flags"
          ],
          "line": 3561
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_worker",
          "args": [
            "pwq->pool"
          ],
          "line": 3556
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwq_activate_first_delayed",
          "args": [
            "pwq"
          ],
          "line": 3550
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_activate_first_delayed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1124-1130",
          "snippet": "static void pwq_activate_first_delayed(struct pool_workqueue *pwq)\n{\n\tstruct work_struct *work = list_first_entry(&pwq->delayed_works,\n\t\t\t\t\t\t    struct work_struct, entry);\n\n\tpwq_activate_delayed_work(work);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pwq_activate_first_delayed(struct pool_workqueue *pwq)\n{\n\tstruct work_struct *work = list_first_entry(&pwq->delayed_works,\n\t\t\t\t\t\t    struct work_struct, entry);\n\n\tpwq_activate_delayed_work(work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->delayed_works"
          ],
          "line": 3548
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&pwq->pool->lock",
            "flags"
          ],
          "line": 3538
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq->mutex"
          ],
          "line": 3531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool workqueue_freezing;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void pwq_adjust_max_active(struct pool_workqueue *pwq)\n{\n\tstruct workqueue_struct *wq = pwq->wq;\n\tbool freezable = wq->flags & WQ_FREEZABLE;\n\tunsigned long flags;\n\n\t/* for @wq->saved_max_active */\n\tlockdep_assert_held(&wq->mutex);\n\n\t/* fast exit for non-freezable wqs */\n\tif (!freezable && pwq->max_active == wq->saved_max_active)\n\t\treturn;\n\n\t/* this function can be called during early boot w/ irq disabled */\n\tspin_lock_irqsave(&pwq->pool->lock, flags);\n\n\t/*\n\t * During [un]freezing, the caller is responsible for ensuring that\n\t * this function is called at least once after @workqueue_freezing\n\t * is updated and visible.\n\t */\n\tif (!freezable || !workqueue_freezing) {\n\t\tpwq->max_active = wq->saved_max_active;\n\n\t\twhile (!list_empty(&pwq->delayed_works) &&\n\t\t       pwq->nr_active < pwq->max_active)\n\t\t\tpwq_activate_first_delayed(pwq);\n\n\t\t/*\n\t\t * Need to kick a worker after thawed or an unbound wq's\n\t\t * max_active is bumped.  It's a slow path.  Do it always.\n\t\t */\n\t\twake_up_worker(pwq->pool);\n\t} else {\n\t\tpwq->max_active = 0;\n\t}\n\n\tspin_unlock_irqrestore(&pwq->pool->lock, flags);\n}"
  },
  {
    "function_name": "pwq_unbound_release_workfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3486-3514",
    "snippet": "static void pwq_unbound_release_workfn(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = container_of(work, struct pool_workqueue,\n\t\t\t\t\t\t  unbound_release_work);\n\tstruct workqueue_struct *wq = pwq->wq;\n\tstruct worker_pool *pool = pwq->pool;\n\tbool is_last;\n\n\tif (WARN_ON_ONCE(!(wq->flags & WQ_UNBOUND)))\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\tlist_del_rcu(&pwq->pwqs_node);\n\tis_last = list_empty(&wq->pwqs);\n\tmutex_unlock(&wq->mutex);\n\n\tmutex_lock(&wq_pool_mutex);\n\tput_unbound_pool(pool);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tcall_rcu_sched(&pwq->rcu, rcu_free_pwq);\n\n\t/*\n\t * If we're the last pwq going away, @wq is already dead and no one\n\t * is gonna access it anymore.  Schedule RCU free.\n\t */\n\tif (is_last)\n\t\tcall_rcu_sched(&wq->rcu, rcu_free_wq);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu_sched",
          "args": [
            "&wq->rcu",
            "rcu_free_wq"
          ],
          "line": 3513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu_sched",
          "args": [
            "&pwq->rcu",
            "rcu_free_pwq"
          ],
          "line": 3506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 3504
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_unbound_pool",
          "args": [
            "pool"
          ],
          "line": 3503
        },
        "resolved": true,
        "details": {
          "function_name": "put_unbound_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3351-3400",
          "snippet": "static void put_unbound_pool(struct worker_pool *pool)\n{\n\tDECLARE_COMPLETION_ONSTACK(detach_completion);\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (--pool->refcnt)\n\t\treturn;\n\n\t/* sanity checks */\n\tif (WARN_ON(!(pool->cpu < 0)) ||\n\t    WARN_ON(!list_empty(&pool->worklist)))\n\t\treturn;\n\n\t/* release id and unhash */\n\tif (pool->id >= 0)\n\t\tidr_remove(&worker_pool_idr, pool->id);\n\thash_del(&pool->hash_node);\n\n\t/*\n\t * Become the manager and destroy all workers.  This prevents\n\t * @pool's workers from blocking on attach_mutex.  We're the last\n\t * manager and @pool gets freed with the flag set.\n\t */\n\tspin_lock_irq(&pool->lock);\n\twait_event_lock_irq(wq_manager_wait,\n\t\t\t    !(pool->flags & POOL_MANAGER_ACTIVE), pool->lock);\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\n\twhile ((worker = first_idle_worker(pool)))\n\t\tdestroy_worker(worker);\n\tWARN_ON(pool->nr_workers || pool->nr_idle);\n\tspin_unlock_irq(&pool->lock);\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (!list_empty(&pool->workers))\n\t\tpool->detach_completion = &detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\tif (pool->detach_completion)\n\t\twait_for_completion(pool->detach_completion);\n\n\t/* shut down the timers */\n\tdel_timer_sync(&pool->idle_timer);\n\tdel_timer_sync(&pool->mayday_timer);\n\n\t/* sched-RCU protected to allow dereferences from get_work_pool() */\n\tcall_rcu_sched(&pool->rcu, rcu_free_pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static DECLARE_WAIT_QUEUE_HEAD(wq_manager_wait);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static DEFINE_IDR(worker_pool_idr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DECLARE_WAIT_QUEUE_HEAD(wq_manager_wait);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic DEFINE_IDR(worker_pool_idr);\n\nstatic void put_unbound_pool(struct worker_pool *pool)\n{\n\tDECLARE_COMPLETION_ONSTACK(detach_completion);\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (--pool->refcnt)\n\t\treturn;\n\n\t/* sanity checks */\n\tif (WARN_ON(!(pool->cpu < 0)) ||\n\t    WARN_ON(!list_empty(&pool->worklist)))\n\t\treturn;\n\n\t/* release id and unhash */\n\tif (pool->id >= 0)\n\t\tidr_remove(&worker_pool_idr, pool->id);\n\thash_del(&pool->hash_node);\n\n\t/*\n\t * Become the manager and destroy all workers.  This prevents\n\t * @pool's workers from blocking on attach_mutex.  We're the last\n\t * manager and @pool gets freed with the flag set.\n\t */\n\tspin_lock_irq(&pool->lock);\n\twait_event_lock_irq(wq_manager_wait,\n\t\t\t    !(pool->flags & POOL_MANAGER_ACTIVE), pool->lock);\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\n\twhile ((worker = first_idle_worker(pool)))\n\t\tdestroy_worker(worker);\n\tWARN_ON(pool->nr_workers || pool->nr_idle);\n\tspin_unlock_irq(&pool->lock);\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (!list_empty(&pool->workers))\n\t\tpool->detach_completion = &detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\tif (pool->detach_completion)\n\t\twait_for_completion(pool->detach_completion);\n\n\t/* shut down the timers */\n\tdel_timer_sync(&pool->idle_timer);\n\tdel_timer_sync(&pool->mayday_timer);\n\n\t/* sched-RCU protected to allow dereferences from get_work_pool() */\n\tcall_rcu_sched(&pool->rcu, rcu_free_pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 3502
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wq->pwqs"
          ],
          "line": 3499
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&pwq->pwqs_node"
          ],
          "line": 3498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(wq->flags & WQ_UNBOUND)"
          ],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structpool_workqueue",
            "unbound_release_work"
          ],
          "line": 3488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void pwq_unbound_release_workfn(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = container_of(work, struct pool_workqueue,\n\t\t\t\t\t\t  unbound_release_work);\n\tstruct workqueue_struct *wq = pwq->wq;\n\tstruct worker_pool *pool = pwq->pool;\n\tbool is_last;\n\n\tif (WARN_ON_ONCE(!(wq->flags & WQ_UNBOUND)))\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\tlist_del_rcu(&pwq->pwqs_node);\n\tis_last = list_empty(&wq->pwqs);\n\tmutex_unlock(&wq->mutex);\n\n\tmutex_lock(&wq_pool_mutex);\n\tput_unbound_pool(pool);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tcall_rcu_sched(&pwq->rcu, rcu_free_pwq);\n\n\t/*\n\t * If we're the last pwq going away, @wq is already dead and no one\n\t * is gonna access it anymore.  Schedule RCU free.\n\t */\n\tif (is_last)\n\t\tcall_rcu_sched(&wq->rcu, rcu_free_wq);\n}"
  },
  {
    "function_name": "rcu_free_pwq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3476-3480",
    "snippet": "static void rcu_free_pwq(struct rcu_head *rcu)\n{\n\tkmem_cache_free(pwq_cache,\n\t\t\tcontainer_of(rcu, struct pool_workqueue, rcu));\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *pwq_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "pwq_cache",
            "container_of(rcu, struct pool_workqueue, rcu)"
          ],
          "line": 3478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structpool_workqueue",
            "rcu"
          ],
          "line": 3479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *pwq_cache;\n\nstatic void rcu_free_pwq(struct rcu_head *rcu)\n{\n\tkmem_cache_free(pwq_cache,\n\t\t\tcontainer_of(rcu, struct pool_workqueue, rcu));\n}"
  },
  {
    "function_name": "get_unbound_pool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3416-3474",
    "snippet": "static struct worker_pool *get_unbound_pool(const struct workqueue_attrs *attrs)\n{\n\tu32 hash = wqattrs_hash(attrs);\n\tstruct worker_pool *pool;\n\tint node;\n\tint target_node = NUMA_NO_NODE;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\t/* do we already have a matching pool? */\n\thash_for_each_possible(unbound_pool_hash, pool, hash_node, hash) {\n\t\tif (wqattrs_equal(pool->attrs, attrs)) {\n\t\t\tpool->refcnt++;\n\t\t\treturn pool;\n\t\t}\n\t}\n\n\t/* if cpumask is contained inside a NUMA node, we belong to that node */\n\tif (wq_numa_enabled) {\n\t\tfor_each_node(node) {\n\t\t\tif (cpumask_subset(attrs->cpumask,\n\t\t\t\t\t   wq_numa_possible_cpumask[node])) {\n\t\t\t\ttarget_node = node;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* nope, create a new one */\n\tpool = kzalloc_node(sizeof(*pool), GFP_KERNEL, target_node);\n\tif (!pool || init_worker_pool(pool) < 0)\n\t\tgoto fail;\n\n\tlockdep_set_subclass(&pool->lock, 1);\t/* see put_pwq() */\n\tcopy_workqueue_attrs(pool->attrs, attrs);\n\tpool->node = target_node;\n\n\t/*\n\t * no_numa isn't a worker_pool attribute, always clear it.  See\n\t * 'struct workqueue_attrs' comments for detail.\n\t */\n\tpool->attrs->no_numa = false;\n\n\tif (worker_pool_assign_id(pool) < 0)\n\t\tgoto fail;\n\n\t/* create and start the initial worker */\n\tif (wq_online && !create_worker(pool))\n\t\tgoto fail;\n\n\t/* install */\n\thash_add(unbound_pool_hash, &pool->hash_node, hash);\n\n\treturn pool;\nfail:\n\tif (pool)\n\t\tput_unbound_pool(pool);\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t *wq_numa_possible_cpumask;",
      "static bool wq_online;",
      "static bool wq_numa_enabled;",
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_unbound_pool",
          "args": [
            "pool"
          ],
          "line": 3472
        },
        "resolved": true,
        "details": {
          "function_name": "put_unbound_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3351-3400",
          "snippet": "static void put_unbound_pool(struct worker_pool *pool)\n{\n\tDECLARE_COMPLETION_ONSTACK(detach_completion);\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (--pool->refcnt)\n\t\treturn;\n\n\t/* sanity checks */\n\tif (WARN_ON(!(pool->cpu < 0)) ||\n\t    WARN_ON(!list_empty(&pool->worklist)))\n\t\treturn;\n\n\t/* release id and unhash */\n\tif (pool->id >= 0)\n\t\tidr_remove(&worker_pool_idr, pool->id);\n\thash_del(&pool->hash_node);\n\n\t/*\n\t * Become the manager and destroy all workers.  This prevents\n\t * @pool's workers from blocking on attach_mutex.  We're the last\n\t * manager and @pool gets freed with the flag set.\n\t */\n\tspin_lock_irq(&pool->lock);\n\twait_event_lock_irq(wq_manager_wait,\n\t\t\t    !(pool->flags & POOL_MANAGER_ACTIVE), pool->lock);\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\n\twhile ((worker = first_idle_worker(pool)))\n\t\tdestroy_worker(worker);\n\tWARN_ON(pool->nr_workers || pool->nr_idle);\n\tspin_unlock_irq(&pool->lock);\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (!list_empty(&pool->workers))\n\t\tpool->detach_completion = &detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\tif (pool->detach_completion)\n\t\twait_for_completion(pool->detach_completion);\n\n\t/* shut down the timers */\n\tdel_timer_sync(&pool->idle_timer);\n\tdel_timer_sync(&pool->mayday_timer);\n\n\t/* sched-RCU protected to allow dereferences from get_work_pool() */\n\tcall_rcu_sched(&pool->rcu, rcu_free_pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static DECLARE_WAIT_QUEUE_HEAD(wq_manager_wait);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static DEFINE_IDR(worker_pool_idr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DECLARE_WAIT_QUEUE_HEAD(wq_manager_wait);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic DEFINE_IDR(worker_pool_idr);\n\nstatic void put_unbound_pool(struct worker_pool *pool)\n{\n\tDECLARE_COMPLETION_ONSTACK(detach_completion);\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (--pool->refcnt)\n\t\treturn;\n\n\t/* sanity checks */\n\tif (WARN_ON(!(pool->cpu < 0)) ||\n\t    WARN_ON(!list_empty(&pool->worklist)))\n\t\treturn;\n\n\t/* release id and unhash */\n\tif (pool->id >= 0)\n\t\tidr_remove(&worker_pool_idr, pool->id);\n\thash_del(&pool->hash_node);\n\n\t/*\n\t * Become the manager and destroy all workers.  This prevents\n\t * @pool's workers from blocking on attach_mutex.  We're the last\n\t * manager and @pool gets freed with the flag set.\n\t */\n\tspin_lock_irq(&pool->lock);\n\twait_event_lock_irq(wq_manager_wait,\n\t\t\t    !(pool->flags & POOL_MANAGER_ACTIVE), pool->lock);\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\n\twhile ((worker = first_idle_worker(pool)))\n\t\tdestroy_worker(worker);\n\tWARN_ON(pool->nr_workers || pool->nr_idle);\n\tspin_unlock_irq(&pool->lock);\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (!list_empty(&pool->workers))\n\t\tpool->detach_completion = &detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\tif (pool->detach_completion)\n\t\twait_for_completion(pool->detach_completion);\n\n\t/* shut down the timers */\n\tdel_timer_sync(&pool->idle_timer);\n\tdel_timer_sync(&pool->mayday_timer);\n\n\t/* sched-RCU protected to allow dereferences from get_work_pool() */\n\tcall_rcu_sched(&pool->rcu, rcu_free_pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_add",
          "args": [
            "unbound_pool_hash",
            "&pool->hash_node",
            "hash"
          ],
          "line": 3467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_worker",
          "args": [
            "pool"
          ],
          "line": 3463
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_create_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1961-1990",
          "snippet": "static void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\tspin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\tspin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\tspin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\tspin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}"
        }
      },
      {
        "call_info": {
          "callee": "worker_pool_assign_id",
          "args": [
            "pool"
          ],
          "line": 3459
        },
        "resolved": true,
        "details": {
          "function_name": "worker_pool_assign_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "533-546",
          "snippet": "static int worker_pool_assign_id(struct worker_pool *pool)\n{\n\tint ret;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tret = idr_alloc(&worker_pool_idr, pool, 0, WORK_OFFQ_POOL_NONE,\n\t\t\tGFP_KERNEL);\n\tif (ret >= 0) {\n\t\tpool->id = ret;\n\t\treturn 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static DEFINE_IDR(worker_pool_idr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic DEFINE_IDR(worker_pool_idr);\n\nstatic int worker_pool_assign_id(struct worker_pool *pool)\n{\n\tint ret;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tret = idr_alloc(&worker_pool_idr, pool, 0, WORK_OFFQ_POOL_NONE,\n\t\t\tGFP_KERNEL);\n\tif (ret >= 0) {\n\t\tpool->id = ret;\n\t\treturn 0;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_workqueue_attrs",
          "args": [
            "pool->attrs",
            "attrs"
          ],
          "line": 3450
        },
        "resolved": true,
        "details": {
          "function_name": "copy_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3243-3254",
          "snippet": "static void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_set_subclass",
          "args": [
            "&pool->lock",
            "1"
          ],
          "line": 3449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_worker_pool",
          "args": [
            "pool"
          ],
          "line": 3446
        },
        "resolved": true,
        "details": {
          "function_name": "init_worker_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3288-3315",
          "snippet": "static int init_worker_pool(struct worker_pool *pool)\n{\n\tspin_lock_init(&pool->lock);\n\tpool->id = -1;\n\tpool->cpu = -1;\n\tpool->node = NUMA_NO_NODE;\n\tpool->flags |= POOL_DISASSOCIATED;\n\tpool->watchdog_ts = jiffies;\n\tINIT_LIST_HEAD(&pool->worklist);\n\tINIT_LIST_HEAD(&pool->idle_list);\n\thash_init(pool->busy_hash);\n\n\ttimer_setup(&pool->idle_timer, idle_worker_timeout, TIMER_DEFERRABLE);\n\n\ttimer_setup(&pool->mayday_timer, pool_mayday_timeout, 0);\n\n\tINIT_LIST_HEAD(&pool->workers);\n\n\tida_init(&pool->worker_ida);\n\tINIT_HLIST_NODE(&pool->hash_node);\n\tpool->refcnt = 1;\n\n\t/* shouldn't fail above this point */\n\tpool->attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!pool->attrs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic int init_worker_pool(struct worker_pool *pool)\n{\n\tspin_lock_init(&pool->lock);\n\tpool->id = -1;\n\tpool->cpu = -1;\n\tpool->node = NUMA_NO_NODE;\n\tpool->flags |= POOL_DISASSOCIATED;\n\tpool->watchdog_ts = jiffies;\n\tINIT_LIST_HEAD(&pool->worklist);\n\tINIT_LIST_HEAD(&pool->idle_list);\n\thash_init(pool->busy_hash);\n\n\ttimer_setup(&pool->idle_timer, idle_worker_timeout, TIMER_DEFERRABLE);\n\n\ttimer_setup(&pool->mayday_timer, pool_mayday_timeout, 0);\n\n\tINIT_LIST_HEAD(&pool->workers);\n\n\tida_init(&pool->worker_ida);\n\tINIT_HLIST_NODE(&pool->hash_node);\n\tpool->refcnt = 1;\n\n\t/* shouldn't fail above this point */\n\tpool->attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!pool->attrs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(*pool)",
            "GFP_KERNEL",
            "target_node"
          ],
          "line": 3445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "attrs->cpumask",
            "wq_numa_possible_cpumask[node]"
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wqattrs_equal",
          "args": [
            "pool->attrs",
            "attrs"
          ],
          "line": 3427
        },
        "resolved": true,
        "details": {
          "function_name": "wqattrs_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3268-3276",
          "snippet": "static bool wqattrs_equal(const struct workqueue_attrs *a,\n\t\t\t  const struct workqueue_attrs *b)\n{\n\tif (a->nice != b->nice)\n\t\treturn false;\n\tif (!cpumask_equal(a->cpumask, b->cpumask))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wqattrs_equal(const struct workqueue_attrs *a,\n\t\t\t  const struct workqueue_attrs *b)\n{\n\tif (a->nice != b->nice)\n\t\treturn false;\n\tif (!cpumask_equal(a->cpumask, b->cpumask))\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_for_each_possible",
          "args": [
            "unbound_pool_hash",
            "pool",
            "hash_node",
            "hash"
          ],
          "line": 3426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wqattrs_hash",
          "args": [
            "attrs"
          ],
          "line": 3418
        },
        "resolved": true,
        "details": {
          "function_name": "wqattrs_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3257-3265",
          "snippet": "static u32 wqattrs_hash(const struct workqueue_attrs *attrs)\n{\n\tu32 hash = 0;\n\n\thash = jhash_1word(attrs->nice, hash);\n\thash = jhash(cpumask_bits(attrs->cpumask),\n\t\t     BITS_TO_LONGS(nr_cpumask_bits) * sizeof(long), hash);\n\treturn hash;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic u32 wqattrs_hash(const struct workqueue_attrs *attrs)\n{\n\tu32 hash = 0;\n\n\thash = jhash_1word(attrs->nice, hash);\n\thash = jhash(cpumask_bits(attrs->cpumask),\n\t\t     BITS_TO_LONGS(nr_cpumask_bits) * sizeof(long), hash);\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t *wq_numa_possible_cpumask;\nstatic bool wq_online;\nstatic bool wq_numa_enabled;\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic struct worker_pool *get_unbound_pool(const struct workqueue_attrs *attrs)\n{\n\tu32 hash = wqattrs_hash(attrs);\n\tstruct worker_pool *pool;\n\tint node;\n\tint target_node = NUMA_NO_NODE;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\t/* do we already have a matching pool? */\n\thash_for_each_possible(unbound_pool_hash, pool, hash_node, hash) {\n\t\tif (wqattrs_equal(pool->attrs, attrs)) {\n\t\t\tpool->refcnt++;\n\t\t\treturn pool;\n\t\t}\n\t}\n\n\t/* if cpumask is contained inside a NUMA node, we belong to that node */\n\tif (wq_numa_enabled) {\n\t\tfor_each_node(node) {\n\t\t\tif (cpumask_subset(attrs->cpumask,\n\t\t\t\t\t   wq_numa_possible_cpumask[node])) {\n\t\t\t\ttarget_node = node;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* nope, create a new one */\n\tpool = kzalloc_node(sizeof(*pool), GFP_KERNEL, target_node);\n\tif (!pool || init_worker_pool(pool) < 0)\n\t\tgoto fail;\n\n\tlockdep_set_subclass(&pool->lock, 1);\t/* see put_pwq() */\n\tcopy_workqueue_attrs(pool->attrs, attrs);\n\tpool->node = target_node;\n\n\t/*\n\t * no_numa isn't a worker_pool attribute, always clear it.  See\n\t * 'struct workqueue_attrs' comments for detail.\n\t */\n\tpool->attrs->no_numa = false;\n\n\tif (worker_pool_assign_id(pool) < 0)\n\t\tgoto fail;\n\n\t/* create and start the initial worker */\n\tif (wq_online && !create_worker(pool))\n\t\tgoto fail;\n\n\t/* install */\n\thash_add(unbound_pool_hash, &pool->hash_node, hash);\n\n\treturn pool;\nfail:\n\tif (pool)\n\t\tput_unbound_pool(pool);\n\treturn NULL;\n}"
  },
  {
    "function_name": "put_unbound_pool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3351-3400",
    "snippet": "static void put_unbound_pool(struct worker_pool *pool)\n{\n\tDECLARE_COMPLETION_ONSTACK(detach_completion);\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (--pool->refcnt)\n\t\treturn;\n\n\t/* sanity checks */\n\tif (WARN_ON(!(pool->cpu < 0)) ||\n\t    WARN_ON(!list_empty(&pool->worklist)))\n\t\treturn;\n\n\t/* release id and unhash */\n\tif (pool->id >= 0)\n\t\tidr_remove(&worker_pool_idr, pool->id);\n\thash_del(&pool->hash_node);\n\n\t/*\n\t * Become the manager and destroy all workers.  This prevents\n\t * @pool's workers from blocking on attach_mutex.  We're the last\n\t * manager and @pool gets freed with the flag set.\n\t */\n\tspin_lock_irq(&pool->lock);\n\twait_event_lock_irq(wq_manager_wait,\n\t\t\t    !(pool->flags & POOL_MANAGER_ACTIVE), pool->lock);\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\n\twhile ((worker = first_idle_worker(pool)))\n\t\tdestroy_worker(worker);\n\tWARN_ON(pool->nr_workers || pool->nr_idle);\n\tspin_unlock_irq(&pool->lock);\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (!list_empty(&pool->workers))\n\t\tpool->detach_completion = &detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\tif (pool->detach_completion)\n\t\twait_for_completion(pool->detach_completion);\n\n\t/* shut down the timers */\n\tdel_timer_sync(&pool->idle_timer);\n\tdel_timer_sync(&pool->mayday_timer);\n\n\t/* sched-RCU protected to allow dereferences from get_work_pool() */\n\tcall_rcu_sched(&pool->rcu, rcu_free_pool);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static DEFINE_MUTEX(wq_pool_attach_mutex);",
      "static DECLARE_WAIT_QUEUE_HEAD(wq_manager_wait);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static DEFINE_IDR(worker_pool_idr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu_sched",
          "args": [
            "&pool->rcu",
            "rcu_free_pool"
          ],
          "line": 3399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&pool->mayday_timer"
          ],
          "line": 3396
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1273-1298",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "pool->detach_completion"
          ],
          "line": 3392
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 3389
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pool->workers"
          ],
          "line": 3387
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 3386
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 3384
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "pool->nr_workers || pool->nr_idle"
          ],
          "line": 3383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_worker",
          "args": [
            "worker"
          ],
          "line": 3382
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1850-1868",
          "snippet": "static void destroy_worker(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tlockdep_assert_held(&pool->lock);\n\n\t/* sanity check frenzy */\n\tif (WARN_ON(worker->current_work) ||\n\t    WARN_ON(!list_empty(&worker->scheduled)) ||\n\t    WARN_ON(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\n\tpool->nr_workers--;\n\tpool->nr_idle--;\n\n\tlist_del_init(&worker->entry);\n\tworker->flags |= WORKER_DIE;\n\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void destroy_worker(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tlockdep_assert_held(&pool->lock);\n\n\t/* sanity check frenzy */\n\tif (WARN_ON(worker->current_work) ||\n\t    WARN_ON(!list_empty(&worker->scheduled)) ||\n\t    WARN_ON(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\n\tpool->nr_workers--;\n\tpool->nr_idle--;\n\n\tlist_del_init(&worker->entry);\n\tworker->flags |= WORKER_DIE;\n\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "first_idle_worker",
          "args": [
            "pool"
          ],
          "line": 3381
        },
        "resolved": true,
        "details": {
          "function_name": "first_idle_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "816-822",
          "snippet": "static struct worker *first_idle_worker(struct worker_pool *pool)\n{\n\tif (unlikely(list_empty(&pool->idle_list)))\n\t\treturn NULL;\n\n\treturn list_first_entry(&pool->idle_list, struct worker, entry);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic struct worker *first_idle_worker(struct worker_pool *pool)\n{\n\tif (unlikely(list_empty(&pool->idle_list)))\n\t\treturn NULL;\n\n\treturn list_first_entry(&pool->idle_list, struct worker, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_lock_irq",
          "args": [
            "wq_manager_wait",
            "!(pool->flags & POOL_MANAGER_ACTIVE)",
            "pool->lock"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 3376
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_del",
          "args": [
            "&pool->hash_node"
          ],
          "line": 3369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&worker_pool_idr",
            "pool->id"
          ],
          "line": 3368
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "324-329",
          "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&pool->worklist)"
          ],
          "line": 3363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(pool->cpu < 0)"
          ],
          "line": 3362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 3356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_COMPLETION_ONSTACK",
          "args": [
            "detach_completion"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DECLARE_WAIT_QUEUE_HEAD(wq_manager_wait);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic DEFINE_IDR(worker_pool_idr);\n\nstatic void put_unbound_pool(struct worker_pool *pool)\n{\n\tDECLARE_COMPLETION_ONSTACK(detach_completion);\n\tstruct worker *worker;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tif (--pool->refcnt)\n\t\treturn;\n\n\t/* sanity checks */\n\tif (WARN_ON(!(pool->cpu < 0)) ||\n\t    WARN_ON(!list_empty(&pool->worklist)))\n\t\treturn;\n\n\t/* release id and unhash */\n\tif (pool->id >= 0)\n\t\tidr_remove(&worker_pool_idr, pool->id);\n\thash_del(&pool->hash_node);\n\n\t/*\n\t * Become the manager and destroy all workers.  This prevents\n\t * @pool's workers from blocking on attach_mutex.  We're the last\n\t * manager and @pool gets freed with the flag set.\n\t */\n\tspin_lock_irq(&pool->lock);\n\twait_event_lock_irq(wq_manager_wait,\n\t\t\t    !(pool->flags & POOL_MANAGER_ACTIVE), pool->lock);\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\n\twhile ((worker = first_idle_worker(pool)))\n\t\tdestroy_worker(worker);\n\tWARN_ON(pool->nr_workers || pool->nr_idle);\n\tspin_unlock_irq(&pool->lock);\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (!list_empty(&pool->workers))\n\t\tpool->detach_completion = &detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\tif (pool->detach_completion)\n\t\twait_for_completion(pool->detach_completion);\n\n\t/* shut down the timers */\n\tdel_timer_sync(&pool->idle_timer);\n\tdel_timer_sync(&pool->mayday_timer);\n\n\t/* sched-RCU protected to allow dereferences from get_work_pool() */\n\tcall_rcu_sched(&pool->rcu, rcu_free_pool);\n}"
  },
  {
    "function_name": "rcu_free_pool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3331-3338",
    "snippet": "static void rcu_free_pool(struct rcu_head *rcu)\n{\n\tstruct worker_pool *pool = container_of(rcu, struct worker_pool, rcu);\n\n\tida_destroy(&pool->worker_ida);\n\tfree_workqueue_attrs(pool->attrs);\n\tkfree(pool);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pool"
          ],
          "line": 3337
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_workqueue_attrs",
          "args": [
            "pool->attrs"
          ],
          "line": 3336
        },
        "resolved": true,
        "details": {
          "function_name": "free_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3209-3215",
          "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ida_destroy",
          "args": [
            "&pool->worker_ida"
          ],
          "line": 3335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structworker_pool",
            "rcu"
          ],
          "line": 3333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void rcu_free_pool(struct rcu_head *rcu)\n{\n\tstruct worker_pool *pool = container_of(rcu, struct worker_pool, rcu);\n\n\tida_destroy(&pool->worker_ida);\n\tfree_workqueue_attrs(pool->attrs);\n\tkfree(pool);\n}"
  },
  {
    "function_name": "rcu_free_wq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3317-3329",
    "snippet": "static void rcu_free_wq(struct rcu_head *rcu)\n{\n\tstruct workqueue_struct *wq =\n\t\tcontainer_of(rcu, struct workqueue_struct, rcu);\n\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tfree_percpu(wq->cpu_pwqs);\n\telse\n\t\tfree_workqueue_attrs(wq->unbound_attrs);\n\n\tkfree(wq->rescuer);\n\tkfree(wq);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "wq"
          ],
          "line": 3328
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_workqueue_attrs",
          "args": [
            "wq->unbound_attrs"
          ],
          "line": 3325
        },
        "resolved": true,
        "details": {
          "function_name": "free_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3209-3215",
          "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "wq->cpu_pwqs"
          ],
          "line": 3323
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structworkqueue_struct",
            "rcu"
          ],
          "line": 3320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void rcu_free_wq(struct rcu_head *rcu)\n{\n\tstruct workqueue_struct *wq =\n\t\tcontainer_of(rcu, struct workqueue_struct, rcu);\n\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tfree_percpu(wq->cpu_pwqs);\n\telse\n\t\tfree_workqueue_attrs(wq->unbound_attrs);\n\n\tkfree(wq->rescuer);\n\tkfree(wq);\n}"
  },
  {
    "function_name": "init_worker_pool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3288-3315",
    "snippet": "static int init_worker_pool(struct worker_pool *pool)\n{\n\tspin_lock_init(&pool->lock);\n\tpool->id = -1;\n\tpool->cpu = -1;\n\tpool->node = NUMA_NO_NODE;\n\tpool->flags |= POOL_DISASSOCIATED;\n\tpool->watchdog_ts = jiffies;\n\tINIT_LIST_HEAD(&pool->worklist);\n\tINIT_LIST_HEAD(&pool->idle_list);\n\thash_init(pool->busy_hash);\n\n\ttimer_setup(&pool->idle_timer, idle_worker_timeout, TIMER_DEFERRABLE);\n\n\ttimer_setup(&pool->mayday_timer, pool_mayday_timeout, 0);\n\n\tINIT_LIST_HEAD(&pool->workers);\n\n\tida_init(&pool->worker_ida);\n\tINIT_HLIST_NODE(&pool->hash_node);\n\tpool->refcnt = 1;\n\n\t/* shouldn't fail above this point */\n\tpool->attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!pool->attrs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_workqueue_attrs",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 3311
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3226-3241",
          "snippet": "struct workqueue_attrs *alloc_workqueue_attrs(gfp_t gfp_mask)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), gfp_mask);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, gfp_mask))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct workqueue_attrs *alloc_workqueue_attrs(gfp_t gfp_mask)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), gfp_mask);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, gfp_mask))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&pool->hash_node"
          ],
          "line": 3307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ida_init",
          "args": [
            "&pool->worker_ida"
          ],
          "line": 3306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pool->workers"
          ],
          "line": 3304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_setup",
          "args": [
            "&pool->mayday_timer",
            "pool_mayday_timeout",
            "0"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_setup",
          "args": [
            "&pool->idle_timer",
            "idle_worker_timeout",
            "TIMER_DEFERRABLE"
          ],
          "line": 3300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_init",
          "args": [
            "pool->busy_hash"
          ],
          "line": 3298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pool->idle_list"
          ],
          "line": 3297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pool->worklist"
          ],
          "line": 3296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pool->lock"
          ],
          "line": 3290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic int init_worker_pool(struct worker_pool *pool)\n{\n\tspin_lock_init(&pool->lock);\n\tpool->id = -1;\n\tpool->cpu = -1;\n\tpool->node = NUMA_NO_NODE;\n\tpool->flags |= POOL_DISASSOCIATED;\n\tpool->watchdog_ts = jiffies;\n\tINIT_LIST_HEAD(&pool->worklist);\n\tINIT_LIST_HEAD(&pool->idle_list);\n\thash_init(pool->busy_hash);\n\n\ttimer_setup(&pool->idle_timer, idle_worker_timeout, TIMER_DEFERRABLE);\n\n\ttimer_setup(&pool->mayday_timer, pool_mayday_timeout, 0);\n\n\tINIT_LIST_HEAD(&pool->workers);\n\n\tida_init(&pool->worker_ida);\n\tINIT_HLIST_NODE(&pool->hash_node);\n\tpool->refcnt = 1;\n\n\t/* shouldn't fail above this point */\n\tpool->attrs = alloc_workqueue_attrs(GFP_KERNEL);\n\tif (!pool->attrs)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "wqattrs_equal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3268-3276",
    "snippet": "static bool wqattrs_equal(const struct workqueue_attrs *a,\n\t\t\t  const struct workqueue_attrs *b)\n{\n\tif (a->nice != b->nice)\n\t\treturn false;\n\tif (!cpumask_equal(a->cpumask, b->cpumask))\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "a->cpumask",
            "b->cpumask"
          ],
          "line": 3273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wqattrs_equal(const struct workqueue_attrs *a,\n\t\t\t  const struct workqueue_attrs *b)\n{\n\tif (a->nice != b->nice)\n\t\treturn false;\n\tif (!cpumask_equal(a->cpumask, b->cpumask))\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "wqattrs_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3257-3265",
    "snippet": "static u32 wqattrs_hash(const struct workqueue_attrs *attrs)\n{\n\tu32 hash = 0;\n\n\thash = jhash_1word(attrs->nice, hash);\n\thash = jhash(cpumask_bits(attrs->cpumask),\n\t\t     BITS_TO_LONGS(nr_cpumask_bits) * sizeof(long), hash);\n\treturn hash;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "cpumask_bits(attrs->cpumask)",
            "BITS_TO_LONGS(nr_cpumask_bits) * sizeof(long)",
            "hash"
          ],
          "line": 3262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "nr_cpumask_bits"
          ],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_bits",
          "args": [
            "attrs->cpumask"
          ],
          "line": 3262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jhash_1word",
          "args": [
            "attrs->nice",
            "hash"
          ],
          "line": 3261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic u32 wqattrs_hash(const struct workqueue_attrs *attrs)\n{\n\tu32 hash = 0;\n\n\thash = jhash_1word(attrs->nice, hash);\n\thash = jhash(cpumask_bits(attrs->cpumask),\n\t\t     BITS_TO_LONGS(nr_cpumask_bits) * sizeof(long), hash);\n\treturn hash;\n}"
  },
  {
    "function_name": "copy_workqueue_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3243-3254",
    "snippet": "static void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "to->cpumask",
            "from->cpumask"
          ],
          "line": 3247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from)\n{\n\tto->nice = from->nice;\n\tcpumask_copy(to->cpumask, from->cpumask);\n\t/*\n\t * Unlike hash and equality test, this function doesn't ignore\n\t * ->no_numa as it is used for both pool and wq attrs.  Instead,\n\t * get_unbound_pool() explicitly clears ->no_numa after copying.\n\t */\n\tto->no_numa = from->no_numa;\n}"
  },
  {
    "function_name": "alloc_workqueue_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3226-3241",
    "snippet": "struct workqueue_attrs *alloc_workqueue_attrs(gfp_t gfp_mask)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), gfp_mask);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, gfp_mask))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_workqueue_attrs",
          "args": [
            "attrs"
          ],
          "line": 3239
        },
        "resolved": true,
        "details": {
          "function_name": "free_workqueue_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3209-3215",
          "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "attrs->cpumask",
            "cpu_possible_mask"
          ],
          "line": 3236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&attrs->cpumask",
            "gfp_mask"
          ],
          "line": 3233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*attrs)",
            "gfp_mask"
          ],
          "line": 3230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct workqueue_attrs *alloc_workqueue_attrs(gfp_t gfp_mask)\n{\n\tstruct workqueue_attrs *attrs;\n\n\tattrs = kzalloc(sizeof(*attrs), gfp_mask);\n\tif (!attrs)\n\t\tgoto fail;\n\tif (!alloc_cpumask_var(&attrs->cpumask, gfp_mask))\n\t\tgoto fail;\n\n\tcpumask_copy(attrs->cpumask, cpu_possible_mask);\n\treturn attrs;\nfail:\n\tfree_workqueue_attrs(attrs);\n\treturn NULL;\n}"
  },
  {
    "function_name": "free_workqueue_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3209-3215",
    "snippet": "void free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "attrs"
          ],
          "line": 3213
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "attrs->cpumask"
          ],
          "line": 3212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs)\n{\n\tif (attrs) {\n\t\tfree_cpumask_var(attrs->cpumask);\n\t\tkfree(attrs);\n\t}\n}"
  },
  {
    "function_name": "execute_in_process_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3189-3200",
    "snippet": "int execute_in_process_context(work_func_t fn, struct execute_work *ew)\n{\n\tif (!in_interrupt()) {\n\t\tfn(&ew->work);\n\t\treturn 0;\n\t}\n\n\tINIT_WORK(&ew->work, fn);\n\tschedule_work(&ew->work);\n\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&ew->work"
          ],
          "line": 3197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&ew->work",
            "fn"
          ],
          "line": 3196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "&ew->work"
          ],
          "line": 3192
        },
        "resolved": true,
        "details": {
          "function_name": "wq_watchdog_timer_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "5523-5575",
          "snippet": "static void wq_watchdog_timer_fn(struct timer_list *unused)\n{\n\tunsigned long thresh = READ_ONCE(wq_watchdog_thresh) * HZ;\n\tbool lockup_detected = false;\n\tstruct worker_pool *pool;\n\tint pi;\n\n\tif (!thresh)\n\t\treturn;\n\n\trcu_read_lock();\n\n\tfor_each_pool(pool, pi) {\n\t\tunsigned long pool_ts, touched, ts;\n\n\t\tif (list_empty(&pool->worklist))\n\t\t\tcontinue;\n\n\t\t/* get the latest of pool and touched timestamps */\n\t\tpool_ts = READ_ONCE(pool->watchdog_ts);\n\t\ttouched = READ_ONCE(wq_watchdog_touched);\n\n\t\tif (time_after(pool_ts, touched))\n\t\t\tts = pool_ts;\n\t\telse\n\t\t\tts = touched;\n\n\t\tif (pool->cpu >= 0) {\n\t\t\tunsigned long cpu_touched =\n\t\t\t\tREAD_ONCE(per_cpu(wq_watchdog_touched_cpu,\n\t\t\t\t\t\t  pool->cpu));\n\t\t\tif (time_after(cpu_touched, ts))\n\t\t\t\tts = cpu_touched;\n\t\t}\n\n\t\t/* did we stall? */\n\t\tif (time_after(jiffies, ts + thresh)) {\n\t\t\tlockup_detected = true;\n\t\t\tpr_emerg(\"BUG: workqueue lockup - pool\");\n\t\t\tpr_cont_pool_info(pool);\n\t\t\tpr_cont(\" stuck for %us!\\n\",\n\t\t\t\tjiffies_to_msecs(jiffies - pool_ts) / 1000);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tif (lockup_detected)\n\t\tshow_workqueue_state();\n\n\twq_watchdog_reset_touched();\n\tmod_timer(&wq_watchdog_timer, jiffies + thresh);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wq_watchdog_timer_fn(struct timer_list *unused)\n{\n\tunsigned long thresh = READ_ONCE(wq_watchdog_thresh) * HZ;\n\tbool lockup_detected = false;\n\tstruct worker_pool *pool;\n\tint pi;\n\n\tif (!thresh)\n\t\treturn;\n\n\trcu_read_lock();\n\n\tfor_each_pool(pool, pi) {\n\t\tunsigned long pool_ts, touched, ts;\n\n\t\tif (list_empty(&pool->worklist))\n\t\t\tcontinue;\n\n\t\t/* get the latest of pool and touched timestamps */\n\t\tpool_ts = READ_ONCE(pool->watchdog_ts);\n\t\ttouched = READ_ONCE(wq_watchdog_touched);\n\n\t\tif (time_after(pool_ts, touched))\n\t\t\tts = pool_ts;\n\t\telse\n\t\t\tts = touched;\n\n\t\tif (pool->cpu >= 0) {\n\t\t\tunsigned long cpu_touched =\n\t\t\t\tREAD_ONCE(per_cpu(wq_watchdog_touched_cpu,\n\t\t\t\t\t\t  pool->cpu));\n\t\t\tif (time_after(cpu_touched, ts))\n\t\t\t\tts = cpu_touched;\n\t\t}\n\n\t\t/* did we stall? */\n\t\tif (time_after(jiffies, ts + thresh)) {\n\t\t\tlockup_detected = true;\n\t\t\tpr_emerg(\"BUG: workqueue lockup - pool\");\n\t\t\tpr_cont_pool_info(pool);\n\t\t\tpr_cont(\" stuck for %us!\\n\",\n\t\t\t\tjiffies_to_msecs(jiffies - pool_ts) / 1000);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tif (lockup_detected)\n\t\tshow_workqueue_state();\n\n\twq_watchdog_reset_touched();\n\tmod_timer(&wq_watchdog_timer, jiffies + thresh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint execute_in_process_context(work_func_t fn, struct execute_work *ew)\n{\n\tif (!in_interrupt()) {\n\t\tfn(&ew->work);\n\t\treturn 0;\n\t}\n\n\tINIT_WORK(&ew->work, fn);\n\tschedule_work(&ew->work);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "schedule_on_each_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3151-3175",
    "snippet": "int schedule_on_each_cpu(work_func_t func)\n{\n\tint cpu;\n\tstruct work_struct __percpu *works;\n\n\tworks = alloc_percpu(struct work_struct);\n\tif (!works)\n\t\treturn -ENOMEM;\n\n\tget_online_cpus();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = per_cpu_ptr(works, cpu);\n\n\t\tINIT_WORK(work, func);\n\t\tschedule_work_on(cpu, work);\n\t}\n\n\tfor_each_online_cpu(cpu)\n\t\tflush_work(per_cpu_ptr(works, cpu));\n\n\tput_online_cpus();\n\tfree_percpu(works);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "works"
          ],
          "line": 3173
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_online_cpus",
          "args": [],
          "line": 3172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work_on",
          "args": [
            "cpu",
            "work"
          ],
          "line": 3166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "work",
            "func"
          ],
          "line": 3165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "works",
            "cpu"
          ],
          "line": 3163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_online_cpus",
          "args": [],
          "line": 3160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structwork_struct"
          ],
          "line": 3156
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "37-54",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint schedule_on_each_cpu(work_func_t func)\n{\n\tint cpu;\n\tstruct work_struct __percpu *works;\n\n\tworks = alloc_percpu(struct work_struct);\n\tif (!works)\n\t\treturn -ENOMEM;\n\n\tget_online_cpus();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = per_cpu_ptr(works, cpu);\n\n\t\tINIT_WORK(work, func);\n\t\tschedule_work_on(cpu, work);\n\t}\n\n\tfor_each_online_cpu(cpu)\n\t\tflush_work(per_cpu_ptr(works, cpu));\n\n\tput_online_cpus();\n\tfree_percpu(works);\n\treturn 0;\n}"
  },
  {
    "function_name": "cancel_delayed_work_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3134-3137",
    "snippet": "bool cancel_delayed_work_sync(struct delayed_work *dwork)\n{\n\treturn __cancel_work_timer(&dwork->work, true);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cancel_work_timer",
          "args": [
            "&dwork->work",
            "true"
          ],
          "line": 3136
        },
        "resolved": true,
        "details": {
          "function_name": "__cancel_work_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2956-3018",
          "snippet": "static bool __cancel_work_timer(struct work_struct *work, bool is_dwork)\n{\n\tstatic DECLARE_WAIT_QUEUE_HEAD(cancel_waitq);\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t\t/*\n\t\t * If someone else is already canceling, wait for it to\n\t\t * finish.  flush_work() doesn't work for PREEMPT_NONE\n\t\t * because we may get scheduled between @work's completion\n\t\t * and the other canceling task resuming and clearing\n\t\t * CANCELING - flush_work() will return false immediately\n\t\t * as @work is no longer busy, try_to_grab_pending() will\n\t\t * return -ENOENT as @work is still being canceled and the\n\t\t * other canceling task won't be able to clear CANCELING as\n\t\t * we're hogging the CPU.\n\t\t *\n\t\t * Let's wait for completion using a waitqueue.  As this\n\t\t * may lead to the thundering herd problem, use a custom\n\t\t * wake function which matches @work along with exclusive\n\t\t * wait and wakeup.\n\t\t */\n\t\tif (unlikely(ret == -ENOENT)) {\n\t\t\tstruct cwt_wait cwait;\n\n\t\t\tinit_wait(&cwait.wait);\n\t\t\tcwait.wait.func = cwt_wakefn;\n\t\t\tcwait.work = work;\n\n\t\t\tprepare_to_wait_exclusive(&cancel_waitq, &cwait.wait,\n\t\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\t\tif (work_is_canceling(work))\n\t\t\t\tschedule();\n\t\t\tfinish_wait(&cancel_waitq, &cwait.wait);\n\t\t}\n\t} while (unlikely(ret < 0));\n\n\t/* tell other tasks trying to grab @work to back off */\n\tmark_work_canceling(work);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * This allows canceling during early boot.  We know that @work\n\t * isn't executing.\n\t */\n\tif (wq_online)\n\t\t__flush_work(work, true);\n\n\tclear_work_data(work);\n\n\t/*\n\t * Paired with prepare_to_wait() above so that either\n\t * waitqueue_active() is visible here or !work_is_canceling() is\n\t * visible there.\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&cancel_waitq))\n\t\t__wake_up(&cancel_waitq, TASK_NORMAL, 1, work);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_online;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\n\nstatic bool __cancel_work_timer(struct work_struct *work, bool is_dwork)\n{\n\tstatic DECLARE_WAIT_QUEUE_HEAD(cancel_waitq);\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t\t/*\n\t\t * If someone else is already canceling, wait for it to\n\t\t * finish.  flush_work() doesn't work for PREEMPT_NONE\n\t\t * because we may get scheduled between @work's completion\n\t\t * and the other canceling task resuming and clearing\n\t\t * CANCELING - flush_work() will return false immediately\n\t\t * as @work is no longer busy, try_to_grab_pending() will\n\t\t * return -ENOENT as @work is still being canceled and the\n\t\t * other canceling task won't be able to clear CANCELING as\n\t\t * we're hogging the CPU.\n\t\t *\n\t\t * Let's wait for completion using a waitqueue.  As this\n\t\t * may lead to the thundering herd problem, use a custom\n\t\t * wake function which matches @work along with exclusive\n\t\t * wait and wakeup.\n\t\t */\n\t\tif (unlikely(ret == -ENOENT)) {\n\t\t\tstruct cwt_wait cwait;\n\n\t\t\tinit_wait(&cwait.wait);\n\t\t\tcwait.wait.func = cwt_wakefn;\n\t\t\tcwait.work = work;\n\n\t\t\tprepare_to_wait_exclusive(&cancel_waitq, &cwait.wait,\n\t\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\t\tif (work_is_canceling(work))\n\t\t\t\tschedule();\n\t\t\tfinish_wait(&cancel_waitq, &cwait.wait);\n\t\t}\n\t} while (unlikely(ret < 0));\n\n\t/* tell other tasks trying to grab @work to back off */\n\tmark_work_canceling(work);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * This allows canceling during early boot.  We know that @work\n\t * isn't executing.\n\t */\n\tif (wq_online)\n\t\t__flush_work(work, true);\n\n\tclear_work_data(work);\n\n\t/*\n\t * Paired with prepare_to_wait() above so that either\n\t * waitqueue_active() is visible here or !work_is_canceling() is\n\t * visible there.\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&cancel_waitq))\n\t\t__wake_up(&cancel_waitq, TASK_NORMAL, 1, work);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool cancel_delayed_work_sync(struct delayed_work *dwork)\n{\n\treturn __cancel_work_timer(&dwork->work, true);\n}"
  },
  {
    "function_name": "cancel_delayed_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3119-3122",
    "snippet": "bool cancel_delayed_work(struct delayed_work *dwork)\n{\n\treturn __cancel_work(&dwork->work, true);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cancel_work",
          "args": [
            "&dwork->work",
            "true"
          ],
          "line": 3121
        },
        "resolved": true,
        "details": {
          "function_name": "__cancel_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3086-3101",
          "snippet": "static bool __cancel_work(struct work_struct *work, bool is_dwork)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t} while (unlikely(ret == -EAGAIN));\n\n\tif (unlikely(ret < 0))\n\t\treturn false;\n\n\tset_work_pool_and_clear_pending(work, get_work_pool_id(work));\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool __cancel_work(struct work_struct *work, bool is_dwork)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t} while (unlikely(ret == -EAGAIN));\n\n\tif (unlikely(ret < 0))\n\t\treturn false;\n\n\tset_work_pool_and_clear_pending(work, get_work_pool_id(work));\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool cancel_delayed_work(struct delayed_work *dwork)\n{\n\treturn __cancel_work(&dwork->work, true);\n}"
  },
  {
    "function_name": "__cancel_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3086-3101",
    "snippet": "static bool __cancel_work(struct work_struct *work, bool is_dwork)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t} while (unlikely(ret == -EAGAIN));\n\n\tif (unlikely(ret < 0))\n\t\treturn false;\n\n\tset_work_pool_and_clear_pending(work, get_work_pool_id(work));\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 3099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_work_pool_and_clear_pending",
          "args": [
            "work",
            "get_work_pool_id(work)"
          ],
          "line": 3098
        },
        "resolved": true,
        "details": {
          "function_name": "set_work_pool_and_clear_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "634-674",
          "snippet": "static void set_work_pool_and_clear_pending(struct work_struct *work,\n\t\t\t\t\t    int pool_id)\n{\n\t/*\n\t * The following wmb is paired with the implied mb in\n\t * test_and_set_bit(PENDING) and ensures all updates to @work made\n\t * here are visible to and precede any updates by the next PENDING\n\t * owner.\n\t */\n\tsmp_wmb();\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT, 0);\n\t/*\n\t * The following mb guarantees that previous clear of a PENDING bit\n\t * will not be reordered with any speculative LOADS or STORES from\n\t * work->current_func, which is executed afterwards.  This possible\n\t * reordering can lead to a missed execution on attempt to qeueue\n\t * the same @work.  E.g. consider this case:\n\t *\n\t *   CPU#0                         CPU#1\n\t *   ----------------------------  --------------------------------\n\t *\n\t * 1  STORE event_indicated\n\t * 2  queue_work_on() {\n\t * 3    test_and_set_bit(PENDING)\n\t * 4 }                             set_..._and_clear_pending() {\n\t * 5                                 set_work_data() # clear bit\n\t * 6                                 smp_mb()\n\t * 7                               work->current_func() {\n\t * 8\t\t\t\t      LOAD event_indicated\n\t *\t\t\t\t   }\n\t *\n\t * Without an explicit full barrier speculative LOAD on line 8 can\n\t * be executed before CPU#0 does STORE on line 1.  If that happens,\n\t * CPU#0 observes the PENDING bit is still set and new execution of\n\t * a @work is not queued in a hope, that CPU#1 will eventually\n\t * finish the queued @work.  Meanwhile CPU#1 does not see\n\t * event_indicated is set, because speculative LOAD was executed\n\t * before actual STORE.\n\t */\n\tsmp_mb();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void set_work_pool_and_clear_pending(struct work_struct *work,\n\t\t\t\t\t    int pool_id)\n{\n\t/*\n\t * The following wmb is paired with the implied mb in\n\t * test_and_set_bit(PENDING) and ensures all updates to @work made\n\t * here are visible to and precede any updates by the next PENDING\n\t * owner.\n\t */\n\tsmp_wmb();\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT, 0);\n\t/*\n\t * The following mb guarantees that previous clear of a PENDING bit\n\t * will not be reordered with any speculative LOADS or STORES from\n\t * work->current_func, which is executed afterwards.  This possible\n\t * reordering can lead to a missed execution on attempt to qeueue\n\t * the same @work.  E.g. consider this case:\n\t *\n\t *   CPU#0                         CPU#1\n\t *   ----------------------------  --------------------------------\n\t *\n\t * 1  STORE event_indicated\n\t * 2  queue_work_on() {\n\t * 3    test_and_set_bit(PENDING)\n\t * 4 }                             set_..._and_clear_pending() {\n\t * 5                                 set_work_data() # clear bit\n\t * 6                                 smp_mb()\n\t * 7                               work->current_func() {\n\t * 8\t\t\t\t      LOAD event_indicated\n\t *\t\t\t\t   }\n\t *\n\t * Without an explicit full barrier speculative LOAD on line 8 can\n\t * be executed before CPU#0 does STORE on line 1.  If that happens,\n\t * CPU#0 observes the PENDING bit is still set and new execution of\n\t * a @work is not queued in a hope, that CPU#1 will eventually\n\t * finish the queued @work.  Meanwhile CPU#1 does not see\n\t * event_indicated is set, because speculative LOAD was executed\n\t * before actual STORE.\n\t */\n\tsmp_mb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_work_pool_id",
          "args": [
            "work"
          ],
          "line": 3098
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pool_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "732-741",
          "snippet": "static int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 3095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == -EAGAIN"
          ],
          "line": 3093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_grab_pending",
          "args": [
            "work",
            "is_dwork",
            "&flags"
          ],
          "line": 3092
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_grab_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1206-1278",
          "snippet": "static int try_to_grab_pending(struct work_struct *work, bool is_dwork,\n\t\t\t       unsigned long *flags)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlocal_irq_save(*flags);\n\n\t/* try to steal the timer if it exists */\n\tif (is_dwork) {\n\t\tstruct delayed_work *dwork = to_delayed_work(work);\n\n\t\t/*\n\t\t * dwork->timer is irqsafe.  If del_timer() fails, it's\n\t\t * guaranteed that the timer is not queued anywhere and not\n\t\t * running on the local CPU.\n\t\t */\n\t\tif (likely(del_timer(&dwork->timer)))\n\t\t\treturn 1;\n\t}\n\n\t/* try to claim PENDING the normal way */\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work)))\n\t\treturn 0;\n\n\t/*\n\t * The queueing is in progress, or it is already queued. Try to\n\t * steal it from ->worklist without clearing WORK_STRUCT_PENDING.\n\t */\n\tpool = get_work_pool(work);\n\tif (!pool)\n\t\tgoto fail;\n\n\tspin_lock(&pool->lock);\n\t/*\n\t * work->data is guaranteed to point to pwq only while the work\n\t * item is queued on pwq->wq, and both updating work->data to point\n\t * to pwq on queueing and to pool on dequeueing are done under\n\t * pwq->pool->lock.  This in turn guarantees that, if work->data\n\t * points to pwq which is associated with a locked pool, the work\n\t * item is currently queued on that pool.\n\t */\n\tpwq = get_work_pwq(work);\n\tif (pwq && pwq->pool == pool) {\n\t\tdebug_work_deactivate(work);\n\n\t\t/*\n\t\t * A delayed work item cannot be grabbed directly because\n\t\t * it might have linked NO_COLOR work items which, if left\n\t\t * on the delayed_list, will confuse pwq->nr_active\n\t\t * management later on and cause stall.  Make sure the work\n\t\t * item is activated before grabbing.\n\t\t */\n\t\tif (*work_data_bits(work) & WORK_STRUCT_DELAYED)\n\t\t\tpwq_activate_delayed_work(work);\n\n\t\tlist_del_init(&work->entry);\n\t\tpwq_dec_nr_in_flight(pwq, get_work_color(work));\n\n\t\t/* work->data points to pwq iff queued, point to pool */\n\t\tset_work_pool_and_keep_pending(work, pool->id);\n\n\t\tspin_unlock(&pool->lock);\n\t\treturn 1;\n\t}\n\tspin_unlock(&pool->lock);\nfail:\n\tlocal_irq_restore(*flags);\n\tif (work_is_canceling(work))\n\t\treturn -ENOENT;\n\tcpu_relax();\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int try_to_grab_pending(struct work_struct *work, bool is_dwork,\n\t\t\t       unsigned long *flags)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlocal_irq_save(*flags);\n\n\t/* try to steal the timer if it exists */\n\tif (is_dwork) {\n\t\tstruct delayed_work *dwork = to_delayed_work(work);\n\n\t\t/*\n\t\t * dwork->timer is irqsafe.  If del_timer() fails, it's\n\t\t * guaranteed that the timer is not queued anywhere and not\n\t\t * running on the local CPU.\n\t\t */\n\t\tif (likely(del_timer(&dwork->timer)))\n\t\t\treturn 1;\n\t}\n\n\t/* try to claim PENDING the normal way */\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work)))\n\t\treturn 0;\n\n\t/*\n\t * The queueing is in progress, or it is already queued. Try to\n\t * steal it from ->worklist without clearing WORK_STRUCT_PENDING.\n\t */\n\tpool = get_work_pool(work);\n\tif (!pool)\n\t\tgoto fail;\n\n\tspin_lock(&pool->lock);\n\t/*\n\t * work->data is guaranteed to point to pwq only while the work\n\t * item is queued on pwq->wq, and both updating work->data to point\n\t * to pwq on queueing and to pool on dequeueing are done under\n\t * pwq->pool->lock.  This in turn guarantees that, if work->data\n\t * points to pwq which is associated with a locked pool, the work\n\t * item is currently queued on that pool.\n\t */\n\tpwq = get_work_pwq(work);\n\tif (pwq && pwq->pool == pool) {\n\t\tdebug_work_deactivate(work);\n\n\t\t/*\n\t\t * A delayed work item cannot be grabbed directly because\n\t\t * it might have linked NO_COLOR work items which, if left\n\t\t * on the delayed_list, will confuse pwq->nr_active\n\t\t * management later on and cause stall.  Make sure the work\n\t\t * item is activated before grabbing.\n\t\t */\n\t\tif (*work_data_bits(work) & WORK_STRUCT_DELAYED)\n\t\t\tpwq_activate_delayed_work(work);\n\n\t\tlist_del_init(&work->entry);\n\t\tpwq_dec_nr_in_flight(pwq, get_work_color(work));\n\n\t\t/* work->data points to pwq iff queued, point to pool */\n\t\tset_work_pool_and_keep_pending(work, pool->id);\n\n\t\tspin_unlock(&pool->lock);\n\t\treturn 1;\n\t}\n\tspin_unlock(&pool->lock);\nfail:\n\tlocal_irq_restore(*flags);\n\tif (work_is_canceling(work))\n\t\treturn -ENOENT;\n\tcpu_relax();\n\treturn -EAGAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool __cancel_work(struct work_struct *work, bool is_dwork)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t} while (unlikely(ret == -EAGAIN));\n\n\tif (unlikely(ret < 0))\n\t\treturn false;\n\n\tset_work_pool_and_clear_pending(work, get_work_pool_id(work));\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "flush_rcu_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3074-3083",
    "snippet": "bool flush_rcu_work(struct rcu_work *rwork)\n{\n\tif (test_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(&rwork->work))) {\n\t\trcu_barrier();\n\t\tflush_work(&rwork->work);\n\t\treturn true;\n\t} else {\n\t\treturn flush_work(&rwork->work);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&rwork->work"
          ],
          "line": 3081
        },
        "resolved": true,
        "details": {
          "function_name": "flush_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2936-2939",
          "snippet": "bool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 3077
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_barrier_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "620-624",
          "snippet": "void rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid rcu_barrier_tasks(void)\n{\n\t/* There is only one callback queue, so this is easy.  ;-) */\n\tsynchronize_rcu_tasks();\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "WORK_STRUCT_PENDING_BIT",
            "work_data_bits(&rwork->work)"
          ],
          "line": 3076
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "811-820",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "&rwork->work"
          ],
          "line": 3076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_rcu_work(struct rcu_work *rwork)\n{\n\tif (test_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(&rwork->work))) {\n\t\trcu_barrier();\n\t\tflush_work(&rwork->work);\n\t\treturn true;\n\t} else {\n\t\treturn flush_work(&rwork->work);\n\t}\n}"
  },
  {
    "function_name": "flush_delayed_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3056-3063",
    "snippet": "bool flush_delayed_work(struct delayed_work *dwork)\n{\n\tlocal_irq_disable();\n\tif (del_timer_sync(&dwork->timer))\n\t\t__queue_work(dwork->cpu, dwork->wq, &dwork->work);\n\tlocal_irq_enable();\n\treturn flush_work(&dwork->work);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&dwork->work"
          ],
          "line": 3062
        },
        "resolved": true,
        "details": {
          "function_name": "flush_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2936-2939",
          "snippet": "bool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 3061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__queue_work",
          "args": [
            "dwork->cpu",
            "dwork->wq",
            "&dwork->work"
          ],
          "line": 3060
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1363-1464",
          "snippet": "static void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\tdebug_work_activate(work);\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\nretry:\n\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\telse\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\tspin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\tspin_unlock(&last_pool->lock);\n\t\t\tspin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\tspin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\tspin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry))) {\n\t\tspin_unlock(&pwq->pool->lock);\n\t\treturn;\n\t}\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_DELAYED;\n\t\tworklist = &pwq->delayed_works;\n\t}\n\n\tinsert_work(pwq, work, worklist, work_flags);\n\n\tspin_unlock(&pwq->pool->lock);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\tdebug_work_activate(work);\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\nretry:\n\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\telse\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\tspin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\tspin_unlock(&last_pool->lock);\n\t\t\tspin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\tspin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\tspin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry))) {\n\t\tspin_unlock(&pwq->pool->lock);\n\t\treturn;\n\t}\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_DELAYED;\n\t\tworklist = &pwq->delayed_works;\n\t}\n\n\tinsert_work(pwq, work, worklist, work_flags);\n\n\tspin_unlock(&pwq->pool->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&dwork->timer"
          ],
          "line": 3059
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1273-1298",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 3058
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool flush_delayed_work(struct delayed_work *dwork)\n{\n\tlocal_irq_disable();\n\tif (del_timer_sync(&dwork->timer))\n\t\t__queue_work(dwork->cpu, dwork->wq, &dwork->work);\n\tlocal_irq_enable();\n\treturn flush_work(&dwork->work);\n}"
  },
  {
    "function_name": "cancel_work_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "3038-3041",
    "snippet": "bool cancel_work_sync(struct work_struct *work)\n{\n\treturn __cancel_work_timer(work, false);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cancel_work_timer",
          "args": [
            "work",
            "false"
          ],
          "line": 3040
        },
        "resolved": true,
        "details": {
          "function_name": "__cancel_work_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2956-3018",
          "snippet": "static bool __cancel_work_timer(struct work_struct *work, bool is_dwork)\n{\n\tstatic DECLARE_WAIT_QUEUE_HEAD(cancel_waitq);\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t\t/*\n\t\t * If someone else is already canceling, wait for it to\n\t\t * finish.  flush_work() doesn't work for PREEMPT_NONE\n\t\t * because we may get scheduled between @work's completion\n\t\t * and the other canceling task resuming and clearing\n\t\t * CANCELING - flush_work() will return false immediately\n\t\t * as @work is no longer busy, try_to_grab_pending() will\n\t\t * return -ENOENT as @work is still being canceled and the\n\t\t * other canceling task won't be able to clear CANCELING as\n\t\t * we're hogging the CPU.\n\t\t *\n\t\t * Let's wait for completion using a waitqueue.  As this\n\t\t * may lead to the thundering herd problem, use a custom\n\t\t * wake function which matches @work along with exclusive\n\t\t * wait and wakeup.\n\t\t */\n\t\tif (unlikely(ret == -ENOENT)) {\n\t\t\tstruct cwt_wait cwait;\n\n\t\t\tinit_wait(&cwait.wait);\n\t\t\tcwait.wait.func = cwt_wakefn;\n\t\t\tcwait.work = work;\n\n\t\t\tprepare_to_wait_exclusive(&cancel_waitq, &cwait.wait,\n\t\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\t\tif (work_is_canceling(work))\n\t\t\t\tschedule();\n\t\t\tfinish_wait(&cancel_waitq, &cwait.wait);\n\t\t}\n\t} while (unlikely(ret < 0));\n\n\t/* tell other tasks trying to grab @work to back off */\n\tmark_work_canceling(work);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * This allows canceling during early boot.  We know that @work\n\t * isn't executing.\n\t */\n\tif (wq_online)\n\t\t__flush_work(work, true);\n\n\tclear_work_data(work);\n\n\t/*\n\t * Paired with prepare_to_wait() above so that either\n\t * waitqueue_active() is visible here or !work_is_canceling() is\n\t * visible there.\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&cancel_waitq))\n\t\t__wake_up(&cancel_waitq, TASK_NORMAL, 1, work);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_online;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\n\nstatic bool __cancel_work_timer(struct work_struct *work, bool is_dwork)\n{\n\tstatic DECLARE_WAIT_QUEUE_HEAD(cancel_waitq);\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t\t/*\n\t\t * If someone else is already canceling, wait for it to\n\t\t * finish.  flush_work() doesn't work for PREEMPT_NONE\n\t\t * because we may get scheduled between @work's completion\n\t\t * and the other canceling task resuming and clearing\n\t\t * CANCELING - flush_work() will return false immediately\n\t\t * as @work is no longer busy, try_to_grab_pending() will\n\t\t * return -ENOENT as @work is still being canceled and the\n\t\t * other canceling task won't be able to clear CANCELING as\n\t\t * we're hogging the CPU.\n\t\t *\n\t\t * Let's wait for completion using a waitqueue.  As this\n\t\t * may lead to the thundering herd problem, use a custom\n\t\t * wake function which matches @work along with exclusive\n\t\t * wait and wakeup.\n\t\t */\n\t\tif (unlikely(ret == -ENOENT)) {\n\t\t\tstruct cwt_wait cwait;\n\n\t\t\tinit_wait(&cwait.wait);\n\t\t\tcwait.wait.func = cwt_wakefn;\n\t\t\tcwait.work = work;\n\n\t\t\tprepare_to_wait_exclusive(&cancel_waitq, &cwait.wait,\n\t\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\t\tif (work_is_canceling(work))\n\t\t\t\tschedule();\n\t\t\tfinish_wait(&cancel_waitq, &cwait.wait);\n\t\t}\n\t} while (unlikely(ret < 0));\n\n\t/* tell other tasks trying to grab @work to back off */\n\tmark_work_canceling(work);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * This allows canceling during early boot.  We know that @work\n\t * isn't executing.\n\t */\n\tif (wq_online)\n\t\t__flush_work(work, true);\n\n\tclear_work_data(work);\n\n\t/*\n\t * Paired with prepare_to_wait() above so that either\n\t * waitqueue_active() is visible here or !work_is_canceling() is\n\t * visible there.\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&cancel_waitq))\n\t\t__wake_up(&cancel_waitq, TASK_NORMAL, 1, work);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool cancel_work_sync(struct work_struct *work)\n{\n\treturn __cancel_work_timer(work, false);\n}"
  },
  {
    "function_name": "__cancel_work_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "2956-3018",
    "snippet": "static bool __cancel_work_timer(struct work_struct *work, bool is_dwork)\n{\n\tstatic DECLARE_WAIT_QUEUE_HEAD(cancel_waitq);\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t\t/*\n\t\t * If someone else is already canceling, wait for it to\n\t\t * finish.  flush_work() doesn't work for PREEMPT_NONE\n\t\t * because we may get scheduled between @work's completion\n\t\t * and the other canceling task resuming and clearing\n\t\t * CANCELING - flush_work() will return false immediately\n\t\t * as @work is no longer busy, try_to_grab_pending() will\n\t\t * return -ENOENT as @work is still being canceled and the\n\t\t * other canceling task won't be able to clear CANCELING as\n\t\t * we're hogging the CPU.\n\t\t *\n\t\t * Let's wait for completion using a waitqueue.  As this\n\t\t * may lead to the thundering herd problem, use a custom\n\t\t * wake function which matches @work along with exclusive\n\t\t * wait and wakeup.\n\t\t */\n\t\tif (unlikely(ret == -ENOENT)) {\n\t\t\tstruct cwt_wait cwait;\n\n\t\t\tinit_wait(&cwait.wait);\n\t\t\tcwait.wait.func = cwt_wakefn;\n\t\t\tcwait.work = work;\n\n\t\t\tprepare_to_wait_exclusive(&cancel_waitq, &cwait.wait,\n\t\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\t\tif (work_is_canceling(work))\n\t\t\t\tschedule();\n\t\t\tfinish_wait(&cancel_waitq, &cwait.wait);\n\t\t}\n\t} while (unlikely(ret < 0));\n\n\t/* tell other tasks trying to grab @work to back off */\n\tmark_work_canceling(work);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * This allows canceling during early boot.  We know that @work\n\t * isn't executing.\n\t */\n\tif (wq_online)\n\t\t__flush_work(work, true);\n\n\tclear_work_data(work);\n\n\t/*\n\t * Paired with prepare_to_wait() above so that either\n\t * waitqueue_active() is visible here or !work_is_canceling() is\n\t * visible there.\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&cancel_waitq))\n\t\t__wake_up(&cancel_waitq, TASK_NORMAL, 1, work);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool wq_online;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up",
          "args": [
            "&cancel_waitq",
            "TASK_NORMAL",
            "1",
            "work"
          ],
          "line": 3015
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_sync_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "188-200",
          "snippet": "void __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, void *key)\n{\n\tint wake_flags = 1; /* XXX WF_SYNC */\n\n\tif (unlikely(!wq_head))\n\t\treturn;\n\n\tif (unlikely(nr_exclusive != 1))\n\t\twake_flags = 0;\n\n\t__wake_up_common_lock(wq_head, mode, nr_exclusive, wake_flags, key);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, void *key)\n{\n\tint wake_flags = 1; /* XXX WF_SYNC */\n\n\tif (unlikely(!wq_head))\n\t\treturn;\n\n\tif (unlikely(nr_exclusive != 1))\n\t\twake_flags = 0;\n\n\t__wake_up_common_lock(wq_head, mode, nr_exclusive, wake_flags, key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&cancel_waitq"
          ],
          "line": 3014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 3013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_work_data",
          "args": [
            "work"
          ],
          "line": 3006
        },
        "resolved": true,
        "details": {
          "function_name": "clear_work_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "676-680",
          "snippet": "static void clear_work_data(struct work_struct *work)\n{\n\tsmp_wmb();\t/* see set_work_pool_and_clear_pending() */\n\tset_work_data(work, WORK_STRUCT_NO_POOL, 0);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void clear_work_data(struct work_struct *work)\n{\n\tsmp_wmb();\t/* see set_work_pool_and_clear_pending() */\n\tset_work_data(work, WORK_STRUCT_NO_POOL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__flush_work",
          "args": [
            "work",
            "true"
          ],
          "line": 3004
        },
        "resolved": true,
        "details": {
          "function_name": "__flush_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2904-2923",
          "snippet": "static bool __flush_work(struct work_struct *work, bool from_cancel)\n{\n\tstruct wq_barrier barr;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn false;\n\n\tif (!from_cancel) {\n\t\tlock_map_acquire(&work->lockdep_map);\n\t\tlock_map_release(&work->lockdep_map);\n\t}\n\n\tif (start_flush_work(work, &barr, from_cancel)) {\n\t\twait_for_completion(&barr.done);\n\t\tdestroy_work_on_stack(&barr.work);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_online;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\n\nstatic bool __flush_work(struct work_struct *work, bool from_cancel)\n{\n\tstruct wq_barrier barr;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn false;\n\n\tif (!from_cancel) {\n\t\tlock_map_acquire(&work->lockdep_map);\n\t\tlock_map_release(&work->lockdep_map);\n\t}\n\n\tif (start_flush_work(work, &barr, from_cancel)) {\n\t\twait_for_completion(&barr.done);\n\t\tdestroy_work_on_stack(&barr.work);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_work_canceling",
          "args": [
            "work"
          ],
          "line": 2996
        },
        "resolved": true,
        "details": {
          "function_name": "mark_work_canceling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "743-749",
          "snippet": "static void mark_work_canceling(struct work_struct *work)\n{\n\tunsigned long pool_id = get_work_pool_id(work);\n\n\tpool_id <<= WORK_OFFQ_POOL_SHIFT;\n\tset_work_data(work, pool_id | WORK_OFFQ_CANCELING, WORK_STRUCT_PENDING);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void mark_work_canceling(struct work_struct *work)\n{\n\tunsigned long pool_id = get_work_pool_id(work);\n\n\tpool_id <<= WORK_OFFQ_POOL_SHIFT;\n\tset_work_data(work, pool_id | WORK_OFFQ_CANCELING, WORK_STRUCT_PENDING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 2993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&cancel_waitq",
            "&cwait.wait"
          ],
          "line": 2991
        },
        "resolved": true,
        "details": {
          "function_name": "finish_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "347-370",
          "snippet": "void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2990
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "work_is_canceling",
          "args": [
            "work"
          ],
          "line": 2989
        },
        "resolved": true,
        "details": {
          "function_name": "work_is_canceling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "751-756",
          "snippet": "static bool work_is_canceling(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\treturn !(data & WORK_STRUCT_PWQ) && (data & WORK_OFFQ_CANCELING);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool work_is_canceling(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\treturn !(data & WORK_STRUCT_PWQ) && (data & WORK_OFFQ_CANCELING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait_exclusive",
          "args": [
            "&cancel_waitq",
            "&cwait.wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 2987
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_to_wait_exclusive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "238-249",
          "snippet": "void\nprepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (list_empty(&wq_entry->entry))\n\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\tset_current_state(state);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid\nprepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (list_empty(&wq_entry->entry))\n\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\tset_current_state(state);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_wait",
          "args": [
            "&cwait.wait"
          ],
          "line": 2983
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_waiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1149-1155",
          "snippet": "void rt_mutex_init_waiter(struct rt_mutex_waiter *waiter)\n{\n\tdebug_rt_mutex_init_waiter(waiter);\n\tRB_CLEAR_NODE(&waiter->pi_tree_entry);\n\tRB_CLEAR_NODE(&waiter->tree_entry);\n\twaiter->task = NULL;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid rt_mutex_init_waiter(struct rt_mutex_waiter *waiter)\n{\n\tdebug_rt_mutex_init_waiter(waiter);\n\tRB_CLEAR_NODE(&waiter->pi_tree_entry);\n\tRB_CLEAR_NODE(&waiter->tree_entry);\n\twaiter->task = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == -ENOENT"
          ],
          "line": 2980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_grab_pending",
          "args": [
            "work",
            "is_dwork",
            "&flags"
          ],
          "line": 2963
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_grab_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1206-1278",
          "snippet": "static int try_to_grab_pending(struct work_struct *work, bool is_dwork,\n\t\t\t       unsigned long *flags)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlocal_irq_save(*flags);\n\n\t/* try to steal the timer if it exists */\n\tif (is_dwork) {\n\t\tstruct delayed_work *dwork = to_delayed_work(work);\n\n\t\t/*\n\t\t * dwork->timer is irqsafe.  If del_timer() fails, it's\n\t\t * guaranteed that the timer is not queued anywhere and not\n\t\t * running on the local CPU.\n\t\t */\n\t\tif (likely(del_timer(&dwork->timer)))\n\t\t\treturn 1;\n\t}\n\n\t/* try to claim PENDING the normal way */\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work)))\n\t\treturn 0;\n\n\t/*\n\t * The queueing is in progress, or it is already queued. Try to\n\t * steal it from ->worklist without clearing WORK_STRUCT_PENDING.\n\t */\n\tpool = get_work_pool(work);\n\tif (!pool)\n\t\tgoto fail;\n\n\tspin_lock(&pool->lock);\n\t/*\n\t * work->data is guaranteed to point to pwq only while the work\n\t * item is queued on pwq->wq, and both updating work->data to point\n\t * to pwq on queueing and to pool on dequeueing are done under\n\t * pwq->pool->lock.  This in turn guarantees that, if work->data\n\t * points to pwq which is associated with a locked pool, the work\n\t * item is currently queued on that pool.\n\t */\n\tpwq = get_work_pwq(work);\n\tif (pwq && pwq->pool == pool) {\n\t\tdebug_work_deactivate(work);\n\n\t\t/*\n\t\t * A delayed work item cannot be grabbed directly because\n\t\t * it might have linked NO_COLOR work items which, if left\n\t\t * on the delayed_list, will confuse pwq->nr_active\n\t\t * management later on and cause stall.  Make sure the work\n\t\t * item is activated before grabbing.\n\t\t */\n\t\tif (*work_data_bits(work) & WORK_STRUCT_DELAYED)\n\t\t\tpwq_activate_delayed_work(work);\n\n\t\tlist_del_init(&work->entry);\n\t\tpwq_dec_nr_in_flight(pwq, get_work_color(work));\n\n\t\t/* work->data points to pwq iff queued, point to pool */\n\t\tset_work_pool_and_keep_pending(work, pool->id);\n\n\t\tspin_unlock(&pool->lock);\n\t\treturn 1;\n\t}\n\tspin_unlock(&pool->lock);\nfail:\n\tlocal_irq_restore(*flags);\n\tif (work_is_canceling(work))\n\t\treturn -ENOENT;\n\tcpu_relax();\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int try_to_grab_pending(struct work_struct *work, bool is_dwork,\n\t\t\t       unsigned long *flags)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlocal_irq_save(*flags);\n\n\t/* try to steal the timer if it exists */\n\tif (is_dwork) {\n\t\tstruct delayed_work *dwork = to_delayed_work(work);\n\n\t\t/*\n\t\t * dwork->timer is irqsafe.  If del_timer() fails, it's\n\t\t * guaranteed that the timer is not queued anywhere and not\n\t\t * running on the local CPU.\n\t\t */\n\t\tif (likely(del_timer(&dwork->timer)))\n\t\t\treturn 1;\n\t}\n\n\t/* try to claim PENDING the normal way */\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work)))\n\t\treturn 0;\n\n\t/*\n\t * The queueing is in progress, or it is already queued. Try to\n\t * steal it from ->worklist without clearing WORK_STRUCT_PENDING.\n\t */\n\tpool = get_work_pool(work);\n\tif (!pool)\n\t\tgoto fail;\n\n\tspin_lock(&pool->lock);\n\t/*\n\t * work->data is guaranteed to point to pwq only while the work\n\t * item is queued on pwq->wq, and both updating work->data to point\n\t * to pwq on queueing and to pool on dequeueing are done under\n\t * pwq->pool->lock.  This in turn guarantees that, if work->data\n\t * points to pwq which is associated with a locked pool, the work\n\t * item is currently queued on that pool.\n\t */\n\tpwq = get_work_pwq(work);\n\tif (pwq && pwq->pool == pool) {\n\t\tdebug_work_deactivate(work);\n\n\t\t/*\n\t\t * A delayed work item cannot be grabbed directly because\n\t\t * it might have linked NO_COLOR work items which, if left\n\t\t * on the delayed_list, will confuse pwq->nr_active\n\t\t * management later on and cause stall.  Make sure the work\n\t\t * item is activated before grabbing.\n\t\t */\n\t\tif (*work_data_bits(work) & WORK_STRUCT_DELAYED)\n\t\t\tpwq_activate_delayed_work(work);\n\n\t\tlist_del_init(&work->entry);\n\t\tpwq_dec_nr_in_flight(pwq, get_work_color(work));\n\n\t\t/* work->data points to pwq iff queued, point to pool */\n\t\tset_work_pool_and_keep_pending(work, pool->id);\n\n\t\tspin_unlock(&pool->lock);\n\t\treturn 1;\n\t}\n\tspin_unlock(&pool->lock);\nfail:\n\tlocal_irq_restore(*flags);\n\tif (work_is_canceling(work))\n\t\treturn -ENOENT;\n\tcpu_relax();\n\treturn -EAGAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\n\nstatic bool __cancel_work_timer(struct work_struct *work, bool is_dwork)\n{\n\tstatic DECLARE_WAIT_QUEUE_HEAD(cancel_waitq);\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(work, is_dwork, &flags);\n\t\t/*\n\t\t * If someone else is already canceling, wait for it to\n\t\t * finish.  flush_work() doesn't work for PREEMPT_NONE\n\t\t * because we may get scheduled between @work's completion\n\t\t * and the other canceling task resuming and clearing\n\t\t * CANCELING - flush_work() will return false immediately\n\t\t * as @work is no longer busy, try_to_grab_pending() will\n\t\t * return -ENOENT as @work is still being canceled and the\n\t\t * other canceling task won't be able to clear CANCELING as\n\t\t * we're hogging the CPU.\n\t\t *\n\t\t * Let's wait for completion using a waitqueue.  As this\n\t\t * may lead to the thundering herd problem, use a custom\n\t\t * wake function which matches @work along with exclusive\n\t\t * wait and wakeup.\n\t\t */\n\t\tif (unlikely(ret == -ENOENT)) {\n\t\t\tstruct cwt_wait cwait;\n\n\t\t\tinit_wait(&cwait.wait);\n\t\t\tcwait.wait.func = cwt_wakefn;\n\t\t\tcwait.work = work;\n\n\t\t\tprepare_to_wait_exclusive(&cancel_waitq, &cwait.wait,\n\t\t\t\t\t\t  TASK_UNINTERRUPTIBLE);\n\t\t\tif (work_is_canceling(work))\n\t\t\t\tschedule();\n\t\t\tfinish_wait(&cancel_waitq, &cwait.wait);\n\t\t}\n\t} while (unlikely(ret < 0));\n\n\t/* tell other tasks trying to grab @work to back off */\n\tmark_work_canceling(work);\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * This allows canceling during early boot.  We know that @work\n\t * isn't executing.\n\t */\n\tif (wq_online)\n\t\t__flush_work(work, true);\n\n\tclear_work_data(work);\n\n\t/*\n\t * Paired with prepare_to_wait() above so that either\n\t * waitqueue_active() is visible here or !work_is_canceling() is\n\t * visible there.\n\t */\n\tsmp_mb();\n\tif (waitqueue_active(&cancel_waitq))\n\t\t__wake_up(&cancel_waitq, TASK_NORMAL, 1, work);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cwt_wakefn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "2947-2954",
    "snippet": "static int cwt_wakefn(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct cwt_wait *cwait = container_of(wait, struct cwt_wait, wait);\n\n\tif (cwait->work != key)\n\t\treturn 0;\n\treturn autoremove_wake_function(wait, mode, sync, key);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autoremove_wake_function",
          "args": [
            "wait",
            "mode",
            "sync",
            "key"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "autoremove_wake_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait.c",
          "lines": "373-381",
          "snippet": "int autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)\n{\n\tint ret = default_wake_function(wq_entry, mode, sync, key);\n\n\tif (ret)\n\t\tlist_del_init(&wq_entry->entry);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)\n{\n\tint ret = default_wake_function(wq_entry, mode, sync, key);\n\n\tif (ret)\n\t\tlist_del_init(&wq_entry->entry);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wait",
            "structcwt_wait",
            "wait"
          ],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int cwt_wakefn(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct cwt_wait *cwait = container_of(wait, struct cwt_wait, wait);\n\n\tif (cwait->work != key)\n\t\treturn 0;\n\treturn autoremove_wake_function(wait, mode, sync, key);\n}"
  },
  {
    "function_name": "flush_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "2936-2939",
    "snippet": "bool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__flush_work",
          "args": [
            "work",
            "false"
          ],
          "line": 2938
        },
        "resolved": true,
        "details": {
          "function_name": "__flush_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2904-2923",
          "snippet": "static bool __flush_work(struct work_struct *work, bool from_cancel)\n{\n\tstruct wq_barrier barr;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn false;\n\n\tif (!from_cancel) {\n\t\tlock_map_acquire(&work->lockdep_map);\n\t\tlock_map_release(&work->lockdep_map);\n\t}\n\n\tif (start_flush_work(work, &barr, from_cancel)) {\n\t\twait_for_completion(&barr.done);\n\t\tdestroy_work_on_stack(&barr.work);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_online;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\n\nstatic bool __flush_work(struct work_struct *work, bool from_cancel)\n{\n\tstruct wq_barrier barr;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn false;\n\n\tif (!from_cancel) {\n\t\tlock_map_acquire(&work->lockdep_map);\n\t\tlock_map_release(&work->lockdep_map);\n\t}\n\n\tif (start_flush_work(work, &barr, from_cancel)) {\n\t\twait_for_completion(&barr.done);\n\t\tdestroy_work_on_stack(&barr.work);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}"
  },
  {
    "function_name": "__flush_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "2904-2923",
    "snippet": "static bool __flush_work(struct work_struct *work, bool from_cancel)\n{\n\tstruct wq_barrier barr;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn false;\n\n\tif (!from_cancel) {\n\t\tlock_map_acquire(&work->lockdep_map);\n\t\tlock_map_release(&work->lockdep_map);\n\t}\n\n\tif (start_flush_work(work, &barr, from_cancel)) {\n\t\twait_for_completion(&barr.done);\n\t\tdestroy_work_on_stack(&barr.work);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool wq_online;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_work_on_stack",
          "args": [
            "&barr.work"
          ],
          "line": 2918
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_work_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "508-511",
          "snippet": "void destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&barr.done"
          ],
          "line": 2917
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_flush_work",
          "args": [
            "work",
            "&barr",
            "from_cancel"
          ],
          "line": 2916
        },
        "resolved": true,
        "details": {
          "function_name": "start_flush_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2849-2902",
          "snippet": "static bool start_flush_work(struct work_struct *work, struct wq_barrier *barr,\n\t\t\t     bool from_cancel)\n{\n\tstruct worker *worker = NULL;\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tmight_sleep();\n\n\tlocal_irq_disable();\n\tpool = get_work_pool(work);\n\tif (!pool) {\n\t\tlocal_irq_enable();\n\t\treturn false;\n\t}\n\n\tspin_lock(&pool->lock);\n\t/* see the comment in try_to_grab_pending() with the same code */\n\tpwq = get_work_pwq(work);\n\tif (pwq) {\n\t\tif (unlikely(pwq->pool != pool))\n\t\t\tgoto already_gone;\n\t} else {\n\t\tworker = find_worker_executing_work(pool, work);\n\t\tif (!worker)\n\t\t\tgoto already_gone;\n\t\tpwq = worker->current_pwq;\n\t}\n\n\tcheck_flush_dependency(pwq->wq, work);\n\n\tinsert_wq_barrier(pwq, barr, work, worker);\n\tspin_unlock_irq(&pool->lock);\n\n\t/*\n\t * Force a lock recursion deadlock when using flush_work() inside a\n\t * single-threaded or rescuer equipped workqueue.\n\t *\n\t * For single threaded workqueues the deadlock happens when the work\n\t * is after the work issuing the flush_work(). For rescuer equipped\n\t * workqueues the deadlock happens when the rescuer stalls, blocking\n\t * forward progress.\n\t */\n\tif (!from_cancel &&\n\t    (pwq->wq->saved_max_active == 1 || pwq->wq->rescuer)) {\n\t\tlock_map_acquire(&pwq->wq->lockdep_map);\n\t\tlock_map_release(&pwq->wq->lockdep_map);\n\t}\n\n\treturn true;\nalready_gone:\n\tspin_unlock_irq(&pool->lock);\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic bool start_flush_work(struct work_struct *work, struct wq_barrier *barr,\n\t\t\t     bool from_cancel)\n{\n\tstruct worker *worker = NULL;\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tmight_sleep();\n\n\tlocal_irq_disable();\n\tpool = get_work_pool(work);\n\tif (!pool) {\n\t\tlocal_irq_enable();\n\t\treturn false;\n\t}\n\n\tspin_lock(&pool->lock);\n\t/* see the comment in try_to_grab_pending() with the same code */\n\tpwq = get_work_pwq(work);\n\tif (pwq) {\n\t\tif (unlikely(pwq->pool != pool))\n\t\t\tgoto already_gone;\n\t} else {\n\t\tworker = find_worker_executing_work(pool, work);\n\t\tif (!worker)\n\t\t\tgoto already_gone;\n\t\tpwq = worker->current_pwq;\n\t}\n\n\tcheck_flush_dependency(pwq->wq, work);\n\n\tinsert_wq_barrier(pwq, barr, work, worker);\n\tspin_unlock_irq(&pool->lock);\n\n\t/*\n\t * Force a lock recursion deadlock when using flush_work() inside a\n\t * single-threaded or rescuer equipped workqueue.\n\t *\n\t * For single threaded workqueues the deadlock happens when the work\n\t * is after the work issuing the flush_work(). For rescuer equipped\n\t * workqueues the deadlock happens when the rescuer stalls, blocking\n\t * forward progress.\n\t */\n\tif (!from_cancel &&\n\t    (pwq->wq->saved_max_active == 1 || pwq->wq->rescuer)) {\n\t\tlock_map_acquire(&pwq->wq->lockdep_map);\n\t\tlock_map_release(&pwq->wq->lockdep_map);\n\t}\n\n\treturn true;\nalready_gone:\n\tspin_unlock_irq(&pool->lock);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_map_release",
          "args": [
            "&work->lockdep_map"
          ],
          "line": 2913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_acquire",
          "args": [
            "&work->lockdep_map"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!wq_online"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\n\nstatic bool __flush_work(struct work_struct *work, bool from_cancel)\n{\n\tstruct wq_barrier barr;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn false;\n\n\tif (!from_cancel) {\n\t\tlock_map_acquire(&work->lockdep_map);\n\t\tlock_map_release(&work->lockdep_map);\n\t}\n\n\tif (start_flush_work(work, &barr, from_cancel)) {\n\t\twait_for_completion(&barr.done);\n\t\tdestroy_work_on_stack(&barr.work);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "start_flush_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "2849-2902",
    "snippet": "static bool start_flush_work(struct work_struct *work, struct wq_barrier *barr,\n\t\t\t     bool from_cancel)\n{\n\tstruct worker *worker = NULL;\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tmight_sleep();\n\n\tlocal_irq_disable();\n\tpool = get_work_pool(work);\n\tif (!pool) {\n\t\tlocal_irq_enable();\n\t\treturn false;\n\t}\n\n\tspin_lock(&pool->lock);\n\t/* see the comment in try_to_grab_pending() with the same code */\n\tpwq = get_work_pwq(work);\n\tif (pwq) {\n\t\tif (unlikely(pwq->pool != pool))\n\t\t\tgoto already_gone;\n\t} else {\n\t\tworker = find_worker_executing_work(pool, work);\n\t\tif (!worker)\n\t\t\tgoto already_gone;\n\t\tpwq = worker->current_pwq;\n\t}\n\n\tcheck_flush_dependency(pwq->wq, work);\n\n\tinsert_wq_barrier(pwq, barr, work, worker);\n\tspin_unlock_irq(&pool->lock);\n\n\t/*\n\t * Force a lock recursion deadlock when using flush_work() inside a\n\t * single-threaded or rescuer equipped workqueue.\n\t *\n\t * For single threaded workqueues the deadlock happens when the work\n\t * is after the work issuing the flush_work(). For rescuer equipped\n\t * workqueues the deadlock happens when the rescuer stalls, blocking\n\t * forward progress.\n\t */\n\tif (!from_cancel &&\n\t    (pwq->wq->saved_max_active == 1 || pwq->wq->rescuer)) {\n\t\tlock_map_acquire(&pwq->wq->lockdep_map);\n\t\tlock_map_release(&pwq->wq->lockdep_map);\n\t}\n\n\treturn true;\nalready_gone:\n\tspin_unlock_irq(&pool->lock);\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(workqueues);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 2900
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_map_release",
          "args": [
            "&pwq->wq->lockdep_map"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_acquire",
          "args": [
            "&pwq->wq->lockdep_map"
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_wq_barrier",
          "args": [
            "pwq",
            "barr",
            "work",
            "worker"
          ],
          "line": 2880
        },
        "resolved": true,
        "details": {
          "function_name": "insert_wq_barrier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2525-2563",
          "snippet": "static void insert_wq_barrier(struct pool_workqueue *pwq,\n\t\t\t      struct wq_barrier *barr,\n\t\t\t      struct work_struct *target, struct worker *worker)\n{\n\tstruct list_head *head;\n\tunsigned int linked = 0;\n\n\t/*\n\t * debugobject calls are safe here even with pool->lock locked\n\t * as we know for sure that this will not trigger any of the\n\t * checks and call back into the fixup functions where we\n\t * might deadlock.\n\t */\n\tINIT_WORK_ONSTACK(&barr->work, wq_barrier_func);\n\t__set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(&barr->work));\n\n\tinit_completion_map(&barr->done, &target->lockdep_map);\n\n\tbarr->task = current;\n\n\t/*\n\t * If @target is currently being executed, schedule the\n\t * barrier to the worker; otherwise, put it after @target.\n\t */\n\tif (worker)\n\t\thead = worker->scheduled.next;\n\telse {\n\t\tunsigned long *bits = work_data_bits(target);\n\n\t\thead = target->entry.next;\n\t\t/* there can already be other linked works, inherit and set */\n\t\tlinked = *bits & WORK_STRUCT_LINKED;\n\t\t__set_bit(WORK_STRUCT_LINKED_BIT, bits);\n\t}\n\n\tdebug_work_activate(&barr->work);\n\tinsert_work(pwq, &barr->work, head,\n\t\t    work_color_to_flags(WORK_NO_COLOR) | linked);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void insert_wq_barrier(struct pool_workqueue *pwq,\n\t\t\t      struct wq_barrier *barr,\n\t\t\t      struct work_struct *target, struct worker *worker)\n{\n\tstruct list_head *head;\n\tunsigned int linked = 0;\n\n\t/*\n\t * debugobject calls are safe here even with pool->lock locked\n\t * as we know for sure that this will not trigger any of the\n\t * checks and call back into the fixup functions where we\n\t * might deadlock.\n\t */\n\tINIT_WORK_ONSTACK(&barr->work, wq_barrier_func);\n\t__set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(&barr->work));\n\n\tinit_completion_map(&barr->done, &target->lockdep_map);\n\n\tbarr->task = current;\n\n\t/*\n\t * If @target is currently being executed, schedule the\n\t * barrier to the worker; otherwise, put it after @target.\n\t */\n\tif (worker)\n\t\thead = worker->scheduled.next;\n\telse {\n\t\tunsigned long *bits = work_data_bits(target);\n\n\t\thead = target->entry.next;\n\t\t/* there can already be other linked works, inherit and set */\n\t\tlinked = *bits & WORK_STRUCT_LINKED;\n\t\t__set_bit(WORK_STRUCT_LINKED_BIT, bits);\n\t}\n\n\tdebug_work_activate(&barr->work);\n\tinsert_work(pwq, &barr->work, head,\n\t\t    work_color_to_flags(WORK_NO_COLOR) | linked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flush_dependency",
          "args": [
            "pwq->wq",
            "work"
          ],
          "line": 2878
        },
        "resolved": true,
        "details": {
          "function_name": "check_flush_dependency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2468-2487",
          "snippet": "static void check_flush_dependency(struct workqueue_struct *target_wq,\n\t\t\t\t   struct work_struct *target_work)\n{\n\twork_func_t target_func = target_work ? target_work->func : NULL;\n\tstruct worker *worker;\n\n\tif (target_wq->flags & WQ_MEM_RECLAIM)\n\t\treturn;\n\n\tworker = current_wq_worker();\n\n\tWARN_ONCE(current->flags & PF_MEMALLOC,\n\t\t  \"workqueue: PF_MEMALLOC task %d(%s) is flushing !WQ_MEM_RECLAIM %s:%pf\",\n\t\t  current->pid, current->comm, target_wq->name, target_func);\n\tWARN_ONCE(worker && ((worker->current_pwq->wq->flags &\n\t\t\t      (WQ_MEM_RECLAIM | __WQ_LEGACY)) == WQ_MEM_RECLAIM),\n\t\t  \"workqueue: WQ_MEM_RECLAIM %s:%pf is flushing !WQ_MEM_RECLAIM %s:%pf\",\n\t\t  worker->current_pwq->wq->name, worker->current_func,\n\t\t  target_wq->name, target_func);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void check_flush_dependency(struct workqueue_struct *target_wq,\n\t\t\t\t   struct work_struct *target_work)\n{\n\twork_func_t target_func = target_work ? target_work->func : NULL;\n\tstruct worker *worker;\n\n\tif (target_wq->flags & WQ_MEM_RECLAIM)\n\t\treturn;\n\n\tworker = current_wq_worker();\n\n\tWARN_ONCE(current->flags & PF_MEMALLOC,\n\t\t  \"workqueue: PF_MEMALLOC task %d(%s) is flushing !WQ_MEM_RECLAIM %s:%pf\",\n\t\t  current->pid, current->comm, target_wq->name, target_func);\n\tWARN_ONCE(worker && ((worker->current_pwq->wq->flags &\n\t\t\t      (WQ_MEM_RECLAIM | __WQ_LEGACY)) == WQ_MEM_RECLAIM),\n\t\t  \"workqueue: WQ_MEM_RECLAIM %s:%pf is flushing !WQ_MEM_RECLAIM %s:%pf\",\n\t\t  worker->current_pwq->wq->name, worker->current_func,\n\t\t  target_wq->name, target_func);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_worker_executing_work",
          "args": [
            "pool",
            "work"
          ],
          "line": 2872
        },
        "resolved": true,
        "details": {
          "function_name": "find_worker_executing_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "999-1011",
          "snippet": "static struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pwq->pool != pool"
          ],
          "line": 2869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_work_pwq",
          "args": [
            "work"
          ],
          "line": 2867
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pwq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "682-690",
          "snippet": "static struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 2865
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_work_pool",
          "args": [
            "work"
          ],
          "line": 2859
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pool_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "732-741",
          "snippet": "static int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 2856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic bool start_flush_work(struct work_struct *work, struct wq_barrier *barr,\n\t\t\t     bool from_cancel)\n{\n\tstruct worker *worker = NULL;\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tmight_sleep();\n\n\tlocal_irq_disable();\n\tpool = get_work_pool(work);\n\tif (!pool) {\n\t\tlocal_irq_enable();\n\t\treturn false;\n\t}\n\n\tspin_lock(&pool->lock);\n\t/* see the comment in try_to_grab_pending() with the same code */\n\tpwq = get_work_pwq(work);\n\tif (pwq) {\n\t\tif (unlikely(pwq->pool != pool))\n\t\t\tgoto already_gone;\n\t} else {\n\t\tworker = find_worker_executing_work(pool, work);\n\t\tif (!worker)\n\t\t\tgoto already_gone;\n\t\tpwq = worker->current_pwq;\n\t}\n\n\tcheck_flush_dependency(pwq->wq, work);\n\n\tinsert_wq_barrier(pwq, barr, work, worker);\n\tspin_unlock_irq(&pool->lock);\n\n\t/*\n\t * Force a lock recursion deadlock when using flush_work() inside a\n\t * single-threaded or rescuer equipped workqueue.\n\t *\n\t * For single threaded workqueues the deadlock happens when the work\n\t * is after the work issuing the flush_work(). For rescuer equipped\n\t * workqueues the deadlock happens when the rescuer stalls, blocking\n\t * forward progress.\n\t */\n\tif (!from_cancel &&\n\t    (pwq->wq->saved_max_active == 1 || pwq->wq->rescuer)) {\n\t\tlock_map_acquire(&pwq->wq->lockdep_map);\n\t\tlock_map_release(&pwq->wq->lockdep_map);\n\t}\n\n\treturn true;\nalready_gone:\n\tspin_unlock_irq(&pool->lock);\n\treturn false;\n}"
  },
  {
    "function_name": "drain_workqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "2805-2846",
    "snippet": "void drain_workqueue(struct workqueue_struct *wq)\n{\n\tunsigned int flush_cnt = 0;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * __queue_work() needs to test whether there are drainers, is much\n\t * hotter than drain_workqueue() and already looks at @wq->flags.\n\t * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.\n\t */\n\tmutex_lock(&wq->mutex);\n\tif (!wq->nr_drainers++)\n\t\twq->flags |= __WQ_DRAINING;\n\tmutex_unlock(&wq->mutex);\nreflush:\n\tflush_workqueue(wq);\n\n\tmutex_lock(&wq->mutex);\n\n\tfor_each_pwq(pwq, wq) {\n\t\tbool drained;\n\n\t\tspin_lock_irq(&pwq->pool->lock);\n\t\tdrained = !pwq->nr_active && list_empty(&pwq->delayed_works);\n\t\tspin_unlock_irq(&pwq->pool->lock);\n\n\t\tif (drained)\n\t\t\tcontinue;\n\n\t\tif (++flush_cnt == 10 ||\n\t\t    (flush_cnt % 100 == 0 && flush_cnt <= 1000))\n\t\t\tpr_warn(\"workqueue %s: drain_workqueue() isn't complete after %u tries\\n\",\n\t\t\t\twq->name, flush_cnt);\n\n\t\tmutex_unlock(&wq->mutex);\n\t\tgoto reflush;\n\t}\n\n\tif (!--wq->nr_drainers)\n\t\twq->flags &= ~__WQ_DRAINING;\n\tmutex_unlock(&wq->mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq->mutex"
          ],
          "line": 2845
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"workqueue %s: drain_workqueue() isn't complete after %u tries\\n\"",
            "wq->name",
            "flush_cnt"
          ],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pwq->pool->lock"
          ],
          "line": 2829
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->delayed_works"
          ],
          "line": 2828
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pwq->pool->lock"
          ],
          "line": 2827
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 2824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 2822
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "wq"
          ],
          "line": 2820
        },
        "resolved": true,
        "details": {
          "function_name": "flush_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2643-2791",
          "snippet": "void flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (wq->first_flusher != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\twq->first_flusher = NULL;\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_online;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (wq->first_flusher != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\twq->first_flusher = NULL;\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid drain_workqueue(struct workqueue_struct *wq)\n{\n\tunsigned int flush_cnt = 0;\n\tstruct pool_workqueue *pwq;\n\n\t/*\n\t * __queue_work() needs to test whether there are drainers, is much\n\t * hotter than drain_workqueue() and already looks at @wq->flags.\n\t * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.\n\t */\n\tmutex_lock(&wq->mutex);\n\tif (!wq->nr_drainers++)\n\t\twq->flags |= __WQ_DRAINING;\n\tmutex_unlock(&wq->mutex);\nreflush:\n\tflush_workqueue(wq);\n\n\tmutex_lock(&wq->mutex);\n\n\tfor_each_pwq(pwq, wq) {\n\t\tbool drained;\n\n\t\tspin_lock_irq(&pwq->pool->lock);\n\t\tdrained = !pwq->nr_active && list_empty(&pwq->delayed_works);\n\t\tspin_unlock_irq(&pwq->pool->lock);\n\n\t\tif (drained)\n\t\t\tcontinue;\n\n\t\tif (++flush_cnt == 10 ||\n\t\t    (flush_cnt % 100 == 0 && flush_cnt <= 1000))\n\t\t\tpr_warn(\"workqueue %s: drain_workqueue() isn't complete after %u tries\\n\",\n\t\t\t\twq->name, flush_cnt);\n\n\t\tmutex_unlock(&wq->mutex);\n\t\tgoto reflush;\n\t}\n\n\tif (!--wq->nr_drainers)\n\t\twq->flags &= ~__WQ_DRAINING;\n\tmutex_unlock(&wq->mutex);\n}"
  },
  {
    "function_name": "flush_workqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "2643-2791",
    "snippet": "void flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (wq->first_flusher != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\twq->first_flusher = NULL;\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool wq_online;",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq->mutex"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_workqueue_prep_pwqs",
          "args": [
            "wq",
            "wq->flush_color",
            "-1"
          ],
          "line": 2779
        },
        "resolved": true,
        "details": {
          "function_name": "flush_workqueue_prep_pwqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2596-2634",
          "snippet": "static bool flush_workqueue_prep_pwqs(struct workqueue_struct *wq,\n\t\t\t\t      int flush_color, int work_color)\n{\n\tbool wait = false;\n\tstruct pool_workqueue *pwq;\n\n\tif (flush_color >= 0) {\n\t\tWARN_ON_ONCE(atomic_read(&wq->nr_pwqs_to_flush));\n\t\tatomic_set(&wq->nr_pwqs_to_flush, 1);\n\t}\n\n\tfor_each_pwq(pwq, wq) {\n\t\tstruct worker_pool *pool = pwq->pool;\n\n\t\tspin_lock_irq(&pool->lock);\n\n\t\tif (flush_color >= 0) {\n\t\t\tWARN_ON_ONCE(pwq->flush_color != -1);\n\n\t\t\tif (pwq->nr_in_flight[flush_color]) {\n\t\t\t\tpwq->flush_color = flush_color;\n\t\t\t\tatomic_inc(&wq->nr_pwqs_to_flush);\n\t\t\t\twait = true;\n\t\t\t}\n\t\t}\n\n\t\tif (work_color >= 0) {\n\t\t\tWARN_ON_ONCE(work_color != work_next_color(pwq->work_color));\n\t\t\tpwq->work_color = work_color;\n\t\t}\n\n\t\tspin_unlock_irq(&pool->lock);\n\t}\n\n\tif (flush_color >= 0 && atomic_dec_and_test(&wq->nr_pwqs_to_flush))\n\t\tcomplete(&wq->first_flusher->done);\n\n\treturn wait;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic bool flush_workqueue_prep_pwqs(struct workqueue_struct *wq,\n\t\t\t\t      int flush_color, int work_color)\n{\n\tbool wait = false;\n\tstruct pool_workqueue *pwq;\n\n\tif (flush_color >= 0) {\n\t\tWARN_ON_ONCE(atomic_read(&wq->nr_pwqs_to_flush));\n\t\tatomic_set(&wq->nr_pwqs_to_flush, 1);\n\t}\n\n\tfor_each_pwq(pwq, wq) {\n\t\tstruct worker_pool *pool = pwq->pool;\n\n\t\tspin_lock_irq(&pool->lock);\n\n\t\tif (flush_color >= 0) {\n\t\t\tWARN_ON_ONCE(pwq->flush_color != -1);\n\n\t\t\tif (pwq->nr_in_flight[flush_color]) {\n\t\t\t\tpwq->flush_color = flush_color;\n\t\t\t\tatomic_inc(&wq->nr_pwqs_to_flush);\n\t\t\t\twait = true;\n\t\t\t}\n\t\t}\n\n\t\tif (work_color >= 0) {\n\t\t\tWARN_ON_ONCE(work_color != work_next_color(pwq->work_color));\n\t\t\tpwq->work_color = work_color;\n\t\t}\n\n\t\tspin_unlock_irq(&pool->lock);\n\t}\n\n\tif (flush_color >= 0 && atomic_dec_and_test(&wq->nr_pwqs_to_flush))\n\t\tcomplete(&wq->first_flusher->done);\n\n\treturn wait;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&next->list"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "wq->flush_color != next->flush_color"
          ],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "wq->flush_color == wq->work_color"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "wq->flush_color != wq->work_color"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wq->flusher_queue"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_tail_init",
          "args": [
            "&wq->flusher_overflow",
            "&wq->flusher_queue"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_next_color",
          "args": [
            "wq->work_color"
          ],
          "line": 2757
        },
        "resolved": true,
        "details": {
          "function_name": "work_next_color",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "588-591",
          "snippet": "static int work_next_color(int color)\n{\n\treturn (color + 1) % WORK_NR_COLORS;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int work_next_color(int color)\n{\n\treturn (color + 1) % WORK_NR_COLORS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp",
            "&wq->flusher_overflow",
            "list"
          ],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color)"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&next->done"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1205-1216",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&next->list"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "next",
            "tmp",
            "&wq->flusher_queue",
            "list"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "wq->flush_color != this_flusher.flush_color"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&this_flusher.list)"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq->mutex"
          ],
          "line": 2718
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&this_flusher.done"
          ],
          "line": 2707
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_flush_dependency",
          "args": [
            "wq",
            "NULL"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "check_flush_dependency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2468-2487",
          "snippet": "static void check_flush_dependency(struct workqueue_struct *target_wq,\n\t\t\t\t   struct work_struct *target_work)\n{\n\twork_func_t target_func = target_work ? target_work->func : NULL;\n\tstruct worker *worker;\n\n\tif (target_wq->flags & WQ_MEM_RECLAIM)\n\t\treturn;\n\n\tworker = current_wq_worker();\n\n\tWARN_ONCE(current->flags & PF_MEMALLOC,\n\t\t  \"workqueue: PF_MEMALLOC task %d(%s) is flushing !WQ_MEM_RECLAIM %s:%pf\",\n\t\t  current->pid, current->comm, target_wq->name, target_func);\n\tWARN_ONCE(worker && ((worker->current_pwq->wq->flags &\n\t\t\t      (WQ_MEM_RECLAIM | __WQ_LEGACY)) == WQ_MEM_RECLAIM),\n\t\t  \"workqueue: WQ_MEM_RECLAIM %s:%pf is flushing !WQ_MEM_RECLAIM %s:%pf\",\n\t\t  worker->current_pwq->wq->name, worker->current_func,\n\t\t  target_wq->name, target_func);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void check_flush_dependency(struct workqueue_struct *target_wq,\n\t\t\t\t   struct work_struct *target_work)\n{\n\twork_func_t target_func = target_work ? target_work->func : NULL;\n\tstruct worker *worker;\n\n\tif (target_wq->flags & WQ_MEM_RECLAIM)\n\t\treturn;\n\n\tworker = current_wq_worker();\n\n\tWARN_ONCE(current->flags & PF_MEMALLOC,\n\t\t  \"workqueue: PF_MEMALLOC task %d(%s) is flushing !WQ_MEM_RECLAIM %s:%pf\",\n\t\t  current->pid, current->comm, target_wq->name, target_func);\n\tWARN_ONCE(worker && ((worker->current_pwq->wq->flags &\n\t\t\t      (WQ_MEM_RECLAIM | __WQ_LEGACY)) == WQ_MEM_RECLAIM),\n\t\t  \"workqueue: WQ_MEM_RECLAIM %s:%pf is flushing !WQ_MEM_RECLAIM %s:%pf\",\n\t\t  worker->current_pwq->wq->name, worker->current_func,\n\t\t  target_wq->name, target_func);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&this_flusher.list",
            "&wq->flusher_overflow"
          ],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&this_flusher.list",
            "&wq->flusher_queue"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "wq->flush_color == this_flusher.flush_color"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "wq->flush_color != this_flusher.flush_color"
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&wq->flusher_overflow)"
          ],
          "line": 2671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_release",
          "args": [
            "&wq->lockdep_map"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_acquire",
          "args": [
            "&wq->lockdep_map"
          ],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!wq_online"
          ],
          "line": 2652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPLETION_INITIALIZER_ONSTACK_MAP",
          "args": [
            "this_flusher.done",
            "wq->lockdep_map"
          ],
          "line": 2648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD_INIT",
          "args": [
            "this_flusher.list"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (wq->first_flusher != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\twq->first_flusher = NULL;\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}"
  },
  {
    "function_name": "flush_workqueue_prep_pwqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "2596-2634",
    "snippet": "static bool flush_workqueue_prep_pwqs(struct workqueue_struct *wq,\n\t\t\t\t      int flush_color, int work_color)\n{\n\tbool wait = false;\n\tstruct pool_workqueue *pwq;\n\n\tif (flush_color >= 0) {\n\t\tWARN_ON_ONCE(atomic_read(&wq->nr_pwqs_to_flush));\n\t\tatomic_set(&wq->nr_pwqs_to_flush, 1);\n\t}\n\n\tfor_each_pwq(pwq, wq) {\n\t\tstruct worker_pool *pool = pwq->pool;\n\n\t\tspin_lock_irq(&pool->lock);\n\n\t\tif (flush_color >= 0) {\n\t\t\tWARN_ON_ONCE(pwq->flush_color != -1);\n\n\t\t\tif (pwq->nr_in_flight[flush_color]) {\n\t\t\t\tpwq->flush_color = flush_color;\n\t\t\t\tatomic_inc(&wq->nr_pwqs_to_flush);\n\t\t\t\twait = true;\n\t\t\t}\n\t\t}\n\n\t\tif (work_color >= 0) {\n\t\t\tWARN_ON_ONCE(work_color != work_next_color(pwq->work_color));\n\t\t\tpwq->work_color = work_color;\n\t\t}\n\n\t\tspin_unlock_irq(&pool->lock);\n\t}\n\n\tif (flush_color >= 0 && atomic_dec_and_test(&wq->nr_pwqs_to_flush))\n\t\tcomplete(&wq->first_flusher->done);\n\n\treturn wait;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&wq->first_flusher->done"
          ],
          "line": 2631
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1205-1216",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&wq->nr_pwqs_to_flush"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "work_color != work_next_color(pwq->work_color)"
          ],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_next_color",
          "args": [
            "pwq->work_color"
          ],
          "line": 2623
        },
        "resolved": true,
        "details": {
          "function_name": "work_next_color",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "588-591",
          "snippet": "static int work_next_color(int color)\n{\n\treturn (color + 1) % WORK_NR_COLORS;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int work_next_color(int color)\n{\n\treturn (color + 1) % WORK_NR_COLORS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&wq->nr_pwqs_to_flush"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pwq->flush_color != -1"
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 2610
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_pwq",
          "args": [
            "pwq",
            "wq"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&wq->nr_pwqs_to_flush",
            "1"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "atomic_read(&wq->nr_pwqs_to_flush)"
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&wq->nr_pwqs_to_flush"
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic bool flush_workqueue_prep_pwqs(struct workqueue_struct *wq,\n\t\t\t\t      int flush_color, int work_color)\n{\n\tbool wait = false;\n\tstruct pool_workqueue *pwq;\n\n\tif (flush_color >= 0) {\n\t\tWARN_ON_ONCE(atomic_read(&wq->nr_pwqs_to_flush));\n\t\tatomic_set(&wq->nr_pwqs_to_flush, 1);\n\t}\n\n\tfor_each_pwq(pwq, wq) {\n\t\tstruct worker_pool *pool = pwq->pool;\n\n\t\tspin_lock_irq(&pool->lock);\n\n\t\tif (flush_color >= 0) {\n\t\t\tWARN_ON_ONCE(pwq->flush_color != -1);\n\n\t\t\tif (pwq->nr_in_flight[flush_color]) {\n\t\t\t\tpwq->flush_color = flush_color;\n\t\t\t\tatomic_inc(&wq->nr_pwqs_to_flush);\n\t\t\t\twait = true;\n\t\t\t}\n\t\t}\n\n\t\tif (work_color >= 0) {\n\t\t\tWARN_ON_ONCE(work_color != work_next_color(pwq->work_color));\n\t\t\tpwq->work_color = work_color;\n\t\t}\n\n\t\tspin_unlock_irq(&pool->lock);\n\t}\n\n\tif (flush_color >= 0 && atomic_dec_and_test(&wq->nr_pwqs_to_flush))\n\t\tcomplete(&wq->first_flusher->done);\n\n\treturn wait;\n}"
  },
  {
    "function_name": "insert_wq_barrier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "2525-2563",
    "snippet": "static void insert_wq_barrier(struct pool_workqueue *pwq,\n\t\t\t      struct wq_barrier *barr,\n\t\t\t      struct work_struct *target, struct worker *worker)\n{\n\tstruct list_head *head;\n\tunsigned int linked = 0;\n\n\t/*\n\t * debugobject calls are safe here even with pool->lock locked\n\t * as we know for sure that this will not trigger any of the\n\t * checks and call back into the fixup functions where we\n\t * might deadlock.\n\t */\n\tINIT_WORK_ONSTACK(&barr->work, wq_barrier_func);\n\t__set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(&barr->work));\n\n\tinit_completion_map(&barr->done, &target->lockdep_map);\n\n\tbarr->task = current;\n\n\t/*\n\t * If @target is currently being executed, schedule the\n\t * barrier to the worker; otherwise, put it after @target.\n\t */\n\tif (worker)\n\t\thead = worker->scheduled.next;\n\telse {\n\t\tunsigned long *bits = work_data_bits(target);\n\n\t\thead = target->entry.next;\n\t\t/* there can already be other linked works, inherit and set */\n\t\tlinked = *bits & WORK_STRUCT_LINKED;\n\t\t__set_bit(WORK_STRUCT_LINKED_BIT, bits);\n\t}\n\n\tdebug_work_activate(&barr->work);\n\tinsert_work(pwq, &barr->work, head,\n\t\t    work_color_to_flags(WORK_NO_COLOR) | linked);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_work",
          "args": [
            "pwq",
            "&barr->work",
            "head",
            "work_color_to_flags(WORK_NO_COLOR) | linked"
          ],
          "line": 2561
        },
        "resolved": true,
        "details": {
          "function_name": "insert_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1293-1312",
          "snippet": "static void insert_work(struct pool_workqueue *pwq, struct work_struct *work,\n\t\t\tstruct list_head *head, unsigned int extra_flags)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\n\t/* we own @work, set data and link */\n\tset_work_pwq(work, pwq, extra_flags);\n\tlist_add_tail(&work->entry, head);\n\tget_pwq(pwq);\n\n\t/*\n\t * Ensure either wq_worker_sleeping() sees the above\n\t * list_add_tail() or we see zero nr_running to avoid workers lying\n\t * around lazily while there are works to be processed.\n\t */\n\tsmp_mb();\n\n\tif (__need_more_worker(pool))\n\t\twake_up_worker(pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void insert_work(struct pool_workqueue *pwq, struct work_struct *work,\n\t\t\tstruct list_head *head, unsigned int extra_flags)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\n\t/* we own @work, set data and link */\n\tset_work_pwq(work, pwq, extra_flags);\n\tlist_add_tail(&work->entry, head);\n\tget_pwq(pwq);\n\n\t/*\n\t * Ensure either wq_worker_sleeping() sees the above\n\t * list_add_tail() or we see zero nr_running to avoid workers lying\n\t * around lazily while there are works to be processed.\n\t */\n\tsmp_mb();\n\n\tif (__need_more_worker(pool))\n\t\twake_up_worker(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "work_color_to_flags",
          "args": [
            "WORK_NO_COLOR"
          ],
          "line": 2562
        },
        "resolved": true,
        "details": {
          "function_name": "work_color_to_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "577-580",
          "snippet": "static unsigned int work_color_to_flags(int color)\n{\n\treturn color << WORK_STRUCT_COLOR_SHIFT;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic unsigned int work_color_to_flags(int color)\n{\n\treturn color << WORK_STRUCT_COLOR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_work_activate",
          "args": [
            "&barr->work"
          ],
          "line": 2560
        },
        "resolved": true,
        "details": {
          "function_name": "debug_work_activate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "522-522",
          "snippet": "static inline void debug_work_activate(struct work_struct *work) { }",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void debug_work_activate(struct work_struct *work) { }"
        }
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "WORK_STRUCT_LINKED_BIT",
            "bits"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "target"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion_map",
          "args": [
            "&barr->done",
            "&target->lockdep_map"
          ],
          "line": 2541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "WORK_STRUCT_PENDING_BIT",
            "work_data_bits(&barr->work)"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "&barr->work"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK_ONSTACK",
          "args": [
            "&barr->work",
            "wq_barrier_func"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void insert_wq_barrier(struct pool_workqueue *pwq,\n\t\t\t      struct wq_barrier *barr,\n\t\t\t      struct work_struct *target, struct worker *worker)\n{\n\tstruct list_head *head;\n\tunsigned int linked = 0;\n\n\t/*\n\t * debugobject calls are safe here even with pool->lock locked\n\t * as we know for sure that this will not trigger any of the\n\t * checks and call back into the fixup functions where we\n\t * might deadlock.\n\t */\n\tINIT_WORK_ONSTACK(&barr->work, wq_barrier_func);\n\t__set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(&barr->work));\n\n\tinit_completion_map(&barr->done, &target->lockdep_map);\n\n\tbarr->task = current;\n\n\t/*\n\t * If @target is currently being executed, schedule the\n\t * barrier to the worker; otherwise, put it after @target.\n\t */\n\tif (worker)\n\t\thead = worker->scheduled.next;\n\telse {\n\t\tunsigned long *bits = work_data_bits(target);\n\n\t\thead = target->entry.next;\n\t\t/* there can already be other linked works, inherit and set */\n\t\tlinked = *bits & WORK_STRUCT_LINKED;\n\t\t__set_bit(WORK_STRUCT_LINKED_BIT, bits);\n\t}\n\n\tdebug_work_activate(&barr->work);\n\tinsert_work(pwq, &barr->work, head,\n\t\t    work_color_to_flags(WORK_NO_COLOR) | linked);\n}"
  },
  {
    "function_name": "wq_barrier_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "2495-2499",
    "snippet": "static void wq_barrier_func(struct work_struct *work)\n{\n\tstruct wq_barrier *barr = container_of(work, struct wq_barrier, work);\n\tcomplete(&barr->done);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&barr->done"
          ],
          "line": 2498
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1205-1216",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structwq_barrier",
            "work"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void wq_barrier_func(struct work_struct *work)\n{\n\tstruct wq_barrier *barr = container_of(work, struct wq_barrier, work);\n\tcomplete(&barr->done);\n}"
  },
  {
    "function_name": "check_flush_dependency",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "2468-2487",
    "snippet": "static void check_flush_dependency(struct workqueue_struct *target_wq,\n\t\t\t\t   struct work_struct *target_work)\n{\n\twork_func_t target_func = target_work ? target_work->func : NULL;\n\tstruct worker *worker;\n\n\tif (target_wq->flags & WQ_MEM_RECLAIM)\n\t\treturn;\n\n\tworker = current_wq_worker();\n\n\tWARN_ONCE(current->flags & PF_MEMALLOC,\n\t\t  \"workqueue: PF_MEMALLOC task %d(%s) is flushing !WQ_MEM_RECLAIM %s:%pf\",\n\t\t  current->pid, current->comm, target_wq->name, target_func);\n\tWARN_ONCE(worker && ((worker->current_pwq->wq->flags &\n\t\t\t      (WQ_MEM_RECLAIM | __WQ_LEGACY)) == WQ_MEM_RECLAIM),\n\t\t  \"workqueue: WQ_MEM_RECLAIM %s:%pf is flushing !WQ_MEM_RECLAIM %s:%pf\",\n\t\t  worker->current_pwq->wq->name, worker->current_func,\n\t\t  target_wq->name, target_func);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "worker && ((worker->current_pwq->wq->flags &\n\t\t\t      (WQ_MEM_RECLAIM | __WQ_LEGACY)) == WQ_MEM_RECLAIM)",
            "\"workqueue: WQ_MEM_RECLAIM %s:%pf is flushing !WQ_MEM_RECLAIM %s:%pf\"",
            "worker->current_pwq->wq->name",
            "worker->current_func",
            "target_wq->name",
            "target_func"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "current->flags & PF_MEMALLOC",
            "\"workqueue: PF_MEMALLOC task %d(%s) is flushing !WQ_MEM_RECLAIM %s:%pf\"",
            "current->pid",
            "current->comm",
            "target_wq->name",
            "target_func"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_wq_worker",
          "args": [],
          "line": 2477
        },
        "resolved": true,
        "details": {
          "function_name": "current_wq_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue_internal.h",
          "lines": "61-66",
          "snippet": "static inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/preempt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/preempt.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n\nstatic inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void check_flush_dependency(struct workqueue_struct *target_wq,\n\t\t\t\t   struct work_struct *target_work)\n{\n\twork_func_t target_func = target_work ? target_work->func : NULL;\n\tstruct worker *worker;\n\n\tif (target_wq->flags & WQ_MEM_RECLAIM)\n\t\treturn;\n\n\tworker = current_wq_worker();\n\n\tWARN_ONCE(current->flags & PF_MEMALLOC,\n\t\t  \"workqueue: PF_MEMALLOC task %d(%s) is flushing !WQ_MEM_RECLAIM %s:%pf\",\n\t\t  current->pid, current->comm, target_wq->name, target_func);\n\tWARN_ONCE(worker && ((worker->current_pwq->wq->flags &\n\t\t\t      (WQ_MEM_RECLAIM | __WQ_LEGACY)) == WQ_MEM_RECLAIM),\n\t\t  \"workqueue: WQ_MEM_RECLAIM %s:%pf is flushing !WQ_MEM_RECLAIM %s:%pf\",\n\t\t  worker->current_pwq->wq->name, worker->current_func,\n\t\t  target_wq->name, target_func);\n}"
  },
  {
    "function_name": "rescuer_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "2342-2455",
    "snippet": "static int rescuer_thread(void *__rescuer)\n{\n\tstruct worker *rescuer = __rescuer;\n\tstruct workqueue_struct *wq = rescuer->rescue_wq;\n\tstruct list_head *scheduled = &rescuer->scheduled;\n\tbool should_stop;\n\n\tset_user_nice(current, RESCUER_NICE_LEVEL);\n\n\t/*\n\t * Mark rescuer as worker too.  As WORKER_PREP is never cleared, it\n\t * doesn't participate in concurrency management.\n\t */\n\tset_pf_worker(true);\nrepeat:\n\tset_current_state(TASK_IDLE);\n\n\t/*\n\t * By the time the rescuer is requested to stop, the workqueue\n\t * shouldn't have any work pending, but @wq->maydays may still have\n\t * pwq(s) queued.  This can happen by non-rescuer workers consuming\n\t * all the work items before the rescuer got to them.  Go through\n\t * @wq->maydays processing before acting on should_stop so that the\n\t * list is always empty on exit.\n\t */\n\tshould_stop = kthread_should_stop();\n\n\t/* see whether any pwq is asking for help */\n\tspin_lock_irq(&wq_mayday_lock);\n\n\twhile (!list_empty(&wq->maydays)) {\n\t\tstruct pool_workqueue *pwq = list_first_entry(&wq->maydays,\n\t\t\t\t\tstruct pool_workqueue, mayday_node);\n\t\tstruct worker_pool *pool = pwq->pool;\n\t\tstruct work_struct *work, *n;\n\t\tbool first = true;\n\n\t\t__set_current_state(TASK_RUNNING);\n\t\tlist_del_init(&pwq->mayday_node);\n\n\t\tspin_unlock_irq(&wq_mayday_lock);\n\n\t\tworker_attach_to_pool(rescuer, pool);\n\n\t\tspin_lock_irq(&pool->lock);\n\n\t\t/*\n\t\t * Slurp in all works issued via this workqueue and\n\t\t * process'em.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(scheduled));\n\t\tlist_for_each_entry_safe(work, n, &pool->worklist, entry) {\n\t\t\tif (get_work_pwq(work) == pwq) {\n\t\t\t\tif (first)\n\t\t\t\t\tpool->watchdog_ts = jiffies;\n\t\t\t\tmove_linked_works(work, scheduled, &n);\n\t\t\t}\n\t\t\tfirst = false;\n\t\t}\n\n\t\tif (!list_empty(scheduled)) {\n\t\t\tprocess_scheduled_works(rescuer);\n\n\t\t\t/*\n\t\t\t * The above execution of rescued work items could\n\t\t\t * have created more to rescue through\n\t\t\t * pwq_activate_first_delayed() or chained\n\t\t\t * queueing.  Let's put @pwq back on mayday list so\n\t\t\t * that such back-to-back work items, which may be\n\t\t\t * being used to relieve memory pressure, don't\n\t\t\t * incur MAYDAY_INTERVAL delay inbetween.\n\t\t\t */\n\t\t\tif (need_to_create_worker(pool)) {\n\t\t\t\tspin_lock(&wq_mayday_lock);\n\t\t\t\tget_pwq(pwq);\n\t\t\t\tlist_move_tail(&pwq->mayday_node, &wq->maydays);\n\t\t\t\tspin_unlock(&wq_mayday_lock);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Put the reference grabbed by send_mayday().  @pool won't\n\t\t * go away while we're still attached to it.\n\t\t */\n\t\tput_pwq(pwq);\n\n\t\t/*\n\t\t * Leave this pool.  If need_more_worker() is %true, notify a\n\t\t * regular worker; otherwise, we end up with 0 concurrency\n\t\t * and stalling the execution.\n\t\t */\n\t\tif (need_more_worker(pool))\n\t\t\twake_up_worker(pool);\n\n\t\tspin_unlock_irq(&pool->lock);\n\n\t\tworker_detach_from_pool(rescuer);\n\n\t\tspin_lock_irq(&wq_mayday_lock);\n\t}\n\n\tspin_unlock_irq(&wq_mayday_lock);\n\n\tif (should_stop) {\n\t\t__set_current_state(TASK_RUNNING);\n\t\tset_pf_worker(false);\n\t\treturn 0;\n\t}\n\n\t/* rescuers should never participate in concurrency management */\n\tWARN_ON_ONCE(!(rescuer->flags & WORKER_NOT_RUNNING));\n\tschedule();\n\tgoto repeat;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(wq_mayday_lock);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(rescuer->flags & WORKER_NOT_RUNNING)"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pf_worker",
          "args": [
            "false"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "set_pf_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2216-2224",
          "snippet": "static void set_pf_worker(bool val)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (val)\n\t\tcurrent->flags |= PF_WQ_WORKER;\n\telse\n\t\tcurrent->flags &= ~PF_WQ_WORKER;\n\tmutex_unlock(&wq_pool_attach_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_attach_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\n\nstatic void set_pf_worker(bool val)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (val)\n\t\tcurrent->flags |= PF_WQ_WORKER;\n\telse\n\t\tcurrent->flags &= ~PF_WQ_WORKER;\n\tmutex_unlock(&wq_pool_attach_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&wq_mayday_lock"
          ],
          "line": 2443
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&wq_mayday_lock"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "worker_detach_from_pool",
          "args": [
            "rescuer"
          ],
          "line": 2438
        },
        "resolved": true,
        "details": {
          "function_name": "worker_detach_from_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1757-1776",
          "snippet": "static void worker_detach_from_pool(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tstruct completion *detach_completion = NULL;\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\tlist_del(&worker->node);\n\tworker->pool = NULL;\n\n\tif (list_empty(&pool->workers))\n\t\tdetach_completion = pool->detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\t/* clear leftover flags without pool->lock after it is detached */\n\tworker->flags &= ~(WORKER_UNBOUND | WORKER_REBOUND);\n\n\tif (detach_completion)\n\t\tcomplete(detach_completion);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void worker_detach_from_pool(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tstruct completion *detach_completion = NULL;\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\tlist_del(&worker->node);\n\tworker->pool = NULL;\n\n\tif (list_empty(&pool->workers))\n\t\tdetach_completion = pool->detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\t/* clear leftover flags without pool->lock after it is detached */\n\tworker->flags &= ~(WORKER_UNBOUND | WORKER_REBOUND);\n\n\tif (detach_completion)\n\t\tcomplete(detach_completion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_worker",
          "args": [
            "pool"
          ],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_more_worker",
          "args": [
            "pool"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "need_more_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "777-780",
          "snippet": "static bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pwq",
          "args": [
            "pwq"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "put_pwq_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1099-1110",
          "snippet": "static void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are sched-RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\tspin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\tspin_unlock_irq(&pwq->pool->lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are sched-RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\tspin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\tspin_unlock_irq(&pwq->pool->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&wq_mayday_lock"
          ],
          "line": 2418
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&pwq->mayday_node",
            "&wq->maydays"
          ],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pwq",
          "args": [
            "pwq"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "get_pwq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1061-1066",
          "snippet": "static void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&wq_mayday_lock"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_to_create_worker",
          "args": [
            "pool"
          ],
          "line": 2414
        },
        "resolved": true,
        "details": {
          "function_name": "need_to_create_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "796-799",
          "snippet": "static bool need_to_create_worker(struct worker_pool *pool)\n{\n\treturn need_more_worker(pool) && !may_start_working(pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool need_to_create_worker(struct worker_pool *pool)\n{\n\treturn need_more_worker(pool) && !may_start_working(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_scheduled_works",
          "args": [
            "rescuer"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "process_scheduled_works",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2207-2214",
          "snippet": "static void process_scheduled_works(struct worker *worker)\n{\n\twhile (!list_empty(&worker->scheduled)) {\n\t\tstruct work_struct *work = list_first_entry(&worker->scheduled,\n\t\t\t\t\t\tstruct work_struct, entry);\n\t\tprocess_one_work(worker, work);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void process_scheduled_works(struct worker *worker)\n{\n\twhile (!list_empty(&worker->scheduled)) {\n\t\tstruct work_struct *work = list_first_entry(&worker->scheduled,\n\t\t\t\t\t\tstruct work_struct, entry);\n\t\tprocess_one_work(worker, work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "scheduled"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_linked_works",
          "args": [
            "work",
            "scheduled",
            "&n"
          ],
          "line": 2397
        },
        "resolved": true,
        "details": {
          "function_name": "move_linked_works",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1030-1052",
          "snippet": "static void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_work_pwq",
          "args": [
            "work"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pwq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "682-690",
          "snippet": "static struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "work",
            "n",
            "&pool->worklist",
            "entry"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(scheduled)"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "worker_attach_to_pool",
          "args": [
            "rescuer",
            "pool"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "worker_attach_to_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1724-1747",
          "snippet": "static void worker_attach_to_pool(struct worker *worker,\n\t\t\t\t   struct worker_pool *pool)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\t/*\n\t * set_cpus_allowed_ptr() will fail if the cpumask doesn't have any\n\t * online CPUs.  It'll be re-applied when any of the CPUs come up.\n\t */\n\tset_cpus_allowed_ptr(worker->task, pool->attrs->cpumask);\n\n\t/*\n\t * The wq_pool_attach_mutex ensures %POOL_DISASSOCIATED remains\n\t * stable across this function.  See the comments above the flag\n\t * definition for details.\n\t */\n\tif (pool->flags & POOL_DISASSOCIATED)\n\t\tworker->flags |= WORKER_UNBOUND;\n\n\tlist_add_tail(&worker->node, &pool->workers);\n\tworker->pool = pool;\n\n\tmutex_unlock(&wq_pool_attach_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void worker_attach_to_pool(struct worker *worker,\n\t\t\t\t   struct worker_pool *pool)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\t/*\n\t * set_cpus_allowed_ptr() will fail if the cpumask doesn't have any\n\t * online CPUs.  It'll be re-applied when any of the CPUs come up.\n\t */\n\tset_cpus_allowed_ptr(worker->task, pool->attrs->cpumask);\n\n\t/*\n\t * The wq_pool_attach_mutex ensures %POOL_DISASSOCIATED remains\n\t * stable across this function.  See the comments above the flag\n\t * definition for details.\n\t */\n\tif (pool->flags & POOL_DISASSOCIATED)\n\t\tworker->flags |= WORKER_UNBOUND;\n\n\tlist_add_tail(&worker->node, &pool->workers);\n\tworker->pool = pool;\n\n\tmutex_unlock(&wq_pool_attach_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&pwq->mayday_node"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&wq->maydays",
            "structpool_workqueue",
            "mayday_node"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 2367
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "98-101",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_IDLE"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "RESCUER_NICE_LEVEL"
          ],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3865-3917",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_SPINLOCK(wq_mayday_lock);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int rescuer_thread(void *__rescuer)\n{\n\tstruct worker *rescuer = __rescuer;\n\tstruct workqueue_struct *wq = rescuer->rescue_wq;\n\tstruct list_head *scheduled = &rescuer->scheduled;\n\tbool should_stop;\n\n\tset_user_nice(current, RESCUER_NICE_LEVEL);\n\n\t/*\n\t * Mark rescuer as worker too.  As WORKER_PREP is never cleared, it\n\t * doesn't participate in concurrency management.\n\t */\n\tset_pf_worker(true);\nrepeat:\n\tset_current_state(TASK_IDLE);\n\n\t/*\n\t * By the time the rescuer is requested to stop, the workqueue\n\t * shouldn't have any work pending, but @wq->maydays may still have\n\t * pwq(s) queued.  This can happen by non-rescuer workers consuming\n\t * all the work items before the rescuer got to them.  Go through\n\t * @wq->maydays processing before acting on should_stop so that the\n\t * list is always empty on exit.\n\t */\n\tshould_stop = kthread_should_stop();\n\n\t/* see whether any pwq is asking for help */\n\tspin_lock_irq(&wq_mayday_lock);\n\n\twhile (!list_empty(&wq->maydays)) {\n\t\tstruct pool_workqueue *pwq = list_first_entry(&wq->maydays,\n\t\t\t\t\tstruct pool_workqueue, mayday_node);\n\t\tstruct worker_pool *pool = pwq->pool;\n\t\tstruct work_struct *work, *n;\n\t\tbool first = true;\n\n\t\t__set_current_state(TASK_RUNNING);\n\t\tlist_del_init(&pwq->mayday_node);\n\n\t\tspin_unlock_irq(&wq_mayday_lock);\n\n\t\tworker_attach_to_pool(rescuer, pool);\n\n\t\tspin_lock_irq(&pool->lock);\n\n\t\t/*\n\t\t * Slurp in all works issued via this workqueue and\n\t\t * process'em.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(scheduled));\n\t\tlist_for_each_entry_safe(work, n, &pool->worklist, entry) {\n\t\t\tif (get_work_pwq(work) == pwq) {\n\t\t\t\tif (first)\n\t\t\t\t\tpool->watchdog_ts = jiffies;\n\t\t\t\tmove_linked_works(work, scheduled, &n);\n\t\t\t}\n\t\t\tfirst = false;\n\t\t}\n\n\t\tif (!list_empty(scheduled)) {\n\t\t\tprocess_scheduled_works(rescuer);\n\n\t\t\t/*\n\t\t\t * The above execution of rescued work items could\n\t\t\t * have created more to rescue through\n\t\t\t * pwq_activate_first_delayed() or chained\n\t\t\t * queueing.  Let's put @pwq back on mayday list so\n\t\t\t * that such back-to-back work items, which may be\n\t\t\t * being used to relieve memory pressure, don't\n\t\t\t * incur MAYDAY_INTERVAL delay inbetween.\n\t\t\t */\n\t\t\tif (need_to_create_worker(pool)) {\n\t\t\t\tspin_lock(&wq_mayday_lock);\n\t\t\t\tget_pwq(pwq);\n\t\t\t\tlist_move_tail(&pwq->mayday_node, &wq->maydays);\n\t\t\t\tspin_unlock(&wq_mayday_lock);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Put the reference grabbed by send_mayday().  @pool won't\n\t\t * go away while we're still attached to it.\n\t\t */\n\t\tput_pwq(pwq);\n\n\t\t/*\n\t\t * Leave this pool.  If need_more_worker() is %true, notify a\n\t\t * regular worker; otherwise, we end up with 0 concurrency\n\t\t * and stalling the execution.\n\t\t */\n\t\tif (need_more_worker(pool))\n\t\t\twake_up_worker(pool);\n\n\t\tspin_unlock_irq(&pool->lock);\n\n\t\tworker_detach_from_pool(rescuer);\n\n\t\tspin_lock_irq(&wq_mayday_lock);\n\t}\n\n\tspin_unlock_irq(&wq_mayday_lock);\n\n\tif (should_stop) {\n\t\t__set_current_state(TASK_RUNNING);\n\t\tset_pf_worker(false);\n\t\treturn 0;\n\t}\n\n\t/* rescuers should never participate in concurrency management */\n\tWARN_ON_ONCE(!(rescuer->flags & WORKER_NOT_RUNNING));\n\tschedule();\n\tgoto repeat;\n}"
  },
  {
    "function_name": "worker_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "2238-2319",
    "snippet": "static int worker_thread(void *__worker)\n{\n\tstruct worker *worker = __worker;\n\tstruct worker_pool *pool = worker->pool;\n\n\t/* tell the scheduler that this is a workqueue worker */\n\tset_pf_worker(true);\nwoke_up:\n\tspin_lock_irq(&pool->lock);\n\n\t/* am I supposed to die? */\n\tif (unlikely(worker->flags & WORKER_DIE)) {\n\t\tspin_unlock_irq(&pool->lock);\n\t\tWARN_ON_ONCE(!list_empty(&worker->entry));\n\t\tset_pf_worker(false);\n\n\t\tset_task_comm(worker->task, \"kworker/dying\");\n\t\tida_simple_remove(&pool->worker_ida, worker->id);\n\t\tworker_detach_from_pool(worker);\n\t\tkfree(worker);\n\t\treturn 0;\n\t}\n\n\tworker_leave_idle(worker);\nrecheck:\n\t/* no more worker necessary? */\n\tif (!need_more_worker(pool))\n\t\tgoto sleep;\n\n\t/* do we need to manage? */\n\tif (unlikely(!may_start_working(pool)) && manage_workers(worker))\n\t\tgoto recheck;\n\n\t/*\n\t * ->scheduled list can only be filled while a worker is\n\t * preparing to process a work or actually processing it.\n\t * Make sure nobody diddled with it while I was sleeping.\n\t */\n\tWARN_ON_ONCE(!list_empty(&worker->scheduled));\n\n\t/*\n\t * Finish PREP stage.  We're guaranteed to have at least one idle\n\t * worker or that someone else has already assumed the manager\n\t * role.  This is where @worker starts participating in concurrency\n\t * management if applicable and concurrency management is restored\n\t * after being rebound.  See rebind_workers() for details.\n\t */\n\tworker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);\n\n\tdo {\n\t\tstruct work_struct *work =\n\t\t\tlist_first_entry(&pool->worklist,\n\t\t\t\t\t struct work_struct, entry);\n\n\t\tpool->watchdog_ts = jiffies;\n\n\t\tif (likely(!(*work_data_bits(work) & WORK_STRUCT_LINKED))) {\n\t\t\t/* optimization path, not strictly necessary */\n\t\t\tprocess_one_work(worker, work);\n\t\t\tif (unlikely(!list_empty(&worker->scheduled)))\n\t\t\t\tprocess_scheduled_works(worker);\n\t\t} else {\n\t\t\tmove_linked_works(work, &worker->scheduled, NULL);\n\t\t\tprocess_scheduled_works(worker);\n\t\t}\n\t} while (keep_working(pool));\n\n\tworker_set_flags(worker, WORKER_PREP);\nsleep:\n\t/*\n\t * pool->lock is held and there's no work to process and no need to\n\t * manage, sleep.  Workers are woken up only while holding\n\t * pool->lock or from local cpu, so setting the current state\n\t * before releasing pool->lock is enough to prevent losing any\n\t * event.\n\t */\n\tworker_enter_idle(worker);\n\t__set_current_state(TASK_IDLE);\n\tspin_unlock_irq(&pool->lock);\n\tschedule();\n\tgoto woke_up;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static int worker_thread(void *__worker);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2317
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_IDLE"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "worker_enter_idle",
          "args": [
            "worker"
          ],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "worker_enter_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1649-1678",
          "snippet": "static void worker_enter_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(worker->flags & WORKER_IDLE) ||\n\t    WARN_ON_ONCE(!list_empty(&worker->entry) &&\n\t\t\t (worker->hentry.next || worker->hentry.pprev)))\n\t\treturn;\n\n\t/* can't use worker_set_flags(), also called from create_worker() */\n\tworker->flags |= WORKER_IDLE;\n\tpool->nr_idle++;\n\tworker->last_active = jiffies;\n\n\t/* idle_list is LIFO */\n\tlist_add(&worker->entry, &pool->idle_list);\n\n\tif (too_many_workers(pool) && !timer_pending(&pool->idle_timer))\n\t\tmod_timer(&pool->idle_timer, jiffies + IDLE_WORKER_TIMEOUT);\n\n\t/*\n\t * Sanity check nr_running.  Because unbind_workers() releases\n\t * pool->lock between setting %WORKER_UNBOUND and zapping\n\t * nr_running, the warning may trigger spuriously.  Check iff\n\t * unbind is not in progress.\n\t */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     pool->nr_workers == pool->nr_idle &&\n\t\t     atomic_read(&pool->nr_running));\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void worker_enter_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(worker->flags & WORKER_IDLE) ||\n\t    WARN_ON_ONCE(!list_empty(&worker->entry) &&\n\t\t\t (worker->hentry.next || worker->hentry.pprev)))\n\t\treturn;\n\n\t/* can't use worker_set_flags(), also called from create_worker() */\n\tworker->flags |= WORKER_IDLE;\n\tpool->nr_idle++;\n\tworker->last_active = jiffies;\n\n\t/* idle_list is LIFO */\n\tlist_add(&worker->entry, &pool->idle_list);\n\n\tif (too_many_workers(pool) && !timer_pending(&pool->idle_timer))\n\t\tmod_timer(&pool->idle_timer, jiffies + IDLE_WORKER_TIMEOUT);\n\n\t/*\n\t * Sanity check nr_running.  Because unbind_workers() releases\n\t * pool->lock between setting %WORKER_UNBOUND and zapping\n\t * nr_running, the warning may trigger spuriously.  Check iff\n\t * unbind is not in progress.\n\t */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     pool->nr_workers == pool->nr_idle &&\n\t\t     atomic_read(&pool->nr_running));\n}"
        }
      },
      {
        "call_info": {
          "callee": "worker_set_flags",
          "args": [
            "worker",
            "WORKER_PREP"
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "worker_set_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "922-935",
          "snippet": "static inline void worker_set_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\t/* If transitioning into NOT_RUNNING, adjust nr_running. */\n\tif ((flags & WORKER_NOT_RUNNING) &&\n\t    !(worker->flags & WORKER_NOT_RUNNING)) {\n\t\tatomic_dec(&pool->nr_running);\n\t}\n\n\tworker->flags |= flags;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic inline void worker_set_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\t/* If transitioning into NOT_RUNNING, adjust nr_running. */\n\tif ((flags & WORKER_NOT_RUNNING) &&\n\t    !(worker->flags & WORKER_NOT_RUNNING)) {\n\t\tatomic_dec(&pool->nr_running);\n\t}\n\n\tworker->flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "keep_working",
          "args": [
            "pool"
          ],
          "line": 2303
        },
        "resolved": true,
        "details": {
          "function_name": "keep_working",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "789-793",
          "snippet": "static bool keep_working(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) &&\n\t\tatomic_read(&pool->nr_running) <= 1;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool keep_working(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) &&\n\t\tatomic_read(&pool->nr_running) <= 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_scheduled_works",
          "args": [
            "worker"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "process_scheduled_works",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2207-2214",
          "snippet": "static void process_scheduled_works(struct worker *worker)\n{\n\twhile (!list_empty(&worker->scheduled)) {\n\t\tstruct work_struct *work = list_first_entry(&worker->scheduled,\n\t\t\t\t\t\tstruct work_struct, entry);\n\t\tprocess_one_work(worker, work);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void process_scheduled_works(struct worker *worker)\n{\n\twhile (!list_empty(&worker->scheduled)) {\n\t\tstruct work_struct *work = list_first_entry(&worker->scheduled,\n\t\t\t\t\t\tstruct work_struct, entry);\n\t\tprocess_one_work(worker, work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_linked_works",
          "args": [
            "work",
            "&worker->scheduled",
            "NULL"
          ],
          "line": 2300
        },
        "resolved": true,
        "details": {
          "function_name": "move_linked_works",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1030-1052",
          "snippet": "static void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!list_empty(&worker->scheduled)"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&worker->scheduled"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_one_work",
          "args": [
            "worker",
            "work"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "process_one_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2046-2193",
          "snippet": "static void process_one_work(struct worker *worker, struct work_struct *work)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct worker_pool *pool = worker->pool;\n\tbool cpu_intensive = pwq->wq->flags & WQ_CPU_INTENSIVE;\n\tint work_color;\n\tstruct worker *collision;\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * It is permissible to free the struct work_struct from\n\t * inside the function that is called from it, this we need to\n\t * take into account for lockdep too.  To avoid bogus \"held\n\t * lock freed\" warnings as well as problems when looking into\n\t * work->lockdep_map, make a copy and use that here.\n\t */\n\tstruct lockdep_map lockdep_map;\n\n\tlockdep_copy_map(&lockdep_map, &work->lockdep_map);\n#endif\n\t/* ensure we're on the correct CPU */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     raw_smp_processor_id() != pool->cpu);\n\n\t/*\n\t * A single work shouldn't be executed concurrently by\n\t * multiple workers on a single cpu.  Check whether anyone is\n\t * already processing the work.  If so, defer the work to the\n\t * currently executing one.\n\t */\n\tcollision = find_worker_executing_work(pool, work);\n\tif (unlikely(collision)) {\n\t\tmove_linked_works(work, &collision->scheduled, NULL);\n\t\treturn;\n\t}\n\n\t/* claim and dequeue */\n\tdebug_work_deactivate(work);\n\thash_add(pool->busy_hash, &worker->hentry, (unsigned long)work);\n\tworker->current_work = work;\n\tworker->current_func = work->func;\n\tworker->current_pwq = pwq;\n\twork_color = get_work_color(work);\n\n\t/*\n\t * Record wq name for cmdline and debug reporting, may get\n\t * overridden through set_worker_desc().\n\t */\n\tstrscpy(worker->desc, pwq->wq->name, WORKER_DESC_LEN);\n\n\tlist_del_init(&work->entry);\n\n\t/*\n\t * CPU intensive works don't participate in concurrency management.\n\t * They're the scheduler's responsibility.  This takes @worker out\n\t * of concurrency management and the next code block will chain\n\t * execution of the pending work items.\n\t */\n\tif (unlikely(cpu_intensive))\n\t\tworker_set_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/*\n\t * Wake up another worker if necessary.  The condition is always\n\t * false for normal per-cpu workers since nr_running would always\n\t * be >= 1 at this point.  This is used to chain execution of the\n\t * pending work items for WORKER_NOT_RUNNING workers such as the\n\t * UNBOUND and CPU_INTENSIVE ones.\n\t */\n\tif (need_more_worker(pool))\n\t\twake_up_worker(pool);\n\n\t/*\n\t * Record the last pool and clear PENDING which should be the last\n\t * update to @work.  Also, do this inside @pool->lock so that\n\t * PENDING and queued state changes happen together while IRQ is\n\t * disabled.\n\t */\n\tset_work_pool_and_clear_pending(work, pool->id);\n\n\tspin_unlock_irq(&pool->lock);\n\n\tlock_map_acquire(&pwq->wq->lockdep_map);\n\tlock_map_acquire(&lockdep_map);\n\t/*\n\t * Strictly speaking we should mark the invariant state without holding\n\t * any locks, that is, before these two lock_map_acquire()'s.\n\t *\n\t * However, that would result in:\n\t *\n\t *   A(W1)\n\t *   WFC(C)\n\t *\t\tA(W1)\n\t *\t\tC(C)\n\t *\n\t * Which would create W1->C->W1 dependencies, even though there is no\n\t * actual deadlock possible. There are two solutions, using a\n\t * read-recursive acquire on the work(queue) 'locks', but this will then\n\t * hit the lockdep limitation on recursive locks, or simply discard\n\t * these locks.\n\t *\n\t * AFAICT there is no possible deadlock scenario between the\n\t * flush_work() and complete() primitives (except for single-threaded\n\t * workqueues), so hiding them isn't a problem.\n\t */\n\tlockdep_invariant_state(true);\n\ttrace_workqueue_execute_start(work);\n\tworker->current_func(work);\n\t/*\n\t * While we must be careful to not use \"work\" after this, the trace\n\t * point will only record its address.\n\t */\n\ttrace_workqueue_execute_end(work);\n\tlock_map_release(&lockdep_map);\n\tlock_map_release(&pwq->wq->lockdep_map);\n\n\tif (unlikely(in_atomic() || lockdep_depth(current) > 0)) {\n\t\tpr_err(\"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"\n\t\t       \"     last function: %pf\\n\",\n\t\t       current->comm, preempt_count(), task_pid_nr(current),\n\t\t       worker->current_func);\n\t\tdebug_show_held_locks(current);\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * The following prevents a kworker from hogging CPU on !PREEMPT\n\t * kernels, where a requeueing work item waiting for something to\n\t * happen could deadlock with stop_machine as such work item could\n\t * indefinitely requeue itself while all other CPUs are trapped in\n\t * stop_machine. At the same time, report a quiescent RCU state so\n\t * the same condition doesn't freeze RCU.\n\t */\n\tcond_resched();\n\n\tspin_lock_irq(&pool->lock);\n\n\t/* clear cpu intensive status */\n\tif (unlikely(cpu_intensive))\n\t\tworker_clr_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/* we're done with it, release */\n\thash_del(&worker->hentry);\n\tworker->current_work = NULL;\n\tworker->current_func = NULL;\n\tworker->current_pwq = NULL;\n\tpwq_dec_nr_in_flight(pwq, work_color);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void process_one_work(struct worker *worker, struct work_struct *work)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct worker_pool *pool = worker->pool;\n\tbool cpu_intensive = pwq->wq->flags & WQ_CPU_INTENSIVE;\n\tint work_color;\n\tstruct worker *collision;\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * It is permissible to free the struct work_struct from\n\t * inside the function that is called from it, this we need to\n\t * take into account for lockdep too.  To avoid bogus \"held\n\t * lock freed\" warnings as well as problems when looking into\n\t * work->lockdep_map, make a copy and use that here.\n\t */\n\tstruct lockdep_map lockdep_map;\n\n\tlockdep_copy_map(&lockdep_map, &work->lockdep_map);\n#endif\n\t/* ensure we're on the correct CPU */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     raw_smp_processor_id() != pool->cpu);\n\n\t/*\n\t * A single work shouldn't be executed concurrently by\n\t * multiple workers on a single cpu.  Check whether anyone is\n\t * already processing the work.  If so, defer the work to the\n\t * currently executing one.\n\t */\n\tcollision = find_worker_executing_work(pool, work);\n\tif (unlikely(collision)) {\n\t\tmove_linked_works(work, &collision->scheduled, NULL);\n\t\treturn;\n\t}\n\n\t/* claim and dequeue */\n\tdebug_work_deactivate(work);\n\thash_add(pool->busy_hash, &worker->hentry, (unsigned long)work);\n\tworker->current_work = work;\n\tworker->current_func = work->func;\n\tworker->current_pwq = pwq;\n\twork_color = get_work_color(work);\n\n\t/*\n\t * Record wq name for cmdline and debug reporting, may get\n\t * overridden through set_worker_desc().\n\t */\n\tstrscpy(worker->desc, pwq->wq->name, WORKER_DESC_LEN);\n\n\tlist_del_init(&work->entry);\n\n\t/*\n\t * CPU intensive works don't participate in concurrency management.\n\t * They're the scheduler's responsibility.  This takes @worker out\n\t * of concurrency management and the next code block will chain\n\t * execution of the pending work items.\n\t */\n\tif (unlikely(cpu_intensive))\n\t\tworker_set_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/*\n\t * Wake up another worker if necessary.  The condition is always\n\t * false for normal per-cpu workers since nr_running would always\n\t * be >= 1 at this point.  This is used to chain execution of the\n\t * pending work items for WORKER_NOT_RUNNING workers such as the\n\t * UNBOUND and CPU_INTENSIVE ones.\n\t */\n\tif (need_more_worker(pool))\n\t\twake_up_worker(pool);\n\n\t/*\n\t * Record the last pool and clear PENDING which should be the last\n\t * update to @work.  Also, do this inside @pool->lock so that\n\t * PENDING and queued state changes happen together while IRQ is\n\t * disabled.\n\t */\n\tset_work_pool_and_clear_pending(work, pool->id);\n\n\tspin_unlock_irq(&pool->lock);\n\n\tlock_map_acquire(&pwq->wq->lockdep_map);\n\tlock_map_acquire(&lockdep_map);\n\t/*\n\t * Strictly speaking we should mark the invariant state without holding\n\t * any locks, that is, before these two lock_map_acquire()'s.\n\t *\n\t * However, that would result in:\n\t *\n\t *   A(W1)\n\t *   WFC(C)\n\t *\t\tA(W1)\n\t *\t\tC(C)\n\t *\n\t * Which would create W1->C->W1 dependencies, even though there is no\n\t * actual deadlock possible. There are two solutions, using a\n\t * read-recursive acquire on the work(queue) 'locks', but this will then\n\t * hit the lockdep limitation on recursive locks, or simply discard\n\t * these locks.\n\t *\n\t * AFAICT there is no possible deadlock scenario between the\n\t * flush_work() and complete() primitives (except for single-threaded\n\t * workqueues), so hiding them isn't a problem.\n\t */\n\tlockdep_invariant_state(true);\n\ttrace_workqueue_execute_start(work);\n\tworker->current_func(work);\n\t/*\n\t * While we must be careful to not use \"work\" after this, the trace\n\t * point will only record its address.\n\t */\n\ttrace_workqueue_execute_end(work);\n\tlock_map_release(&lockdep_map);\n\tlock_map_release(&pwq->wq->lockdep_map);\n\n\tif (unlikely(in_atomic() || lockdep_depth(current) > 0)) {\n\t\tpr_err(\"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"\n\t\t       \"     last function: %pf\\n\",\n\t\t       current->comm, preempt_count(), task_pid_nr(current),\n\t\t       worker->current_func);\n\t\tdebug_show_held_locks(current);\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * The following prevents a kworker from hogging CPU on !PREEMPT\n\t * kernels, where a requeueing work item waiting for something to\n\t * happen could deadlock with stop_machine as such work item could\n\t * indefinitely requeue itself while all other CPUs are trapped in\n\t * stop_machine. At the same time, report a quiescent RCU state so\n\t * the same condition doesn't freeze RCU.\n\t */\n\tcond_resched();\n\n\tspin_lock_irq(&pool->lock);\n\n\t/* clear cpu intensive status */\n\tif (unlikely(cpu_intensive))\n\t\tworker_clr_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/* we're done with it, release */\n\thash_del(&worker->hentry);\n\tworker->current_work = NULL;\n\tworker->current_func = NULL;\n\tworker->current_pwq = NULL;\n\tpwq_dec_nr_in_flight(pwq, work_color);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(*work_data_bits(work) & WORK_STRUCT_LINKED)"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&pool->worklist",
            "structwork_struct",
            "entry"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "worker_clr_flags",
          "args": [
            "worker",
            "WORKER_PREP | WORKER_REBOUND"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "worker_clr_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "947-964",
          "snippet": "static inline void worker_clr_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tunsigned int oflags = worker->flags;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\tworker->flags &= ~flags;\n\n\t/*\n\t * If transitioning out of NOT_RUNNING, increment nr_running.  Note\n\t * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask\n\t * of multiple flags, not a single flag.\n\t */\n\tif ((flags & WORKER_NOT_RUNNING) && (oflags & WORKER_NOT_RUNNING))\n\t\tif (!(worker->flags & WORKER_NOT_RUNNING))\n\t\t\tatomic_inc(&pool->nr_running);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic inline void worker_clr_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tunsigned int oflags = worker->flags;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\tworker->flags &= ~flags;\n\n\t/*\n\t * If transitioning out of NOT_RUNNING, increment nr_running.  Note\n\t * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask\n\t * of multiple flags, not a single flag.\n\t */\n\tif ((flags & WORKER_NOT_RUNNING) && (oflags & WORKER_NOT_RUNNING))\n\t\tif (!(worker->flags & WORKER_NOT_RUNNING))\n\t\t\tatomic_inc(&pool->nr_running);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&worker->scheduled)"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "manage_workers",
          "args": [
            "worker"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "manage_workers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2014-2030",
          "snippet": "static bool manage_workers(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (pool->flags & POOL_MANAGER_ACTIVE)\n\t\treturn false;\n\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\tpool->manager = worker;\n\n\tmaybe_create_worker(pool);\n\n\tpool->manager = NULL;\n\tpool->flags &= ~POOL_MANAGER_ACTIVE;\n\twake_up(&wq_manager_wait);\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(wq_manager_wait);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(wq_manager_wait);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool manage_workers(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (pool->flags & POOL_MANAGER_ACTIVE)\n\t\treturn false;\n\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\tpool->manager = worker;\n\n\tmaybe_create_worker(pool);\n\n\tpool->manager = NULL;\n\tpool->flags &= ~POOL_MANAGER_ACTIVE;\n\twake_up(&wq_manager_wait);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!may_start_working(pool)"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "may_start_working",
          "args": [
            "pool"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "may_start_working",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "783-786",
          "snippet": "static bool may_start_working(struct worker_pool *pool)\n{\n\treturn pool->nr_idle;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool may_start_working(struct worker_pool *pool)\n{\n\treturn pool->nr_idle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_more_worker",
          "args": [
            "pool"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "need_more_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "777-780",
          "snippet": "static bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "worker_leave_idle",
          "args": [
            "worker"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "worker_leave_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1689-1698",
          "snippet": "static void worker_leave_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\tworker_clr_flags(worker, WORKER_IDLE);\n\tpool->nr_idle--;\n\tlist_del_init(&worker->entry);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void worker_leave_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\tworker_clr_flags(worker, WORKER_IDLE);\n\tpool->nr_idle--;\n\tlist_del_init(&worker->entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "worker"
          ],
          "line": 2257
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "worker_detach_from_pool",
          "args": [
            "worker"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "worker_detach_from_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1757-1776",
          "snippet": "static void worker_detach_from_pool(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tstruct completion *detach_completion = NULL;\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\tlist_del(&worker->node);\n\tworker->pool = NULL;\n\n\tif (list_empty(&pool->workers))\n\t\tdetach_completion = pool->detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\t/* clear leftover flags without pool->lock after it is detached */\n\tworker->flags &= ~(WORKER_UNBOUND | WORKER_REBOUND);\n\n\tif (detach_completion)\n\t\tcomplete(detach_completion);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void worker_detach_from_pool(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tstruct completion *detach_completion = NULL;\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\tlist_del(&worker->node);\n\tworker->pool = NULL;\n\n\tif (list_empty(&pool->workers))\n\t\tdetach_completion = pool->detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\t/* clear leftover flags without pool->lock after it is detached */\n\tworker->flags &= ~(WORKER_UNBOUND | WORKER_REBOUND);\n\n\tif (detach_completion)\n\t\tcomplete(detach_completion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ida_simple_remove",
          "args": [
            "&pool->worker_ida",
            "worker->id"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_task_comm",
          "args": [
            "worker->task",
            "\"kworker/dying\""
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_pf_worker",
          "args": [
            "false"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "set_pf_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2216-2224",
          "snippet": "static void set_pf_worker(bool val)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (val)\n\t\tcurrent->flags |= PF_WQ_WORKER;\n\telse\n\t\tcurrent->flags &= ~PF_WQ_WORKER;\n\tmutex_unlock(&wq_pool_attach_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_attach_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\n\nstatic void set_pf_worker(bool val)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (val)\n\t\tcurrent->flags |= PF_WQ_WORKER;\n\telse\n\t\tcurrent->flags &= ~PF_WQ_WORKER;\n\tmutex_unlock(&wq_pool_attach_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&worker->entry)"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "worker->flags & WORKER_DIE"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic int worker_thread(void *__worker);\n\nstatic int worker_thread(void *__worker)\n{\n\tstruct worker *worker = __worker;\n\tstruct worker_pool *pool = worker->pool;\n\n\t/* tell the scheduler that this is a workqueue worker */\n\tset_pf_worker(true);\nwoke_up:\n\tspin_lock_irq(&pool->lock);\n\n\t/* am I supposed to die? */\n\tif (unlikely(worker->flags & WORKER_DIE)) {\n\t\tspin_unlock_irq(&pool->lock);\n\t\tWARN_ON_ONCE(!list_empty(&worker->entry));\n\t\tset_pf_worker(false);\n\n\t\tset_task_comm(worker->task, \"kworker/dying\");\n\t\tida_simple_remove(&pool->worker_ida, worker->id);\n\t\tworker_detach_from_pool(worker);\n\t\tkfree(worker);\n\t\treturn 0;\n\t}\n\n\tworker_leave_idle(worker);\nrecheck:\n\t/* no more worker necessary? */\n\tif (!need_more_worker(pool))\n\t\tgoto sleep;\n\n\t/* do we need to manage? */\n\tif (unlikely(!may_start_working(pool)) && manage_workers(worker))\n\t\tgoto recheck;\n\n\t/*\n\t * ->scheduled list can only be filled while a worker is\n\t * preparing to process a work or actually processing it.\n\t * Make sure nobody diddled with it while I was sleeping.\n\t */\n\tWARN_ON_ONCE(!list_empty(&worker->scheduled));\n\n\t/*\n\t * Finish PREP stage.  We're guaranteed to have at least one idle\n\t * worker or that someone else has already assumed the manager\n\t * role.  This is where @worker starts participating in concurrency\n\t * management if applicable and concurrency management is restored\n\t * after being rebound.  See rebind_workers() for details.\n\t */\n\tworker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);\n\n\tdo {\n\t\tstruct work_struct *work =\n\t\t\tlist_first_entry(&pool->worklist,\n\t\t\t\t\t struct work_struct, entry);\n\n\t\tpool->watchdog_ts = jiffies;\n\n\t\tif (likely(!(*work_data_bits(work) & WORK_STRUCT_LINKED))) {\n\t\t\t/* optimization path, not strictly necessary */\n\t\t\tprocess_one_work(worker, work);\n\t\t\tif (unlikely(!list_empty(&worker->scheduled)))\n\t\t\t\tprocess_scheduled_works(worker);\n\t\t} else {\n\t\t\tmove_linked_works(work, &worker->scheduled, NULL);\n\t\t\tprocess_scheduled_works(worker);\n\t\t}\n\t} while (keep_working(pool));\n\n\tworker_set_flags(worker, WORKER_PREP);\nsleep:\n\t/*\n\t * pool->lock is held and there's no work to process and no need to\n\t * manage, sleep.  Workers are woken up only while holding\n\t * pool->lock or from local cpu, so setting the current state\n\t * before releasing pool->lock is enough to prevent losing any\n\t * event.\n\t */\n\tworker_enter_idle(worker);\n\t__set_current_state(TASK_IDLE);\n\tspin_unlock_irq(&pool->lock);\n\tschedule();\n\tgoto woke_up;\n}"
  },
  {
    "function_name": "set_pf_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "2216-2224",
    "snippet": "static void set_pf_worker(bool val)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (val)\n\t\tcurrent->flags |= PF_WQ_WORKER;\n\telse\n\t\tcurrent->flags &= ~PF_WQ_WORKER;\n\tmutex_unlock(&wq_pool_attach_mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_attach_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 2223
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\n\nstatic void set_pf_worker(bool val)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\tif (val)\n\t\tcurrent->flags |= PF_WQ_WORKER;\n\telse\n\t\tcurrent->flags &= ~PF_WQ_WORKER;\n\tmutex_unlock(&wq_pool_attach_mutex);\n}"
  },
  {
    "function_name": "process_scheduled_works",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "2207-2214",
    "snippet": "static void process_scheduled_works(struct worker *worker)\n{\n\twhile (!list_empty(&worker->scheduled)) {\n\t\tstruct work_struct *work = list_first_entry(&worker->scheduled,\n\t\t\t\t\t\tstruct work_struct, entry);\n\t\tprocess_one_work(worker, work);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_one_work",
          "args": [
            "worker",
            "work"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "process_one_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2046-2193",
          "snippet": "static void process_one_work(struct worker *worker, struct work_struct *work)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct worker_pool *pool = worker->pool;\n\tbool cpu_intensive = pwq->wq->flags & WQ_CPU_INTENSIVE;\n\tint work_color;\n\tstruct worker *collision;\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * It is permissible to free the struct work_struct from\n\t * inside the function that is called from it, this we need to\n\t * take into account for lockdep too.  To avoid bogus \"held\n\t * lock freed\" warnings as well as problems when looking into\n\t * work->lockdep_map, make a copy and use that here.\n\t */\n\tstruct lockdep_map lockdep_map;\n\n\tlockdep_copy_map(&lockdep_map, &work->lockdep_map);\n#endif\n\t/* ensure we're on the correct CPU */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     raw_smp_processor_id() != pool->cpu);\n\n\t/*\n\t * A single work shouldn't be executed concurrently by\n\t * multiple workers on a single cpu.  Check whether anyone is\n\t * already processing the work.  If so, defer the work to the\n\t * currently executing one.\n\t */\n\tcollision = find_worker_executing_work(pool, work);\n\tif (unlikely(collision)) {\n\t\tmove_linked_works(work, &collision->scheduled, NULL);\n\t\treturn;\n\t}\n\n\t/* claim and dequeue */\n\tdebug_work_deactivate(work);\n\thash_add(pool->busy_hash, &worker->hentry, (unsigned long)work);\n\tworker->current_work = work;\n\tworker->current_func = work->func;\n\tworker->current_pwq = pwq;\n\twork_color = get_work_color(work);\n\n\t/*\n\t * Record wq name for cmdline and debug reporting, may get\n\t * overridden through set_worker_desc().\n\t */\n\tstrscpy(worker->desc, pwq->wq->name, WORKER_DESC_LEN);\n\n\tlist_del_init(&work->entry);\n\n\t/*\n\t * CPU intensive works don't participate in concurrency management.\n\t * They're the scheduler's responsibility.  This takes @worker out\n\t * of concurrency management and the next code block will chain\n\t * execution of the pending work items.\n\t */\n\tif (unlikely(cpu_intensive))\n\t\tworker_set_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/*\n\t * Wake up another worker if necessary.  The condition is always\n\t * false for normal per-cpu workers since nr_running would always\n\t * be >= 1 at this point.  This is used to chain execution of the\n\t * pending work items for WORKER_NOT_RUNNING workers such as the\n\t * UNBOUND and CPU_INTENSIVE ones.\n\t */\n\tif (need_more_worker(pool))\n\t\twake_up_worker(pool);\n\n\t/*\n\t * Record the last pool and clear PENDING which should be the last\n\t * update to @work.  Also, do this inside @pool->lock so that\n\t * PENDING and queued state changes happen together while IRQ is\n\t * disabled.\n\t */\n\tset_work_pool_and_clear_pending(work, pool->id);\n\n\tspin_unlock_irq(&pool->lock);\n\n\tlock_map_acquire(&pwq->wq->lockdep_map);\n\tlock_map_acquire(&lockdep_map);\n\t/*\n\t * Strictly speaking we should mark the invariant state without holding\n\t * any locks, that is, before these two lock_map_acquire()'s.\n\t *\n\t * However, that would result in:\n\t *\n\t *   A(W1)\n\t *   WFC(C)\n\t *\t\tA(W1)\n\t *\t\tC(C)\n\t *\n\t * Which would create W1->C->W1 dependencies, even though there is no\n\t * actual deadlock possible. There are two solutions, using a\n\t * read-recursive acquire on the work(queue) 'locks', but this will then\n\t * hit the lockdep limitation on recursive locks, or simply discard\n\t * these locks.\n\t *\n\t * AFAICT there is no possible deadlock scenario between the\n\t * flush_work() and complete() primitives (except for single-threaded\n\t * workqueues), so hiding them isn't a problem.\n\t */\n\tlockdep_invariant_state(true);\n\ttrace_workqueue_execute_start(work);\n\tworker->current_func(work);\n\t/*\n\t * While we must be careful to not use \"work\" after this, the trace\n\t * point will only record its address.\n\t */\n\ttrace_workqueue_execute_end(work);\n\tlock_map_release(&lockdep_map);\n\tlock_map_release(&pwq->wq->lockdep_map);\n\n\tif (unlikely(in_atomic() || lockdep_depth(current) > 0)) {\n\t\tpr_err(\"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"\n\t\t       \"     last function: %pf\\n\",\n\t\t       current->comm, preempt_count(), task_pid_nr(current),\n\t\t       worker->current_func);\n\t\tdebug_show_held_locks(current);\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * The following prevents a kworker from hogging CPU on !PREEMPT\n\t * kernels, where a requeueing work item waiting for something to\n\t * happen could deadlock with stop_machine as such work item could\n\t * indefinitely requeue itself while all other CPUs are trapped in\n\t * stop_machine. At the same time, report a quiescent RCU state so\n\t * the same condition doesn't freeze RCU.\n\t */\n\tcond_resched();\n\n\tspin_lock_irq(&pool->lock);\n\n\t/* clear cpu intensive status */\n\tif (unlikely(cpu_intensive))\n\t\tworker_clr_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/* we're done with it, release */\n\thash_del(&worker->hentry);\n\tworker->current_work = NULL;\n\tworker->current_func = NULL;\n\tworker->current_pwq = NULL;\n\tpwq_dec_nr_in_flight(pwq, work_color);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void process_one_work(struct worker *worker, struct work_struct *work)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct worker_pool *pool = worker->pool;\n\tbool cpu_intensive = pwq->wq->flags & WQ_CPU_INTENSIVE;\n\tint work_color;\n\tstruct worker *collision;\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * It is permissible to free the struct work_struct from\n\t * inside the function that is called from it, this we need to\n\t * take into account for lockdep too.  To avoid bogus \"held\n\t * lock freed\" warnings as well as problems when looking into\n\t * work->lockdep_map, make a copy and use that here.\n\t */\n\tstruct lockdep_map lockdep_map;\n\n\tlockdep_copy_map(&lockdep_map, &work->lockdep_map);\n#endif\n\t/* ensure we're on the correct CPU */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     raw_smp_processor_id() != pool->cpu);\n\n\t/*\n\t * A single work shouldn't be executed concurrently by\n\t * multiple workers on a single cpu.  Check whether anyone is\n\t * already processing the work.  If so, defer the work to the\n\t * currently executing one.\n\t */\n\tcollision = find_worker_executing_work(pool, work);\n\tif (unlikely(collision)) {\n\t\tmove_linked_works(work, &collision->scheduled, NULL);\n\t\treturn;\n\t}\n\n\t/* claim and dequeue */\n\tdebug_work_deactivate(work);\n\thash_add(pool->busy_hash, &worker->hentry, (unsigned long)work);\n\tworker->current_work = work;\n\tworker->current_func = work->func;\n\tworker->current_pwq = pwq;\n\twork_color = get_work_color(work);\n\n\t/*\n\t * Record wq name for cmdline and debug reporting, may get\n\t * overridden through set_worker_desc().\n\t */\n\tstrscpy(worker->desc, pwq->wq->name, WORKER_DESC_LEN);\n\n\tlist_del_init(&work->entry);\n\n\t/*\n\t * CPU intensive works don't participate in concurrency management.\n\t * They're the scheduler's responsibility.  This takes @worker out\n\t * of concurrency management and the next code block will chain\n\t * execution of the pending work items.\n\t */\n\tif (unlikely(cpu_intensive))\n\t\tworker_set_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/*\n\t * Wake up another worker if necessary.  The condition is always\n\t * false for normal per-cpu workers since nr_running would always\n\t * be >= 1 at this point.  This is used to chain execution of the\n\t * pending work items for WORKER_NOT_RUNNING workers such as the\n\t * UNBOUND and CPU_INTENSIVE ones.\n\t */\n\tif (need_more_worker(pool))\n\t\twake_up_worker(pool);\n\n\t/*\n\t * Record the last pool and clear PENDING which should be the last\n\t * update to @work.  Also, do this inside @pool->lock so that\n\t * PENDING and queued state changes happen together while IRQ is\n\t * disabled.\n\t */\n\tset_work_pool_and_clear_pending(work, pool->id);\n\n\tspin_unlock_irq(&pool->lock);\n\n\tlock_map_acquire(&pwq->wq->lockdep_map);\n\tlock_map_acquire(&lockdep_map);\n\t/*\n\t * Strictly speaking we should mark the invariant state without holding\n\t * any locks, that is, before these two lock_map_acquire()'s.\n\t *\n\t * However, that would result in:\n\t *\n\t *   A(W1)\n\t *   WFC(C)\n\t *\t\tA(W1)\n\t *\t\tC(C)\n\t *\n\t * Which would create W1->C->W1 dependencies, even though there is no\n\t * actual deadlock possible. There are two solutions, using a\n\t * read-recursive acquire on the work(queue) 'locks', but this will then\n\t * hit the lockdep limitation on recursive locks, or simply discard\n\t * these locks.\n\t *\n\t * AFAICT there is no possible deadlock scenario between the\n\t * flush_work() and complete() primitives (except for single-threaded\n\t * workqueues), so hiding them isn't a problem.\n\t */\n\tlockdep_invariant_state(true);\n\ttrace_workqueue_execute_start(work);\n\tworker->current_func(work);\n\t/*\n\t * While we must be careful to not use \"work\" after this, the trace\n\t * point will only record its address.\n\t */\n\ttrace_workqueue_execute_end(work);\n\tlock_map_release(&lockdep_map);\n\tlock_map_release(&pwq->wq->lockdep_map);\n\n\tif (unlikely(in_atomic() || lockdep_depth(current) > 0)) {\n\t\tpr_err(\"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"\n\t\t       \"     last function: %pf\\n\",\n\t\t       current->comm, preempt_count(), task_pid_nr(current),\n\t\t       worker->current_func);\n\t\tdebug_show_held_locks(current);\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * The following prevents a kworker from hogging CPU on !PREEMPT\n\t * kernels, where a requeueing work item waiting for something to\n\t * happen could deadlock with stop_machine as such work item could\n\t * indefinitely requeue itself while all other CPUs are trapped in\n\t * stop_machine. At the same time, report a quiescent RCU state so\n\t * the same condition doesn't freeze RCU.\n\t */\n\tcond_resched();\n\n\tspin_lock_irq(&pool->lock);\n\n\t/* clear cpu intensive status */\n\tif (unlikely(cpu_intensive))\n\t\tworker_clr_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/* we're done with it, release */\n\thash_del(&worker->hentry);\n\tworker->current_work = NULL;\n\tworker->current_func = NULL;\n\tworker->current_pwq = NULL;\n\tpwq_dec_nr_in_flight(pwq, work_color);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&worker->scheduled",
            "structwork_struct",
            "entry"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&worker->scheduled"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void process_scheduled_works(struct worker *worker)\n{\n\twhile (!list_empty(&worker->scheduled)) {\n\t\tstruct work_struct *work = list_first_entry(&worker->scheduled,\n\t\t\t\t\t\tstruct work_struct, entry);\n\t\tprocess_one_work(worker, work);\n\t}\n}"
  },
  {
    "function_name": "process_one_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "2046-2193",
    "snippet": "static void process_one_work(struct worker *worker, struct work_struct *work)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct worker_pool *pool = worker->pool;\n\tbool cpu_intensive = pwq->wq->flags & WQ_CPU_INTENSIVE;\n\tint work_color;\n\tstruct worker *collision;\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * It is permissible to free the struct work_struct from\n\t * inside the function that is called from it, this we need to\n\t * take into account for lockdep too.  To avoid bogus \"held\n\t * lock freed\" warnings as well as problems when looking into\n\t * work->lockdep_map, make a copy and use that here.\n\t */\n\tstruct lockdep_map lockdep_map;\n\n\tlockdep_copy_map(&lockdep_map, &work->lockdep_map);\n#endif\n\t/* ensure we're on the correct CPU */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     raw_smp_processor_id() != pool->cpu);\n\n\t/*\n\t * A single work shouldn't be executed concurrently by\n\t * multiple workers on a single cpu.  Check whether anyone is\n\t * already processing the work.  If so, defer the work to the\n\t * currently executing one.\n\t */\n\tcollision = find_worker_executing_work(pool, work);\n\tif (unlikely(collision)) {\n\t\tmove_linked_works(work, &collision->scheduled, NULL);\n\t\treturn;\n\t}\n\n\t/* claim and dequeue */\n\tdebug_work_deactivate(work);\n\thash_add(pool->busy_hash, &worker->hentry, (unsigned long)work);\n\tworker->current_work = work;\n\tworker->current_func = work->func;\n\tworker->current_pwq = pwq;\n\twork_color = get_work_color(work);\n\n\t/*\n\t * Record wq name for cmdline and debug reporting, may get\n\t * overridden through set_worker_desc().\n\t */\n\tstrscpy(worker->desc, pwq->wq->name, WORKER_DESC_LEN);\n\n\tlist_del_init(&work->entry);\n\n\t/*\n\t * CPU intensive works don't participate in concurrency management.\n\t * They're the scheduler's responsibility.  This takes @worker out\n\t * of concurrency management and the next code block will chain\n\t * execution of the pending work items.\n\t */\n\tif (unlikely(cpu_intensive))\n\t\tworker_set_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/*\n\t * Wake up another worker if necessary.  The condition is always\n\t * false for normal per-cpu workers since nr_running would always\n\t * be >= 1 at this point.  This is used to chain execution of the\n\t * pending work items for WORKER_NOT_RUNNING workers such as the\n\t * UNBOUND and CPU_INTENSIVE ones.\n\t */\n\tif (need_more_worker(pool))\n\t\twake_up_worker(pool);\n\n\t/*\n\t * Record the last pool and clear PENDING which should be the last\n\t * update to @work.  Also, do this inside @pool->lock so that\n\t * PENDING and queued state changes happen together while IRQ is\n\t * disabled.\n\t */\n\tset_work_pool_and_clear_pending(work, pool->id);\n\n\tspin_unlock_irq(&pool->lock);\n\n\tlock_map_acquire(&pwq->wq->lockdep_map);\n\tlock_map_acquire(&lockdep_map);\n\t/*\n\t * Strictly speaking we should mark the invariant state without holding\n\t * any locks, that is, before these two lock_map_acquire()'s.\n\t *\n\t * However, that would result in:\n\t *\n\t *   A(W1)\n\t *   WFC(C)\n\t *\t\tA(W1)\n\t *\t\tC(C)\n\t *\n\t * Which would create W1->C->W1 dependencies, even though there is no\n\t * actual deadlock possible. There are two solutions, using a\n\t * read-recursive acquire on the work(queue) 'locks', but this will then\n\t * hit the lockdep limitation on recursive locks, or simply discard\n\t * these locks.\n\t *\n\t * AFAICT there is no possible deadlock scenario between the\n\t * flush_work() and complete() primitives (except for single-threaded\n\t * workqueues), so hiding them isn't a problem.\n\t */\n\tlockdep_invariant_state(true);\n\ttrace_workqueue_execute_start(work);\n\tworker->current_func(work);\n\t/*\n\t * While we must be careful to not use \"work\" after this, the trace\n\t * point will only record its address.\n\t */\n\ttrace_workqueue_execute_end(work);\n\tlock_map_release(&lockdep_map);\n\tlock_map_release(&pwq->wq->lockdep_map);\n\n\tif (unlikely(in_atomic() || lockdep_depth(current) > 0)) {\n\t\tpr_err(\"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"\n\t\t       \"     last function: %pf\\n\",\n\t\t       current->comm, preempt_count(), task_pid_nr(current),\n\t\t       worker->current_func);\n\t\tdebug_show_held_locks(current);\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * The following prevents a kworker from hogging CPU on !PREEMPT\n\t * kernels, where a requeueing work item waiting for something to\n\t * happen could deadlock with stop_machine as such work item could\n\t * indefinitely requeue itself while all other CPUs are trapped in\n\t * stop_machine. At the same time, report a quiescent RCU state so\n\t * the same condition doesn't freeze RCU.\n\t */\n\tcond_resched();\n\n\tspin_lock_irq(&pool->lock);\n\n\t/* clear cpu intensive status */\n\tif (unlikely(cpu_intensive))\n\t\tworker_clr_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/* we're done with it, release */\n\thash_del(&worker->hentry);\n\tworker->current_work = NULL;\n\tworker->current_func = NULL;\n\tworker->current_pwq = NULL;\n\tpwq_dec_nr_in_flight(pwq, work_color);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(workqueues);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pwq_dec_nr_in_flight",
          "args": [
            "pwq",
            "work_color"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_dec_nr_in_flight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1143-1177",
          "snippet": "static void pwq_dec_nr_in_flight(struct pool_workqueue *pwq, int color)\n{\n\t/* uncolored work items don't participate in flushing or nr_active */\n\tif (color == WORK_NO_COLOR)\n\t\tgoto out_put;\n\n\tpwq->nr_in_flight[color]--;\n\n\tpwq->nr_active--;\n\tif (!list_empty(&pwq->delayed_works)) {\n\t\t/* one down, submit a delayed one */\n\t\tif (pwq->nr_active < pwq->max_active)\n\t\t\tpwq_activate_first_delayed(pwq);\n\t}\n\n\t/* is flush in progress and are we at the flushing tip? */\n\tif (likely(pwq->flush_color != color))\n\t\tgoto out_put;\n\n\t/* are there still in-flight works? */\n\tif (pwq->nr_in_flight[color])\n\t\tgoto out_put;\n\n\t/* this pwq is done, clear flush_color */\n\tpwq->flush_color = -1;\n\n\t/*\n\t * If this was the last pwq, wake up the first flusher.  It\n\t * will handle the rest.\n\t */\n\tif (atomic_dec_and_test(&pwq->wq->nr_pwqs_to_flush))\n\t\tcomplete(&pwq->wq->first_flusher->done);\nout_put:\n\tput_pwq(pwq);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void pwq_dec_nr_in_flight(struct pool_workqueue *pwq, int color)\n{\n\t/* uncolored work items don't participate in flushing or nr_active */\n\tif (color == WORK_NO_COLOR)\n\t\tgoto out_put;\n\n\tpwq->nr_in_flight[color]--;\n\n\tpwq->nr_active--;\n\tif (!list_empty(&pwq->delayed_works)) {\n\t\t/* one down, submit a delayed one */\n\t\tif (pwq->nr_active < pwq->max_active)\n\t\t\tpwq_activate_first_delayed(pwq);\n\t}\n\n\t/* is flush in progress and are we at the flushing tip? */\n\tif (likely(pwq->flush_color != color))\n\t\tgoto out_put;\n\n\t/* are there still in-flight works? */\n\tif (pwq->nr_in_flight[color])\n\t\tgoto out_put;\n\n\t/* this pwq is done, clear flush_color */\n\tpwq->flush_color = -1;\n\n\t/*\n\t * If this was the last pwq, wake up the first flusher.  It\n\t * will handle the rest.\n\t */\n\tif (atomic_dec_and_test(&pwq->wq->nr_pwqs_to_flush))\n\t\tcomplete(&pwq->wq->first_flusher->done);\nout_put:\n\tput_pwq(pwq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_del",
          "args": [
            "&worker->hentry"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "worker_clr_flags",
          "args": [
            "worker",
            "WORKER_CPU_INTENSIVE"
          ],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "worker_clr_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "947-964",
          "snippet": "static inline void worker_clr_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tunsigned int oflags = worker->flags;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\tworker->flags &= ~flags;\n\n\t/*\n\t * If transitioning out of NOT_RUNNING, increment nr_running.  Note\n\t * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask\n\t * of multiple flags, not a single flag.\n\t */\n\tif ((flags & WORKER_NOT_RUNNING) && (oflags & WORKER_NOT_RUNNING))\n\t\tif (!(worker->flags & WORKER_NOT_RUNNING))\n\t\t\tatomic_inc(&pool->nr_running);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic inline void worker_clr_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tunsigned int oflags = worker->flags;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\tworker->flags &= ~flags;\n\n\t/*\n\t * If transitioning out of NOT_RUNNING, increment nr_running.  Note\n\t * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask\n\t * of multiple flags, not a single flag.\n\t */\n\tif ((flags & WORKER_NOT_RUNNING) && (oflags & WORKER_NOT_RUNNING))\n\t\tif (!(worker->flags & WORKER_NOT_RUNNING))\n\t\t\tatomic_inc(&pool->nr_running);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cpu_intensive"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4957-4965",
          "snippet": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_show_held_locks",
          "args": [
            "current"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "debug_show_held_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4403-4410",
          "snippet": "void debug_show_held_locks(struct task_struct *task)\n{\n\tif (unlikely(!debug_locks)) {\n\t\tprintk(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tlockdep_print_held_locks(task);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_show_held_locks(struct task_struct *task)\n{\n\tif (unlikely(!debug_locks)) {\n\t\tprintk(\"INFO: lockdep is turned off.\\n\");\n\t\treturn;\n\t}\n\tlockdep_print_held_locks(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"\n\t\t       \"     last function: %pf\\n\"",
            "current->comm",
            "preempt_count()",
            "task_pid_nr(current)",
            "worker->current_func"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "in_atomic() || lockdep_depth(current) > 0"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_depth",
          "args": [
            "current"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_atomic",
          "args": [],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_release",
          "args": [
            "&pwq->wq->lockdep_map"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_release",
          "args": [
            "&lockdep_map"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_workqueue_execute_end",
          "args": [
            "work"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "worker->current_func",
          "args": [
            "work"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_workqueue_execute_start",
          "args": [
            "work"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_invariant_state",
          "args": [
            "true"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_acquire",
          "args": [
            "&lockdep_map"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_acquire",
          "args": [
            "&pwq->wq->lockdep_map"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_work_pool_and_clear_pending",
          "args": [
            "work",
            "pool->id"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "set_work_pool_and_clear_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "634-674",
          "snippet": "static void set_work_pool_and_clear_pending(struct work_struct *work,\n\t\t\t\t\t    int pool_id)\n{\n\t/*\n\t * The following wmb is paired with the implied mb in\n\t * test_and_set_bit(PENDING) and ensures all updates to @work made\n\t * here are visible to and precede any updates by the next PENDING\n\t * owner.\n\t */\n\tsmp_wmb();\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT, 0);\n\t/*\n\t * The following mb guarantees that previous clear of a PENDING bit\n\t * will not be reordered with any speculative LOADS or STORES from\n\t * work->current_func, which is executed afterwards.  This possible\n\t * reordering can lead to a missed execution on attempt to qeueue\n\t * the same @work.  E.g. consider this case:\n\t *\n\t *   CPU#0                         CPU#1\n\t *   ----------------------------  --------------------------------\n\t *\n\t * 1  STORE event_indicated\n\t * 2  queue_work_on() {\n\t * 3    test_and_set_bit(PENDING)\n\t * 4 }                             set_..._and_clear_pending() {\n\t * 5                                 set_work_data() # clear bit\n\t * 6                                 smp_mb()\n\t * 7                               work->current_func() {\n\t * 8\t\t\t\t      LOAD event_indicated\n\t *\t\t\t\t   }\n\t *\n\t * Without an explicit full barrier speculative LOAD on line 8 can\n\t * be executed before CPU#0 does STORE on line 1.  If that happens,\n\t * CPU#0 observes the PENDING bit is still set and new execution of\n\t * a @work is not queued in a hope, that CPU#1 will eventually\n\t * finish the queued @work.  Meanwhile CPU#1 does not see\n\t * event_indicated is set, because speculative LOAD was executed\n\t * before actual STORE.\n\t */\n\tsmp_mb();\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void set_work_pool_and_clear_pending(struct work_struct *work,\n\t\t\t\t\t    int pool_id)\n{\n\t/*\n\t * The following wmb is paired with the implied mb in\n\t * test_and_set_bit(PENDING) and ensures all updates to @work made\n\t * here are visible to and precede any updates by the next PENDING\n\t * owner.\n\t */\n\tsmp_wmb();\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT, 0);\n\t/*\n\t * The following mb guarantees that previous clear of a PENDING bit\n\t * will not be reordered with any speculative LOADS or STORES from\n\t * work->current_func, which is executed afterwards.  This possible\n\t * reordering can lead to a missed execution on attempt to qeueue\n\t * the same @work.  E.g. consider this case:\n\t *\n\t *   CPU#0                         CPU#1\n\t *   ----------------------------  --------------------------------\n\t *\n\t * 1  STORE event_indicated\n\t * 2  queue_work_on() {\n\t * 3    test_and_set_bit(PENDING)\n\t * 4 }                             set_..._and_clear_pending() {\n\t * 5                                 set_work_data() # clear bit\n\t * 6                                 smp_mb()\n\t * 7                               work->current_func() {\n\t * 8\t\t\t\t      LOAD event_indicated\n\t *\t\t\t\t   }\n\t *\n\t * Without an explicit full barrier speculative LOAD on line 8 can\n\t * be executed before CPU#0 does STORE on line 1.  If that happens,\n\t * CPU#0 observes the PENDING bit is still set and new execution of\n\t * a @work is not queued in a hope, that CPU#1 will eventually\n\t * finish the queued @work.  Meanwhile CPU#1 does not see\n\t * event_indicated is set, because speculative LOAD was executed\n\t * before actual STORE.\n\t */\n\tsmp_mb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_worker",
          "args": [
            "pool"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_more_worker",
          "args": [
            "pool"
          ],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "need_more_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "777-780",
          "snippet": "static bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "worker_set_flags",
          "args": [
            "worker",
            "WORKER_CPU_INTENSIVE"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "worker_set_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "922-935",
          "snippet": "static inline void worker_set_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\t/* If transitioning into NOT_RUNNING, adjust nr_running. */\n\tif ((flags & WORKER_NOT_RUNNING) &&\n\t    !(worker->flags & WORKER_NOT_RUNNING)) {\n\t\tatomic_dec(&pool->nr_running);\n\t}\n\n\tworker->flags |= flags;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic inline void worker_set_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\t/* If transitioning into NOT_RUNNING, adjust nr_running. */\n\tif ((flags & WORKER_NOT_RUNNING) &&\n\t    !(worker->flags & WORKER_NOT_RUNNING)) {\n\t\tatomic_dec(&pool->nr_running);\n\t}\n\n\tworker->flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cpu_intensive"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&work->entry"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "worker->desc",
            "pwq->wq->name",
            "WORKER_DESC_LEN"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_work_color",
          "args": [
            "work"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_color",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "582-586",
          "snippet": "static int get_work_color(struct work_struct *work)\n{\n\treturn (*work_data_bits(work) >> WORK_STRUCT_COLOR_SHIFT) &\n\t\t((1 << WORK_STRUCT_COLOR_BITS) - 1);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int get_work_color(struct work_struct *work)\n{\n\treturn (*work_data_bits(work) >> WORK_STRUCT_COLOR_SHIFT) &\n\t\t((1 << WORK_STRUCT_COLOR_BITS) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_add",
          "args": [
            "pool->busy_hash",
            "&worker->hentry",
            "(unsigned long)work"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_work_deactivate",
          "args": [
            "work"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "debug_work_deactivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "523-523",
          "snippet": "static inline void debug_work_deactivate(struct work_struct *work) { }",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void debug_work_deactivate(struct work_struct *work) { }"
        }
      },
      {
        "call_info": {
          "callee": "move_linked_works",
          "args": [
            "work",
            "&collision->scheduled",
            "NULL"
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "move_linked_works",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1030-1052",
          "snippet": "static void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "collision"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_worker_executing_work",
          "args": [
            "pool",
            "work"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "find_worker_executing_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "999-1011",
          "snippet": "static struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     raw_smp_processor_id() != pool->cpu"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_copy_map",
          "args": [
            "&lockdep_map",
            "&work->lockdep_map"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_work_pwq",
          "args": [
            "work"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pwq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "682-690",
          "snippet": "static struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&pool->lock"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&pool->lock"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void process_one_work(struct worker *worker, struct work_struct *work)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct worker_pool *pool = worker->pool;\n\tbool cpu_intensive = pwq->wq->flags & WQ_CPU_INTENSIVE;\n\tint work_color;\n\tstruct worker *collision;\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * It is permissible to free the struct work_struct from\n\t * inside the function that is called from it, this we need to\n\t * take into account for lockdep too.  To avoid bogus \"held\n\t * lock freed\" warnings as well as problems when looking into\n\t * work->lockdep_map, make a copy and use that here.\n\t */\n\tstruct lockdep_map lockdep_map;\n\n\tlockdep_copy_map(&lockdep_map, &work->lockdep_map);\n#endif\n\t/* ensure we're on the correct CPU */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     raw_smp_processor_id() != pool->cpu);\n\n\t/*\n\t * A single work shouldn't be executed concurrently by\n\t * multiple workers on a single cpu.  Check whether anyone is\n\t * already processing the work.  If so, defer the work to the\n\t * currently executing one.\n\t */\n\tcollision = find_worker_executing_work(pool, work);\n\tif (unlikely(collision)) {\n\t\tmove_linked_works(work, &collision->scheduled, NULL);\n\t\treturn;\n\t}\n\n\t/* claim and dequeue */\n\tdebug_work_deactivate(work);\n\thash_add(pool->busy_hash, &worker->hentry, (unsigned long)work);\n\tworker->current_work = work;\n\tworker->current_func = work->func;\n\tworker->current_pwq = pwq;\n\twork_color = get_work_color(work);\n\n\t/*\n\t * Record wq name for cmdline and debug reporting, may get\n\t * overridden through set_worker_desc().\n\t */\n\tstrscpy(worker->desc, pwq->wq->name, WORKER_DESC_LEN);\n\n\tlist_del_init(&work->entry);\n\n\t/*\n\t * CPU intensive works don't participate in concurrency management.\n\t * They're the scheduler's responsibility.  This takes @worker out\n\t * of concurrency management and the next code block will chain\n\t * execution of the pending work items.\n\t */\n\tif (unlikely(cpu_intensive))\n\t\tworker_set_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/*\n\t * Wake up another worker if necessary.  The condition is always\n\t * false for normal per-cpu workers since nr_running would always\n\t * be >= 1 at this point.  This is used to chain execution of the\n\t * pending work items for WORKER_NOT_RUNNING workers such as the\n\t * UNBOUND and CPU_INTENSIVE ones.\n\t */\n\tif (need_more_worker(pool))\n\t\twake_up_worker(pool);\n\n\t/*\n\t * Record the last pool and clear PENDING which should be the last\n\t * update to @work.  Also, do this inside @pool->lock so that\n\t * PENDING and queued state changes happen together while IRQ is\n\t * disabled.\n\t */\n\tset_work_pool_and_clear_pending(work, pool->id);\n\n\tspin_unlock_irq(&pool->lock);\n\n\tlock_map_acquire(&pwq->wq->lockdep_map);\n\tlock_map_acquire(&lockdep_map);\n\t/*\n\t * Strictly speaking we should mark the invariant state without holding\n\t * any locks, that is, before these two lock_map_acquire()'s.\n\t *\n\t * However, that would result in:\n\t *\n\t *   A(W1)\n\t *   WFC(C)\n\t *\t\tA(W1)\n\t *\t\tC(C)\n\t *\n\t * Which would create W1->C->W1 dependencies, even though there is no\n\t * actual deadlock possible. There are two solutions, using a\n\t * read-recursive acquire on the work(queue) 'locks', but this will then\n\t * hit the lockdep limitation on recursive locks, or simply discard\n\t * these locks.\n\t *\n\t * AFAICT there is no possible deadlock scenario between the\n\t * flush_work() and complete() primitives (except for single-threaded\n\t * workqueues), so hiding them isn't a problem.\n\t */\n\tlockdep_invariant_state(true);\n\ttrace_workqueue_execute_start(work);\n\tworker->current_func(work);\n\t/*\n\t * While we must be careful to not use \"work\" after this, the trace\n\t * point will only record its address.\n\t */\n\ttrace_workqueue_execute_end(work);\n\tlock_map_release(&lockdep_map);\n\tlock_map_release(&pwq->wq->lockdep_map);\n\n\tif (unlikely(in_atomic() || lockdep_depth(current) > 0)) {\n\t\tpr_err(\"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"\n\t\t       \"     last function: %pf\\n\",\n\t\t       current->comm, preempt_count(), task_pid_nr(current),\n\t\t       worker->current_func);\n\t\tdebug_show_held_locks(current);\n\t\tdump_stack();\n\t}\n\n\t/*\n\t * The following prevents a kworker from hogging CPU on !PREEMPT\n\t * kernels, where a requeueing work item waiting for something to\n\t * happen could deadlock with stop_machine as such work item could\n\t * indefinitely requeue itself while all other CPUs are trapped in\n\t * stop_machine. At the same time, report a quiescent RCU state so\n\t * the same condition doesn't freeze RCU.\n\t */\n\tcond_resched();\n\n\tspin_lock_irq(&pool->lock);\n\n\t/* clear cpu intensive status */\n\tif (unlikely(cpu_intensive))\n\t\tworker_clr_flags(worker, WORKER_CPU_INTENSIVE);\n\n\t/* we're done with it, release */\n\thash_del(&worker->hentry);\n\tworker->current_work = NULL;\n\tworker->current_func = NULL;\n\tworker->current_pwq = NULL;\n\tpwq_dec_nr_in_flight(pwq, work_color);\n}"
  },
  {
    "function_name": "manage_workers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "2014-2030",
    "snippet": "static bool manage_workers(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (pool->flags & POOL_MANAGER_ACTIVE)\n\t\treturn false;\n\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\tpool->manager = worker;\n\n\tmaybe_create_worker(pool);\n\n\tpool->manager = NULL;\n\tpool->flags &= ~POOL_MANAGER_ACTIVE;\n\twake_up(&wq_manager_wait);\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(wq_manager_wait);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&wq_manager_wait"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybe_create_worker",
          "args": [
            "pool"
          ],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_create_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1961-1990",
          "snippet": "static void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\tspin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\tspin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\tspin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\tspin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(wq_manager_wait);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool manage_workers(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (pool->flags & POOL_MANAGER_ACTIVE)\n\t\treturn false;\n\n\tpool->flags |= POOL_MANAGER_ACTIVE;\n\tpool->manager = worker;\n\n\tmaybe_create_worker(pool);\n\n\tpool->manager = NULL;\n\tpool->flags &= ~POOL_MANAGER_ACTIVE;\n\twake_up(&wq_manager_wait);\n\treturn true;\n}"
  },
  {
    "function_name": "maybe_create_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1961-1990",
    "snippet": "static void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\tspin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\tspin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "need_to_create_worker",
          "args": [
            "pool"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "need_to_create_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "796-799",
          "snippet": "static bool need_to_create_worker(struct worker_pool *pool)\n{\n\treturn need_more_worker(pool) && !may_start_working(pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool need_to_create_worker(struct worker_pool *pool)\n{\n\treturn need_more_worker(pool) && !may_start_working(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&pool->mayday_timer"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1273-1298",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "CREATE_COOLDOWN"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1821-1825",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_worker",
          "args": [
            "pool"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_create_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1961-1990",
          "snippet": "static void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\tspin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\tspin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&pool->mayday_timer",
            "jiffies + MAYDAY_INITIAL_TIMEOUT"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1100-1103",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&pool->lock"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&pool->lock"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void maybe_create_worker(struct worker_pool *pool)\n__releases(&pool->lock)\n__acquires(&pool->lock)\n{\nrestart:\n\tspin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\tspin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}"
  },
  {
    "function_name": "pool_mayday_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1918-1941",
    "snippet": "static void pool_mayday_timeout(struct timer_list *t)\n{\n\tstruct worker_pool *pool = from_timer(pool, t, mayday_timer);\n\tstruct work_struct *work;\n\n\tspin_lock_irq(&pool->lock);\n\tspin_lock(&wq_mayday_lock);\t\t/* for wq->maydays */\n\n\tif (need_to_create_worker(pool)) {\n\t\t/*\n\t\t * We've been trying to create a new worker but\n\t\t * haven't been successful.  We might be hitting an\n\t\t * allocation deadlock.  Send distress signals to\n\t\t * rescuers.\n\t\t */\n\t\tlist_for_each_entry(work, &pool->worklist, entry)\n\t\t\tsend_mayday(work);\n\t}\n\n\tspin_unlock(&wq_mayday_lock);\n\tspin_unlock_irq(&pool->lock);\n\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INTERVAL);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(wq_mayday_lock);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&pool->mayday_timer",
            "jiffies + MAYDAY_INTERVAL"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1100-1103",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&wq_mayday_lock"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_mayday",
          "args": [
            "work"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "send_mayday",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1895-1916",
          "snippet": "static void send_mayday(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct workqueue_struct *wq = pwq->wq;\n\n\tlockdep_assert_held(&wq_mayday_lock);\n\n\tif (!wq->rescuer)\n\t\treturn;\n\n\t/* mayday mayday mayday */\n\tif (list_empty(&pwq->mayday_node)) {\n\t\t/*\n\t\t * If @pwq is for an unbound wq, its base ref may be put at\n\t\t * any time due to an attribute change.  Pin @pwq until the\n\t\t * rescuer is done with it.\n\t\t */\n\t\tget_pwq(pwq);\n\t\tlist_add_tail(&pwq->mayday_node, &wq->maydays);\n\t\twake_up_process(wq->rescuer->task);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(wq_mayday_lock);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_SPINLOCK(wq_mayday_lock);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void send_mayday(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct workqueue_struct *wq = pwq->wq;\n\n\tlockdep_assert_held(&wq_mayday_lock);\n\n\tif (!wq->rescuer)\n\t\treturn;\n\n\t/* mayday mayday mayday */\n\tif (list_empty(&pwq->mayday_node)) {\n\t\t/*\n\t\t * If @pwq is for an unbound wq, its base ref may be put at\n\t\t * any time due to an attribute change.  Pin @pwq until the\n\t\t * rescuer is done with it.\n\t\t */\n\t\tget_pwq(pwq);\n\t\tlist_add_tail(&pwq->mayday_node, &wq->maydays);\n\t\twake_up_process(wq->rescuer->task);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "work",
            "&pool->worklist",
            "entry"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_to_create_worker",
          "args": [
            "pool"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "need_to_create_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "796-799",
          "snippet": "static bool need_to_create_worker(struct worker_pool *pool)\n{\n\treturn need_more_worker(pool) && !may_start_working(pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool need_to_create_worker(struct worker_pool *pool)\n{\n\treturn need_more_worker(pool) && !may_start_working(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&wq_mayday_lock"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_timer",
          "args": [
            "pool",
            "t",
            "mayday_timer"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_SPINLOCK(wq_mayday_lock);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void pool_mayday_timeout(struct timer_list *t)\n{\n\tstruct worker_pool *pool = from_timer(pool, t, mayday_timer);\n\tstruct work_struct *work;\n\n\tspin_lock_irq(&pool->lock);\n\tspin_lock(&wq_mayday_lock);\t\t/* for wq->maydays */\n\n\tif (need_to_create_worker(pool)) {\n\t\t/*\n\t\t * We've been trying to create a new worker but\n\t\t * haven't been successful.  We might be hitting an\n\t\t * allocation deadlock.  Send distress signals to\n\t\t * rescuers.\n\t\t */\n\t\tlist_for_each_entry(work, &pool->worklist, entry)\n\t\t\tsend_mayday(work);\n\t}\n\n\tspin_unlock(&wq_mayday_lock);\n\tspin_unlock_irq(&pool->lock);\n\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INTERVAL);\n}"
  },
  {
    "function_name": "send_mayday",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1895-1916",
    "snippet": "static void send_mayday(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct workqueue_struct *wq = pwq->wq;\n\n\tlockdep_assert_held(&wq_mayday_lock);\n\n\tif (!wq->rescuer)\n\t\treturn;\n\n\t/* mayday mayday mayday */\n\tif (list_empty(&pwq->mayday_node)) {\n\t\t/*\n\t\t * If @pwq is for an unbound wq, its base ref may be put at\n\t\t * any time due to an attribute change.  Pin @pwq until the\n\t\t * rescuer is done with it.\n\t\t */\n\t\tget_pwq(pwq);\n\t\tlist_add_tail(&pwq->mayday_node, &wq->maydays);\n\t\twake_up_process(wq->rescuer->task);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(wq_mayday_lock);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "wq->rescuer->task"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&pwq->mayday_node",
            "&wq->maydays"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pwq",
          "args": [
            "pwq"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "get_pwq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1061-1066",
          "snippet": "static void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->mayday_node"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_mayday_lock"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_work_pwq",
          "args": [
            "work"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pwq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "682-690",
          "snippet": "static struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_SPINLOCK(wq_mayday_lock);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void send_mayday(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\tstruct workqueue_struct *wq = pwq->wq;\n\n\tlockdep_assert_held(&wq_mayday_lock);\n\n\tif (!wq->rescuer)\n\t\treturn;\n\n\t/* mayday mayday mayday */\n\tif (list_empty(&pwq->mayday_node)) {\n\t\t/*\n\t\t * If @pwq is for an unbound wq, its base ref may be put at\n\t\t * any time due to an attribute change.  Pin @pwq until the\n\t\t * rescuer is done with it.\n\t\t */\n\t\tget_pwq(pwq);\n\t\tlist_add_tail(&pwq->mayday_node, &wq->maydays);\n\t\twake_up_process(wq->rescuer->task);\n\t}\n}"
  },
  {
    "function_name": "idle_worker_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1870-1893",
    "snippet": "static void idle_worker_timeout(struct timer_list *t)\n{\n\tstruct worker_pool *pool = from_timer(pool, t, idle_timer);\n\n\tspin_lock_irq(&pool->lock);\n\n\twhile (too_many_workers(pool)) {\n\t\tstruct worker *worker;\n\t\tunsigned long expires;\n\n\t\t/* idle_list is kept in LIFO order, check the last one */\n\t\tworker = list_entry(pool->idle_list.prev, struct worker, entry);\n\t\texpires = worker->last_active + IDLE_WORKER_TIMEOUT;\n\n\t\tif (time_before(jiffies, expires)) {\n\t\t\tmod_timer(&pool->idle_timer, expires);\n\t\t\tbreak;\n\t\t}\n\n\t\tdestroy_worker(worker);\n\t}\n\n\tspin_unlock_irq(&pool->lock);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_worker",
          "args": [
            "worker"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1850-1868",
          "snippet": "static void destroy_worker(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tlockdep_assert_held(&pool->lock);\n\n\t/* sanity check frenzy */\n\tif (WARN_ON(worker->current_work) ||\n\t    WARN_ON(!list_empty(&worker->scheduled)) ||\n\t    WARN_ON(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\n\tpool->nr_workers--;\n\tpool->nr_idle--;\n\n\tlist_del_init(&worker->entry);\n\tworker->flags |= WORKER_DIE;\n\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void destroy_worker(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tlockdep_assert_held(&pool->lock);\n\n\t/* sanity check frenzy */\n\tif (WARN_ON(worker->current_work) ||\n\t    WARN_ON(!list_empty(&worker->scheduled)) ||\n\t    WARN_ON(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\n\tpool->nr_workers--;\n\tpool->nr_idle--;\n\n\tlist_del_init(&worker->entry);\n\tworker->flags |= WORKER_DIE;\n\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&pool->idle_timer",
            "expires"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1100-1103",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "expires"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pool->idle_list.prev",
            "structworker",
            "entry"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "too_many_workers",
          "args": [
            "pool"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "too_many_workers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "802-809",
          "snippet": "static bool too_many_workers(struct worker_pool *pool)\n{\n\tbool managing = pool->flags & POOL_MANAGER_ACTIVE;\n\tint nr_idle = pool->nr_idle + managing; /* manager is considered idle */\n\tint nr_busy = pool->nr_workers - nr_idle;\n\n\treturn nr_idle > 2 && (nr_idle - 2) * MAX_IDLE_WORKERS_RATIO >= nr_busy;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool too_many_workers(struct worker_pool *pool)\n{\n\tbool managing = pool->flags & POOL_MANAGER_ACTIVE;\n\tint nr_idle = pool->nr_idle + managing; /* manager is considered idle */\n\tint nr_busy = pool->nr_workers - nr_idle;\n\n\treturn nr_idle > 2 && (nr_idle - 2) * MAX_IDLE_WORKERS_RATIO >= nr_busy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_timer",
          "args": [
            "pool",
            "t",
            "idle_timer"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void idle_worker_timeout(struct timer_list *t)\n{\n\tstruct worker_pool *pool = from_timer(pool, t, idle_timer);\n\n\tspin_lock_irq(&pool->lock);\n\n\twhile (too_many_workers(pool)) {\n\t\tstruct worker *worker;\n\t\tunsigned long expires;\n\n\t\t/* idle_list is kept in LIFO order, check the last one */\n\t\tworker = list_entry(pool->idle_list.prev, struct worker, entry);\n\t\texpires = worker->last_active + IDLE_WORKER_TIMEOUT;\n\n\t\tif (time_before(jiffies, expires)) {\n\t\t\tmod_timer(&pool->idle_timer, expires);\n\t\t\tbreak;\n\t\t}\n\n\t\tdestroy_worker(worker);\n\t}\n\n\tspin_unlock_irq(&pool->lock);\n}"
  },
  {
    "function_name": "destroy_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1850-1868",
    "snippet": "static void destroy_worker(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tlockdep_assert_held(&pool->lock);\n\n\t/* sanity check frenzy */\n\tif (WARN_ON(worker->current_work) ||\n\t    WARN_ON(!list_empty(&worker->scheduled)) ||\n\t    WARN_ON(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\n\tpool->nr_workers--;\n\tpool->nr_idle--;\n\n\tlist_del_init(&worker->entry);\n\tworker->flags |= WORKER_DIE;\n\twake_up_process(worker->task);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "worker->task"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&worker->entry"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(worker->flags & WORKER_IDLE)"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&worker->scheduled)"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&worker->scheduled"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "worker->current_work"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&pool->lock"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void destroy_worker(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tlockdep_assert_held(&pool->lock);\n\n\t/* sanity check frenzy */\n\tif (WARN_ON(worker->current_work) ||\n\t    WARN_ON(!list_empty(&worker->scheduled)) ||\n\t    WARN_ON(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\n\tpool->nr_workers--;\n\tpool->nr_idle--;\n\n\tlist_del_init(&worker->entry);\n\tworker->flags |= WORKER_DIE;\n\twake_up_process(worker->task);\n}"
  },
  {
    "function_name": "create_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1790-1838",
    "snippet": "static struct worker *create_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = NULL;\n\tint id = -1;\n\tchar id_buf[16];\n\n\t/* ID is needed to determine kthread name */\n\tid = ida_simple_get(&pool->worker_ida, 0, 0, GFP_KERNEL);\n\tif (id < 0)\n\t\tgoto fail;\n\n\tworker = alloc_worker(pool->node);\n\tif (!worker)\n\t\tgoto fail;\n\n\tworker->id = id;\n\n\tif (pool->cpu >= 0)\n\t\tsnprintf(id_buf, sizeof(id_buf), \"%d:%d%s\", pool->cpu, id,\n\t\t\t pool->attrs->nice < 0  ? \"H\" : \"\");\n\telse\n\t\tsnprintf(id_buf, sizeof(id_buf), \"u%d:%d\", pool->id, id);\n\n\tworker->task = kthread_create_on_node(worker_thread, worker, pool->node,\n\t\t\t\t\t      \"kworker/%s\", id_buf);\n\tif (IS_ERR(worker->task))\n\t\tgoto fail;\n\n\tset_user_nice(worker->task, pool->attrs->nice);\n\tkthread_bind_mask(worker->task, pool->attrs->cpumask);\n\n\t/* successful, attach the worker to the pool */\n\tworker_attach_to_pool(worker, pool);\n\n\t/* start the newly created worker */\n\tspin_lock_irq(&pool->lock);\n\tworker->pool->nr_workers++;\n\tworker_enter_idle(worker);\n\twake_up_process(worker->task);\n\tspin_unlock_irq(&pool->lock);\n\n\treturn worker;\n\nfail:\n\tif (id >= 0)\n\t\tida_simple_remove(&pool->worker_ida, id);\n\tkfree(worker);\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "worker"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ida_simple_remove",
          "args": [
            "&pool->worker_ida",
            "id"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "worker->task"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "worker_enter_idle",
          "args": [
            "worker"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "worker_enter_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1649-1678",
          "snippet": "static void worker_enter_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(worker->flags & WORKER_IDLE) ||\n\t    WARN_ON_ONCE(!list_empty(&worker->entry) &&\n\t\t\t (worker->hentry.next || worker->hentry.pprev)))\n\t\treturn;\n\n\t/* can't use worker_set_flags(), also called from create_worker() */\n\tworker->flags |= WORKER_IDLE;\n\tpool->nr_idle++;\n\tworker->last_active = jiffies;\n\n\t/* idle_list is LIFO */\n\tlist_add(&worker->entry, &pool->idle_list);\n\n\tif (too_many_workers(pool) && !timer_pending(&pool->idle_timer))\n\t\tmod_timer(&pool->idle_timer, jiffies + IDLE_WORKER_TIMEOUT);\n\n\t/*\n\t * Sanity check nr_running.  Because unbind_workers() releases\n\t * pool->lock between setting %WORKER_UNBOUND and zapping\n\t * nr_running, the warning may trigger spuriously.  Check iff\n\t * unbind is not in progress.\n\t */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     pool->nr_workers == pool->nr_idle &&\n\t\t     atomic_read(&pool->nr_running));\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void worker_enter_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(worker->flags & WORKER_IDLE) ||\n\t    WARN_ON_ONCE(!list_empty(&worker->entry) &&\n\t\t\t (worker->hentry.next || worker->hentry.pprev)))\n\t\treturn;\n\n\t/* can't use worker_set_flags(), also called from create_worker() */\n\tworker->flags |= WORKER_IDLE;\n\tpool->nr_idle++;\n\tworker->last_active = jiffies;\n\n\t/* idle_list is LIFO */\n\tlist_add(&worker->entry, &pool->idle_list);\n\n\tif (too_many_workers(pool) && !timer_pending(&pool->idle_timer))\n\t\tmod_timer(&pool->idle_timer, jiffies + IDLE_WORKER_TIMEOUT);\n\n\t/*\n\t * Sanity check nr_running.  Because unbind_workers() releases\n\t * pool->lock between setting %WORKER_UNBOUND and zapping\n\t * nr_running, the warning may trigger spuriously.  Check iff\n\t * unbind is not in progress.\n\t */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     pool->nr_workers == pool->nr_idle &&\n\t\t     atomic_read(&pool->nr_running));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pool->lock"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "worker_attach_to_pool",
          "args": [
            "worker",
            "pool"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "worker_attach_to_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1724-1747",
          "snippet": "static void worker_attach_to_pool(struct worker *worker,\n\t\t\t\t   struct worker_pool *pool)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\t/*\n\t * set_cpus_allowed_ptr() will fail if the cpumask doesn't have any\n\t * online CPUs.  It'll be re-applied when any of the CPUs come up.\n\t */\n\tset_cpus_allowed_ptr(worker->task, pool->attrs->cpumask);\n\n\t/*\n\t * The wq_pool_attach_mutex ensures %POOL_DISASSOCIATED remains\n\t * stable across this function.  See the comments above the flag\n\t * definition for details.\n\t */\n\tif (pool->flags & POOL_DISASSOCIATED)\n\t\tworker->flags |= WORKER_UNBOUND;\n\n\tlist_add_tail(&worker->node, &pool->workers);\n\tworker->pool = pool;\n\n\tmutex_unlock(&wq_pool_attach_mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wq_pool_attach_mutex);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void worker_attach_to_pool(struct worker *worker,\n\t\t\t\t   struct worker_pool *pool)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\t/*\n\t * set_cpus_allowed_ptr() will fail if the cpumask doesn't have any\n\t * online CPUs.  It'll be re-applied when any of the CPUs come up.\n\t */\n\tset_cpus_allowed_ptr(worker->task, pool->attrs->cpumask);\n\n\t/*\n\t * The wq_pool_attach_mutex ensures %POOL_DISASSOCIATED remains\n\t * stable across this function.  See the comments above the flag\n\t * definition for details.\n\t */\n\tif (pool->flags & POOL_DISASSOCIATED)\n\t\tworker->flags |= WORKER_UNBOUND;\n\n\tlist_add_tail(&worker->node, &pool->workers);\n\tworker->pool = pool;\n\n\tmutex_unlock(&wq_pool_attach_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_bind_mask",
          "args": [
            "worker->task",
            "pool->attrs->cpumask"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_bind_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "407-410",
          "snippet": "void kthread_bind_mask(struct task_struct *p, const struct cpumask *mask)\n{\n\t__kthread_bind_mask(p, mask, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_bind_mask(struct task_struct *p, const struct cpumask *mask)\n{\n\t__kthread_bind_mask(p, mask, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "worker->task",
            "pool->attrs->nice"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3865-3917",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio, delta;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it wont have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\tdelta = p->prio - old_prio;\n\n\tif (queued) {\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\t\t/*\n\t\t * If the task increased its priority or is running and\n\t\t * lowered its priority, then reschedule its CPU:\n\t\t */\n\t\tif (delta < 0 || (delta > 0 && task_running(rq, p)))\n\t\t\tresched_curr(rq);\n\t}\n\tif (running)\n\t\tset_curr_task(rq, p);\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "worker->task"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_create_on_node",
          "args": [
            "worker_thread",
            "worker",
            "pool->node",
            "\"kworker/%s\"",
            "id_buf"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_create_on_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "370-383",
          "snippet": "struct task_struct *kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t   void *data, int node,\n\t\t\t\t\t   const char namefmt[],\n\t\t\t\t\t   ...)\n{\n\tstruct task_struct *task;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\ttask = __kthread_create_on_node(threadfn, data, node, namefmt, args);\n\tva_end(args);\n\n\treturn task;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
            "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;",
            "struct task_struct *task;",
            "int node = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\nstruct task_struct *task;\nint node = -1;\n\nstruct task_struct *kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t   void *data, int node,\n\t\t\t\t\t   const char namefmt[],\n\t\t\t\t\t   ...)\n{\n\tstruct task_struct *task;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\ttask = __kthread_create_on_node(threadfn, data, node, namefmt, args);\n\tva_end(args);\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "id_buf",
            "sizeof(id_buf)",
            "\"u%d:%d\"",
            "pool->id",
            "id"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "id_buf",
            "sizeof(id_buf)",
            "\"%d:%d%s\"",
            "pool->cpu",
            "id",
            "pool->attrs->nice < 0  ? \"H\" : \"\""
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_worker",
          "args": [
            "pool->node"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1700-1713",
          "snippet": "static struct worker *alloc_worker(int node)\n{\n\tstruct worker *worker;\n\n\tworker = kzalloc_node(sizeof(*worker), GFP_KERNEL, node);\n\tif (worker) {\n\t\tINIT_LIST_HEAD(&worker->entry);\n\t\tINIT_LIST_HEAD(&worker->scheduled);\n\t\tINIT_LIST_HEAD(&worker->node);\n\t\t/* on creation a worker is in !idle && prep state */\n\t\tworker->flags = WORKER_PREP;\n\t}\n\treturn worker;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct worker *alloc_worker(int node)\n{\n\tstruct worker *worker;\n\n\tworker = kzalloc_node(sizeof(*worker), GFP_KERNEL, node);\n\tif (worker) {\n\t\tINIT_LIST_HEAD(&worker->entry);\n\t\tINIT_LIST_HEAD(&worker->scheduled);\n\t\tINIT_LIST_HEAD(&worker->node);\n\t\t/* on creation a worker is in !idle && prep state */\n\t\tworker->flags = WORKER_PREP;\n\t}\n\treturn worker;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ida_simple_get",
          "args": [
            "&pool->worker_ida",
            "0",
            "0",
            "GFP_KERNEL"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic struct worker *create_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = NULL;\n\tint id = -1;\n\tchar id_buf[16];\n\n\t/* ID is needed to determine kthread name */\n\tid = ida_simple_get(&pool->worker_ida, 0, 0, GFP_KERNEL);\n\tif (id < 0)\n\t\tgoto fail;\n\n\tworker = alloc_worker(pool->node);\n\tif (!worker)\n\t\tgoto fail;\n\n\tworker->id = id;\n\n\tif (pool->cpu >= 0)\n\t\tsnprintf(id_buf, sizeof(id_buf), \"%d:%d%s\", pool->cpu, id,\n\t\t\t pool->attrs->nice < 0  ? \"H\" : \"\");\n\telse\n\t\tsnprintf(id_buf, sizeof(id_buf), \"u%d:%d\", pool->id, id);\n\n\tworker->task = kthread_create_on_node(worker_thread, worker, pool->node,\n\t\t\t\t\t      \"kworker/%s\", id_buf);\n\tif (IS_ERR(worker->task))\n\t\tgoto fail;\n\n\tset_user_nice(worker->task, pool->attrs->nice);\n\tkthread_bind_mask(worker->task, pool->attrs->cpumask);\n\n\t/* successful, attach the worker to the pool */\n\tworker_attach_to_pool(worker, pool);\n\n\t/* start the newly created worker */\n\tspin_lock_irq(&pool->lock);\n\tworker->pool->nr_workers++;\n\tworker_enter_idle(worker);\n\twake_up_process(worker->task);\n\tspin_unlock_irq(&pool->lock);\n\n\treturn worker;\n\nfail:\n\tif (id >= 0)\n\t\tida_simple_remove(&pool->worker_ida, id);\n\tkfree(worker);\n\treturn NULL;\n}"
  },
  {
    "function_name": "worker_detach_from_pool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1757-1776",
    "snippet": "static void worker_detach_from_pool(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tstruct completion *detach_completion = NULL;\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\tlist_del(&worker->node);\n\tworker->pool = NULL;\n\n\tif (list_empty(&pool->workers))\n\t\tdetach_completion = pool->detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\t/* clear leftover flags without pool->lock after it is detached */\n\tworker->flags &= ~(WORKER_UNBOUND | WORKER_REBOUND);\n\n\tif (detach_completion)\n\t\tcomplete(detach_completion);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_attach_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "detach_completion"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1205-1216",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pool->workers"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&worker->node"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void worker_detach_from_pool(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tstruct completion *detach_completion = NULL;\n\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\tlist_del(&worker->node);\n\tworker->pool = NULL;\n\n\tif (list_empty(&pool->workers))\n\t\tdetach_completion = pool->detach_completion;\n\tmutex_unlock(&wq_pool_attach_mutex);\n\n\t/* clear leftover flags without pool->lock after it is detached */\n\tworker->flags &= ~(WORKER_UNBOUND | WORKER_REBOUND);\n\n\tif (detach_completion)\n\t\tcomplete(detach_completion);\n}"
  },
  {
    "function_name": "worker_attach_to_pool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1724-1747",
    "snippet": "static void worker_attach_to_pool(struct worker *worker,\n\t\t\t\t   struct worker_pool *pool)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\t/*\n\t * set_cpus_allowed_ptr() will fail if the cpumask doesn't have any\n\t * online CPUs.  It'll be re-applied when any of the CPUs come up.\n\t */\n\tset_cpus_allowed_ptr(worker->task, pool->attrs->cpumask);\n\n\t/*\n\t * The wq_pool_attach_mutex ensures %POOL_DISASSOCIATED remains\n\t * stable across this function.  See the comments above the flag\n\t * definition for details.\n\t */\n\tif (pool->flags & POOL_DISASSOCIATED)\n\t\tworker->flags |= WORKER_UNBOUND;\n\n\tlist_add_tail(&worker->node, &pool->workers);\n\tworker->pool = pool;\n\n\tmutex_unlock(&wq_pool_attach_mutex);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_attach_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&worker->node",
            "&pool->workers"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "worker->task",
            "pool->attrs->cpumask"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1126-1129",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, false);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&wq_pool_attach_mutex"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_attach_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void worker_attach_to_pool(struct worker *worker,\n\t\t\t\t   struct worker_pool *pool)\n{\n\tmutex_lock(&wq_pool_attach_mutex);\n\n\t/*\n\t * set_cpus_allowed_ptr() will fail if the cpumask doesn't have any\n\t * online CPUs.  It'll be re-applied when any of the CPUs come up.\n\t */\n\tset_cpus_allowed_ptr(worker->task, pool->attrs->cpumask);\n\n\t/*\n\t * The wq_pool_attach_mutex ensures %POOL_DISASSOCIATED remains\n\t * stable across this function.  See the comments above the flag\n\t * definition for details.\n\t */\n\tif (pool->flags & POOL_DISASSOCIATED)\n\t\tworker->flags |= WORKER_UNBOUND;\n\n\tlist_add_tail(&worker->node, &pool->workers);\n\tworker->pool = pool;\n\n\tmutex_unlock(&wq_pool_attach_mutex);\n}"
  },
  {
    "function_name": "alloc_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1700-1713",
    "snippet": "static struct worker *alloc_worker(int node)\n{\n\tstruct worker *worker;\n\n\tworker = kzalloc_node(sizeof(*worker), GFP_KERNEL, node);\n\tif (worker) {\n\t\tINIT_LIST_HEAD(&worker->entry);\n\t\tINIT_LIST_HEAD(&worker->scheduled);\n\t\tINIT_LIST_HEAD(&worker->node);\n\t\t/* on creation a worker is in !idle && prep state */\n\t\tworker->flags = WORKER_PREP;\n\t}\n\treturn worker;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&worker->node"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&worker->scheduled"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&worker->entry"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(*worker)",
            "GFP_KERNEL",
            "node"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct worker *alloc_worker(int node)\n{\n\tstruct worker *worker;\n\n\tworker = kzalloc_node(sizeof(*worker), GFP_KERNEL, node);\n\tif (worker) {\n\t\tINIT_LIST_HEAD(&worker->entry);\n\t\tINIT_LIST_HEAD(&worker->scheduled);\n\t\tINIT_LIST_HEAD(&worker->node);\n\t\t/* on creation a worker is in !idle && prep state */\n\t\tworker->flags = WORKER_PREP;\n\t}\n\treturn worker;\n}"
  },
  {
    "function_name": "worker_leave_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1689-1698",
    "snippet": "static void worker_leave_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\tworker_clr_flags(worker, WORKER_IDLE);\n\tpool->nr_idle--;\n\tlist_del_init(&worker->entry);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&worker->entry"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "worker_clr_flags",
          "args": [
            "worker",
            "WORKER_IDLE"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "worker_clr_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "947-964",
          "snippet": "static inline void worker_clr_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tunsigned int oflags = worker->flags;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\tworker->flags &= ~flags;\n\n\t/*\n\t * If transitioning out of NOT_RUNNING, increment nr_running.  Note\n\t * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask\n\t * of multiple flags, not a single flag.\n\t */\n\tif ((flags & WORKER_NOT_RUNNING) && (oflags & WORKER_NOT_RUNNING))\n\t\tif (!(worker->flags & WORKER_NOT_RUNNING))\n\t\t\tatomic_inc(&pool->nr_running);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic inline void worker_clr_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tunsigned int oflags = worker->flags;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\tworker->flags &= ~flags;\n\n\t/*\n\t * If transitioning out of NOT_RUNNING, increment nr_running.  Note\n\t * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask\n\t * of multiple flags, not a single flag.\n\t */\n\tif ((flags & WORKER_NOT_RUNNING) && (oflags & WORKER_NOT_RUNNING))\n\t\tif (!(worker->flags & WORKER_NOT_RUNNING))\n\t\t\tatomic_inc(&pool->nr_running);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(worker->flags & WORKER_IDLE)"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void worker_leave_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(!(worker->flags & WORKER_IDLE)))\n\t\treturn;\n\tworker_clr_flags(worker, WORKER_IDLE);\n\tpool->nr_idle--;\n\tlist_del_init(&worker->entry);\n}"
  },
  {
    "function_name": "worker_enter_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1649-1678",
    "snippet": "static void worker_enter_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(worker->flags & WORKER_IDLE) ||\n\t    WARN_ON_ONCE(!list_empty(&worker->entry) &&\n\t\t\t (worker->hentry.next || worker->hentry.pprev)))\n\t\treturn;\n\n\t/* can't use worker_set_flags(), also called from create_worker() */\n\tworker->flags |= WORKER_IDLE;\n\tpool->nr_idle++;\n\tworker->last_active = jiffies;\n\n\t/* idle_list is LIFO */\n\tlist_add(&worker->entry, &pool->idle_list);\n\n\tif (too_many_workers(pool) && !timer_pending(&pool->idle_timer))\n\t\tmod_timer(&pool->idle_timer, jiffies + IDLE_WORKER_TIMEOUT);\n\n\t/*\n\t * Sanity check nr_running.  Because unbind_workers() releases\n\t * pool->lock between setting %WORKER_UNBOUND and zapping\n\t * nr_running, the warning may trigger spuriously.  Check iff\n\t * unbind is not in progress.\n\t */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     pool->nr_workers == pool->nr_idle &&\n\t\t     atomic_read(&pool->nr_running));\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     pool->nr_workers == pool->nr_idle &&\n\t\t     atomic_read(&pool->nr_running)"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pool->nr_running"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&pool->idle_timer",
            "jiffies + IDLE_WORKER_TIMEOUT"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1100-1103",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "&pool->idle_timer"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "too_many_workers",
          "args": [
            "pool"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "too_many_workers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "802-809",
          "snippet": "static bool too_many_workers(struct worker_pool *pool)\n{\n\tbool managing = pool->flags & POOL_MANAGER_ACTIVE;\n\tint nr_idle = pool->nr_idle + managing; /* manager is considered idle */\n\tint nr_busy = pool->nr_workers - nr_idle;\n\n\treturn nr_idle > 2 && (nr_idle - 2) * MAX_IDLE_WORKERS_RATIO >= nr_busy;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool too_many_workers(struct worker_pool *pool)\n{\n\tbool managing = pool->flags & POOL_MANAGER_ACTIVE;\n\tint nr_idle = pool->nr_idle + managing; /* manager is considered idle */\n\tint nr_busy = pool->nr_workers - nr_idle;\n\n\treturn nr_idle > 2 && (nr_idle - 2) * MAX_IDLE_WORKERS_RATIO >= nr_busy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&worker->entry",
            "&pool->idle_list"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&worker->entry) &&\n\t\t\t (worker->hentry.next || worker->hentry.pprev)"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&worker->entry"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "worker->flags & WORKER_IDLE"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void worker_enter_idle(struct worker *worker)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tif (WARN_ON_ONCE(worker->flags & WORKER_IDLE) ||\n\t    WARN_ON_ONCE(!list_empty(&worker->entry) &&\n\t\t\t (worker->hentry.next || worker->hentry.pprev)))\n\t\treturn;\n\n\t/* can't use worker_set_flags(), also called from create_worker() */\n\tworker->flags |= WORKER_IDLE;\n\tpool->nr_idle++;\n\tworker->last_active = jiffies;\n\n\t/* idle_list is LIFO */\n\tlist_add(&worker->entry, &pool->idle_list);\n\n\tif (too_many_workers(pool) && !timer_pending(&pool->idle_timer))\n\t\tmod_timer(&pool->idle_timer, jiffies + IDLE_WORKER_TIMEOUT);\n\n\t/*\n\t * Sanity check nr_running.  Because unbind_workers() releases\n\t * pool->lock between setting %WORKER_UNBOUND and zapping\n\t * nr_running, the warning may trigger spuriously.  Check iff\n\t * unbind is not in progress.\n\t */\n\tWARN_ON_ONCE(!(pool->flags & POOL_DISASSOCIATED) &&\n\t\t     pool->nr_workers == pool->nr_idle &&\n\t\t     atomic_read(&pool->nr_running));\n}"
  },
  {
    "function_name": "queue_rcu_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1625-1636",
    "snippet": "bool queue_rcu_work(struct workqueue_struct *wq, struct rcu_work *rwork)\n{\n\tstruct work_struct *work = &rwork->work;\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\trwork->wq = wq;\n\t\tcall_rcu(&rwork->rcu, rcu_work_rcufn);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&rwork->rcu",
            "rcu_work_rcufn"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "WORK_STRUCT_PENDING_BIT",
            "work_data_bits(work)"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_rcu_work(struct workqueue_struct *wq, struct rcu_work *rwork)\n{\n\tstruct work_struct *work = &rwork->work;\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\trwork->wq = wq;\n\t\tcall_rcu(&rwork->rcu, rcu_work_rcufn);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "rcu_work_rcufn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1605-1613",
    "snippet": "static void rcu_work_rcufn(struct rcu_head *rcu)\n{\n\tstruct rcu_work *rwork = container_of(rcu, struct rcu_work, rcu);\n\n\t/* read the comment in __queue_work() */\n\tlocal_irq_disable();\n\t__queue_work(WORK_CPU_UNBOUND, rwork->wq, &rwork->work);\n\tlocal_irq_enable();\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__queue_work",
          "args": [
            "WORK_CPU_UNBOUND",
            "rwork->wq",
            "&rwork->work"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1363-1464",
          "snippet": "static void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\tdebug_work_activate(work);\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\nretry:\n\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\telse\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\tspin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\tspin_unlock(&last_pool->lock);\n\t\t\tspin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\tspin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\tspin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry))) {\n\t\tspin_unlock(&pwq->pool->lock);\n\t\treturn;\n\t}\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_DELAYED;\n\t\tworklist = &pwq->delayed_works;\n\t}\n\n\tinsert_work(pwq, work, worklist, work_flags);\n\n\tspin_unlock(&pwq->pool->lock);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\tdebug_work_activate(work);\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\nretry:\n\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\telse\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\tspin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\tspin_unlock(&last_pool->lock);\n\t\t\tspin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\tspin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\tspin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry))) {\n\t\tspin_unlock(&pwq->pool->lock);\n\t\treturn;\n\t}\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_DELAYED;\n\t\tworklist = &pwq->delayed_works;\n\t}\n\n\tinsert_work(pwq, work, worklist, work_flags);\n\n\tspin_unlock(&pwq->pool->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structrcu_work",
            "rcu"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void rcu_work_rcufn(struct rcu_head *rcu)\n{\n\tstruct rcu_work *rwork = container_of(rcu, struct rcu_work, rcu);\n\n\t/* read the comment in __queue_work() */\n\tlocal_irq_disable();\n\t__queue_work(WORK_CPU_UNBOUND, rwork->wq, &rwork->work);\n\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "mod_delayed_work_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1585-1602",
    "snippet": "bool mod_delayed_work_on(int cpu, struct workqueue_struct *wq,\n\t\t\t struct delayed_work *dwork, unsigned long delay)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(&dwork->work, true, &flags);\n\t} while (unlikely(ret == -EAGAIN));\n\n\tif (likely(ret >= 0)) {\n\t\t__queue_delayed_work(cpu, wq, dwork, delay);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\t/* -ENOENT from try_to_grab_pending() becomes %true */\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__queue_delayed_work",
          "args": [
            "cpu",
            "wq",
            "dwork",
            "delay"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1504-1534",
          "snippet": "static void __queue_delayed_work(int cpu, struct workqueue_struct *wq,\n\t\t\t\tstruct delayed_work *dwork, unsigned long delay)\n{\n\tstruct timer_list *timer = &dwork->timer;\n\tstruct work_struct *work = &dwork->work;\n\n\tWARN_ON_ONCE(!wq);\n\tWARN_ON_ONCE(timer->function != delayed_work_timer_fn);\n\tWARN_ON_ONCE(timer_pending(timer));\n\tWARN_ON_ONCE(!list_empty(&work->entry));\n\n\t/*\n\t * If @delay is 0, queue @dwork->work immediately.  This is for\n\t * both optimization and correctness.  The earliest @timer can\n\t * expire is on the closest next tick and delayed_work users depend\n\t * on that there's no such delay when @delay is 0.\n\t */\n\tif (!delay) {\n\t\t__queue_work(cpu, wq, &dwork->work);\n\t\treturn;\n\t}\n\n\tdwork->wq = wq;\n\tdwork->cpu = cpu;\n\ttimer->expires = jiffies + delay;\n\n\tif (unlikely(cpu != WORK_CPU_UNBOUND))\n\t\tadd_timer_on(timer, cpu);\n\telse\n\t\tadd_timer(timer);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void __queue_delayed_work(int cpu, struct workqueue_struct *wq,\n\t\t\t\tstruct delayed_work *dwork, unsigned long delay)\n{\n\tstruct timer_list *timer = &dwork->timer;\n\tstruct work_struct *work = &dwork->work;\n\n\tWARN_ON_ONCE(!wq);\n\tWARN_ON_ONCE(timer->function != delayed_work_timer_fn);\n\tWARN_ON_ONCE(timer_pending(timer));\n\tWARN_ON_ONCE(!list_empty(&work->entry));\n\n\t/*\n\t * If @delay is 0, queue @dwork->work immediately.  This is for\n\t * both optimization and correctness.  The earliest @timer can\n\t * expire is on the closest next tick and delayed_work users depend\n\t * on that there's no such delay when @delay is 0.\n\t */\n\tif (!delay) {\n\t\t__queue_work(cpu, wq, &dwork->work);\n\t\treturn;\n\t}\n\n\tdwork->wq = wq;\n\tdwork->cpu = cpu;\n\ttimer->expires = jiffies + delay;\n\n\tif (unlikely(cpu != WORK_CPU_UNBOUND))\n\t\tadd_timer_on(timer, cpu);\n\telse\n\t\tadd_timer(timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ret >= 0"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == -EAGAIN"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_grab_pending",
          "args": [
            "&dwork->work",
            "true",
            "&flags"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_grab_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1206-1278",
          "snippet": "static int try_to_grab_pending(struct work_struct *work, bool is_dwork,\n\t\t\t       unsigned long *flags)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlocal_irq_save(*flags);\n\n\t/* try to steal the timer if it exists */\n\tif (is_dwork) {\n\t\tstruct delayed_work *dwork = to_delayed_work(work);\n\n\t\t/*\n\t\t * dwork->timer is irqsafe.  If del_timer() fails, it's\n\t\t * guaranteed that the timer is not queued anywhere and not\n\t\t * running on the local CPU.\n\t\t */\n\t\tif (likely(del_timer(&dwork->timer)))\n\t\t\treturn 1;\n\t}\n\n\t/* try to claim PENDING the normal way */\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work)))\n\t\treturn 0;\n\n\t/*\n\t * The queueing is in progress, or it is already queued. Try to\n\t * steal it from ->worklist without clearing WORK_STRUCT_PENDING.\n\t */\n\tpool = get_work_pool(work);\n\tif (!pool)\n\t\tgoto fail;\n\n\tspin_lock(&pool->lock);\n\t/*\n\t * work->data is guaranteed to point to pwq only while the work\n\t * item is queued on pwq->wq, and both updating work->data to point\n\t * to pwq on queueing and to pool on dequeueing are done under\n\t * pwq->pool->lock.  This in turn guarantees that, if work->data\n\t * points to pwq which is associated with a locked pool, the work\n\t * item is currently queued on that pool.\n\t */\n\tpwq = get_work_pwq(work);\n\tif (pwq && pwq->pool == pool) {\n\t\tdebug_work_deactivate(work);\n\n\t\t/*\n\t\t * A delayed work item cannot be grabbed directly because\n\t\t * it might have linked NO_COLOR work items which, if left\n\t\t * on the delayed_list, will confuse pwq->nr_active\n\t\t * management later on and cause stall.  Make sure the work\n\t\t * item is activated before grabbing.\n\t\t */\n\t\tif (*work_data_bits(work) & WORK_STRUCT_DELAYED)\n\t\t\tpwq_activate_delayed_work(work);\n\n\t\tlist_del_init(&work->entry);\n\t\tpwq_dec_nr_in_flight(pwq, get_work_color(work));\n\n\t\t/* work->data points to pwq iff queued, point to pool */\n\t\tset_work_pool_and_keep_pending(work, pool->id);\n\n\t\tspin_unlock(&pool->lock);\n\t\treturn 1;\n\t}\n\tspin_unlock(&pool->lock);\nfail:\n\tlocal_irq_restore(*flags);\n\tif (work_is_canceling(work))\n\t\treturn -ENOENT;\n\tcpu_relax();\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int try_to_grab_pending(struct work_struct *work, bool is_dwork,\n\t\t\t       unsigned long *flags)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlocal_irq_save(*flags);\n\n\t/* try to steal the timer if it exists */\n\tif (is_dwork) {\n\t\tstruct delayed_work *dwork = to_delayed_work(work);\n\n\t\t/*\n\t\t * dwork->timer is irqsafe.  If del_timer() fails, it's\n\t\t * guaranteed that the timer is not queued anywhere and not\n\t\t * running on the local CPU.\n\t\t */\n\t\tif (likely(del_timer(&dwork->timer)))\n\t\t\treturn 1;\n\t}\n\n\t/* try to claim PENDING the normal way */\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work)))\n\t\treturn 0;\n\n\t/*\n\t * The queueing is in progress, or it is already queued. Try to\n\t * steal it from ->worklist without clearing WORK_STRUCT_PENDING.\n\t */\n\tpool = get_work_pool(work);\n\tif (!pool)\n\t\tgoto fail;\n\n\tspin_lock(&pool->lock);\n\t/*\n\t * work->data is guaranteed to point to pwq only while the work\n\t * item is queued on pwq->wq, and both updating work->data to point\n\t * to pwq on queueing and to pool on dequeueing are done under\n\t * pwq->pool->lock.  This in turn guarantees that, if work->data\n\t * points to pwq which is associated with a locked pool, the work\n\t * item is currently queued on that pool.\n\t */\n\tpwq = get_work_pwq(work);\n\tif (pwq && pwq->pool == pool) {\n\t\tdebug_work_deactivate(work);\n\n\t\t/*\n\t\t * A delayed work item cannot be grabbed directly because\n\t\t * it might have linked NO_COLOR work items which, if left\n\t\t * on the delayed_list, will confuse pwq->nr_active\n\t\t * management later on and cause stall.  Make sure the work\n\t\t * item is activated before grabbing.\n\t\t */\n\t\tif (*work_data_bits(work) & WORK_STRUCT_DELAYED)\n\t\t\tpwq_activate_delayed_work(work);\n\n\t\tlist_del_init(&work->entry);\n\t\tpwq_dec_nr_in_flight(pwq, get_work_color(work));\n\n\t\t/* work->data points to pwq iff queued, point to pool */\n\t\tset_work_pool_and_keep_pending(work, pool->id);\n\n\t\tspin_unlock(&pool->lock);\n\t\treturn 1;\n\t}\n\tspin_unlock(&pool->lock);\nfail:\n\tlocal_irq_restore(*flags);\n\tif (work_is_canceling(work))\n\t\treturn -ENOENT;\n\tcpu_relax();\n\treturn -EAGAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool mod_delayed_work_on(int cpu, struct workqueue_struct *wq,\n\t\t\t struct delayed_work *dwork, unsigned long delay)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tret = try_to_grab_pending(&dwork->work, true, &flags);\n\t} while (unlikely(ret == -EAGAIN));\n\n\tif (likely(ret >= 0)) {\n\t\t__queue_delayed_work(cpu, wq, dwork, delay);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\t/* -ENOENT from try_to_grab_pending() becomes %true */\n\treturn ret;\n}"
  },
  {
    "function_name": "queue_delayed_work_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1547-1564",
    "snippet": "bool queue_delayed_work_on(int cpu, struct workqueue_struct *wq,\n\t\t\t   struct delayed_work *dwork, unsigned long delay)\n{\n\tstruct work_struct *work = &dwork->work;\n\tbool ret = false;\n\tunsigned long flags;\n\n\t/* read the comment in __queue_work() */\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_delayed_work(cpu, wq, dwork, delay);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__queue_delayed_work",
          "args": [
            "cpu",
            "wq",
            "dwork",
            "delay"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1504-1534",
          "snippet": "static void __queue_delayed_work(int cpu, struct workqueue_struct *wq,\n\t\t\t\tstruct delayed_work *dwork, unsigned long delay)\n{\n\tstruct timer_list *timer = &dwork->timer;\n\tstruct work_struct *work = &dwork->work;\n\n\tWARN_ON_ONCE(!wq);\n\tWARN_ON_ONCE(timer->function != delayed_work_timer_fn);\n\tWARN_ON_ONCE(timer_pending(timer));\n\tWARN_ON_ONCE(!list_empty(&work->entry));\n\n\t/*\n\t * If @delay is 0, queue @dwork->work immediately.  This is for\n\t * both optimization and correctness.  The earliest @timer can\n\t * expire is on the closest next tick and delayed_work users depend\n\t * on that there's no such delay when @delay is 0.\n\t */\n\tif (!delay) {\n\t\t__queue_work(cpu, wq, &dwork->work);\n\t\treturn;\n\t}\n\n\tdwork->wq = wq;\n\tdwork->cpu = cpu;\n\ttimer->expires = jiffies + delay;\n\n\tif (unlikely(cpu != WORK_CPU_UNBOUND))\n\t\tadd_timer_on(timer, cpu);\n\telse\n\t\tadd_timer(timer);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void __queue_delayed_work(int cpu, struct workqueue_struct *wq,\n\t\t\t\tstruct delayed_work *dwork, unsigned long delay)\n{\n\tstruct timer_list *timer = &dwork->timer;\n\tstruct work_struct *work = &dwork->work;\n\n\tWARN_ON_ONCE(!wq);\n\tWARN_ON_ONCE(timer->function != delayed_work_timer_fn);\n\tWARN_ON_ONCE(timer_pending(timer));\n\tWARN_ON_ONCE(!list_empty(&work->entry));\n\n\t/*\n\t * If @delay is 0, queue @dwork->work immediately.  This is for\n\t * both optimization and correctness.  The earliest @timer can\n\t * expire is on the closest next tick and delayed_work users depend\n\t * on that there's no such delay when @delay is 0.\n\t */\n\tif (!delay) {\n\t\t__queue_work(cpu, wq, &dwork->work);\n\t\treturn;\n\t}\n\n\tdwork->wq = wq;\n\tdwork->cpu = cpu;\n\ttimer->expires = jiffies + delay;\n\n\tif (unlikely(cpu != WORK_CPU_UNBOUND))\n\t\tadd_timer_on(timer, cpu);\n\telse\n\t\tadd_timer(timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "WORK_STRUCT_PENDING_BIT",
            "work_data_bits(work)"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_delayed_work_on(int cpu, struct workqueue_struct *wq,\n\t\t\t   struct delayed_work *dwork, unsigned long delay)\n{\n\tstruct work_struct *work = &dwork->work;\n\tbool ret = false;\n\tunsigned long flags;\n\n\t/* read the comment in __queue_work() */\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_delayed_work(cpu, wq, dwork, delay);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "__queue_delayed_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1504-1534",
    "snippet": "static void __queue_delayed_work(int cpu, struct workqueue_struct *wq,\n\t\t\t\tstruct delayed_work *dwork, unsigned long delay)\n{\n\tstruct timer_list *timer = &dwork->timer;\n\tstruct work_struct *work = &dwork->work;\n\n\tWARN_ON_ONCE(!wq);\n\tWARN_ON_ONCE(timer->function != delayed_work_timer_fn);\n\tWARN_ON_ONCE(timer_pending(timer));\n\tWARN_ON_ONCE(!list_empty(&work->entry));\n\n\t/*\n\t * If @delay is 0, queue @dwork->work immediately.  This is for\n\t * both optimization and correctness.  The earliest @timer can\n\t * expire is on the closest next tick and delayed_work users depend\n\t * on that there's no such delay when @delay is 0.\n\t */\n\tif (!delay) {\n\t\t__queue_work(cpu, wq, &dwork->work);\n\t\treturn;\n\t}\n\n\tdwork->wq = wq;\n\tdwork->cpu = cpu;\n\ttimer->expires = jiffies + delay;\n\n\tif (unlikely(cpu != WORK_CPU_UNBOUND))\n\t\tadd_timer_on(timer, cpu);\n\telse\n\t\tadd_timer(timer);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_timer",
          "args": [
            "timer"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "add_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1135-1139",
          "snippet": "void add_timer(struct timer_list *timer)\n{\n\tBUG_ON(timer_pending(timer));\n\tmod_timer(timer, timer->expires);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid add_timer(struct timer_list *timer)\n{\n\tBUG_ON(timer_pending(timer));\n\tmod_timer(timer, timer->expires);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_timer_on",
          "args": [
            "timer",
            "cpu"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "add_timer_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1149-1178",
          "snippet": "void add_timer_on(struct timer_list *timer, int cpu)\n{\n\tstruct timer_base *new_base, *base;\n\tunsigned long flags;\n\n\tBUG_ON(timer_pending(timer) || !timer->function);\n\n\tnew_base = get_timer_cpu_base(timer->flags, cpu);\n\n\t/*\n\t * If @timer was on a different CPU, it should be migrated with the\n\t * old base locked to prevent other operations proceeding with the\n\t * wrong base locked.  See lock_timer_base().\n\t */\n\tbase = lock_timer_base(timer, &flags);\n\tif (base != new_base) {\n\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\traw_spin_unlock(&base->lock);\n\t\tbase = new_base;\n\t\traw_spin_lock(&base->lock);\n\t\tWRITE_ONCE(timer->flags,\n\t\t\t   (timer->flags & ~TIMER_BASEMASK) | cpu);\n\t}\n\tforward_timer_base(base);\n\n\tdebug_activate(timer, timer->expires);\n\tinternal_add_timer(base, timer);\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid add_timer_on(struct timer_list *timer, int cpu)\n{\n\tstruct timer_base *new_base, *base;\n\tunsigned long flags;\n\n\tBUG_ON(timer_pending(timer) || !timer->function);\n\n\tnew_base = get_timer_cpu_base(timer->flags, cpu);\n\n\t/*\n\t * If @timer was on a different CPU, it should be migrated with the\n\t * old base locked to prevent other operations proceeding with the\n\t * wrong base locked.  See lock_timer_base().\n\t */\n\tbase = lock_timer_base(timer, &flags);\n\tif (base != new_base) {\n\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\traw_spin_unlock(&base->lock);\n\t\tbase = new_base;\n\t\traw_spin_lock(&base->lock);\n\t\tWRITE_ONCE(timer->flags,\n\t\t\t   (timer->flags & ~TIMER_BASEMASK) | cpu);\n\t}\n\tforward_timer_base(base);\n\n\tdebug_activate(timer, timer->expires);\n\tinternal_add_timer(base, timer);\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cpu != WORK_CPU_UNBOUND"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__queue_work",
          "args": [
            "cpu",
            "wq",
            "&dwork->work"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1363-1464",
          "snippet": "static void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\tdebug_work_activate(work);\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\nretry:\n\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\telse\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\tspin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\tspin_unlock(&last_pool->lock);\n\t\t\tspin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\tspin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\tspin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry))) {\n\t\tspin_unlock(&pwq->pool->lock);\n\t\treturn;\n\t}\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_DELAYED;\n\t\tworklist = &pwq->delayed_works;\n\t}\n\n\tinsert_work(pwq, work, worklist, work_flags);\n\n\tspin_unlock(&pwq->pool->lock);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\tdebug_work_activate(work);\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\nretry:\n\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\telse\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\tspin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\tspin_unlock(&last_pool->lock);\n\t\t\tspin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\tspin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\tspin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry))) {\n\t\tspin_unlock(&pwq->pool->lock);\n\t\treturn;\n\t}\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_DELAYED;\n\t\tworklist = &pwq->delayed_works;\n\t}\n\n\tinsert_work(pwq, work, worklist, work_flags);\n\n\tspin_unlock(&pwq->pool->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&work->entry)"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&work->entry"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "timer_pending(timer)"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "timer"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "timer->function != delayed_work_timer_fn"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!wq"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void __queue_delayed_work(int cpu, struct workqueue_struct *wq,\n\t\t\t\tstruct delayed_work *dwork, unsigned long delay)\n{\n\tstruct timer_list *timer = &dwork->timer;\n\tstruct work_struct *work = &dwork->work;\n\n\tWARN_ON_ONCE(!wq);\n\tWARN_ON_ONCE(timer->function != delayed_work_timer_fn);\n\tWARN_ON_ONCE(timer_pending(timer));\n\tWARN_ON_ONCE(!list_empty(&work->entry));\n\n\t/*\n\t * If @delay is 0, queue @dwork->work immediately.  This is for\n\t * both optimization and correctness.  The earliest @timer can\n\t * expire is on the closest next tick and delayed_work users depend\n\t * on that there's no such delay when @delay is 0.\n\t */\n\tif (!delay) {\n\t\t__queue_work(cpu, wq, &dwork->work);\n\t\treturn;\n\t}\n\n\tdwork->wq = wq;\n\tdwork->cpu = cpu;\n\ttimer->expires = jiffies + delay;\n\n\tif (unlikely(cpu != WORK_CPU_UNBOUND))\n\t\tadd_timer_on(timer, cpu);\n\telse\n\t\tadd_timer(timer);\n}"
  },
  {
    "function_name": "delayed_work_timer_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1495-1501",
    "snippet": "void delayed_work_timer_fn(struct timer_list *t)\n{\n\tstruct delayed_work *dwork = from_timer(dwork, t, timer);\n\n\t/* should have been called from irqsafe timer with irq already off */\n\t__queue_work(dwork->cpu, dwork->wq, &dwork->work);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__queue_work",
          "args": [
            "dwork->cpu",
            "dwork->wq",
            "&dwork->work"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1363-1464",
          "snippet": "static void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\tdebug_work_activate(work);\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\nretry:\n\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\telse\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\tspin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\tspin_unlock(&last_pool->lock);\n\t\t\tspin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\tspin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\tspin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry))) {\n\t\tspin_unlock(&pwq->pool->lock);\n\t\treturn;\n\t}\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_DELAYED;\n\t\tworklist = &pwq->delayed_works;\n\t}\n\n\tinsert_work(pwq, work, worklist, work_flags);\n\n\tspin_unlock(&pwq->pool->lock);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\tdebug_work_activate(work);\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\nretry:\n\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\telse\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\tspin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\tspin_unlock(&last_pool->lock);\n\t\t\tspin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\tspin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\tspin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry))) {\n\t\tspin_unlock(&pwq->pool->lock);\n\t\treturn;\n\t}\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_DELAYED;\n\t\tworklist = &pwq->delayed_works;\n\t}\n\n\tinsert_work(pwq, work, worklist, work_flags);\n\n\tspin_unlock(&pwq->pool->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_timer",
          "args": [
            "dwork",
            "t",
            "timer"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid delayed_work_timer_fn(struct timer_list *t)\n{\n\tstruct delayed_work *dwork = from_timer(dwork, t, timer);\n\n\t/* should have been called from irqsafe timer with irq already off */\n\t__queue_work(dwork->cpu, dwork->wq, &dwork->work);\n}"
  },
  {
    "function_name": "queue_work_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1477-1492",
    "snippet": "bool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__queue_work",
          "args": [
            "cpu",
            "wq",
            "work"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1363-1464",
          "snippet": "static void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\tdebug_work_activate(work);\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\nretry:\n\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\telse\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\tspin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\tspin_unlock(&last_pool->lock);\n\t\t\tspin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\tspin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\tspin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry))) {\n\t\tspin_unlock(&pwq->pool->lock);\n\t\treturn;\n\t}\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_DELAYED;\n\t\tworklist = &pwq->delayed_works;\n\t}\n\n\tinsert_work(pwq, work, worklist, work_flags);\n\n\tspin_unlock(&pwq->pool->lock);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\tdebug_work_activate(work);\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\nretry:\n\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\telse\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\tspin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\tspin_unlock(&last_pool->lock);\n\t\t\tspin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\tspin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\tspin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry))) {\n\t\tspin_unlock(&pwq->pool->lock);\n\t\treturn;\n\t}\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_DELAYED;\n\t\tworklist = &pwq->delayed_works;\n\t}\n\n\tinsert_work(pwq, work, worklist, work_flags);\n\n\tspin_unlock(&pwq->pool->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "WORK_STRUCT_PENDING_BIT",
            "work_data_bits(work)"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "__queue_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1363-1464",
    "snippet": "static void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\tdebug_work_activate(work);\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\nretry:\n\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\telse\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\tspin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\tspin_unlock(&last_pool->lock);\n\t\t\tspin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\tspin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\tspin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry))) {\n\t\tspin_unlock(&pwq->pool->lock);\n\t\treturn;\n\t}\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_DELAYED;\n\t\tworklist = &pwq->delayed_works;\n\t}\n\n\tinsert_work(pwq, work, worklist, work_flags);\n\n\tspin_unlock(&pwq->pool->lock);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pwq->pool->lock"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_work",
          "args": [
            "pwq",
            "work",
            "worklist",
            "work_flags"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "insert_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1293-1312",
          "snippet": "static void insert_work(struct pool_workqueue *pwq, struct work_struct *work,\n\t\t\tstruct list_head *head, unsigned int extra_flags)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\n\t/* we own @work, set data and link */\n\tset_work_pwq(work, pwq, extra_flags);\n\tlist_add_tail(&work->entry, head);\n\tget_pwq(pwq);\n\n\t/*\n\t * Ensure either wq_worker_sleeping() sees the above\n\t * list_add_tail() or we see zero nr_running to avoid workers lying\n\t * around lazily while there are works to be processed.\n\t */\n\tsmp_mb();\n\n\tif (__need_more_worker(pool))\n\t\twake_up_worker(pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void insert_work(struct pool_workqueue *pwq, struct work_struct *work,\n\t\t\tstruct list_head *head, unsigned int extra_flags)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\n\t/* we own @work, set data and link */\n\tset_work_pwq(work, pwq, extra_flags);\n\tlist_add_tail(&work->entry, head);\n\tget_pwq(pwq);\n\n\t/*\n\t * Ensure either wq_worker_sleeping() sees the above\n\t * list_add_tail() or we see zero nr_running to avoid workers lying\n\t * around lazily while there are works to be processed.\n\t */\n\tsmp_mb();\n\n\tif (__need_more_worker(pool))\n\t\twake_up_worker(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "worklist"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_workqueue_activate_work",
          "args": [
            "work"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "pwq->nr_active < pwq->max_active"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_color_to_flags",
          "args": [
            "pwq->work_color"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "work_color_to_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "577-580",
          "snippet": "static unsigned int work_color_to_flags(int color)\n{\n\treturn color << WORK_STRUCT_COLOR_SHIFT;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic unsigned int work_color_to_flags(int color)\n{\n\treturn color << WORK_STRUCT_COLOR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&work->entry)"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_workqueue_queue_work",
          "args": [
            "req_cpu",
            "pwq",
            "work"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "true",
            "\"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\"",
            "wq->name",
            "cpu"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pwq->refcnt"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pwq->pool->lock"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_worker_executing_work",
          "args": [
            "last_pool",
            "work"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "find_worker_executing_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "999-1011",
          "snippet": "static struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_work_pool",
          "args": [
            "work"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pool_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "732-741",
          "snippet": "static int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unbound_pwq_by_node",
          "args": [
            "wq",
            "cpu_to_node(cpu)"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "unbound_pwq_by_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "560-575",
          "snippet": "static struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "wq->cpu_pwqs",
            "cpu"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wq_select_unbound_cpu",
          "args": [
            "raw_smp_processor_id()"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "wq_select_unbound_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1335-1361",
          "snippet": "static int wq_select_unbound_cpu(int cpu)\n{\n\tstatic bool printed_dbg_warning;\n\tint new_cpu;\n\n\tif (likely(!wq_debug_force_rr_cpu)) {\n\t\tif (cpumask_test_cpu(cpu, wq_unbound_cpumask))\n\t\t\treturn cpu;\n\t} else if (!printed_dbg_warning) {\n\t\tpr_warn(\"workqueue: round-robin CPU selection forced, expect performance impact\\n\");\n\t\tprinted_dbg_warning = true;\n\t}\n\n\tif (cpumask_empty(wq_unbound_cpumask))\n\t\treturn cpu;\n\n\tnew_cpu = __this_cpu_read(wq_rr_cpu_last);\n\tnew_cpu = cpumask_next_and(new_cpu, wq_unbound_cpumask, cpu_online_mask);\n\tif (unlikely(new_cpu >= nr_cpu_ids)) {\n\t\tnew_cpu = cpumask_first_and(wq_unbound_cpumask, cpu_online_mask);\n\t\tif (unlikely(new_cpu >= nr_cpu_ids))\n\t\t\treturn cpu;\n\t}\n\t__this_cpu_write(wq_rr_cpu_last, new_cpu);\n\n\treturn new_cpu;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t wq_unbound_cpumask;",
            "static DEFINE_PER_CPU(int, wq_rr_cpu_last);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t wq_unbound_cpumask;\nstatic DEFINE_PER_CPU(int, wq_rr_cpu_last);\n\nstatic int wq_select_unbound_cpu(int cpu)\n{\n\tstatic bool printed_dbg_warning;\n\tint new_cpu;\n\n\tif (likely(!wq_debug_force_rr_cpu)) {\n\t\tif (cpumask_test_cpu(cpu, wq_unbound_cpumask))\n\t\t\treturn cpu;\n\t} else if (!printed_dbg_warning) {\n\t\tpr_warn(\"workqueue: round-robin CPU selection forced, expect performance impact\\n\");\n\t\tprinted_dbg_warning = true;\n\t}\n\n\tif (cpumask_empty(wq_unbound_cpumask))\n\t\treturn cpu;\n\n\tnew_cpu = __this_cpu_read(wq_rr_cpu_last);\n\tnew_cpu = cpumask_next_and(new_cpu, wq_unbound_cpumask, cpu_online_mask);\n\tif (unlikely(new_cpu >= nr_cpu_ids)) {\n\t\tnew_cpu = cpumask_first_and(wq_unbound_cpumask, cpu_online_mask);\n\t\tif (unlikely(new_cpu >= nr_cpu_ids))\n\t\t\treturn cpu;\n\t}\n\t__this_cpu_write(wq_rr_cpu_last, new_cpu);\n\n\treturn new_cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!is_chained_work(wq)"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_chained_work",
          "args": [
            "wq"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "is_chained_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1318-1328",
          "snippet": "static bool is_chained_work(struct workqueue_struct *wq)\n{\n\tstruct worker *worker;\n\n\tworker = current_wq_worker();\n\t/*\n\t * Return %true iff I'm a worker execuing a work item on @wq.  If\n\t * I'm @worker, it's safe to dereference it without locking.\n\t */\n\treturn worker && worker->current_pwq->wq == wq;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic bool is_chained_work(struct workqueue_struct *wq)\n{\n\tstruct worker *worker;\n\n\tworker = current_wq_worker();\n\t/*\n\t * Return %true iff I'm a worker execuing a work item on @wq.  If\n\t * I'm @worker, it's safe to dereference it without locking.\n\t */\n\treturn worker && worker->current_pwq->wq == wq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "wq->flags & __WQ_DRAINING"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_work_activate",
          "args": [
            "work"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "debug_work_activate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "522-522",
          "snippet": "static inline void debug_work_activate(struct work_struct *work) { }",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void debug_work_activate(struct work_struct *work) { }"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void __queue_work(int cpu, struct workqueue_struct *wq,\n\t\t\t struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq;\n\tstruct worker_pool *last_pool;\n\tstruct list_head *worklist;\n\tunsigned int work_flags;\n\tunsigned int req_cpu = cpu;\n\n\t/*\n\t * While a work item is PENDING && off queue, a task trying to\n\t * steal the PENDING will busy-loop waiting for it to either get\n\t * queued or lose PENDING.  Grabbing PENDING and queueing should\n\t * happen with IRQ disabled.\n\t */\n\tlockdep_assert_irqs_disabled();\n\n\tdebug_work_activate(work);\n\n\t/* if draining, only works from the same workqueue are allowed */\n\tif (unlikely(wq->flags & __WQ_DRAINING) &&\n\t    WARN_ON_ONCE(!is_chained_work(wq)))\n\t\treturn;\nretry:\n\tif (req_cpu == WORK_CPU_UNBOUND)\n\t\tcpu = wq_select_unbound_cpu(raw_smp_processor_id());\n\n\t/* pwq which will be used unless @work is executing elsewhere */\n\tif (!(wq->flags & WQ_UNBOUND))\n\t\tpwq = per_cpu_ptr(wq->cpu_pwqs, cpu);\n\telse\n\t\tpwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));\n\n\t/*\n\t * If @work was previously on a different pool, it might still be\n\t * running there, in which case the work needs to be queued on that\n\t * pool to guarantee non-reentrancy.\n\t */\n\tlast_pool = get_work_pool(work);\n\tif (last_pool && last_pool != pwq->pool) {\n\t\tstruct worker *worker;\n\n\t\tspin_lock(&last_pool->lock);\n\n\t\tworker = find_worker_executing_work(last_pool, work);\n\n\t\tif (worker && worker->current_pwq->wq == wq) {\n\t\t\tpwq = worker->current_pwq;\n\t\t} else {\n\t\t\t/* meh... not running there, queue here */\n\t\t\tspin_unlock(&last_pool->lock);\n\t\t\tspin_lock(&pwq->pool->lock);\n\t\t}\n\t} else {\n\t\tspin_lock(&pwq->pool->lock);\n\t}\n\n\t/*\n\t * pwq is determined and locked.  For unbound pools, we could have\n\t * raced with pwq release and it could already be dead.  If its\n\t * refcnt is zero, repeat pwq selection.  Note that pwqs never die\n\t * without another pwq replacing it in the numa_pwq_tbl or while\n\t * work items are executing on it, so the retrying is guaranteed to\n\t * make forward-progress.\n\t */\n\tif (unlikely(!pwq->refcnt)) {\n\t\tif (wq->flags & WQ_UNBOUND) {\n\t\t\tspin_unlock(&pwq->pool->lock);\n\t\t\tcpu_relax();\n\t\t\tgoto retry;\n\t\t}\n\t\t/* oops */\n\t\tWARN_ONCE(true, \"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\",\n\t\t\t  wq->name, cpu);\n\t}\n\n\t/* pwq determined, queue */\n\ttrace_workqueue_queue_work(req_cpu, pwq, work);\n\n\tif (WARN_ON(!list_empty(&work->entry))) {\n\t\tspin_unlock(&pwq->pool->lock);\n\t\treturn;\n\t}\n\n\tpwq->nr_in_flight[pwq->work_color]++;\n\twork_flags = work_color_to_flags(pwq->work_color);\n\n\tif (likely(pwq->nr_active < pwq->max_active)) {\n\t\ttrace_workqueue_activate_work(work);\n\t\tpwq->nr_active++;\n\t\tworklist = &pwq->pool->worklist;\n\t\tif (list_empty(worklist))\n\t\t\tpwq->pool->watchdog_ts = jiffies;\n\t} else {\n\t\twork_flags |= WORK_STRUCT_DELAYED;\n\t\tworklist = &pwq->delayed_works;\n\t}\n\n\tinsert_work(pwq, work, worklist, work_flags);\n\n\tspin_unlock(&pwq->pool->lock);\n}"
  },
  {
    "function_name": "wq_select_unbound_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1335-1361",
    "snippet": "static int wq_select_unbound_cpu(int cpu)\n{\n\tstatic bool printed_dbg_warning;\n\tint new_cpu;\n\n\tif (likely(!wq_debug_force_rr_cpu)) {\n\t\tif (cpumask_test_cpu(cpu, wq_unbound_cpumask))\n\t\t\treturn cpu;\n\t} else if (!printed_dbg_warning) {\n\t\tpr_warn(\"workqueue: round-robin CPU selection forced, expect performance impact\\n\");\n\t\tprinted_dbg_warning = true;\n\t}\n\n\tif (cpumask_empty(wq_unbound_cpumask))\n\t\treturn cpu;\n\n\tnew_cpu = __this_cpu_read(wq_rr_cpu_last);\n\tnew_cpu = cpumask_next_and(new_cpu, wq_unbound_cpumask, cpu_online_mask);\n\tif (unlikely(new_cpu >= nr_cpu_ids)) {\n\t\tnew_cpu = cpumask_first_and(wq_unbound_cpumask, cpu_online_mask);\n\t\tif (unlikely(new_cpu >= nr_cpu_ids))\n\t\t\treturn cpu;\n\t}\n\t__this_cpu_write(wq_rr_cpu_last, new_cpu);\n\n\treturn new_cpu;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static cpumask_var_t wq_unbound_cpumask;",
      "static DEFINE_PER_CPU(int, wq_rr_cpu_last);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "wq_rr_cpu_last",
            "new_cpu"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "new_cpu >= nr_cpu_ids"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first_and",
          "args": [
            "wq_unbound_cpumask",
            "cpu_online_mask"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "new_cpu >= nr_cpu_ids"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next_and",
          "args": [
            "new_cpu",
            "wq_unbound_cpumask",
            "cpu_online_mask"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "wq_rr_cpu_last"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "wq_unbound_cpumask"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"workqueue: round-robin CPU selection forced, expect performance impact\\n\""
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "wq_unbound_cpumask"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!wq_debug_force_rr_cpu"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic cpumask_var_t wq_unbound_cpumask;\nstatic DEFINE_PER_CPU(int, wq_rr_cpu_last);\n\nstatic int wq_select_unbound_cpu(int cpu)\n{\n\tstatic bool printed_dbg_warning;\n\tint new_cpu;\n\n\tif (likely(!wq_debug_force_rr_cpu)) {\n\t\tif (cpumask_test_cpu(cpu, wq_unbound_cpumask))\n\t\t\treturn cpu;\n\t} else if (!printed_dbg_warning) {\n\t\tpr_warn(\"workqueue: round-robin CPU selection forced, expect performance impact\\n\");\n\t\tprinted_dbg_warning = true;\n\t}\n\n\tif (cpumask_empty(wq_unbound_cpumask))\n\t\treturn cpu;\n\n\tnew_cpu = __this_cpu_read(wq_rr_cpu_last);\n\tnew_cpu = cpumask_next_and(new_cpu, wq_unbound_cpumask, cpu_online_mask);\n\tif (unlikely(new_cpu >= nr_cpu_ids)) {\n\t\tnew_cpu = cpumask_first_and(wq_unbound_cpumask, cpu_online_mask);\n\t\tif (unlikely(new_cpu >= nr_cpu_ids))\n\t\t\treturn cpu;\n\t}\n\t__this_cpu_write(wq_rr_cpu_last, new_cpu);\n\n\treturn new_cpu;\n}"
  },
  {
    "function_name": "is_chained_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1318-1328",
    "snippet": "static bool is_chained_work(struct workqueue_struct *wq)\n{\n\tstruct worker *worker;\n\n\tworker = current_wq_worker();\n\t/*\n\t * Return %true iff I'm a worker execuing a work item on @wq.  If\n\t * I'm @worker, it's safe to dereference it without locking.\n\t */\n\treturn worker && worker->current_pwq->wq == wq;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_wq_worker",
          "args": [],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "current_wq_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue_internal.h",
          "lines": "61-66",
          "snippet": "static inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/preempt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/preempt.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n\nstatic inline struct worker *current_wq_worker(void)\n{\n\tif (in_task() && (current->flags & PF_WQ_WORKER))\n\t\treturn kthread_data(current);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic bool is_chained_work(struct workqueue_struct *wq)\n{\n\tstruct worker *worker;\n\n\tworker = current_wq_worker();\n\t/*\n\t * Return %true iff I'm a worker execuing a work item on @wq.  If\n\t * I'm @worker, it's safe to dereference it without locking.\n\t */\n\treturn worker && worker->current_pwq->wq == wq;\n}"
  },
  {
    "function_name": "insert_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1293-1312",
    "snippet": "static void insert_work(struct pool_workqueue *pwq, struct work_struct *work,\n\t\t\tstruct list_head *head, unsigned int extra_flags)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\n\t/* we own @work, set data and link */\n\tset_work_pwq(work, pwq, extra_flags);\n\tlist_add_tail(&work->entry, head);\n\tget_pwq(pwq);\n\n\t/*\n\t * Ensure either wq_worker_sleeping() sees the above\n\t * list_add_tail() or we see zero nr_running to avoid workers lying\n\t * around lazily while there are works to be processed.\n\t */\n\tsmp_mb();\n\n\tif (__need_more_worker(pool))\n\t\twake_up_worker(pool);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_worker",
          "args": [
            "pool"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__need_more_worker",
          "args": [
            "pool"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "__need_more_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "764-767",
          "snippet": "static bool __need_more_worker(struct worker_pool *pool)\n{\n\treturn !atomic_read(&pool->nr_running);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool __need_more_worker(struct worker_pool *pool)\n{\n\treturn !atomic_read(&pool->nr_running);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pwq",
          "args": [
            "pwq"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "get_pwq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1061-1066",
          "snippet": "static void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&work->entry",
            "head"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_work_pwq",
          "args": [
            "work",
            "pwq",
            "extra_flags"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "set_work_pwq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "620-625",
          "snippet": "static void set_work_pwq(struct work_struct *work, struct pool_workqueue *pwq,\n\t\t\t unsigned long extra_flags)\n{\n\tset_work_data(work, (unsigned long)pwq,\n\t\t      WORK_STRUCT_PENDING | WORK_STRUCT_PWQ | extra_flags);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void set_work_pwq(struct work_struct *work, struct pool_workqueue *pwq,\n\t\t\t unsigned long extra_flags)\n{\n\tset_work_data(work, (unsigned long)pwq,\n\t\t      WORK_STRUCT_PENDING | WORK_STRUCT_PWQ | extra_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void insert_work(struct pool_workqueue *pwq, struct work_struct *work,\n\t\t\tstruct list_head *head, unsigned int extra_flags)\n{\n\tstruct worker_pool *pool = pwq->pool;\n\n\t/* we own @work, set data and link */\n\tset_work_pwq(work, pwq, extra_flags);\n\tlist_add_tail(&work->entry, head);\n\tget_pwq(pwq);\n\n\t/*\n\t * Ensure either wq_worker_sleeping() sees the above\n\t * list_add_tail() or we see zero nr_running to avoid workers lying\n\t * around lazily while there are works to be processed.\n\t */\n\tsmp_mb();\n\n\tif (__need_more_worker(pool))\n\t\twake_up_worker(pool);\n}"
  },
  {
    "function_name": "try_to_grab_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1206-1278",
    "snippet": "static int try_to_grab_pending(struct work_struct *work, bool is_dwork,\n\t\t\t       unsigned long *flags)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlocal_irq_save(*flags);\n\n\t/* try to steal the timer if it exists */\n\tif (is_dwork) {\n\t\tstruct delayed_work *dwork = to_delayed_work(work);\n\n\t\t/*\n\t\t * dwork->timer is irqsafe.  If del_timer() fails, it's\n\t\t * guaranteed that the timer is not queued anywhere and not\n\t\t * running on the local CPU.\n\t\t */\n\t\tif (likely(del_timer(&dwork->timer)))\n\t\t\treturn 1;\n\t}\n\n\t/* try to claim PENDING the normal way */\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work)))\n\t\treturn 0;\n\n\t/*\n\t * The queueing is in progress, or it is already queued. Try to\n\t * steal it from ->worklist without clearing WORK_STRUCT_PENDING.\n\t */\n\tpool = get_work_pool(work);\n\tif (!pool)\n\t\tgoto fail;\n\n\tspin_lock(&pool->lock);\n\t/*\n\t * work->data is guaranteed to point to pwq only while the work\n\t * item is queued on pwq->wq, and both updating work->data to point\n\t * to pwq on queueing and to pool on dequeueing are done under\n\t * pwq->pool->lock.  This in turn guarantees that, if work->data\n\t * points to pwq which is associated with a locked pool, the work\n\t * item is currently queued on that pool.\n\t */\n\tpwq = get_work_pwq(work);\n\tif (pwq && pwq->pool == pool) {\n\t\tdebug_work_deactivate(work);\n\n\t\t/*\n\t\t * A delayed work item cannot be grabbed directly because\n\t\t * it might have linked NO_COLOR work items which, if left\n\t\t * on the delayed_list, will confuse pwq->nr_active\n\t\t * management later on and cause stall.  Make sure the work\n\t\t * item is activated before grabbing.\n\t\t */\n\t\tif (*work_data_bits(work) & WORK_STRUCT_DELAYED)\n\t\t\tpwq_activate_delayed_work(work);\n\n\t\tlist_del_init(&work->entry);\n\t\tpwq_dec_nr_in_flight(pwq, get_work_color(work));\n\n\t\t/* work->data points to pwq iff queued, point to pool */\n\t\tset_work_pool_and_keep_pending(work, pool->id);\n\n\t\tspin_unlock(&pool->lock);\n\t\treturn 1;\n\t}\n\tspin_unlock(&pool->lock);\nfail:\n\tlocal_irq_restore(*flags);\n\tif (work_is_canceling(work))\n\t\treturn -ENOENT;\n\tcpu_relax();\n\treturn -EAGAIN;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_is_canceling",
          "args": [
            "work"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "work_is_canceling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "751-756",
          "snippet": "static bool work_is_canceling(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\treturn !(data & WORK_STRUCT_PWQ) && (data & WORK_OFFQ_CANCELING);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool work_is_canceling(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\treturn !(data & WORK_STRUCT_PWQ) && (data & WORK_OFFQ_CANCELING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "*flags"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pool->lock"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_work_pool_and_keep_pending",
          "args": [
            "work",
            "pool->id"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "set_work_pool_and_keep_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "627-632",
          "snippet": "static void set_work_pool_and_keep_pending(struct work_struct *work,\n\t\t\t\t\t   int pool_id)\n{\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT,\n\t\t      WORK_STRUCT_PENDING);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void set_work_pool_and_keep_pending(struct work_struct *work,\n\t\t\t\t\t   int pool_id)\n{\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT,\n\t\t      WORK_STRUCT_PENDING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwq_dec_nr_in_flight",
          "args": [
            "pwq",
            "get_work_color(work)"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_dec_nr_in_flight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1143-1177",
          "snippet": "static void pwq_dec_nr_in_flight(struct pool_workqueue *pwq, int color)\n{\n\t/* uncolored work items don't participate in flushing or nr_active */\n\tif (color == WORK_NO_COLOR)\n\t\tgoto out_put;\n\n\tpwq->nr_in_flight[color]--;\n\n\tpwq->nr_active--;\n\tif (!list_empty(&pwq->delayed_works)) {\n\t\t/* one down, submit a delayed one */\n\t\tif (pwq->nr_active < pwq->max_active)\n\t\t\tpwq_activate_first_delayed(pwq);\n\t}\n\n\t/* is flush in progress and are we at the flushing tip? */\n\tif (likely(pwq->flush_color != color))\n\t\tgoto out_put;\n\n\t/* are there still in-flight works? */\n\tif (pwq->nr_in_flight[color])\n\t\tgoto out_put;\n\n\t/* this pwq is done, clear flush_color */\n\tpwq->flush_color = -1;\n\n\t/*\n\t * If this was the last pwq, wake up the first flusher.  It\n\t * will handle the rest.\n\t */\n\tif (atomic_dec_and_test(&pwq->wq->nr_pwqs_to_flush))\n\t\tcomplete(&pwq->wq->first_flusher->done);\nout_put:\n\tput_pwq(pwq);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void pwq_dec_nr_in_flight(struct pool_workqueue *pwq, int color)\n{\n\t/* uncolored work items don't participate in flushing or nr_active */\n\tif (color == WORK_NO_COLOR)\n\t\tgoto out_put;\n\n\tpwq->nr_in_flight[color]--;\n\n\tpwq->nr_active--;\n\tif (!list_empty(&pwq->delayed_works)) {\n\t\t/* one down, submit a delayed one */\n\t\tif (pwq->nr_active < pwq->max_active)\n\t\t\tpwq_activate_first_delayed(pwq);\n\t}\n\n\t/* is flush in progress and are we at the flushing tip? */\n\tif (likely(pwq->flush_color != color))\n\t\tgoto out_put;\n\n\t/* are there still in-flight works? */\n\tif (pwq->nr_in_flight[color])\n\t\tgoto out_put;\n\n\t/* this pwq is done, clear flush_color */\n\tpwq->flush_color = -1;\n\n\t/*\n\t * If this was the last pwq, wake up the first flusher.  It\n\t * will handle the rest.\n\t */\n\tif (atomic_dec_and_test(&pwq->wq->nr_pwqs_to_flush))\n\t\tcomplete(&pwq->wq->first_flusher->done);\nout_put:\n\tput_pwq(pwq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_work_color",
          "args": [
            "work"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_color",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "582-586",
          "snippet": "static int get_work_color(struct work_struct *work)\n{\n\treturn (*work_data_bits(work) >> WORK_STRUCT_COLOR_SHIFT) &\n\t\t((1 << WORK_STRUCT_COLOR_BITS) - 1);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int get_work_color(struct work_struct *work)\n{\n\treturn (*work_data_bits(work) >> WORK_STRUCT_COLOR_SHIFT) &\n\t\t((1 << WORK_STRUCT_COLOR_BITS) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&work->entry"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwq_activate_delayed_work",
          "args": [
            "work"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_activate_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1112-1122",
          "snippet": "static void pwq_activate_delayed_work(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\n\ttrace_workqueue_activate_work(work);\n\tif (list_empty(&pwq->pool->worklist))\n\t\tpwq->pool->watchdog_ts = jiffies;\n\tmove_linked_works(work, &pwq->pool->worklist, NULL);\n\t__clear_bit(WORK_STRUCT_DELAYED_BIT, work_data_bits(work));\n\tpwq->nr_active++;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pwq_activate_delayed_work(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\n\ttrace_workqueue_activate_work(work);\n\tif (list_empty(&pwq->pool->worklist))\n\t\tpwq->pool->watchdog_ts = jiffies;\n\tmove_linked_works(work, &pwq->pool->worklist, NULL);\n\t__clear_bit(WORK_STRUCT_DELAYED_BIT, work_data_bits(work));\n\tpwq->nr_active++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_work_deactivate",
          "args": [
            "work"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "debug_work_deactivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "523-523",
          "snippet": "static inline void debug_work_deactivate(struct work_struct *work) { }",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void debug_work_deactivate(struct work_struct *work) { }"
        }
      },
      {
        "call_info": {
          "callee": "get_work_pwq",
          "args": [
            "work"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pwq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "682-690",
          "snippet": "static struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pool->lock"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_work_pool",
          "args": [
            "work"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pool_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "732-741",
          "snippet": "static int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "WORK_STRUCT_PENDING_BIT",
            "work_data_bits(work)"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "del_timer(&dwork->timer)"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_timer",
          "args": [
            "&dwork->timer"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1273-1298",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_delayed_work",
          "args": [
            "work"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "*flags"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic int try_to_grab_pending(struct work_struct *work, bool is_dwork,\n\t\t\t       unsigned long *flags)\n{\n\tstruct worker_pool *pool;\n\tstruct pool_workqueue *pwq;\n\n\tlocal_irq_save(*flags);\n\n\t/* try to steal the timer if it exists */\n\tif (is_dwork) {\n\t\tstruct delayed_work *dwork = to_delayed_work(work);\n\n\t\t/*\n\t\t * dwork->timer is irqsafe.  If del_timer() fails, it's\n\t\t * guaranteed that the timer is not queued anywhere and not\n\t\t * running on the local CPU.\n\t\t */\n\t\tif (likely(del_timer(&dwork->timer)))\n\t\t\treturn 1;\n\t}\n\n\t/* try to claim PENDING the normal way */\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work)))\n\t\treturn 0;\n\n\t/*\n\t * The queueing is in progress, or it is already queued. Try to\n\t * steal it from ->worklist without clearing WORK_STRUCT_PENDING.\n\t */\n\tpool = get_work_pool(work);\n\tif (!pool)\n\t\tgoto fail;\n\n\tspin_lock(&pool->lock);\n\t/*\n\t * work->data is guaranteed to point to pwq only while the work\n\t * item is queued on pwq->wq, and both updating work->data to point\n\t * to pwq on queueing and to pool on dequeueing are done under\n\t * pwq->pool->lock.  This in turn guarantees that, if work->data\n\t * points to pwq which is associated with a locked pool, the work\n\t * item is currently queued on that pool.\n\t */\n\tpwq = get_work_pwq(work);\n\tif (pwq && pwq->pool == pool) {\n\t\tdebug_work_deactivate(work);\n\n\t\t/*\n\t\t * A delayed work item cannot be grabbed directly because\n\t\t * it might have linked NO_COLOR work items which, if left\n\t\t * on the delayed_list, will confuse pwq->nr_active\n\t\t * management later on and cause stall.  Make sure the work\n\t\t * item is activated before grabbing.\n\t\t */\n\t\tif (*work_data_bits(work) & WORK_STRUCT_DELAYED)\n\t\t\tpwq_activate_delayed_work(work);\n\n\t\tlist_del_init(&work->entry);\n\t\tpwq_dec_nr_in_flight(pwq, get_work_color(work));\n\n\t\t/* work->data points to pwq iff queued, point to pool */\n\t\tset_work_pool_and_keep_pending(work, pool->id);\n\n\t\tspin_unlock(&pool->lock);\n\t\treturn 1;\n\t}\n\tspin_unlock(&pool->lock);\nfail:\n\tlocal_irq_restore(*flags);\n\tif (work_is_canceling(work))\n\t\treturn -ENOENT;\n\tcpu_relax();\n\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "pwq_dec_nr_in_flight",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1143-1177",
    "snippet": "static void pwq_dec_nr_in_flight(struct pool_workqueue *pwq, int color)\n{\n\t/* uncolored work items don't participate in flushing or nr_active */\n\tif (color == WORK_NO_COLOR)\n\t\tgoto out_put;\n\n\tpwq->nr_in_flight[color]--;\n\n\tpwq->nr_active--;\n\tif (!list_empty(&pwq->delayed_works)) {\n\t\t/* one down, submit a delayed one */\n\t\tif (pwq->nr_active < pwq->max_active)\n\t\t\tpwq_activate_first_delayed(pwq);\n\t}\n\n\t/* is flush in progress and are we at the flushing tip? */\n\tif (likely(pwq->flush_color != color))\n\t\tgoto out_put;\n\n\t/* are there still in-flight works? */\n\tif (pwq->nr_in_flight[color])\n\t\tgoto out_put;\n\n\t/* this pwq is done, clear flush_color */\n\tpwq->flush_color = -1;\n\n\t/*\n\t * If this was the last pwq, wake up the first flusher.  It\n\t * will handle the rest.\n\t */\n\tif (atomic_dec_and_test(&pwq->wq->nr_pwqs_to_flush))\n\t\tcomplete(&pwq->wq->first_flusher->done);\nout_put:\n\tput_pwq(pwq);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pwq",
          "args": [
            "pwq"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "put_pwq_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1099-1110",
          "snippet": "static void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are sched-RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\tspin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\tspin_unlock_irq(&pwq->pool->lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are sched-RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\tspin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\tspin_unlock_irq(&pwq->pool->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&pwq->wq->first_flusher->done"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1205-1216",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&pwq->wq->nr_pwqs_to_flush"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "pwq->flush_color != color"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwq_activate_first_delayed",
          "args": [
            "pwq"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_activate_first_delayed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1124-1130",
          "snippet": "static void pwq_activate_first_delayed(struct pool_workqueue *pwq)\n{\n\tstruct work_struct *work = list_first_entry(&pwq->delayed_works,\n\t\t\t\t\t\t    struct work_struct, entry);\n\n\tpwq_activate_delayed_work(work);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pwq_activate_first_delayed(struct pool_workqueue *pwq)\n{\n\tstruct work_struct *work = list_first_entry(&pwq->delayed_works,\n\t\t\t\t\t\t    struct work_struct, entry);\n\n\tpwq_activate_delayed_work(work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->delayed_works"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void pwq_dec_nr_in_flight(struct pool_workqueue *pwq, int color)\n{\n\t/* uncolored work items don't participate in flushing or nr_active */\n\tif (color == WORK_NO_COLOR)\n\t\tgoto out_put;\n\n\tpwq->nr_in_flight[color]--;\n\n\tpwq->nr_active--;\n\tif (!list_empty(&pwq->delayed_works)) {\n\t\t/* one down, submit a delayed one */\n\t\tif (pwq->nr_active < pwq->max_active)\n\t\t\tpwq_activate_first_delayed(pwq);\n\t}\n\n\t/* is flush in progress and are we at the flushing tip? */\n\tif (likely(pwq->flush_color != color))\n\t\tgoto out_put;\n\n\t/* are there still in-flight works? */\n\tif (pwq->nr_in_flight[color])\n\t\tgoto out_put;\n\n\t/* this pwq is done, clear flush_color */\n\tpwq->flush_color = -1;\n\n\t/*\n\t * If this was the last pwq, wake up the first flusher.  It\n\t * will handle the rest.\n\t */\n\tif (atomic_dec_and_test(&pwq->wq->nr_pwqs_to_flush))\n\t\tcomplete(&pwq->wq->first_flusher->done);\nout_put:\n\tput_pwq(pwq);\n}"
  },
  {
    "function_name": "pwq_activate_first_delayed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1124-1130",
    "snippet": "static void pwq_activate_first_delayed(struct pool_workqueue *pwq)\n{\n\tstruct work_struct *work = list_first_entry(&pwq->delayed_works,\n\t\t\t\t\t\t    struct work_struct, entry);\n\n\tpwq_activate_delayed_work(work);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pwq_activate_delayed_work",
          "args": [
            "work"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "pwq_activate_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1112-1122",
          "snippet": "static void pwq_activate_delayed_work(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\n\ttrace_workqueue_activate_work(work);\n\tif (list_empty(&pwq->pool->worklist))\n\t\tpwq->pool->watchdog_ts = jiffies;\n\tmove_linked_works(work, &pwq->pool->worklist, NULL);\n\t__clear_bit(WORK_STRUCT_DELAYED_BIT, work_data_bits(work));\n\tpwq->nr_active++;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pwq_activate_delayed_work(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\n\ttrace_workqueue_activate_work(work);\n\tif (list_empty(&pwq->pool->worklist))\n\t\tpwq->pool->watchdog_ts = jiffies;\n\tmove_linked_works(work, &pwq->pool->worklist, NULL);\n\t__clear_bit(WORK_STRUCT_DELAYED_BIT, work_data_bits(work));\n\tpwq->nr_active++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&pwq->delayed_works",
            "structwork_struct",
            "entry"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pwq_activate_first_delayed(struct pool_workqueue *pwq)\n{\n\tstruct work_struct *work = list_first_entry(&pwq->delayed_works,\n\t\t\t\t\t\t    struct work_struct, entry);\n\n\tpwq_activate_delayed_work(work);\n}"
  },
  {
    "function_name": "pwq_activate_delayed_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1112-1122",
    "snippet": "static void pwq_activate_delayed_work(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\n\ttrace_workqueue_activate_work(work);\n\tif (list_empty(&pwq->pool->worklist))\n\t\tpwq->pool->watchdog_ts = jiffies;\n\tmove_linked_works(work, &pwq->pool->worklist, NULL);\n\t__clear_bit(WORK_STRUCT_DELAYED_BIT, work_data_bits(work));\n\tpwq->nr_active++;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "WORK_STRUCT_DELAYED_BIT",
            "work_data_bits(work)"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_linked_works",
          "args": [
            "work",
            "&pwq->pool->worklist",
            "NULL"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "move_linked_works",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1030-1052",
          "snippet": "static void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pwq->pool->worklist"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_workqueue_activate_work",
          "args": [
            "work"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_work_pwq",
          "args": [
            "work"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pwq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "682-690",
          "snippet": "static struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pwq_activate_delayed_work(struct work_struct *work)\n{\n\tstruct pool_workqueue *pwq = get_work_pwq(work);\n\n\ttrace_workqueue_activate_work(work);\n\tif (list_empty(&pwq->pool->worklist))\n\t\tpwq->pool->watchdog_ts = jiffies;\n\tmove_linked_works(work, &pwq->pool->worklist, NULL);\n\t__clear_bit(WORK_STRUCT_DELAYED_BIT, work_data_bits(work));\n\tpwq->nr_active++;\n}"
  },
  {
    "function_name": "put_pwq_unlocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1099-1110",
    "snippet": "static void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are sched-RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\tspin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\tspin_unlock_irq(&pwq->pool->lock);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&pwq->pool->lock"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pwq",
          "args": [
            "pwq"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "put_pwq_unlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "1099-1110",
          "snippet": "static void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are sched-RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\tspin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\tspin_unlock_irq(&pwq->pool->lock);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&pwq->pool->lock"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void put_pwq_unlocked(struct pool_workqueue *pwq)\n{\n\tif (pwq) {\n\t\t/*\n\t\t * As both pwqs and pools are sched-RCU protected, the\n\t\t * following lock operations are safe.\n\t\t */\n\t\tspin_lock_irq(&pwq->pool->lock);\n\t\tput_pwq(pwq);\n\t\tspin_unlock_irq(&pwq->pool->lock);\n\t}\n}"
  },
  {
    "function_name": "put_pwq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1075-1091",
    "snippet": "static void put_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tif (likely(--pwq->refcnt))\n\t\treturn;\n\tif (WARN_ON_ONCE(!(pwq->wq->flags & WQ_UNBOUND)))\n\t\treturn;\n\t/*\n\t * @pwq can't be released under pool->lock, bounce to\n\t * pwq_unbound_release_workfn().  This never recurses on the same\n\t * pool->lock as this path is taken only for unbound workqueues and\n\t * the release work item is scheduled on a per-cpu workqueue.  To\n\t * avoid lockdep warning, unbound pool->locks are given lockdep\n\t * subclass of 1 in get_unbound_pool().\n\t */\n\tschedule_work(&pwq->unbound_release_work);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(workqueues);",
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&pwq->unbound_release_work"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(pwq->wq->flags & WQ_UNBOUND)"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "--pwq->refcnt"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&pwq->pool->lock"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic void put_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tif (likely(--pwq->refcnt))\n\t\treturn;\n\tif (WARN_ON_ONCE(!(pwq->wq->flags & WQ_UNBOUND)))\n\t\treturn;\n\t/*\n\t * @pwq can't be released under pool->lock, bounce to\n\t * pwq_unbound_release_workfn().  This never recurses on the same\n\t * pool->lock as this path is taken only for unbound workqueues and\n\t * the release work item is scheduled on a per-cpu workqueue.  To\n\t * avoid lockdep warning, unbound pool->locks are given lockdep\n\t * subclass of 1 in get_unbound_pool().\n\t */\n\tschedule_work(&pwq->unbound_release_work);\n}"
  },
  {
    "function_name": "get_pwq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1061-1066",
    "snippet": "static void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pwq->refcnt <= 0"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&pwq->pool->lock"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void get_pwq(struct pool_workqueue *pwq)\n{\n\tlockdep_assert_held(&pwq->pool->lock);\n\tWARN_ON_ONCE(pwq->refcnt <= 0);\n\tpwq->refcnt++;\n}"
  },
  {
    "function_name": "move_linked_works",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "1030-1052",
    "snippet": "static void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&work->entry",
            "head"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_from",
          "args": [
            "work",
            "n",
            "NULL",
            "entry"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void move_linked_works(struct work_struct *work, struct list_head *head,\n\t\t\t      struct work_struct **nextp)\n{\n\tstruct work_struct *n;\n\n\t/*\n\t * Linked worklist will always end before the end of the list,\n\t * use NULL for list head.\n\t */\n\tlist_for_each_entry_safe_from(work, n, NULL, entry) {\n\t\tlist_move_tail(&work->entry, head);\n\t\tif (!(*work_data_bits(work) & WORK_STRUCT_LINKED))\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we're already inside safe list traversal and have moved\n\t * multiple works to the scheduled queue, the next position\n\t * needs to be updated.\n\t */\n\tif (nextp)\n\t\t*nextp = n;\n}"
  },
  {
    "function_name": "find_worker_executing_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "999-1011",
    "snippet": "static struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_for_each_possible",
          "args": [
            "pool->busy_hash",
            "worker",
            "hentry",
            "(unsigned long)work"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic struct worker *find_worker_executing_work(struct worker_pool *pool,\n\t\t\t\t\t\t struct work_struct *work)\n{\n\tstruct worker *worker;\n\n\thash_for_each_possible(pool->busy_hash, worker, hentry,\n\t\t\t       (unsigned long)work)\n\t\tif (worker->current_work == work &&\n\t\t    worker->current_func == work->func)\n\t\t\treturn worker;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "worker_clr_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "947-964",
    "snippet": "static inline void worker_clr_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tunsigned int oflags = worker->flags;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\tworker->flags &= ~flags;\n\n\t/*\n\t * If transitioning out of NOT_RUNNING, increment nr_running.  Note\n\t * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask\n\t * of multiple flags, not a single flag.\n\t */\n\tif ((flags & WORKER_NOT_RUNNING) && (oflags & WORKER_NOT_RUNNING))\n\t\tif (!(worker->flags & WORKER_NOT_RUNNING))\n\t\t\tatomic_inc(&pool->nr_running);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&pool->nr_running"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "worker->task != current"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic inline void worker_clr_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\tunsigned int oflags = worker->flags;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\tworker->flags &= ~flags;\n\n\t/*\n\t * If transitioning out of NOT_RUNNING, increment nr_running.  Note\n\t * that the nested NOT_RUNNING is not a noop.  NOT_RUNNING is mask\n\t * of multiple flags, not a single flag.\n\t */\n\tif ((flags & WORKER_NOT_RUNNING) && (oflags & WORKER_NOT_RUNNING))\n\t\tif (!(worker->flags & WORKER_NOT_RUNNING))\n\t\t\tatomic_inc(&pool->nr_running);\n}"
  },
  {
    "function_name": "worker_set_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "922-935",
    "snippet": "static inline void worker_set_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\t/* If transitioning into NOT_RUNNING, adjust nr_running. */\n\tif ((flags & WORKER_NOT_RUNNING) &&\n\t    !(worker->flags & WORKER_NOT_RUNNING)) {\n\t\tatomic_dec(&pool->nr_running);\n\t}\n\n\tworker->flags |= flags;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&pool->nr_running"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "worker->task != current"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic inline void worker_set_flags(struct worker *worker, unsigned int flags)\n{\n\tstruct worker_pool *pool = worker->pool;\n\n\tWARN_ON_ONCE(worker->task != current);\n\n\t/* If transitioning into NOT_RUNNING, adjust nr_running. */\n\tif ((flags & WORKER_NOT_RUNNING) &&\n\t    !(worker->flags & WORKER_NOT_RUNNING)) {\n\t\tatomic_dec(&pool->nr_running);\n\t}\n\n\tworker->flags |= flags;\n}"
  },
  {
    "function_name": "wq_worker_sleeping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "876-910",
    "snippet": "struct task_struct *wq_worker_sleeping(struct task_struct *task)\n{\n\tstruct worker *worker = kthread_data(task), *to_wakeup = NULL;\n\tstruct worker_pool *pool;\n\n\t/*\n\t * Rescuers, which may not have all the fields set up like normal\n\t * workers, also reach here, let's not access anything before\n\t * checking NOT_RUNNING.\n\t */\n\tif (worker->flags & WORKER_NOT_RUNNING)\n\t\treturn NULL;\n\n\tpool = worker->pool;\n\n\t/* this can only happen on the local cpu */\n\tif (WARN_ON_ONCE(pool->cpu != raw_smp_processor_id()))\n\t\treturn NULL;\n\n\t/*\n\t * The counterpart of the following dec_and_test, implied mb,\n\t * worklist not empty test sequence is in insert_work().\n\t * Please read comment there.\n\t *\n\t * NOT_RUNNING is clear.  This means that we're bound to and\n\t * running on the local cpu w/ rq lock held and preemption\n\t * disabled, which in turn means that none else could be\n\t * manipulating idle_list, so dereferencing idle_list without pool\n\t * lock is safe.\n\t */\n\tif (atomic_dec_and_test(&pool->nr_running) &&\n\t    !list_empty(&pool->worklist))\n\t\tto_wakeup = first_idle_worker(pool);\n\treturn to_wakeup ? to_wakeup->task : NULL;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "first_idle_worker",
          "args": [
            "pool"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "first_idle_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "816-822",
          "snippet": "static struct worker *first_idle_worker(struct worker_pool *pool)\n{\n\tif (unlikely(list_empty(&pool->idle_list)))\n\t\treturn NULL;\n\n\treturn list_first_entry(&pool->idle_list, struct worker, entry);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic struct worker *first_idle_worker(struct worker_pool *pool)\n{\n\tif (unlikely(list_empty(&pool->idle_list)))\n\t\treturn NULL;\n\n\treturn list_first_entry(&pool->idle_list, struct worker, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pool->worklist"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&pool->nr_running"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pool->cpu != raw_smp_processor_id()"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_data",
          "args": [
            "task"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "154-157",
          "snippet": "void *kthread_data(struct task_struct *task)\n{\n\treturn to_kthread(task)->data;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nvoid *kthread_data(struct task_struct *task)\n{\n\treturn to_kthread(task)->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstruct task_struct *wq_worker_sleeping(struct task_struct *task)\n{\n\tstruct worker *worker = kthread_data(task), *to_wakeup = NULL;\n\tstruct worker_pool *pool;\n\n\t/*\n\t * Rescuers, which may not have all the fields set up like normal\n\t * workers, also reach here, let's not access anything before\n\t * checking NOT_RUNNING.\n\t */\n\tif (worker->flags & WORKER_NOT_RUNNING)\n\t\treturn NULL;\n\n\tpool = worker->pool;\n\n\t/* this can only happen on the local cpu */\n\tif (WARN_ON_ONCE(pool->cpu != raw_smp_processor_id()))\n\t\treturn NULL;\n\n\t/*\n\t * The counterpart of the following dec_and_test, implied mb,\n\t * worklist not empty test sequence is in insert_work().\n\t * Please read comment there.\n\t *\n\t * NOT_RUNNING is clear.  This means that we're bound to and\n\t * running on the local cpu w/ rq lock held and preemption\n\t * disabled, which in turn means that none else could be\n\t * manipulating idle_list, so dereferencing idle_list without pool\n\t * lock is safe.\n\t */\n\tif (atomic_dec_and_test(&pool->nr_running) &&\n\t    !list_empty(&pool->worklist))\n\t\tto_wakeup = first_idle_worker(pool);\n\treturn to_wakeup ? to_wakeup->task : NULL;\n}"
  },
  {
    "function_name": "wq_worker_waking_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "852-860",
    "snippet": "void wq_worker_waking_up(struct task_struct *task, int cpu)\n{\n\tstruct worker *worker = kthread_data(task);\n\n\tif (!(worker->flags & WORKER_NOT_RUNNING)) {\n\t\tWARN_ON_ONCE(worker->pool->cpu != cpu);\n\t\tatomic_inc(&worker->pool->nr_running);\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&worker->pool->nr_running"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "worker->pool->cpu != cpu"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_data",
          "args": [
            "task"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "154-157",
          "snippet": "void *kthread_data(struct task_struct *task)\n{\n\treturn to_kthread(task)->data;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *task;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nstruct task_struct *task;\n\nvoid *kthread_data(struct task_struct *task)\n{\n\treturn to_kthread(task)->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid wq_worker_waking_up(struct task_struct *task, int cpu)\n{\n\tstruct worker *worker = kthread_data(task);\n\n\tif (!(worker->flags & WORKER_NOT_RUNNING)) {\n\t\tWARN_ON_ONCE(worker->pool->cpu != cpu);\n\t\tatomic_inc(&worker->pool->nr_running);\n\t}\n}"
  },
  {
    "function_name": "wake_up_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "833-839",
    "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "worker->task"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "worker"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "first_idle_worker",
          "args": [
            "pool"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "first_idle_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "816-822",
          "snippet": "static struct worker *first_idle_worker(struct worker_pool *pool)\n{\n\tif (unlikely(list_empty(&pool->idle_list)))\n\t\treturn NULL;\n\n\treturn list_first_entry(&pool->idle_list, struct worker, entry);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic struct worker *first_idle_worker(struct worker_pool *pool)\n{\n\tif (unlikely(list_empty(&pool->idle_list)))\n\t\treturn NULL;\n\n\treturn list_first_entry(&pool->idle_list, struct worker, entry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
  },
  {
    "function_name": "first_idle_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "816-822",
    "snippet": "static struct worker *first_idle_worker(struct worker_pool *pool)\n{\n\tif (unlikely(list_empty(&pool->idle_list)))\n\t\treturn NULL;\n\n\treturn list_first_entry(&pool->idle_list, struct worker, entry);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&pool->idle_list",
            "structworker",
            "entry"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "list_empty(&pool->idle_list)"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pool->idle_list"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic struct worker *first_idle_worker(struct worker_pool *pool)\n{\n\tif (unlikely(list_empty(&pool->idle_list)))\n\t\treturn NULL;\n\n\treturn list_first_entry(&pool->idle_list, struct worker, entry);\n}"
  },
  {
    "function_name": "too_many_workers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "802-809",
    "snippet": "static bool too_many_workers(struct worker_pool *pool)\n{\n\tbool managing = pool->flags & POOL_MANAGER_ACTIVE;\n\tint nr_idle = pool->nr_idle + managing; /* manager is considered idle */\n\tint nr_busy = pool->nr_workers - nr_idle;\n\n\treturn nr_idle > 2 && (nr_idle - 2) * MAX_IDLE_WORKERS_RATIO >= nr_busy;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool too_many_workers(struct worker_pool *pool)\n{\n\tbool managing = pool->flags & POOL_MANAGER_ACTIVE;\n\tint nr_idle = pool->nr_idle + managing; /* manager is considered idle */\n\tint nr_busy = pool->nr_workers - nr_idle;\n\n\treturn nr_idle > 2 && (nr_idle - 2) * MAX_IDLE_WORKERS_RATIO >= nr_busy;\n}"
  },
  {
    "function_name": "need_to_create_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "796-799",
    "snippet": "static bool need_to_create_worker(struct worker_pool *pool)\n{\n\treturn need_more_worker(pool) && !may_start_working(pool);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "may_start_working",
          "args": [
            "pool"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "may_start_working",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "783-786",
          "snippet": "static bool may_start_working(struct worker_pool *pool)\n{\n\treturn pool->nr_idle;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool may_start_working(struct worker_pool *pool)\n{\n\treturn pool->nr_idle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_more_worker",
          "args": [
            "pool"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "need_more_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "777-780",
          "snippet": "static bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool need_to_create_worker(struct worker_pool *pool)\n{\n\treturn need_more_worker(pool) && !may_start_working(pool);\n}"
  },
  {
    "function_name": "keep_working",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "789-793",
    "snippet": "static bool keep_working(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) &&\n\t\tatomic_read(&pool->nr_running) <= 1;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pool->nr_running"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pool->worklist"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool keep_working(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) &&\n\t\tatomic_read(&pool->nr_running) <= 1;\n}"
  },
  {
    "function_name": "may_start_working",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "783-786",
    "snippet": "static bool may_start_working(struct worker_pool *pool)\n{\n\treturn pool->nr_idle;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool may_start_working(struct worker_pool *pool)\n{\n\treturn pool->nr_idle;\n}"
  },
  {
    "function_name": "need_more_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "777-780",
    "snippet": "static bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__need_more_worker",
          "args": [
            "pool"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "__need_more_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "764-767",
          "snippet": "static bool __need_more_worker(struct worker_pool *pool)\n{\n\treturn !atomic_read(&pool->nr_running);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool __need_more_worker(struct worker_pool *pool)\n{\n\treturn !atomic_read(&pool->nr_running);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pool->worklist"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool need_more_worker(struct worker_pool *pool)\n{\n\treturn !list_empty(&pool->worklist) && __need_more_worker(pool);\n}"
  },
  {
    "function_name": "__need_more_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "764-767",
    "snippet": "static bool __need_more_worker(struct worker_pool *pool)\n{\n\treturn !atomic_read(&pool->nr_running);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pool->nr_running"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic bool __need_more_worker(struct worker_pool *pool)\n{\n\treturn !atomic_read(&pool->nr_running);\n}"
  },
  {
    "function_name": "work_is_canceling",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "751-756",
    "snippet": "static bool work_is_canceling(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\treturn !(data & WORK_STRUCT_PWQ) && (data & WORK_OFFQ_CANCELING);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&work->data"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool work_is_canceling(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\treturn !(data & WORK_STRUCT_PWQ) && (data & WORK_OFFQ_CANCELING);\n}"
  },
  {
    "function_name": "mark_work_canceling",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "743-749",
    "snippet": "static void mark_work_canceling(struct work_struct *work)\n{\n\tunsigned long pool_id = get_work_pool_id(work);\n\n\tpool_id <<= WORK_OFFQ_POOL_SHIFT;\n\tset_work_data(work, pool_id | WORK_OFFQ_CANCELING, WORK_STRUCT_PENDING);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_work_data",
          "args": [
            "work",
            "pool_id | WORK_OFFQ_CANCELING",
            "WORK_STRUCT_PENDING"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "set_work_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "613-618",
          "snippet": "static inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_work_pool_id",
          "args": [
            "work"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "get_work_pool_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "732-741",
          "snippet": "static int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void mark_work_canceling(struct work_struct *work)\n{\n\tunsigned long pool_id = get_work_pool_id(work);\n\n\tpool_id <<= WORK_OFFQ_POOL_SHIFT;\n\tset_work_data(work, pool_id | WORK_OFFQ_CANCELING, WORK_STRUCT_PENDING);\n}"
  },
  {
    "function_name": "get_work_pool_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "732-741",
    "snippet": "static int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&work->data"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int get_work_pool_id(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool->id;\n\n\treturn data >> WORK_OFFQ_POOL_SHIFT;\n}"
  },
  {
    "function_name": "get_work_pool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "707-723",
    "snippet": "static struct worker_pool *get_work_pool(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\tint pool_id;\n\n\tassert_rcu_or_pool_mutex();\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool;\n\n\tpool_id = data >> WORK_OFFQ_POOL_SHIFT;\n\tif (pool_id == WORK_OFFQ_POOL_NONE)\n\t\treturn NULL;\n\n\treturn idr_find(&worker_pool_idr, pool_id);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static DEFINE_IDR(worker_pool_idr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&worker_pool_idr",
            "pool_id"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_rcu_or_pool_mutex",
          "args": [],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&work->data"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic DEFINE_IDR(worker_pool_idr);\n\nstatic struct worker_pool *get_work_pool(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\tint pool_id;\n\n\tassert_rcu_or_pool_mutex();\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn ((struct pool_workqueue *)\n\t\t\t(data & WORK_STRUCT_WQ_DATA_MASK))->pool;\n\n\tpool_id = data >> WORK_OFFQ_POOL_SHIFT;\n\tif (pool_id == WORK_OFFQ_POOL_NONE)\n\t\treturn NULL;\n\n\treturn idr_find(&worker_pool_idr, pool_id);\n}"
  },
  {
    "function_name": "get_work_pwq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "682-690",
    "snippet": "static struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&work->data"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->data);\n\n\tif (data & WORK_STRUCT_PWQ)\n\t\treturn (void *)(data & WORK_STRUCT_WQ_DATA_MASK);\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "clear_work_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "676-680",
    "snippet": "static void clear_work_data(struct work_struct *work)\n{\n\tsmp_wmb();\t/* see set_work_pool_and_clear_pending() */\n\tset_work_data(work, WORK_STRUCT_NO_POOL, 0);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_work_data",
          "args": [
            "work",
            "WORK_STRUCT_NO_POOL",
            "0"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "set_work_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "613-618",
          "snippet": "static inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void clear_work_data(struct work_struct *work)\n{\n\tsmp_wmb();\t/* see set_work_pool_and_clear_pending() */\n\tset_work_data(work, WORK_STRUCT_NO_POOL, 0);\n}"
  },
  {
    "function_name": "set_work_pool_and_clear_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "634-674",
    "snippet": "static void set_work_pool_and_clear_pending(struct work_struct *work,\n\t\t\t\t\t    int pool_id)\n{\n\t/*\n\t * The following wmb is paired with the implied mb in\n\t * test_and_set_bit(PENDING) and ensures all updates to @work made\n\t * here are visible to and precede any updates by the next PENDING\n\t * owner.\n\t */\n\tsmp_wmb();\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT, 0);\n\t/*\n\t * The following mb guarantees that previous clear of a PENDING bit\n\t * will not be reordered with any speculative LOADS or STORES from\n\t * work->current_func, which is executed afterwards.  This possible\n\t * reordering can lead to a missed execution on attempt to qeueue\n\t * the same @work.  E.g. consider this case:\n\t *\n\t *   CPU#0                         CPU#1\n\t *   ----------------------------  --------------------------------\n\t *\n\t * 1  STORE event_indicated\n\t * 2  queue_work_on() {\n\t * 3    test_and_set_bit(PENDING)\n\t * 4 }                             set_..._and_clear_pending() {\n\t * 5                                 set_work_data() # clear bit\n\t * 6                                 smp_mb()\n\t * 7                               work->current_func() {\n\t * 8\t\t\t\t      LOAD event_indicated\n\t *\t\t\t\t   }\n\t *\n\t * Without an explicit full barrier speculative LOAD on line 8 can\n\t * be executed before CPU#0 does STORE on line 1.  If that happens,\n\t * CPU#0 observes the PENDING bit is still set and new execution of\n\t * a @work is not queued in a hope, that CPU#1 will eventually\n\t * finish the queued @work.  Meanwhile CPU#1 does not see\n\t * event_indicated is set, because speculative LOAD was executed\n\t * before actual STORE.\n\t */\n\tsmp_mb();\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_work_data",
          "args": [
            "work",
            "(unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT",
            "0"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "set_work_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "613-618",
          "snippet": "static inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void set_work_pool_and_clear_pending(struct work_struct *work,\n\t\t\t\t\t    int pool_id)\n{\n\t/*\n\t * The following wmb is paired with the implied mb in\n\t * test_and_set_bit(PENDING) and ensures all updates to @work made\n\t * here are visible to and precede any updates by the next PENDING\n\t * owner.\n\t */\n\tsmp_wmb();\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT, 0);\n\t/*\n\t * The following mb guarantees that previous clear of a PENDING bit\n\t * will not be reordered with any speculative LOADS or STORES from\n\t * work->current_func, which is executed afterwards.  This possible\n\t * reordering can lead to a missed execution on attempt to qeueue\n\t * the same @work.  E.g. consider this case:\n\t *\n\t *   CPU#0                         CPU#1\n\t *   ----------------------------  --------------------------------\n\t *\n\t * 1  STORE event_indicated\n\t * 2  queue_work_on() {\n\t * 3    test_and_set_bit(PENDING)\n\t * 4 }                             set_..._and_clear_pending() {\n\t * 5                                 set_work_data() # clear bit\n\t * 6                                 smp_mb()\n\t * 7                               work->current_func() {\n\t * 8\t\t\t\t      LOAD event_indicated\n\t *\t\t\t\t   }\n\t *\n\t * Without an explicit full barrier speculative LOAD on line 8 can\n\t * be executed before CPU#0 does STORE on line 1.  If that happens,\n\t * CPU#0 observes the PENDING bit is still set and new execution of\n\t * a @work is not queued in a hope, that CPU#1 will eventually\n\t * finish the queued @work.  Meanwhile CPU#1 does not see\n\t * event_indicated is set, because speculative LOAD was executed\n\t * before actual STORE.\n\t */\n\tsmp_mb();\n}"
  },
  {
    "function_name": "set_work_pool_and_keep_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "627-632",
    "snippet": "static void set_work_pool_and_keep_pending(struct work_struct *work,\n\t\t\t\t\t   int pool_id)\n{\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT,\n\t\t      WORK_STRUCT_PENDING);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_work_data",
          "args": [
            "work",
            "(unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT",
            "WORK_STRUCT_PENDING"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "set_work_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "613-618",
          "snippet": "static inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void set_work_pool_and_keep_pending(struct work_struct *work,\n\t\t\t\t\t   int pool_id)\n{\n\tset_work_data(work, (unsigned long)pool_id << WORK_OFFQ_POOL_SHIFT,\n\t\t      WORK_STRUCT_PENDING);\n}"
  },
  {
    "function_name": "set_work_pwq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "620-625",
    "snippet": "static void set_work_pwq(struct work_struct *work, struct pool_workqueue *pwq,\n\t\t\t unsigned long extra_flags)\n{\n\tset_work_data(work, (unsigned long)pwq,\n\t\t      WORK_STRUCT_PENDING | WORK_STRUCT_PWQ | extra_flags);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_work_data",
          "args": [
            "work",
            "(unsigned long)pwq",
            "WORK_STRUCT_PENDING | WORK_STRUCT_PWQ | extra_flags"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "set_work_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "613-618",
          "snippet": "static inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void set_work_pwq(struct work_struct *work, struct pool_workqueue *pwq,\n\t\t\t unsigned long extra_flags)\n{\n\tset_work_data(work, (unsigned long)pwq,\n\t\t      WORK_STRUCT_PENDING | WORK_STRUCT_PWQ | extra_flags);\n}"
  },
  {
    "function_name": "set_work_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "613-618",
    "snippet": "static inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_set",
          "args": [
            "&work->data",
            "data | flags | work_static(work)"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_static",
          "args": [
            "work"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!work_pending(work)"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "work_pending",
          "args": [
            "work"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\tWARN_ON_ONCE(!work_pending(work));\n\tatomic_long_set(&work->data, data | flags | work_static(work));\n}"
  },
  {
    "function_name": "work_next_color",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "588-591",
    "snippet": "static int work_next_color(int color)\n{\n\treturn (color + 1) % WORK_NR_COLORS;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int work_next_color(int color)\n{\n\treturn (color + 1) % WORK_NR_COLORS;\n}"
  },
  {
    "function_name": "get_work_color",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "582-586",
    "snippet": "static int get_work_color(struct work_struct *work)\n{\n\treturn (*work_data_bits(work) >> WORK_STRUCT_COLOR_SHIFT) &\n\t\t((1 << WORK_STRUCT_COLOR_BITS) - 1);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int get_work_color(struct work_struct *work)\n{\n\treturn (*work_data_bits(work) >> WORK_STRUCT_COLOR_SHIFT) &\n\t\t((1 << WORK_STRUCT_COLOR_BITS) - 1);\n}"
  },
  {
    "function_name": "work_color_to_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "577-580",
    "snippet": "static unsigned int work_color_to_flags(int color)\n{\n\treturn color << WORK_STRUCT_COLOR_SHIFT;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic unsigned int work_color_to_flags(int color)\n{\n\treturn color << WORK_STRUCT_COLOR_SHIFT;\n}"
  },
  {
    "function_name": "unbound_pwq_by_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "560-575",
    "snippet": "static struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "wq->numa_pwq_tbl[node]"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "node == NUMA_NO_NODE"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_rcu_or_wq_mutex_or_pool_mutex",
          "args": [
            "wq"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nstatic struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,\n\t\t\t\t\t\t  int node)\n{\n\tassert_rcu_or_wq_mutex_or_pool_mutex(wq);\n\n\t/*\n\t * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a\n\t * delayed item is pending.  The plan is to keep CPU -> NODE\n\t * mapping valid and stable across CPU on/offlines.  Once that\n\t * happens, this workaround can be removed.\n\t */\n\tif (unlikely(node == NUMA_NO_NODE))\n\t\treturn wq->dfl_pwq;\n\n\treturn rcu_dereference_raw(wq->numa_pwq_tbl[node]);\n}"
  },
  {
    "function_name": "worker_pool_assign_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "533-546",
    "snippet": "static int worker_pool_assign_id(struct worker_pool *pool)\n{\n\tint ret;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tret = idr_alloc(&worker_pool_idr, pool, 0, WORK_OFFQ_POOL_NONE,\n\t\t\tGFP_KERNEL);\n\tif (ret >= 0) {\n\t\tpool->id = ret;\n\t\treturn 0;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(wq_pool_mutex);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
      "static DEFINE_IDR(worker_pool_idr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_alloc",
          "args": [
            "&worker_pool_idr",
            "pool",
            "0",
            "WORK_OFFQ_POOL_NONE",
            "GFP_KERNEL"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "301-312",
          "snippet": "static int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\n\nstatic int cgroup_idr_alloc(struct idr *idr, void *ptr, int start, int end,\n\t\t\t    gfp_t gfp_mask)\n{\n\tint ret;\n\n\tidr_preload(gfp_mask);\n\tspin_lock_bh(&cgroup_idr_lock);\n\tret = idr_alloc(idr, ptr, start, end, gfp_mask & ~__GFP_DIRECT_RECLAIM);\n\tspin_unlock_bh(&cgroup_idr_lock);\n\tidr_preload_end();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_pool_mutex"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic DEFINE_IDR(worker_pool_idr);\n\nstatic int worker_pool_assign_id(struct worker_pool *pool)\n{\n\tint ret;\n\n\tlockdep_assert_held(&wq_pool_mutex);\n\n\tret = idr_alloc(&worker_pool_idr, pool, 0, WORK_OFFQ_POOL_NONE,\n\t\t\tGFP_KERNEL);\n\tif (ret >= 0) {\n\t\tpool->id = ret;\n\t\treturn 0;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "debug_work_deactivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "523-523",
    "snippet": "static inline void debug_work_deactivate(struct work_struct *work) { }",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void debug_work_deactivate(struct work_struct *work) { }"
  },
  {
    "function_name": "debug_work_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "522-522",
    "snippet": "static inline void debug_work_activate(struct work_struct *work) { }",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void debug_work_activate(struct work_struct *work) { }"
  },
  {
    "function_name": "destroy_delayed_work_on_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "514-518",
    "snippet": "void destroy_delayed_work_on_stack(struct delayed_work *work)\n{\n\tdestroy_timer_on_stack(&work->timer);\n\tdebug_object_free(&work->work, &work_debug_descr);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_free",
          "args": [
            "&work->work",
            "&work_debug_descr"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_timer_on_stack",
          "args": [
            "&work->timer"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_timer_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "742-745",
          "snippet": "void destroy_timer_on_stack(struct timer_list *timer)\n{\n\tdebug_object_free(timer, &timer_debug_descr);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid destroy_timer_on_stack(struct timer_list *timer)\n{\n\tdebug_object_free(timer, &timer_debug_descr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid destroy_delayed_work_on_stack(struct delayed_work *work)\n{\n\tdestroy_timer_on_stack(&work->timer);\n\tdebug_object_free(&work->work, &work_debug_descr);\n}"
  },
  {
    "function_name": "destroy_work_on_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "508-511",
    "snippet": "void destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_free",
          "args": [
            "work",
            "&work_debug_descr"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}"
  },
  {
    "function_name": "__init_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "499-505",
    "snippet": "void __init_work(struct work_struct *work, int onstack)\n{\n\tif (onstack)\n\t\tdebug_object_init_on_stack(work, &work_debug_descr);\n\telse\n\t\tdebug_object_init(work, &work_debug_descr);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_init",
          "args": [
            "work",
            "&work_debug_descr"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_object_init_on_stack",
          "args": [
            "work",
            "&work_debug_descr"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid __init_work(struct work_struct *work, int onstack)\n{\n\tif (onstack)\n\t\tdebug_object_init_on_stack(work, &work_debug_descr);\n\telse\n\t\tdebug_object_init(work, &work_debug_descr);\n}"
  },
  {
    "function_name": "debug_work_deactivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "494-497",
    "snippet": "static inline void debug_work_deactivate(struct work_struct *work)\n{\n\tdebug_object_deactivate(work, &work_debug_descr);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_deactivate",
          "args": [
            "work",
            "&work_debug_descr"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void debug_work_deactivate(struct work_struct *work)\n{\n\tdebug_object_deactivate(work, &work_debug_descr);\n}"
  },
  {
    "function_name": "debug_work_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "489-492",
    "snippet": "static inline void debug_work_activate(struct work_struct *work)\n{\n\tdebug_object_activate(work, &work_debug_descr);\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_activate",
          "args": [
            "work",
            "&work_debug_descr"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic inline void debug_work_activate(struct work_struct *work)\n{\n\tdebug_object_activate(work, &work_debug_descr);\n}"
  },
  {
    "function_name": "work_fixup_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "467-479",
    "snippet": "static bool work_fixup_free(void *addr, enum debug_obj_state state)\n{\n\tstruct work_struct *work = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\tcancel_work_sync(work);\n\t\tdebug_object_free(work, &work_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_free",
          "args": [
            "work",
            "&work_debug_descr"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_work_sync",
          "args": [
            "work"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_work_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3038-3041",
          "snippet": "bool cancel_work_sync(struct work_struct *work)\n{\n\treturn __cancel_work_timer(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool cancel_work_sync(struct work_struct *work)\n{\n\treturn __cancel_work_timer(work, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool work_fixup_free(void *addr, enum debug_obj_state state)\n{\n\tstruct work_struct *work = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\tcancel_work_sync(work);\n\t\tdebug_object_free(work, &work_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "work_fixup_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "449-461",
    "snippet": "static bool work_fixup_init(void *addr, enum debug_obj_state state)\n{\n\tstruct work_struct *work = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\tcancel_work_sync(work);\n\t\tdebug_object_init(work, &work_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_init",
          "args": [
            "work",
            "&work_debug_descr"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_work_sync",
          "args": [
            "work"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_work_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3038-3041",
          "snippet": "bool cancel_work_sync(struct work_struct *work)\n{\n\treturn __cancel_work_timer(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool cancel_work_sync(struct work_struct *work)\n{\n\treturn __cancel_work_timer(work, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool work_fixup_init(void *addr, enum debug_obj_state state)\n{\n\tstruct work_struct *work = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\tcancel_work_sync(work);\n\t\tdebug_object_init(work, &work_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "work_is_static_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "438-443",
    "snippet": "static bool work_is_static_object(void *addr)\n{\n\tstruct work_struct *work = addr;\n\n\treturn test_bit(WORK_STRUCT_STATIC_BIT, work_data_bits(work));\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "WORK_STRUCT_STATIC_BIT",
            "work_data_bits(work)"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "811-820",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "work_data_bits",
          "args": [
            "work"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool work_is_static_object(void *addr)\n{\n\tstruct work_struct *work = addr;\n\n\treturn test_bit(WORK_STRUCT_STATIC_BIT, work_data_bits(work));\n}"
  },
  {
    "function_name": "work_debug_hint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
    "lines": "433-436",
    "snippet": "static void *work_debug_hint(void *addr)\n{\n\treturn ((struct work_struct *) addr)->func;\n}",
    "includes": [
      "#include <trace/events/workqueue.h>",
      "#include \"workqueue_internal.h\"",
      "#include <linux/nmi.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/nodemask.h>",
      "#include <linux/rculist.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/jhash.h>",
      "#include <linux/idr.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/kthread.h>",
      "#include <linux/notifier.h>",
      "#include <linux/cpu.h>",
      "#include <linux/slab.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/completion.h>",
      "#include <linux/signal.h>",
      "#include <linux/init.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void *work_debug_hint(void *addr)\n{\n\treturn ((struct work_struct *) addr)->func;\n}"
  }
]