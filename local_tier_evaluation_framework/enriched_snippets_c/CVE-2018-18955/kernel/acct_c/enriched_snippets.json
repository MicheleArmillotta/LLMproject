[
  {
    "function_name": "acct_process",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
    "lines": "591-606",
    "snippet": "void acct_process(void)\n{\n\tstruct pid_namespace *ns;\n\n\t/*\n\t * This loop is safe lockless, since current is still\n\t * alive and holds its namespace, which in turn holds\n\t * its parent.\n\t */\n\tfor (ns = task_active_pid_ns(current); ns != NULL; ns = ns->parent) {\n\t\tif (ns->bacct)\n\t\t\tbreak;\n\t}\n\tif (unlikely(ns))\n\t\tslow_acct_process(ns);\n}",
    "includes": [
      "#include <linux/fs_pin.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/blkdev.h> /* sector_div */",
      "#include <asm/div64.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mount.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/times.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/vfs.h>",
      "#include <linux/security.h>",
      "#include <linux/tty.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/acct.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slow_acct_process",
          "args": [
            "ns"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "slow_acct_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
          "lines": "574-584",
          "snippet": "static void slow_acct_process(struct pid_namespace *ns)\n{\n\tfor ( ; ns; ns = ns->parent) {\n\t\tstruct bsd_acct_struct *acct = acct_get(ns);\n\t\tif (acct) {\n\t\t\tdo_acct_process(acct);\n\t\t\tmutex_unlock(&acct->lock);\n\t\t\tacct_put(acct);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/blkdev.h> /* sector_div */",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void do_acct_process(struct bsd_acct_struct *acct);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void do_acct_process(struct bsd_acct_struct *acct);\n\nstatic void slow_acct_process(struct pid_namespace *ns)\n{\n\tfor ( ; ns; ns = ns->parent) {\n\t\tstruct bsd_acct_struct *acct = acct_get(ns);\n\t\tif (acct) {\n\t\t\tdo_acct_process(acct);\n\t\t\tmutex_unlock(&acct->lock);\n\t\t\tacct_put(acct);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ns"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "436-439",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid acct_process(void)\n{\n\tstruct pid_namespace *ns;\n\n\t/*\n\t * This loop is safe lockless, since current is still\n\t * alive and holds its namespace, which in turn holds\n\t * its parent.\n\t */\n\tfor (ns = task_active_pid_ns(current); ns != NULL; ns = ns->parent) {\n\t\tif (ns->bacct)\n\t\t\tbreak;\n\t}\n\tif (unlikely(ns))\n\t\tslow_acct_process(ns);\n}"
  },
  {
    "function_name": "slow_acct_process",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
    "lines": "574-584",
    "snippet": "static void slow_acct_process(struct pid_namespace *ns)\n{\n\tfor ( ; ns; ns = ns->parent) {\n\t\tstruct bsd_acct_struct *acct = acct_get(ns);\n\t\tif (acct) {\n\t\t\tdo_acct_process(acct);\n\t\t\tmutex_unlock(&acct->lock);\n\t\t\tacct_put(acct);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/fs_pin.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/blkdev.h> /* sector_div */",
      "#include <asm/div64.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mount.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/times.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/vfs.h>",
      "#include <linux/security.h>",
      "#include <linux/tty.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/acct.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void do_acct_process(struct bsd_acct_struct *acct);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "acct_put",
          "args": [
            "acct"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "acct_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
          "lines": "133-137",
          "snippet": "static void acct_put(struct bsd_acct_struct *p)\n{\n\tif (atomic_long_dec_and_test(&p->count))\n\t\tkfree_rcu(p, rcu);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/blkdev.h> /* sector_div */",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void acct_put(struct bsd_acct_struct *p)\n{\n\tif (atomic_long_dec_and_test(&p->count))\n\t\tkfree_rcu(p, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&acct->lock"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_acct_process",
          "args": [
            "acct"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "do_acct_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
          "lines": "471-526",
          "snippet": "static void do_acct_process(struct bsd_acct_struct *acct)\n{\n\tacct_t ac;\n\tunsigned long flim;\n\tconst struct cred *orig_cred;\n\tstruct file *file = acct->file;\n\n\t/*\n\t * Accounting records are not subject to resource limits.\n\t */\n\tflim = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;\n\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;\n\t/* Perform file operations on behalf of whoever enabled accounting */\n\torig_cred = override_creds(file->f_cred);\n\n\t/*\n\t * First check to see if there is enough free_space to continue\n\t * the process accounting system.\n\t */\n\tif (!check_free_space(acct))\n\t\tgoto out;\n\n\tfill_ac(&ac);\n\t/* we really need to bite the bullet and change layout */\n\tac.ac_uid = from_kuid_munged(file->f_cred->user_ns, orig_cred->uid);\n\tac.ac_gid = from_kgid_munged(file->f_cred->user_ns, orig_cred->gid);\n#if ACCT_VERSION == 1 || ACCT_VERSION == 2\n\t/* backward-compatible 16 bit fields */\n\tac.ac_uid16 = ac.ac_uid;\n\tac.ac_gid16 = ac.ac_gid;\n#endif\n#if ACCT_VERSION == 3\n\t{\n\t\tstruct pid_namespace *ns = acct->ns;\n\n\t\tac.ac_pid = task_tgid_nr_ns(current, ns);\n\t\trcu_read_lock();\n\t\tac.ac_ppid = task_tgid_nr_ns(rcu_dereference(current->real_parent),\n\t\t\t\t\t     ns);\n\t\trcu_read_unlock();\n\t}\n#endif\n\t/*\n\t * Get freeze protection. If the fs is frozen, just skip the write\n\t * as we could deadlock the system otherwise.\n\t */\n\tif (file_start_write_trylock(file)) {\n\t\t/* it's been opened O_APPEND, so position is irrelevant */\n\t\tloff_t pos = 0;\n\t\t__kernel_write(file, &ac, sizeof(acct_t), &pos);\n\t\tfile_end_write(file);\n\t}\nout:\n\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;\n\trevert_creds(orig_cred);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/blkdev.h> /* sector_div */",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void do_acct_process(struct bsd_acct_struct *acct);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void do_acct_process(struct bsd_acct_struct *acct);\n\nstatic void do_acct_process(struct bsd_acct_struct *acct)\n{\n\tacct_t ac;\n\tunsigned long flim;\n\tconst struct cred *orig_cred;\n\tstruct file *file = acct->file;\n\n\t/*\n\t * Accounting records are not subject to resource limits.\n\t */\n\tflim = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;\n\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;\n\t/* Perform file operations on behalf of whoever enabled accounting */\n\torig_cred = override_creds(file->f_cred);\n\n\t/*\n\t * First check to see if there is enough free_space to continue\n\t * the process accounting system.\n\t */\n\tif (!check_free_space(acct))\n\t\tgoto out;\n\n\tfill_ac(&ac);\n\t/* we really need to bite the bullet and change layout */\n\tac.ac_uid = from_kuid_munged(file->f_cred->user_ns, orig_cred->uid);\n\tac.ac_gid = from_kgid_munged(file->f_cred->user_ns, orig_cred->gid);\n#if ACCT_VERSION == 1 || ACCT_VERSION == 2\n\t/* backward-compatible 16 bit fields */\n\tac.ac_uid16 = ac.ac_uid;\n\tac.ac_gid16 = ac.ac_gid;\n#endif\n#if ACCT_VERSION == 3\n\t{\n\t\tstruct pid_namespace *ns = acct->ns;\n\n\t\tac.ac_pid = task_tgid_nr_ns(current, ns);\n\t\trcu_read_lock();\n\t\tac.ac_ppid = task_tgid_nr_ns(rcu_dereference(current->real_parent),\n\t\t\t\t\t     ns);\n\t\trcu_read_unlock();\n\t}\n#endif\n\t/*\n\t * Get freeze protection. If the fs is frozen, just skip the write\n\t * as we could deadlock the system otherwise.\n\t */\n\tif (file_start_write_trylock(file)) {\n\t\t/* it's been opened O_APPEND, so position is irrelevant */\n\t\tloff_t pos = 0;\n\t\t__kernel_write(file, &ac, sizeof(acct_t), &pos);\n\t\tfile_end_write(file);\n\t}\nout:\n\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;\n\trevert_creds(orig_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "acct_get",
          "args": [
            "ns"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "acct_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
          "lines": "144-168",
          "snippet": "static struct bsd_acct_struct *acct_get(struct pid_namespace *ns)\n{\n\tstruct bsd_acct_struct *res;\nagain:\n\tsmp_rmb();\n\trcu_read_lock();\n\tres = to_acct(READ_ONCE(ns->bacct));\n\tif (!res) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\tif (!atomic_long_inc_not_zero(&res->count)) {\n\t\trcu_read_unlock();\n\t\tcpu_relax();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\tmutex_lock(&res->lock);\n\tif (res != to_acct(READ_ONCE(ns->bacct))) {\n\t\tmutex_unlock(&res->lock);\n\t\tacct_put(res);\n\t\tgoto again;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/blkdev.h> /* sector_div */",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic struct bsd_acct_struct *acct_get(struct pid_namespace *ns)\n{\n\tstruct bsd_acct_struct *res;\nagain:\n\tsmp_rmb();\n\trcu_read_lock();\n\tres = to_acct(READ_ONCE(ns->bacct));\n\tif (!res) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\tif (!atomic_long_inc_not_zero(&res->count)) {\n\t\trcu_read_unlock();\n\t\tcpu_relax();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\tmutex_lock(&res->lock);\n\tif (res != to_acct(READ_ONCE(ns->bacct))) {\n\t\tmutex_unlock(&res->lock);\n\t\tacct_put(res);\n\t\tgoto again;\n\t}\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void do_acct_process(struct bsd_acct_struct *acct);\n\nstatic void slow_acct_process(struct pid_namespace *ns)\n{\n\tfor ( ; ns; ns = ns->parent) {\n\t\tstruct bsd_acct_struct *acct = acct_get(ns);\n\t\tif (acct) {\n\t\t\tdo_acct_process(acct);\n\t\t\tmutex_unlock(&acct->lock);\n\t\t\tacct_put(acct);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "acct_collect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
    "lines": "533-572",
    "snippet": "void acct_collect(long exitcode, int group_dead)\n{\n\tstruct pacct_struct *pacct = &current->signal->pacct;\n\tu64 utime, stime;\n\tunsigned long vsize = 0;\n\n\tif (group_dead && current->mm) {\n\t\tstruct vm_area_struct *vma;\n\n\t\tdown_read(&current->mm->mmap_sem);\n\t\tvma = current->mm->mmap;\n\t\twhile (vma) {\n\t\t\tvsize += vma->vm_end - vma->vm_start;\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t\tup_read(&current->mm->mmap_sem);\n\t}\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (group_dead)\n\t\tpacct->ac_mem = vsize / 1024;\n\tif (thread_group_leader(current)) {\n\t\tpacct->ac_exitcode = exitcode;\n\t\tif (current->flags & PF_FORKNOEXEC)\n\t\t\tpacct->ac_flag |= AFORK;\n\t}\n\tif (current->flags & PF_SUPERPRIV)\n\t\tpacct->ac_flag |= ASU;\n\tif (current->flags & PF_DUMPCORE)\n\t\tpacct->ac_flag |= ACORE;\n\tif (current->flags & PF_SIGNALED)\n\t\tpacct->ac_flag |= AXSIG;\n\n\ttask_cputime(current, &utime, &stime);\n\tpacct->ac_utime += utime;\n\tpacct->ac_stime += stime;\n\tpacct->ac_minflt += current->min_flt;\n\tpacct->ac_majflt += current->maj_flt;\n\tspin_unlock_irq(&current->sighand->siglock);\n}",
    "includes": [
      "#include <linux/fs_pin.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/blkdev.h> /* sector_div */",
      "#include <asm/div64.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mount.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/times.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/vfs.h>",
      "#include <linux/security.h>",
      "#include <linux/tty.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/acct.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "current",
            "&utime",
            "&stime"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "861-894",
          "snippet": "void task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "current"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&current->mm->mmap_sem"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "336-342",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&current->mm->mmap_sem"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "down_read_non_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem.c",
          "lines": "180-186",
          "snippet": "void down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}",
          "includes": [
            "#include \"rwsem.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwsem.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid acct_collect(long exitcode, int group_dead)\n{\n\tstruct pacct_struct *pacct = &current->signal->pacct;\n\tu64 utime, stime;\n\tunsigned long vsize = 0;\n\n\tif (group_dead && current->mm) {\n\t\tstruct vm_area_struct *vma;\n\n\t\tdown_read(&current->mm->mmap_sem);\n\t\tvma = current->mm->mmap;\n\t\twhile (vma) {\n\t\t\tvsize += vma->vm_end - vma->vm_start;\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t\tup_read(&current->mm->mmap_sem);\n\t}\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (group_dead)\n\t\tpacct->ac_mem = vsize / 1024;\n\tif (thread_group_leader(current)) {\n\t\tpacct->ac_exitcode = exitcode;\n\t\tif (current->flags & PF_FORKNOEXEC)\n\t\t\tpacct->ac_flag |= AFORK;\n\t}\n\tif (current->flags & PF_SUPERPRIV)\n\t\tpacct->ac_flag |= ASU;\n\tif (current->flags & PF_DUMPCORE)\n\t\tpacct->ac_flag |= ACORE;\n\tif (current->flags & PF_SIGNALED)\n\t\tpacct->ac_flag |= AXSIG;\n\n\ttask_cputime(current, &utime, &stime);\n\tpacct->ac_utime += utime;\n\tpacct->ac_stime += stime;\n\tpacct->ac_minflt += current->min_flt;\n\tpacct->ac_majflt += current->maj_flt;\n\tspin_unlock_irq(&current->sighand->siglock);\n}"
  },
  {
    "function_name": "do_acct_process",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
    "lines": "471-526",
    "snippet": "static void do_acct_process(struct bsd_acct_struct *acct)\n{\n\tacct_t ac;\n\tunsigned long flim;\n\tconst struct cred *orig_cred;\n\tstruct file *file = acct->file;\n\n\t/*\n\t * Accounting records are not subject to resource limits.\n\t */\n\tflim = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;\n\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;\n\t/* Perform file operations on behalf of whoever enabled accounting */\n\torig_cred = override_creds(file->f_cred);\n\n\t/*\n\t * First check to see if there is enough free_space to continue\n\t * the process accounting system.\n\t */\n\tif (!check_free_space(acct))\n\t\tgoto out;\n\n\tfill_ac(&ac);\n\t/* we really need to bite the bullet and change layout */\n\tac.ac_uid = from_kuid_munged(file->f_cred->user_ns, orig_cred->uid);\n\tac.ac_gid = from_kgid_munged(file->f_cred->user_ns, orig_cred->gid);\n#if ACCT_VERSION == 1 || ACCT_VERSION == 2\n\t/* backward-compatible 16 bit fields */\n\tac.ac_uid16 = ac.ac_uid;\n\tac.ac_gid16 = ac.ac_gid;\n#endif\n#if ACCT_VERSION == 3\n\t{\n\t\tstruct pid_namespace *ns = acct->ns;\n\n\t\tac.ac_pid = task_tgid_nr_ns(current, ns);\n\t\trcu_read_lock();\n\t\tac.ac_ppid = task_tgid_nr_ns(rcu_dereference(current->real_parent),\n\t\t\t\t\t     ns);\n\t\trcu_read_unlock();\n\t}\n#endif\n\t/*\n\t * Get freeze protection. If the fs is frozen, just skip the write\n\t * as we could deadlock the system otherwise.\n\t */\n\tif (file_start_write_trylock(file)) {\n\t\t/* it's been opened O_APPEND, so position is irrelevant */\n\t\tloff_t pos = 0;\n\t\t__kernel_write(file, &ac, sizeof(acct_t), &pos);\n\t\tfile_end_write(file);\n\t}\nout:\n\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;\n\trevert_creds(orig_cred);\n}",
    "includes": [
      "#include <linux/fs_pin.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/blkdev.h> /* sector_div */",
      "#include <asm/div64.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mount.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/times.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/vfs.h>",
      "#include <linux/security.h>",
      "#include <linux/tty.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/acct.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void do_acct_process(struct bsd_acct_struct *acct);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "revert_creds",
          "args": [
            "orig_cred"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "revert_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "550-564",
          "snippet": "void revert_creds(const struct cred *old)\n{\n\tconst struct cred *override = current->cred;\n\n\tkdebug(\"revert_creds(%p{%d,%d})\", old,\n\t       atomic_read(&old->usage),\n\t       read_cred_subscribers(old));\n\n\tvalidate_creds(old);\n\tvalidate_creds(override);\n\talter_cred_subscribers(old, 1);\n\trcu_assign_pointer(current->cred, old);\n\talter_cred_subscribers(override, -1);\n\tput_cred(override);\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid revert_creds(const struct cred *old)\n{\n\tconst struct cred *override = current->cred;\n\n\tkdebug(\"revert_creds(%p{%d,%d})\", old,\n\t       atomic_read(&old->usage),\n\t       read_cred_subscribers(old));\n\n\tvalidate_creds(old);\n\tvalidate_creds(override);\n\talter_cred_subscribers(old, 1);\n\trcu_assign_pointer(current->cred, old);\n\talter_cred_subscribers(override, -1);\n\tput_cred(override);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_end_write",
          "args": [
            "file"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kernel_write",
          "args": [
            "file",
            "&ac",
            "sizeof(acct_t)",
            "&pos"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_start_write_trylock",
          "args": [
            "file"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid_nr_ns",
          "args": [
            "rcu_dereference(current->real_parent)",
            "ns"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "current->real_parent"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "task_rcu_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "234-291",
          "snippet": "struct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid_nr_ns",
          "args": [
            "current",
            "ns"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "file->f_cred->user_ns",
            "orig_cred->gid"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "from_kgid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "503-511",
          "snippet": "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "file->f_cred->user_ns",
            "orig_cred->uid"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_ac",
          "args": [
            "&ac"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "fill_ac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
          "lines": "415-467",
          "snippet": "static void fill_ac(acct_t *ac)\n{\n\tstruct pacct_struct *pacct = &current->signal->pacct;\n\tu64 elapsed, run_time;\n\tstruct tty_struct *tty;\n\n\t/*\n\t * Fill the accounting struct with the needed info as recorded\n\t * by the different kernel functions.\n\t */\n\tmemset(ac, 0, sizeof(acct_t));\n\n\tac->ac_version = ACCT_VERSION | ACCT_BYTEORDER;\n\tstrlcpy(ac->ac_comm, current->comm, sizeof(ac->ac_comm));\n\n\t/* calculate run_time in nsec*/\n\trun_time = ktime_get_ns();\n\trun_time -= current->group_leader->start_time;\n\t/* convert nsec -> AHZ */\n\telapsed = nsec_to_AHZ(run_time);\n#if ACCT_VERSION == 3\n\tac->ac_etime = encode_float(elapsed);\n#else\n\tac->ac_etime = encode_comp_t(elapsed < (unsigned long) -1l ?\n\t\t\t\t(unsigned long) elapsed : (unsigned long) -1l);\n#endif\n#if ACCT_VERSION == 1 || ACCT_VERSION == 2\n\t{\n\t\t/* new enlarged etime field */\n\t\tcomp2_t etime = encode_comp2_t(elapsed);\n\n\t\tac->ac_etime_hi = etime >> 16;\n\t\tac->ac_etime_lo = (u16) etime;\n\t}\n#endif\n\tdo_div(elapsed, AHZ);\n\tac->ac_btime = get_seconds() - elapsed;\n#if ACCT_VERSION==2\n\tac->ac_ahz = AHZ;\n#endif\n\n\tspin_lock_irq(&current->sighand->siglock);\n\ttty = current->signal->tty;\t/* Safe as we hold the siglock */\n\tac->ac_tty = tty ? old_encode_dev(tty_devnum(tty)) : 0;\n\tac->ac_utime = encode_comp_t(nsec_to_AHZ(pacct->ac_utime));\n\tac->ac_stime = encode_comp_t(nsec_to_AHZ(pacct->ac_stime));\n\tac->ac_flag = pacct->ac_flag;\n\tac->ac_mem = encode_comp_t(pacct->ac_mem);\n\tac->ac_minflt = encode_comp_t(pacct->ac_minflt);\n\tac->ac_majflt = encode_comp_t(pacct->ac_majflt);\n\tac->ac_exitcode = pacct->ac_exitcode;\n\tspin_unlock_irq(&current->sighand->siglock);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/blkdev.h> /* sector_div */",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void fill_ac(acct_t *ac)\n{\n\tstruct pacct_struct *pacct = &current->signal->pacct;\n\tu64 elapsed, run_time;\n\tstruct tty_struct *tty;\n\n\t/*\n\t * Fill the accounting struct with the needed info as recorded\n\t * by the different kernel functions.\n\t */\n\tmemset(ac, 0, sizeof(acct_t));\n\n\tac->ac_version = ACCT_VERSION | ACCT_BYTEORDER;\n\tstrlcpy(ac->ac_comm, current->comm, sizeof(ac->ac_comm));\n\n\t/* calculate run_time in nsec*/\n\trun_time = ktime_get_ns();\n\trun_time -= current->group_leader->start_time;\n\t/* convert nsec -> AHZ */\n\telapsed = nsec_to_AHZ(run_time);\n#if ACCT_VERSION == 3\n\tac->ac_etime = encode_float(elapsed);\n#else\n\tac->ac_etime = encode_comp_t(elapsed < (unsigned long) -1l ?\n\t\t\t\t(unsigned long) elapsed : (unsigned long) -1l);\n#endif\n#if ACCT_VERSION == 1 || ACCT_VERSION == 2\n\t{\n\t\t/* new enlarged etime field */\n\t\tcomp2_t etime = encode_comp2_t(elapsed);\n\n\t\tac->ac_etime_hi = etime >> 16;\n\t\tac->ac_etime_lo = (u16) etime;\n\t}\n#endif\n\tdo_div(elapsed, AHZ);\n\tac->ac_btime = get_seconds() - elapsed;\n#if ACCT_VERSION==2\n\tac->ac_ahz = AHZ;\n#endif\n\n\tspin_lock_irq(&current->sighand->siglock);\n\ttty = current->signal->tty;\t/* Safe as we hold the siglock */\n\tac->ac_tty = tty ? old_encode_dev(tty_devnum(tty)) : 0;\n\tac->ac_utime = encode_comp_t(nsec_to_AHZ(pacct->ac_utime));\n\tac->ac_stime = encode_comp_t(nsec_to_AHZ(pacct->ac_stime));\n\tac->ac_flag = pacct->ac_flag;\n\tac->ac_mem = encode_comp_t(pacct->ac_mem);\n\tac->ac_minflt = encode_comp_t(pacct->ac_minflt);\n\tac->ac_majflt = encode_comp_t(pacct->ac_majflt);\n\tac->ac_exitcode = pacct->ac_exitcode;\n\tspin_unlock_irq(&current->sighand->siglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_free_space",
          "args": [
            "acct"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "check_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
          "lines": "101-131",
          "snippet": "static int check_free_space(struct bsd_acct_struct *acct)\n{\n\tstruct kstatfs sbuf;\n\n\tif (time_is_after_jiffies(acct->needcheck))\n\t\tgoto out;\n\n\t/* May block */\n\tif (vfs_statfs(&acct->file->f_path, &sbuf))\n\t\tgoto out;\n\n\tif (acct->active) {\n\t\tu64 suspend = sbuf.f_blocks * SUSPEND;\n\t\tdo_div(suspend, 100);\n\t\tif (sbuf.f_bavail <= suspend) {\n\t\t\tacct->active = 0;\n\t\t\tpr_info(\"Process accounting paused\\n\");\n\t\t}\n\t} else {\n\t\tu64 resume = sbuf.f_blocks * RESUME;\n\t\tdo_div(resume, 100);\n\t\tif (sbuf.f_bavail >= resume) {\n\t\t\tacct->active = 1;\n\t\t\tpr_info(\"Process accounting resumed\\n\");\n\t\t}\n\t}\n\n\tacct->needcheck = jiffies + ACCT_TIMEOUT*HZ;\nout:\n\treturn acct->active;\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/blkdev.h> /* sector_div */",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define ACCT_TIMEOUT\t(acct_parm[2])\t/* foo second timeout between checks */",
            "#define SUSPEND\t\t(acct_parm[1])\t/* <foo% free space - suspend */",
            "#define RESUME\t\t(acct_parm[0])\t/* >foo% free space - resume */"
          ],
          "globals_used": [
            "static void do_acct_process(struct bsd_acct_struct *acct);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\n#define ACCT_TIMEOUT\t(acct_parm[2])\t/* foo second timeout between checks */\n#define SUSPEND\t\t(acct_parm[1])\t/* <foo% free space - suspend */\n#define RESUME\t\t(acct_parm[0])\t/* >foo% free space - resume */\n\nstatic void do_acct_process(struct bsd_acct_struct *acct);\n\nstatic int check_free_space(struct bsd_acct_struct *acct)\n{\n\tstruct kstatfs sbuf;\n\n\tif (time_is_after_jiffies(acct->needcheck))\n\t\tgoto out;\n\n\t/* May block */\n\tif (vfs_statfs(&acct->file->f_path, &sbuf))\n\t\tgoto out;\n\n\tif (acct->active) {\n\t\tu64 suspend = sbuf.f_blocks * SUSPEND;\n\t\tdo_div(suspend, 100);\n\t\tif (sbuf.f_bavail <= suspend) {\n\t\t\tacct->active = 0;\n\t\t\tpr_info(\"Process accounting paused\\n\");\n\t\t}\n\t} else {\n\t\tu64 resume = sbuf.f_blocks * RESUME;\n\t\tdo_div(resume, 100);\n\t\tif (sbuf.f_bavail >= resume) {\n\t\t\tacct->active = 1;\n\t\t\tpr_info(\"Process accounting resumed\\n\");\n\t\t}\n\t}\n\n\tacct->needcheck = jiffies + ACCT_TIMEOUT*HZ;\nout:\n\treturn acct->active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "override_creds",
          "args": [
            "file->f_cred"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "override_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "521-540",
          "snippet": "const struct cred *override_creds(const struct cred *new)\n{\n\tconst struct cred *old = current->cred;\n\n\tkdebug(\"override_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n\tget_cred(new);\n\talter_cred_subscribers(new, 1);\n\trcu_assign_pointer(current->cred, new);\n\talter_cred_subscribers(old, -1);\n\n\tkdebug(\"override_creds() = %p{%d,%d}\", old,\n\t       atomic_read(&old->usage),\n\t       read_cred_subscribers(old));\n\treturn old;\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nconst struct cred *override_creds(const struct cred *new)\n{\n\tconst struct cred *old = current->cred;\n\n\tkdebug(\"override_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n\tget_cred(new);\n\talter_cred_subscribers(new, 1);\n\trcu_assign_pointer(current->cred, new);\n\talter_cred_subscribers(old, -1);\n\n\tkdebug(\"override_creds() = %p{%d,%d}\", old,\n\t       atomic_read(&old->usage),\n\t       read_cred_subscribers(old));\n\treturn old;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void do_acct_process(struct bsd_acct_struct *acct);\n\nstatic void do_acct_process(struct bsd_acct_struct *acct)\n{\n\tacct_t ac;\n\tunsigned long flim;\n\tconst struct cred *orig_cred;\n\tstruct file *file = acct->file;\n\n\t/*\n\t * Accounting records are not subject to resource limits.\n\t */\n\tflim = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;\n\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;\n\t/* Perform file operations on behalf of whoever enabled accounting */\n\torig_cred = override_creds(file->f_cred);\n\n\t/*\n\t * First check to see if there is enough free_space to continue\n\t * the process accounting system.\n\t */\n\tif (!check_free_space(acct))\n\t\tgoto out;\n\n\tfill_ac(&ac);\n\t/* we really need to bite the bullet and change layout */\n\tac.ac_uid = from_kuid_munged(file->f_cred->user_ns, orig_cred->uid);\n\tac.ac_gid = from_kgid_munged(file->f_cred->user_ns, orig_cred->gid);\n#if ACCT_VERSION == 1 || ACCT_VERSION == 2\n\t/* backward-compatible 16 bit fields */\n\tac.ac_uid16 = ac.ac_uid;\n\tac.ac_gid16 = ac.ac_gid;\n#endif\n#if ACCT_VERSION == 3\n\t{\n\t\tstruct pid_namespace *ns = acct->ns;\n\n\t\tac.ac_pid = task_tgid_nr_ns(current, ns);\n\t\trcu_read_lock();\n\t\tac.ac_ppid = task_tgid_nr_ns(rcu_dereference(current->real_parent),\n\t\t\t\t\t     ns);\n\t\trcu_read_unlock();\n\t}\n#endif\n\t/*\n\t * Get freeze protection. If the fs is frozen, just skip the write\n\t * as we could deadlock the system otherwise.\n\t */\n\tif (file_start_write_trylock(file)) {\n\t\t/* it's been opened O_APPEND, so position is irrelevant */\n\t\tloff_t pos = 0;\n\t\t__kernel_write(file, &ac, sizeof(acct_t), &pos);\n\t\tfile_end_write(file);\n\t}\nout:\n\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;\n\trevert_creds(orig_cred);\n}"
  },
  {
    "function_name": "fill_ac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
    "lines": "415-467",
    "snippet": "static void fill_ac(acct_t *ac)\n{\n\tstruct pacct_struct *pacct = &current->signal->pacct;\n\tu64 elapsed, run_time;\n\tstruct tty_struct *tty;\n\n\t/*\n\t * Fill the accounting struct with the needed info as recorded\n\t * by the different kernel functions.\n\t */\n\tmemset(ac, 0, sizeof(acct_t));\n\n\tac->ac_version = ACCT_VERSION | ACCT_BYTEORDER;\n\tstrlcpy(ac->ac_comm, current->comm, sizeof(ac->ac_comm));\n\n\t/* calculate run_time in nsec*/\n\trun_time = ktime_get_ns();\n\trun_time -= current->group_leader->start_time;\n\t/* convert nsec -> AHZ */\n\telapsed = nsec_to_AHZ(run_time);\n#if ACCT_VERSION == 3\n\tac->ac_etime = encode_float(elapsed);\n#else\n\tac->ac_etime = encode_comp_t(elapsed < (unsigned long) -1l ?\n\t\t\t\t(unsigned long) elapsed : (unsigned long) -1l);\n#endif\n#if ACCT_VERSION == 1 || ACCT_VERSION == 2\n\t{\n\t\t/* new enlarged etime field */\n\t\tcomp2_t etime = encode_comp2_t(elapsed);\n\n\t\tac->ac_etime_hi = etime >> 16;\n\t\tac->ac_etime_lo = (u16) etime;\n\t}\n#endif\n\tdo_div(elapsed, AHZ);\n\tac->ac_btime = get_seconds() - elapsed;\n#if ACCT_VERSION==2\n\tac->ac_ahz = AHZ;\n#endif\n\n\tspin_lock_irq(&current->sighand->siglock);\n\ttty = current->signal->tty;\t/* Safe as we hold the siglock */\n\tac->ac_tty = tty ? old_encode_dev(tty_devnum(tty)) : 0;\n\tac->ac_utime = encode_comp_t(nsec_to_AHZ(pacct->ac_utime));\n\tac->ac_stime = encode_comp_t(nsec_to_AHZ(pacct->ac_stime));\n\tac->ac_flag = pacct->ac_flag;\n\tac->ac_mem = encode_comp_t(pacct->ac_mem);\n\tac->ac_minflt = encode_comp_t(pacct->ac_minflt);\n\tac->ac_majflt = encode_comp_t(pacct->ac_majflt);\n\tac->ac_exitcode = pacct->ac_exitcode;\n\tspin_unlock_irq(&current->sighand->siglock);\n}",
    "includes": [
      "#include <linux/fs_pin.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/blkdev.h> /* sector_div */",
      "#include <asm/div64.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mount.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/times.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/vfs.h>",
      "#include <linux/security.h>",
      "#include <linux/tty.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/acct.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_comp_t",
          "args": [
            "pacct->ac_majflt"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "encode_comp_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
          "lines": "315-340",
          "snippet": "static comp_t encode_comp_t(unsigned long value)\n{\n\tint exp, rnd;\n\n\texp = rnd = 0;\n\twhile (value > MAXFRACT) {\n\t\trnd = value & (1 << (EXPSIZE - 1));\t/* Round up? */\n\t\tvalue >>= EXPSIZE;\t/* Base 8 exponent == 3 bit shift. */\n\t\texp++;\n\t}\n\n\t/*\n\t * If we need to round up, do it (and handle overflow correctly).\n\t */\n\tif (rnd && (++value > MAXFRACT)) {\n\t\tvalue >>= EXPSIZE;\n\t\texp++;\n\t}\n\n\t/*\n\t * Clean it up and polish it off.\n\t */\n\texp <<= MANTSIZE;\t\t/* Shift the exponent into place */\n\texp += value;\t\t\t/* and add on the mantissa. */\n\treturn exp;\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/blkdev.h> /* sector_div */",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define\tMAXFRACT\t((1 << MANTSIZE) - 1)\t/* Maximum fractional value. */",
            "#define\tEXPSIZE\t\t3\t\t\t/* Base 8 (3 bit) exponent. */",
            "#define\tMANTSIZE\t13\t\t\t/* 13 bit mantissa. */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\n#define\tMAXFRACT\t((1 << MANTSIZE) - 1)\t/* Maximum fractional value. */\n#define\tEXPSIZE\t\t3\t\t\t/* Base 8 (3 bit) exponent. */\n#define\tMANTSIZE\t13\t\t\t/* 13 bit mantissa. */\n\nstatic comp_t encode_comp_t(unsigned long value)\n{\n\tint exp, rnd;\n\n\texp = rnd = 0;\n\twhile (value > MAXFRACT) {\n\t\trnd = value & (1 << (EXPSIZE - 1));\t/* Round up? */\n\t\tvalue >>= EXPSIZE;\t/* Base 8 exponent == 3 bit shift. */\n\t\texp++;\n\t}\n\n\t/*\n\t * If we need to round up, do it (and handle overflow correctly).\n\t */\n\tif (rnd && (++value > MAXFRACT)) {\n\t\tvalue >>= EXPSIZE;\n\t\texp++;\n\t}\n\n\t/*\n\t * Clean it up and polish it off.\n\t */\n\texp <<= MANTSIZE;\t\t/* Shift the exponent into place */\n\texp += value;\t\t\t/* and add on the mantissa. */\n\treturn exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nsec_to_AHZ",
          "args": [
            "pacct->ac_stime"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nsec_to_AHZ",
          "args": [
            "pacct->ac_utime"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_encode_dev",
          "args": [
            "tty_devnum(tty)"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tty_devnum",
          "args": [
            "tty"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "908-914",
          "snippet": "time64_t ktime_get_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tWARN_ON(timekeeping_suspended);\n\treturn tk->ktime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t ktime_get_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tWARN_ON(timekeeping_suspended);\n\treturn tk->ktime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "elapsed",
            "AHZ"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_comp2_t",
          "args": [
            "elapsed"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "encode_comp2_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
          "lines": "357-383",
          "snippet": "static comp2_t encode_comp2_t(u64 value)\n{\n\tint exp, rnd;\n\n\texp = (value > (MAXFRACT2>>1));\n\trnd = 0;\n\twhile (value > MAXFRACT2) {\n\t\trnd = value & 1;\n\t\tvalue >>= 1;\n\t\texp++;\n\t}\n\n\t/*\n\t * If we need to round up, do it (and handle overflow correctly).\n\t */\n\tif (rnd && (++value > MAXFRACT2)) {\n\t\tvalue >>= 1;\n\t\texp++;\n\t}\n\n\tif (exp > MAXEXP2) {\n\t\t/* Overflow. Return largest representable number instead. */\n\t\treturn (1ul << (MANTSIZE2+EXPSIZE2-1)) - 1;\n\t} else {\n\t\treturn (value & (MAXFRACT2>>1)) | (exp << (MANTSIZE2-1));\n\t}\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/blkdev.h> /* sector_div */",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define MAXEXP2         ((1 << EXPSIZE2) - 1)    /* Maximum exponent. */",
            "#define MAXFRACT2       ((1ul << MANTSIZE2) - 1) /* Maximum fractional value. */",
            "#define EXPSIZE2        5                       /* 5 bit base 2 exponent. */",
            "#define MANTSIZE2       20                      /* 20 bit mantissa. */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\n#define MAXEXP2         ((1 << EXPSIZE2) - 1)    /* Maximum exponent. */\n#define MAXFRACT2       ((1ul << MANTSIZE2) - 1) /* Maximum fractional value. */\n#define EXPSIZE2        5                       /* 5 bit base 2 exponent. */\n#define MANTSIZE2       20                      /* 20 bit mantissa. */\n\nstatic comp2_t encode_comp2_t(u64 value)\n{\n\tint exp, rnd;\n\n\texp = (value > (MAXFRACT2>>1));\n\trnd = 0;\n\twhile (value > MAXFRACT2) {\n\t\trnd = value & 1;\n\t\tvalue >>= 1;\n\t\texp++;\n\t}\n\n\t/*\n\t * If we need to round up, do it (and handle overflow correctly).\n\t */\n\tif (rnd && (++value > MAXFRACT2)) {\n\t\tvalue >>= 1;\n\t\texp++;\n\t}\n\n\tif (exp > MAXEXP2) {\n\t\t/* Overflow. Return largest representable number instead. */\n\t\treturn (1ul << (MANTSIZE2+EXPSIZE2-1)) - 1;\n\t} else {\n\t\treturn (value & (MAXFRACT2>>1)) | (exp << (MANTSIZE2-1));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_float",
          "args": [
            "elapsed"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "encode_float",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
          "lines": "390-403",
          "snippet": "static u32 encode_float(u64 value)\n{\n\tunsigned exp = 190;\n\tunsigned u;\n\n\tif (value == 0)\n\t\treturn 0;\n\twhile ((s64)value > 0) {\n\t\tvalue <<= 1;\n\t\texp--;\n\t}\n\tu = (u32)(value >> 40) & 0x7fffffu;\n\treturn u | (exp << 23);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/blkdev.h> /* sector_div */",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic u32 encode_float(u64 value)\n{\n\tunsigned exp = 190;\n\tunsigned u;\n\n\tif (value == 0)\n\t\treturn 0;\n\twhile ((s64)value > 0) {\n\t\tvalue <<= 1;\n\t\texp--;\n\t}\n\tu = (u32)(value >> 40) & 0x7fffffu;\n\treturn u | (exp << 23);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nsec_to_AHZ",
          "args": [
            "run_time"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_ns",
          "args": [],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "ac->ac_comm",
            "current->comm",
            "sizeof(ac->ac_comm)"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ac",
            "0",
            "sizeof(acct_t)"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void fill_ac(acct_t *ac)\n{\n\tstruct pacct_struct *pacct = &current->signal->pacct;\n\tu64 elapsed, run_time;\n\tstruct tty_struct *tty;\n\n\t/*\n\t * Fill the accounting struct with the needed info as recorded\n\t * by the different kernel functions.\n\t */\n\tmemset(ac, 0, sizeof(acct_t));\n\n\tac->ac_version = ACCT_VERSION | ACCT_BYTEORDER;\n\tstrlcpy(ac->ac_comm, current->comm, sizeof(ac->ac_comm));\n\n\t/* calculate run_time in nsec*/\n\trun_time = ktime_get_ns();\n\trun_time -= current->group_leader->start_time;\n\t/* convert nsec -> AHZ */\n\telapsed = nsec_to_AHZ(run_time);\n#if ACCT_VERSION == 3\n\tac->ac_etime = encode_float(elapsed);\n#else\n\tac->ac_etime = encode_comp_t(elapsed < (unsigned long) -1l ?\n\t\t\t\t(unsigned long) elapsed : (unsigned long) -1l);\n#endif\n#if ACCT_VERSION == 1 || ACCT_VERSION == 2\n\t{\n\t\t/* new enlarged etime field */\n\t\tcomp2_t etime = encode_comp2_t(elapsed);\n\n\t\tac->ac_etime_hi = etime >> 16;\n\t\tac->ac_etime_lo = (u16) etime;\n\t}\n#endif\n\tdo_div(elapsed, AHZ);\n\tac->ac_btime = get_seconds() - elapsed;\n#if ACCT_VERSION==2\n\tac->ac_ahz = AHZ;\n#endif\n\n\tspin_lock_irq(&current->sighand->siglock);\n\ttty = current->signal->tty;\t/* Safe as we hold the siglock */\n\tac->ac_tty = tty ? old_encode_dev(tty_devnum(tty)) : 0;\n\tac->ac_utime = encode_comp_t(nsec_to_AHZ(pacct->ac_utime));\n\tac->ac_stime = encode_comp_t(nsec_to_AHZ(pacct->ac_stime));\n\tac->ac_flag = pacct->ac_flag;\n\tac->ac_mem = encode_comp_t(pacct->ac_mem);\n\tac->ac_minflt = encode_comp_t(pacct->ac_minflt);\n\tac->ac_majflt = encode_comp_t(pacct->ac_majflt);\n\tac->ac_exitcode = pacct->ac_exitcode;\n\tspin_unlock_irq(&current->sighand->siglock);\n}"
  },
  {
    "function_name": "encode_float",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
    "lines": "390-403",
    "snippet": "static u32 encode_float(u64 value)\n{\n\tunsigned exp = 190;\n\tunsigned u;\n\n\tif (value == 0)\n\t\treturn 0;\n\twhile ((s64)value > 0) {\n\t\tvalue <<= 1;\n\t\texp--;\n\t}\n\tu = (u32)(value >> 40) & 0x7fffffu;\n\treturn u | (exp << 23);\n}",
    "includes": [
      "#include <linux/fs_pin.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/blkdev.h> /* sector_div */",
      "#include <asm/div64.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mount.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/times.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/vfs.h>",
      "#include <linux/security.h>",
      "#include <linux/tty.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/acct.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "value >> 40"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic u32 encode_float(u64 value)\n{\n\tunsigned exp = 190;\n\tunsigned u;\n\n\tif (value == 0)\n\t\treturn 0;\n\twhile ((s64)value > 0) {\n\t\tvalue <<= 1;\n\t\texp--;\n\t}\n\tu = (u32)(value >> 40) & 0x7fffffu;\n\treturn u | (exp << 23);\n}"
  },
  {
    "function_name": "encode_comp2_t",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
    "lines": "357-383",
    "snippet": "static comp2_t encode_comp2_t(u64 value)\n{\n\tint exp, rnd;\n\n\texp = (value > (MAXFRACT2>>1));\n\trnd = 0;\n\twhile (value > MAXFRACT2) {\n\t\trnd = value & 1;\n\t\tvalue >>= 1;\n\t\texp++;\n\t}\n\n\t/*\n\t * If we need to round up, do it (and handle overflow correctly).\n\t */\n\tif (rnd && (++value > MAXFRACT2)) {\n\t\tvalue >>= 1;\n\t\texp++;\n\t}\n\n\tif (exp > MAXEXP2) {\n\t\t/* Overflow. Return largest representable number instead. */\n\t\treturn (1ul << (MANTSIZE2+EXPSIZE2-1)) - 1;\n\t} else {\n\t\treturn (value & (MAXFRACT2>>1)) | (exp << (MANTSIZE2-1));\n\t}\n}",
    "includes": [
      "#include <linux/fs_pin.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/blkdev.h> /* sector_div */",
      "#include <asm/div64.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mount.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/times.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/vfs.h>",
      "#include <linux/security.h>",
      "#include <linux/tty.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/acct.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define MAXEXP2         ((1 << EXPSIZE2) - 1)    /* Maximum exponent. */",
      "#define MAXFRACT2       ((1ul << MANTSIZE2) - 1) /* Maximum fractional value. */",
      "#define EXPSIZE2        5                       /* 5 bit base 2 exponent. */",
      "#define MANTSIZE2       20                      /* 20 bit mantissa. */"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\n#define MAXEXP2         ((1 << EXPSIZE2) - 1)    /* Maximum exponent. */\n#define MAXFRACT2       ((1ul << MANTSIZE2) - 1) /* Maximum fractional value. */\n#define EXPSIZE2        5                       /* 5 bit base 2 exponent. */\n#define MANTSIZE2       20                      /* 20 bit mantissa. */\n\nstatic comp2_t encode_comp2_t(u64 value)\n{\n\tint exp, rnd;\n\n\texp = (value > (MAXFRACT2>>1));\n\trnd = 0;\n\twhile (value > MAXFRACT2) {\n\t\trnd = value & 1;\n\t\tvalue >>= 1;\n\t\texp++;\n\t}\n\n\t/*\n\t * If we need to round up, do it (and handle overflow correctly).\n\t */\n\tif (rnd && (++value > MAXFRACT2)) {\n\t\tvalue >>= 1;\n\t\texp++;\n\t}\n\n\tif (exp > MAXEXP2) {\n\t\t/* Overflow. Return largest representable number instead. */\n\t\treturn (1ul << (MANTSIZE2+EXPSIZE2-1)) - 1;\n\t} else {\n\t\treturn (value & (MAXFRACT2>>1)) | (exp << (MANTSIZE2-1));\n\t}\n}"
  },
  {
    "function_name": "encode_comp_t",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
    "lines": "315-340",
    "snippet": "static comp_t encode_comp_t(unsigned long value)\n{\n\tint exp, rnd;\n\n\texp = rnd = 0;\n\twhile (value > MAXFRACT) {\n\t\trnd = value & (1 << (EXPSIZE - 1));\t/* Round up? */\n\t\tvalue >>= EXPSIZE;\t/* Base 8 exponent == 3 bit shift. */\n\t\texp++;\n\t}\n\n\t/*\n\t * If we need to round up, do it (and handle overflow correctly).\n\t */\n\tif (rnd && (++value > MAXFRACT)) {\n\t\tvalue >>= EXPSIZE;\n\t\texp++;\n\t}\n\n\t/*\n\t * Clean it up and polish it off.\n\t */\n\texp <<= MANTSIZE;\t\t/* Shift the exponent into place */\n\texp += value;\t\t\t/* and add on the mantissa. */\n\treturn exp;\n}",
    "includes": [
      "#include <linux/fs_pin.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/blkdev.h> /* sector_div */",
      "#include <asm/div64.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mount.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/times.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/vfs.h>",
      "#include <linux/security.h>",
      "#include <linux/tty.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/acct.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define\tMAXFRACT\t((1 << MANTSIZE) - 1)\t/* Maximum fractional value. */",
      "#define\tEXPSIZE\t\t3\t\t\t/* Base 8 (3 bit) exponent. */",
      "#define\tMANTSIZE\t13\t\t\t/* 13 bit mantissa. */"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\n#define\tMAXFRACT\t((1 << MANTSIZE) - 1)\t/* Maximum fractional value. */\n#define\tEXPSIZE\t\t3\t\t\t/* Base 8 (3 bit) exponent. */\n#define\tMANTSIZE\t13\t\t\t/* 13 bit mantissa. */\n\nstatic comp_t encode_comp_t(unsigned long value)\n{\n\tint exp, rnd;\n\n\texp = rnd = 0;\n\twhile (value > MAXFRACT) {\n\t\trnd = value & (1 << (EXPSIZE - 1));\t/* Round up? */\n\t\tvalue >>= EXPSIZE;\t/* Base 8 exponent == 3 bit shift. */\n\t\texp++;\n\t}\n\n\t/*\n\t * If we need to round up, do it (and handle overflow correctly).\n\t */\n\tif (rnd && (++value > MAXFRACT)) {\n\t\tvalue >>= EXPSIZE;\n\t\texp++;\n\t}\n\n\t/*\n\t * Clean it up and polish it off.\n\t */\n\texp <<= MANTSIZE;\t\t/* Shift the exponent into place */\n\texp += value;\t\t\t/* and add on the mantissa. */\n\treturn exp;\n}"
  },
  {
    "function_name": "acct_exit_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
    "lines": "297-301",
    "snippet": "void acct_exit_ns(struct pid_namespace *ns)\n{\n\trcu_read_lock();\n\tpin_kill(ns->bacct);\n}",
    "includes": [
      "#include <linux/fs_pin.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/blkdev.h> /* sector_div */",
      "#include <asm/div64.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mount.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/times.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/vfs.h>",
      "#include <linux/security.h>",
      "#include <linux/tty.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/acct.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pin_kill",
          "args": [
            "ns->bacct"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "acct_pin_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
          "lines": "170-181",
          "snippet": "static void acct_pin_kill(struct fs_pin *pin)\n{\n\tstruct bsd_acct_struct *acct = to_acct(pin);\n\tmutex_lock(&acct->lock);\n\tdo_acct_process(acct);\n\tschedule_work(&acct->work);\n\twait_for_completion(&acct->done);\n\tcmpxchg(&acct->ns->bacct, pin, NULL);\n\tmutex_unlock(&acct->lock);\n\tpin_remove(pin);\n\tacct_put(acct);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/blkdev.h> /* sector_div */",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void do_acct_process(struct bsd_acct_struct *acct);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void do_acct_process(struct bsd_acct_struct *acct);\n\nstatic void acct_pin_kill(struct fs_pin *pin)\n{\n\tstruct bsd_acct_struct *acct = to_acct(pin);\n\tmutex_lock(&acct->lock);\n\tdo_acct_process(acct);\n\tschedule_work(&acct->work);\n\twait_for_completion(&acct->done);\n\tcmpxchg(&acct->ns->bacct, pin, NULL);\n\tmutex_unlock(&acct->lock);\n\tpin_remove(pin);\n\tacct_put(acct);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid acct_exit_ns(struct pid_namespace *ns)\n{\n\trcu_read_lock();\n\tpin_kill(ns->bacct);\n}"
  },
  {
    "function_name": "acct_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
    "lines": "193-258",
    "snippet": "static int acct_on(struct filename *pathname)\n{\n\tstruct file *file;\n\tstruct vfsmount *mnt, *internal;\n\tstruct pid_namespace *ns = task_active_pid_ns(current);\n\tstruct bsd_acct_struct *acct;\n\tstruct fs_pin *old;\n\tint err;\n\n\tacct = kzalloc(sizeof(struct bsd_acct_struct), GFP_KERNEL);\n\tif (!acct)\n\t\treturn -ENOMEM;\n\n\t/* Difference from BSD - they don't do O_APPEND */\n\tfile = file_open_name(pathname, O_WRONLY|O_APPEND|O_LARGEFILE, 0);\n\tif (IS_ERR(file)) {\n\t\tkfree(acct);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tif (!S_ISREG(file_inode(file)->i_mode)) {\n\t\tkfree(acct);\n\t\tfilp_close(file, NULL);\n\t\treturn -EACCES;\n\t}\n\n\tif (!(file->f_mode & FMODE_CAN_WRITE)) {\n\t\tkfree(acct);\n\t\tfilp_close(file, NULL);\n\t\treturn -EIO;\n\t}\n\tinternal = mnt_clone_internal(&file->f_path);\n\tif (IS_ERR(internal)) {\n\t\tkfree(acct);\n\t\tfilp_close(file, NULL);\n\t\treturn PTR_ERR(internal);\n\t}\n\terr = mnt_want_write(internal);\n\tif (err) {\n\t\tmntput(internal);\n\t\tkfree(acct);\n\t\tfilp_close(file, NULL);\n\t\treturn err;\n\t}\n\tmnt = file->f_path.mnt;\n\tfile->f_path.mnt = internal;\n\n\tatomic_long_set(&acct->count, 1);\n\tinit_fs_pin(&acct->pin, acct_pin_kill);\n\tacct->file = file;\n\tacct->needcheck = jiffies;\n\tacct->ns = ns;\n\tmutex_init(&acct->lock);\n\tINIT_WORK(&acct->work, close_work);\n\tinit_completion(&acct->done);\n\tmutex_lock_nested(&acct->lock, 1);\t/* nobody has seen it yet */\n\tpin_insert(&acct->pin, mnt);\n\n\trcu_read_lock();\n\told = xchg(&ns->bacct, &acct->pin);\n\tmutex_unlock(&acct->lock);\n\tpin_kill(old);\n\tmnt_drop_write(mnt);\n\tmntput(mnt);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs_pin.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/blkdev.h> /* sector_div */",
      "#include <asm/div64.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mount.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/times.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/vfs.h>",
      "#include <linux/security.h>",
      "#include <linux/tty.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/acct.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void do_acct_process(struct bsd_acct_struct *acct);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "mnt"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_drop_write",
          "args": [
            "mnt"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_kill",
          "args": [
            "old"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "acct_pin_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
          "lines": "170-181",
          "snippet": "static void acct_pin_kill(struct fs_pin *pin)\n{\n\tstruct bsd_acct_struct *acct = to_acct(pin);\n\tmutex_lock(&acct->lock);\n\tdo_acct_process(acct);\n\tschedule_work(&acct->work);\n\twait_for_completion(&acct->done);\n\tcmpxchg(&acct->ns->bacct, pin, NULL);\n\tmutex_unlock(&acct->lock);\n\tpin_remove(pin);\n\tacct_put(acct);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/blkdev.h> /* sector_div */",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void do_acct_process(struct bsd_acct_struct *acct);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void do_acct_process(struct bsd_acct_struct *acct);\n\nstatic void acct_pin_kill(struct fs_pin *pin)\n{\n\tstruct bsd_acct_struct *acct = to_acct(pin);\n\tmutex_lock(&acct->lock);\n\tdo_acct_process(acct);\n\tschedule_work(&acct->work);\n\twait_for_completion(&acct->done);\n\tcmpxchg(&acct->ns->bacct, pin, NULL);\n\tmutex_unlock(&acct->lock);\n\tpin_remove(pin);\n\tacct_put(acct);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&acct->lock"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&ns->bacct",
            "&acct->pin"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock.c",
          "lines": "231-249",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_insert",
          "args": [
            "&acct->pin",
            "mnt"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&acct->lock",
            "1"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1483-1486",
          "snippet": "void __sched rt_mutex_lock_nested(struct rt_mutex *lock, unsigned int subclass)\n{\n\t__rt_mutex_lock(lock, subclass);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_lock_nested(struct rt_mutex *lock, unsigned int subclass)\n{\n\t__rt_mutex_lock(lock, subclass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&acct->done"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&acct->work",
            "close_work"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&acct->lock"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1604-1612",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_fs_pin",
          "args": [
            "&acct->pin",
            "acct_pin_kill"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_set",
          "args": [
            "&acct->count",
            "1"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filp_close",
          "args": [
            "file",
            "NULL"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "acct"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "internal"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write",
          "args": [
            "internal"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "internal"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filp_close",
          "args": [
            "file",
            "NULL"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "internal"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_clone_internal",
          "args": [
            "&file->f_path"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filp_close",
          "args": [
            "file",
            "NULL"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filp_close",
          "args": [
            "file",
            "NULL"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "file_inode(file)->i_mode"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_open_name",
          "args": [
            "pathname",
            "O_WRONLY|O_APPEND|O_LARGEFILE",
            "0"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct bsd_acct_struct)",
            "GFP_KERNEL"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "436-439",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void do_acct_process(struct bsd_acct_struct *acct);\n\nstatic int acct_on(struct filename *pathname)\n{\n\tstruct file *file;\n\tstruct vfsmount *mnt, *internal;\n\tstruct pid_namespace *ns = task_active_pid_ns(current);\n\tstruct bsd_acct_struct *acct;\n\tstruct fs_pin *old;\n\tint err;\n\n\tacct = kzalloc(sizeof(struct bsd_acct_struct), GFP_KERNEL);\n\tif (!acct)\n\t\treturn -ENOMEM;\n\n\t/* Difference from BSD - they don't do O_APPEND */\n\tfile = file_open_name(pathname, O_WRONLY|O_APPEND|O_LARGEFILE, 0);\n\tif (IS_ERR(file)) {\n\t\tkfree(acct);\n\t\treturn PTR_ERR(file);\n\t}\n\n\tif (!S_ISREG(file_inode(file)->i_mode)) {\n\t\tkfree(acct);\n\t\tfilp_close(file, NULL);\n\t\treturn -EACCES;\n\t}\n\n\tif (!(file->f_mode & FMODE_CAN_WRITE)) {\n\t\tkfree(acct);\n\t\tfilp_close(file, NULL);\n\t\treturn -EIO;\n\t}\n\tinternal = mnt_clone_internal(&file->f_path);\n\tif (IS_ERR(internal)) {\n\t\tkfree(acct);\n\t\tfilp_close(file, NULL);\n\t\treturn PTR_ERR(internal);\n\t}\n\terr = mnt_want_write(internal);\n\tif (err) {\n\t\tmntput(internal);\n\t\tkfree(acct);\n\t\tfilp_close(file, NULL);\n\t\treturn err;\n\t}\n\tmnt = file->f_path.mnt;\n\tfile->f_path.mnt = internal;\n\n\tatomic_long_set(&acct->count, 1);\n\tinit_fs_pin(&acct->pin, acct_pin_kill);\n\tacct->file = file;\n\tacct->needcheck = jiffies;\n\tacct->ns = ns;\n\tmutex_init(&acct->lock);\n\tINIT_WORK(&acct->work, close_work);\n\tinit_completion(&acct->done);\n\tmutex_lock_nested(&acct->lock, 1);\t/* nobody has seen it yet */\n\tpin_insert(&acct->pin, mnt);\n\n\trcu_read_lock();\n\told = xchg(&ns->bacct, &acct->pin);\n\tmutex_unlock(&acct->lock);\n\tpin_kill(old);\n\tmnt_drop_write(mnt);\n\tmntput(mnt);\n\treturn 0;\n}"
  },
  {
    "function_name": "close_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
    "lines": "183-191",
    "snippet": "static void close_work(struct work_struct *work)\n{\n\tstruct bsd_acct_struct *acct = container_of(work, struct bsd_acct_struct, work);\n\tstruct file *file = acct->file;\n\tif (file->f_op->flush)\n\t\tfile->f_op->flush(file, NULL);\n\t__fput_sync(file);\n\tcomplete(&acct->done);\n}",
    "includes": [
      "#include <linux/fs_pin.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/blkdev.h> /* sector_div */",
      "#include <asm/div64.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mount.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/times.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/vfs.h>",
      "#include <linux/security.h>",
      "#include <linux/tty.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/acct.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void do_acct_process(struct bsd_acct_struct *acct);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&acct->done"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1205-1216",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fput_sync",
          "args": [
            "file"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->f_op->flush",
          "args": [
            "file",
            "NULL"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbsd_acct_struct",
            "work"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void do_acct_process(struct bsd_acct_struct *acct);\n\nstatic void close_work(struct work_struct *work)\n{\n\tstruct bsd_acct_struct *acct = container_of(work, struct bsd_acct_struct, work);\n\tstruct file *file = acct->file;\n\tif (file->f_op->flush)\n\t\tfile->f_op->flush(file, NULL);\n\t__fput_sync(file);\n\tcomplete(&acct->done);\n}"
  },
  {
    "function_name": "acct_pin_kill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
    "lines": "170-181",
    "snippet": "static void acct_pin_kill(struct fs_pin *pin)\n{\n\tstruct bsd_acct_struct *acct = to_acct(pin);\n\tmutex_lock(&acct->lock);\n\tdo_acct_process(acct);\n\tschedule_work(&acct->work);\n\twait_for_completion(&acct->done);\n\tcmpxchg(&acct->ns->bacct, pin, NULL);\n\tmutex_unlock(&acct->lock);\n\tpin_remove(pin);\n\tacct_put(acct);\n}",
    "includes": [
      "#include <linux/fs_pin.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/blkdev.h> /* sector_div */",
      "#include <asm/div64.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mount.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/times.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/vfs.h>",
      "#include <linux/security.h>",
      "#include <linux/tty.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/acct.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void do_acct_process(struct bsd_acct_struct *acct);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "acct_put",
          "args": [
            "acct"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "acct_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
          "lines": "133-137",
          "snippet": "static void acct_put(struct bsd_acct_struct *p)\n{\n\tif (atomic_long_dec_and_test(&p->count))\n\t\tkfree_rcu(p, rcu);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/blkdev.h> /* sector_div */",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void acct_put(struct bsd_acct_struct *p)\n{\n\tif (atomic_long_dec_and_test(&p->count))\n\t\tkfree_rcu(p, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_remove",
          "args": [
            "pin"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&acct->lock"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&acct->ns->bacct",
            "pin",
            "NULL"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&acct->done"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&acct->work"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_acct_process",
          "args": [
            "acct"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "do_acct_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
          "lines": "471-526",
          "snippet": "static void do_acct_process(struct bsd_acct_struct *acct)\n{\n\tacct_t ac;\n\tunsigned long flim;\n\tconst struct cred *orig_cred;\n\tstruct file *file = acct->file;\n\n\t/*\n\t * Accounting records are not subject to resource limits.\n\t */\n\tflim = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;\n\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;\n\t/* Perform file operations on behalf of whoever enabled accounting */\n\torig_cred = override_creds(file->f_cred);\n\n\t/*\n\t * First check to see if there is enough free_space to continue\n\t * the process accounting system.\n\t */\n\tif (!check_free_space(acct))\n\t\tgoto out;\n\n\tfill_ac(&ac);\n\t/* we really need to bite the bullet and change layout */\n\tac.ac_uid = from_kuid_munged(file->f_cred->user_ns, orig_cred->uid);\n\tac.ac_gid = from_kgid_munged(file->f_cred->user_ns, orig_cred->gid);\n#if ACCT_VERSION == 1 || ACCT_VERSION == 2\n\t/* backward-compatible 16 bit fields */\n\tac.ac_uid16 = ac.ac_uid;\n\tac.ac_gid16 = ac.ac_gid;\n#endif\n#if ACCT_VERSION == 3\n\t{\n\t\tstruct pid_namespace *ns = acct->ns;\n\n\t\tac.ac_pid = task_tgid_nr_ns(current, ns);\n\t\trcu_read_lock();\n\t\tac.ac_ppid = task_tgid_nr_ns(rcu_dereference(current->real_parent),\n\t\t\t\t\t     ns);\n\t\trcu_read_unlock();\n\t}\n#endif\n\t/*\n\t * Get freeze protection. If the fs is frozen, just skip the write\n\t * as we could deadlock the system otherwise.\n\t */\n\tif (file_start_write_trylock(file)) {\n\t\t/* it's been opened O_APPEND, so position is irrelevant */\n\t\tloff_t pos = 0;\n\t\t__kernel_write(file, &ac, sizeof(acct_t), &pos);\n\t\tfile_end_write(file);\n\t}\nout:\n\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;\n\trevert_creds(orig_cred);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/blkdev.h> /* sector_div */",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void do_acct_process(struct bsd_acct_struct *acct);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void do_acct_process(struct bsd_acct_struct *acct);\n\nstatic void do_acct_process(struct bsd_acct_struct *acct)\n{\n\tacct_t ac;\n\tunsigned long flim;\n\tconst struct cred *orig_cred;\n\tstruct file *file = acct->file;\n\n\t/*\n\t * Accounting records are not subject to resource limits.\n\t */\n\tflim = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;\n\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;\n\t/* Perform file operations on behalf of whoever enabled accounting */\n\torig_cred = override_creds(file->f_cred);\n\n\t/*\n\t * First check to see if there is enough free_space to continue\n\t * the process accounting system.\n\t */\n\tif (!check_free_space(acct))\n\t\tgoto out;\n\n\tfill_ac(&ac);\n\t/* we really need to bite the bullet and change layout */\n\tac.ac_uid = from_kuid_munged(file->f_cred->user_ns, orig_cred->uid);\n\tac.ac_gid = from_kgid_munged(file->f_cred->user_ns, orig_cred->gid);\n#if ACCT_VERSION == 1 || ACCT_VERSION == 2\n\t/* backward-compatible 16 bit fields */\n\tac.ac_uid16 = ac.ac_uid;\n\tac.ac_gid16 = ac.ac_gid;\n#endif\n#if ACCT_VERSION == 3\n\t{\n\t\tstruct pid_namespace *ns = acct->ns;\n\n\t\tac.ac_pid = task_tgid_nr_ns(current, ns);\n\t\trcu_read_lock();\n\t\tac.ac_ppid = task_tgid_nr_ns(rcu_dereference(current->real_parent),\n\t\t\t\t\t     ns);\n\t\trcu_read_unlock();\n\t}\n#endif\n\t/*\n\t * Get freeze protection. If the fs is frozen, just skip the write\n\t * as we could deadlock the system otherwise.\n\t */\n\tif (file_start_write_trylock(file)) {\n\t\t/* it's been opened O_APPEND, so position is irrelevant */\n\t\tloff_t pos = 0;\n\t\t__kernel_write(file, &ac, sizeof(acct_t), &pos);\n\t\tfile_end_write(file);\n\t}\nout:\n\tcurrent->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;\n\trevert_creds(orig_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&acct->lock"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_acct",
          "args": [
            "pin"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "to_acct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
          "lines": "139-142",
          "snippet": "static inline struct bsd_acct_struct *to_acct(struct fs_pin *p)\n{\n\treturn p ? container_of(p, struct bsd_acct_struct, pin) : NULL;\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/blkdev.h> /* sector_div */",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline struct bsd_acct_struct *to_acct(struct fs_pin *p)\n{\n\treturn p ? container_of(p, struct bsd_acct_struct, pin) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void do_acct_process(struct bsd_acct_struct *acct);\n\nstatic void acct_pin_kill(struct fs_pin *pin)\n{\n\tstruct bsd_acct_struct *acct = to_acct(pin);\n\tmutex_lock(&acct->lock);\n\tdo_acct_process(acct);\n\tschedule_work(&acct->work);\n\twait_for_completion(&acct->done);\n\tcmpxchg(&acct->ns->bacct, pin, NULL);\n\tmutex_unlock(&acct->lock);\n\tpin_remove(pin);\n\tacct_put(acct);\n}"
  },
  {
    "function_name": "acct_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
    "lines": "144-168",
    "snippet": "static struct bsd_acct_struct *acct_get(struct pid_namespace *ns)\n{\n\tstruct bsd_acct_struct *res;\nagain:\n\tsmp_rmb();\n\trcu_read_lock();\n\tres = to_acct(READ_ONCE(ns->bacct));\n\tif (!res) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\tif (!atomic_long_inc_not_zero(&res->count)) {\n\t\trcu_read_unlock();\n\t\tcpu_relax();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\tmutex_lock(&res->lock);\n\tif (res != to_acct(READ_ONCE(ns->bacct))) {\n\t\tmutex_unlock(&res->lock);\n\t\tacct_put(res);\n\t\tgoto again;\n\t}\n\treturn res;\n}",
    "includes": [
      "#include <linux/fs_pin.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/blkdev.h> /* sector_div */",
      "#include <asm/div64.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mount.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/times.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/vfs.h>",
      "#include <linux/security.h>",
      "#include <linux/tty.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/acct.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "acct_put",
          "args": [
            "res"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "acct_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
          "lines": "133-137",
          "snippet": "static void acct_put(struct bsd_acct_struct *p)\n{\n\tif (atomic_long_dec_and_test(&p->count))\n\t\tkfree_rcu(p, rcu);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/blkdev.h> /* sector_div */",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void acct_put(struct bsd_acct_struct *p)\n{\n\tif (atomic_long_dec_and_test(&p->count))\n\t\tkfree_rcu(p, rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&res->lock"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_acct",
          "args": [
            "READ_ONCE(ns->bacct)"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "to_acct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
          "lines": "139-142",
          "snippet": "static inline struct bsd_acct_struct *to_acct(struct fs_pin *p)\n{\n\treturn p ? container_of(p, struct bsd_acct_struct, pin) : NULL;\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/blkdev.h> /* sector_div */",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline struct bsd_acct_struct *to_acct(struct fs_pin *p)\n{\n\treturn p ? container_of(p, struct bsd_acct_struct, pin) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ns->bacct"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&res->lock"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_inc_not_zero",
          "args": [
            "&res->count"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ns->bacct"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic struct bsd_acct_struct *acct_get(struct pid_namespace *ns)\n{\n\tstruct bsd_acct_struct *res;\nagain:\n\tsmp_rmb();\n\trcu_read_lock();\n\tres = to_acct(READ_ONCE(ns->bacct));\n\tif (!res) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\tif (!atomic_long_inc_not_zero(&res->count)) {\n\t\trcu_read_unlock();\n\t\tcpu_relax();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\tmutex_lock(&res->lock);\n\tif (res != to_acct(READ_ONCE(ns->bacct))) {\n\t\tmutex_unlock(&res->lock);\n\t\tacct_put(res);\n\t\tgoto again;\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "to_acct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
    "lines": "139-142",
    "snippet": "static inline struct bsd_acct_struct *to_acct(struct fs_pin *p)\n{\n\treturn p ? container_of(p, struct bsd_acct_struct, pin) : NULL;\n}",
    "includes": [
      "#include <linux/fs_pin.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/blkdev.h> /* sector_div */",
      "#include <asm/div64.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mount.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/times.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/vfs.h>",
      "#include <linux/security.h>",
      "#include <linux/tty.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/acct.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structbsd_acct_struct",
            "pin"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline struct bsd_acct_struct *to_acct(struct fs_pin *p)\n{\n\treturn p ? container_of(p, struct bsd_acct_struct, pin) : NULL;\n}"
  },
  {
    "function_name": "acct_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
    "lines": "133-137",
    "snippet": "static void acct_put(struct bsd_acct_struct *p)\n{\n\tif (atomic_long_dec_and_test(&p->count))\n\t\tkfree_rcu(p, rcu);\n}",
    "includes": [
      "#include <linux/fs_pin.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/blkdev.h> /* sector_div */",
      "#include <asm/div64.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mount.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/times.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/vfs.h>",
      "#include <linux/security.h>",
      "#include <linux/tty.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/acct.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "p",
            "rcu"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_dec_and_test",
          "args": [
            "&p->count"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void acct_put(struct bsd_acct_struct *p)\n{\n\tif (atomic_long_dec_and_test(&p->count))\n\t\tkfree_rcu(p, rcu);\n}"
  },
  {
    "function_name": "check_free_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
    "lines": "101-131",
    "snippet": "static int check_free_space(struct bsd_acct_struct *acct)\n{\n\tstruct kstatfs sbuf;\n\n\tif (time_is_after_jiffies(acct->needcheck))\n\t\tgoto out;\n\n\t/* May block */\n\tif (vfs_statfs(&acct->file->f_path, &sbuf))\n\t\tgoto out;\n\n\tif (acct->active) {\n\t\tu64 suspend = sbuf.f_blocks * SUSPEND;\n\t\tdo_div(suspend, 100);\n\t\tif (sbuf.f_bavail <= suspend) {\n\t\t\tacct->active = 0;\n\t\t\tpr_info(\"Process accounting paused\\n\");\n\t\t}\n\t} else {\n\t\tu64 resume = sbuf.f_blocks * RESUME;\n\t\tdo_div(resume, 100);\n\t\tif (sbuf.f_bavail >= resume) {\n\t\t\tacct->active = 1;\n\t\t\tpr_info(\"Process accounting resumed\\n\");\n\t\t}\n\t}\n\n\tacct->needcheck = jiffies + ACCT_TIMEOUT*HZ;\nout:\n\treturn acct->active;\n}",
    "includes": [
      "#include <linux/fs_pin.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/blkdev.h> /* sector_div */",
      "#include <asm/div64.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mount.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/times.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/vfs.h>",
      "#include <linux/security.h>",
      "#include <linux/tty.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/acct.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [
      "#define ACCT_TIMEOUT\t(acct_parm[2])\t/* foo second timeout between checks */",
      "#define SUSPEND\t\t(acct_parm[1])\t/* <foo% free space - suspend */",
      "#define RESUME\t\t(acct_parm[0])\t/* >foo% free space - resume */"
    ],
    "globals_used": [
      "static void do_acct_process(struct bsd_acct_struct *acct);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Process accounting resumed\\n\""
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "resume",
            "100"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Process accounting paused\\n\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "suspend",
            "100"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_statfs",
          "args": [
            "&acct->file->f_path",
            "&sbuf"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_is_after_jiffies",
          "args": [
            "acct->needcheck"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\n#define ACCT_TIMEOUT\t(acct_parm[2])\t/* foo second timeout between checks */\n#define SUSPEND\t\t(acct_parm[1])\t/* <foo% free space - suspend */\n#define RESUME\t\t(acct_parm[0])\t/* >foo% free space - resume */\n\nstatic void do_acct_process(struct bsd_acct_struct *acct);\n\nstatic int check_free_space(struct bsd_acct_struct *acct)\n{\n\tstruct kstatfs sbuf;\n\n\tif (time_is_after_jiffies(acct->needcheck))\n\t\tgoto out;\n\n\t/* May block */\n\tif (vfs_statfs(&acct->file->f_path, &sbuf))\n\t\tgoto out;\n\n\tif (acct->active) {\n\t\tu64 suspend = sbuf.f_blocks * SUSPEND;\n\t\tdo_div(suspend, 100);\n\t\tif (sbuf.f_bavail <= suspend) {\n\t\t\tacct->active = 0;\n\t\t\tpr_info(\"Process accounting paused\\n\");\n\t\t}\n\t} else {\n\t\tu64 resume = sbuf.f_blocks * RESUME;\n\t\tdo_div(resume, 100);\n\t\tif (sbuf.f_bavail >= resume) {\n\t\t\tacct->active = 1;\n\t\t\tpr_info(\"Process accounting resumed\\n\");\n\t\t}\n\t}\n\n\tacct->needcheck = jiffies + ACCT_TIMEOUT*HZ;\nout:\n\treturn acct->active;\n}"
  },
  {
    "function_name": "acct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
    "lines": "273-295",
    "snippet": "SYSCALL_DEFINE1(acct, const char __user *, name)\n{\n\tint error = 0;\n\n\tif (!capable(CAP_SYS_PACCT))\n\t\treturn -EPERM;\n\n\tif (name) {\n\t\tstruct filename *tmp = getname(name);\n\n\t\tif (IS_ERR(tmp))\n\t\t\treturn PTR_ERR(tmp);\n\t\tmutex_lock(&acct_on_mutex);\n\t\terror = acct_on(tmp);\n\t\tmutex_unlock(&acct_on_mutex);\n\t\tputname(tmp);\n\t} else {\n\t\trcu_read_lock();\n\t\tpin_kill(task_active_pid_ns(current)->bacct);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/fs_pin.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/blkdev.h> /* sector_div */",
      "#include <asm/div64.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/mount.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/times.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/vfs.h>",
      "#include <linux/security.h>",
      "#include <linux/tty.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/acct.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void do_acct_process(struct bsd_acct_struct *acct);",
      "static DEFINE_MUTEX(acct_on_mutex);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void do_acct_process(struct bsd_acct_struct *acct);\nstatic DEFINE_MUTEX(acct_on_mutex);\n\nSYSCALL_DEFINE1(acct, const char __user *, name)\n{\n\tint error = 0;\n\n\tif (!capable(CAP_SYS_PACCT))\n\t\treturn -EPERM;\n\n\tif (name) {\n\t\tstruct filename *tmp = getname(name);\n\n\t\tif (IS_ERR(tmp))\n\t\t\treturn PTR_ERR(tmp);\n\t\tmutex_lock(&acct_on_mutex);\n\t\terror = acct_on(tmp);\n\t\tmutex_unlock(&acct_on_mutex);\n\t\tputname(tmp);\n\t} else {\n\t\trcu_read_lock();\n\t\tpin_kill(task_active_pid_ns(current)->bacct);\n\t}\n\n\treturn error;\n}"
  }
]