[
  {
    "function_name": "init_graph_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1548-1563",
    "snippet": "static __init int init_graph_trace(void)\n{\n\tmax_bytes_for_cpu = snprintf(NULL, 0, \"%u\", nr_cpu_ids - 1);\n\n\tif (!register_trace_event(&graph_trace_entry_event)) {\n\t\tpr_warn(\"Warning: could not register graph trace events\\n\");\n\t\treturn 1;\n\t}\n\n\tif (!register_trace_event(&graph_trace_ret_event)) {\n\t\tpr_warn(\"Warning: could not register graph trace events\\n\");\n\t\treturn 1;\n\t}\n\n\treturn register_tracer(&graph_trace);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int max_bytes_for_cpu;",
      "static struct trace_event graph_trace_entry_event = {\n\t.type\t\t= TRACE_GRAPH_ENT,\n\t.funcs\t\t= &graph_functions,\n};",
      "static struct trace_event graph_trace_ret_event = {\n\t.type\t\t= TRACE_GRAPH_RET,\n\t.funcs\t\t= &graph_functions\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_tracer",
          "args": [
            "&graph_trace"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "register_tracer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1591-1672",
          "snippet": "int __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\ttracing_selftest_disabled = true;\n#ifdef CONFIG_FTRACE_STARTUP_TEST\n\tprintk(KERN_INFO \"Disabling FTRACE selftests due to running tracer '%s'\\n\",\n\t       type->name);\n#endif\n\n out_unlock:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define MAX_TRACER_SIZE\t\t100"
          ],
          "globals_used": [
            "static struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};",
            "static char *default_bootup_tracer;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static struct tracer\t\t*trace_types",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void __init apply_trace_boot_options(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define MAX_TRACER_SIZE\t\t100\n\nstatic struct tracer_opt dummy_tracer_opt[] = {\n\t{ }\n};\nstatic char *default_bootup_tracer;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic struct tracer\t\t*trace_types;\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void __init apply_trace_boot_options(void);\n\nint __init register_tracer(struct tracer *type)\n{\n\tstruct tracer *t;\n\tint ret = 0;\n\n\tif (!type->name) {\n\t\tpr_info(\"Tracer must have a name\\n\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(type->name) >= MAX_TRACER_SIZE) {\n\t\tpr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n\t\treturn -1;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\ttracing_selftest_running = true;\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(type->name, t->name) == 0) {\n\t\t\t/* already found */\n\t\t\tpr_info(\"Tracer %s already registered\\n\",\n\t\t\t\ttype->name);\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!type->set_flag)\n\t\ttype->set_flag = &dummy_set_flag;\n\tif (!type->flags) {\n\t\t/*allocate a dummy tracer_flags*/\n\t\ttype->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n\t\tif (!type->flags) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\ttype->flags->val = 0;\n\t\ttype->flags->opts = dummy_tracer_opt;\n\t} else\n\t\tif (!type->flags->opts)\n\t\t\ttype->flags->opts = dummy_tracer_opt;\n\n\t/* store the tracer for __set_tracer_option */\n\ttype->flags->trace = type;\n\n\tret = run_tracer_selftest(type);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttype->next = trace_types;\n\ttrace_types = type;\n\tadd_tracer_options(&global_trace, type);\n\n out:\n\ttracing_selftest_running = false;\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret || !default_bootup_tracer)\n\t\tgoto out_unlock;\n\n\tif (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n\t\tgoto out_unlock;\n\n\tprintk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n\t/* Do we want this tracer to start on bootup? */\n\ttracing_set_tracer(&global_trace, type->name);\n\tdefault_bootup_tracer = NULL;\n\n\tapply_trace_boot_options();\n\n\t/* disable other selftests, since this will break it. */\n\ttracing_selftest_disabled = true;\n#ifdef CONFIG_FTRACE_STARTUP_TEST\n\tprintk(KERN_INFO \"Disabling FTRACE selftests due to running tracer '%s'\\n\",\n\t       type->name);\n#endif\n\n out_unlock:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Warning: could not register graph trace events\\n\""
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_trace_event",
          "args": [
            "&graph_trace_ret_event"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_output.c",
          "lines": "818-825",
          "snippet": "int unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Warning: could not register graph trace events\\n\""
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "NULL",
            "0",
            "\"%u\"",
            "nr_cpu_ids - 1"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int max_bytes_for_cpu;\nstatic struct trace_event graph_trace_entry_event = {\n\t.type\t\t= TRACE_GRAPH_ENT,\n\t.funcs\t\t= &graph_functions,\n};\nstatic struct trace_event graph_trace_ret_event = {\n\t.type\t\t= TRACE_GRAPH_RET,\n\t.funcs\t\t= &graph_functions\n};\n\nstatic __init int init_graph_trace(void)\n{\n\tmax_bytes_for_cpu = snprintf(NULL, 0, \"%u\", nr_cpu_ids - 1);\n\n\tif (!register_trace_event(&graph_trace_entry_event)) {\n\t\tpr_warn(\"Warning: could not register graph trace events\\n\");\n\t\treturn 1;\n\t}\n\n\tif (!register_trace_event(&graph_trace_ret_event)) {\n\t\tpr_warn(\"Warning: could not register graph trace events\\n\");\n\t\treturn 1;\n\t}\n\n\treturn register_tracer(&graph_trace);\n}"
  },
  {
    "function_name": "init_graph_tracefs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1533-1545",
    "snippet": "static __init int init_graph_tracefs(void)\n{\n\tstruct dentry *d_tracer;\n\n\td_tracer = tracing_init_dentry();\n\tif (IS_ERR(d_tracer))\n\t\treturn 0;\n\n\ttrace_create_file(\"max_graph_depth\", 0644, d_tracer,\n\t\t\t  NULL, &graph_depth_fops);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations graph_depth_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.write\t\t= graph_depth_write,\n\t.read\t\t= graph_depth_read,\n\t.llseek\t\t= generic_file_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_create_file",
          "args": [
            "\"max_graph_depth\"",
            "0644",
            "d_tracer",
            "NULL",
            "&graph_depth_fops"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "trace_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "7459-7472",
          "snippet": "struct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warn(\"Could not create tracefs '%s' entry\\n\", name);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "d_tracer"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_init_dentry",
          "args": [],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_init_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8023-8050",
          "snippet": "struct dentry *tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn NULL;\n\n\tif (WARN_ON(!tracefs_initialized()) ||\n\t\t(IS_ENABLED(CONFIG_DEBUG_FS) &&\n\t\t WARN_ON(!debugfs_initialized())))\n\t\treturn ERR_PTR(-ENODEV);\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kerenl.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\tif (!tr->dir) {\n\t\tpr_warn_once(\"Could not create debugfs directory 'tracing'\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nstruct dentry *tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn NULL;\n\n\tif (WARN_ON(!tracefs_initialized()) ||\n\t\t(IS_ENABLED(CONFIG_DEBUG_FS) &&\n\t\t WARN_ON(!debugfs_initialized())))\n\t\treturn ERR_PTR(-ENODEV);\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kerenl.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\tif (!tr->dir) {\n\t\tpr_warn_once(\"Could not create debugfs directory 'tracing'\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic const struct file_operations graph_depth_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.write\t\t= graph_depth_write,\n\t.read\t\t= graph_depth_read,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic __init int init_graph_tracefs(void)\n{\n\tstruct dentry *d_tracer;\n\n\td_tracer = tracing_init_dentry();\n\tif (IS_ERR(d_tracer))\n\t\treturn 0;\n\n\ttrace_create_file(\"max_graph_depth\", 0644, d_tracer,\n\t\t\t  NULL, &graph_depth_fops);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "graph_depth_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1514-1524",
    "snippet": "static ssize_t\ngraph_depth_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t loff_t *ppos)\n{\n\tchar buf[15]; /* More than enough to hold UINT_MAX + \"\\n\"*/\n\tint n;\n\n\tn = sprintf(buf, \"%d\\n\", fgraph_max_depth);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, n);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int fgraph_max_depth;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "ubuf",
            "cnt",
            "ppos",
            "buf",
            "n"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "fgraph_max_depth"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nunsigned int fgraph_max_depth;\n\nstatic ssize_t\ngraph_depth_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t loff_t *ppos)\n{\n\tchar buf[15]; /* More than enough to hold UINT_MAX + \"\\n\"*/\n\tint n;\n\n\tn = sprintf(buf, \"%d\\n\", fgraph_max_depth);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, n);\n}"
  },
  {
    "function_name": "graph_depth_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1496-1512",
    "snippet": "static ssize_t\ngraph_depth_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t  loff_t *ppos)\n{\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tfgraph_max_depth = val;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int fgraph_max_depth;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul_from_user",
          "args": [
            "ubuf",
            "cnt",
            "10",
            "&val"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nunsigned int fgraph_max_depth;\n\nstatic ssize_t\ngraph_depth_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t  loff_t *ppos)\n{\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tfgraph_max_depth = val;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}"
  },
  {
    "function_name": "func_graph_set_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1448-1461",
    "snippet": "static int\nfunc_graph_set_flag(struct trace_array *tr, u32 old_flags, u32 bit, int set)\n{\n\tif (bit == TRACE_GRAPH_PRINT_IRQS)\n\t\tftrace_graph_skip_irqs = !set;\n\n\tif (bit == TRACE_GRAPH_SLEEP_TIME)\n\t\tftrace_graph_sleep_time_control(set);\n\n\tif (bit == TRACE_GRAPH_GRAPH_TIME)\n\t\tftrace_graph_graph_time_control(set);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_graph_skip_irqs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_graph_graph_time_control",
          "args": [
            "set"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_graph_time_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6769-6772",
          "snippet": "void ftrace_graph_graph_time_control(bool enable)\n{\n\tfgraph_graph_time = enable;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_graph_graph_time_control(bool enable)\n{\n\tfgraph_graph_time = enable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_sleep_time_control",
          "args": [
            "set"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_sleep_time_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6764-6767",
          "snippet": "void ftrace_graph_sleep_time_control(bool enable)\n{\n\tfgraph_sleep_time = enable;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nvoid ftrace_graph_sleep_time_control(bool enable)\n{\n\tfgraph_sleep_time = enable;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int ftrace_graph_skip_irqs;\n\nstatic int\nfunc_graph_set_flag(struct trace_array *tr, u32 old_flags, u32 bit, int set)\n{\n\tif (bit == TRACE_GRAPH_PRINT_IRQS)\n\t\tftrace_graph_skip_irqs = !set;\n\n\tif (bit == TRACE_GRAPH_SLEEP_TIME)\n\t\tftrace_graph_sleep_time_control(set);\n\n\tif (bit == TRACE_GRAPH_GRAPH_TIME)\n\t\tftrace_graph_graph_time_control(set);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "graph_trace_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1438-1446",
    "snippet": "void graph_trace_close(struct trace_iterator *iter)\n{\n\tstruct fgraph_data *data = iter->private;\n\n\tif (data) {\n\t\tfree_percpu(data->cpu_data);\n\t\tkfree(data);\n\t}\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "data->cpu_data"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid graph_trace_close(struct trace_iterator *iter)\n{\n\tstruct fgraph_data *data = iter->private;\n\n\tif (data) {\n\t\tfree_percpu(data->cpu_data);\n\t\tkfree(data);\n\t}\n}"
  },
  {
    "function_name": "graph_trace_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1396-1436",
    "snippet": "void graph_trace_open(struct trace_iterator *iter)\n{\n\t/* pid and depth on the last trace processed */\n\tstruct fgraph_data *data;\n\tgfp_t gfpflags;\n\tint cpu;\n\n\titer->private = NULL;\n\n\t/* We can be called in atomic context via ftrace_dump() */\n\tgfpflags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;\n\n\tdata = kzalloc(sizeof(*data), gfpflags);\n\tif (!data)\n\t\tgoto out_err;\n\n\tdata->cpu_data = alloc_percpu_gfp(struct fgraph_cpu_data, gfpflags);\n\tif (!data->cpu_data)\n\t\tgoto out_err_free;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tpid_t *pid = &(per_cpu_ptr(data->cpu_data, cpu)->last_pid);\n\t\tint *depth = &(per_cpu_ptr(data->cpu_data, cpu)->depth);\n\t\tint *ignore = &(per_cpu_ptr(data->cpu_data, cpu)->ignore);\n\t\tint *depth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t\t*pid = -1;\n\t\t*depth = 0;\n\t\t*ignore = 0;\n\t\t*depth_irq = -1;\n\t}\n\n\titer->private = data;\n\n\treturn;\n\n out_err_free:\n\tkfree(data);\n out_err:\n\tpr_warn(\"function graph tracer: not enough memory\\n\");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"function graph tracer: not enough memory\\n\""
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu_gfp",
          "args": [
            "structfgraph_cpu_data",
            "gfpflags"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "gfpflags"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_atomic",
          "args": [],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid graph_trace_open(struct trace_iterator *iter)\n{\n\t/* pid and depth on the last trace processed */\n\tstruct fgraph_data *data;\n\tgfp_t gfpflags;\n\tint cpu;\n\n\titer->private = NULL;\n\n\t/* We can be called in atomic context via ftrace_dump() */\n\tgfpflags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;\n\n\tdata = kzalloc(sizeof(*data), gfpflags);\n\tif (!data)\n\t\tgoto out_err;\n\n\tdata->cpu_data = alloc_percpu_gfp(struct fgraph_cpu_data, gfpflags);\n\tif (!data->cpu_data)\n\t\tgoto out_err_free;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tpid_t *pid = &(per_cpu_ptr(data->cpu_data, cpu)->last_pid);\n\t\tint *depth = &(per_cpu_ptr(data->cpu_data, cpu)->depth);\n\t\tint *ignore = &(per_cpu_ptr(data->cpu_data, cpu)->ignore);\n\t\tint *depth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t\t*pid = -1;\n\t\t*depth = 0;\n\t\t*ignore = 0;\n\t\t*depth_irq = -1;\n\t}\n\n\titer->private = data;\n\n\treturn;\n\n out_err_free:\n\tkfree(data);\n out_err:\n\tpr_warn(\"function graph tracer: not enough memory\\n\");\n}"
  },
  {
    "function_name": "print_graph_headers_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1377-1394",
    "snippet": "void print_graph_headers_flags(struct seq_file *s, u32 flags)\n{\n\tstruct trace_iterator *iter = s->private;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\n\t\tprint_trace_header(s, iter);\n\t}\n\n\t__print_graph_headers_flags(tr, s, flags);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__print_graph_headers_flags",
          "args": [
            "tr",
            "s",
            "flags"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "__print_graph_headers_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1335-1370",
          "snippet": "static void __print_graph_headers_flags(struct trace_array *tr,\n\t\t\t\t\tstruct seq_file *s, u32 flags)\n{\n\tint lat = tr->trace_flags & TRACE_ITER_LATENCY_FMT;\n\n\tif (lat)\n\t\tprint_lat_header(s, flags);\n\n\t/* 1st line */\n\tseq_putc(s, '#');\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tseq_puts(s, \"     TIME       \");\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tseq_puts(s, \" CPU\");\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tseq_puts(s, \"  TASK/PID       \");\n\tif (lat)\n\t\tseq_puts(s, \"||||\");\n\tif (flags & TRACE_GRAPH_PRINT_DURATION)\n\t\tseq_puts(s, \"  DURATION   \");\n\tseq_puts(s, \"               FUNCTION CALLS\\n\");\n\n\t/* 2nd line */\n\tseq_putc(s, '#');\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tseq_puts(s, \"      |         \");\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tseq_puts(s, \" |  \");\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tseq_puts(s, \"   |    |        \");\n\tif (lat)\n\t\tseq_puts(s, \"||||\");\n\tif (flags & TRACE_GRAPH_PRINT_DURATION)\n\t\tseq_puts(s, \"   |   |      \");\n\tseq_puts(s, \"               |   |   |   |\\n\");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void __print_graph_headers_flags(struct trace_array *tr,\n\t\t\t\t\tstruct seq_file *s, u32 flags)\n{\n\tint lat = tr->trace_flags & TRACE_ITER_LATENCY_FMT;\n\n\tif (lat)\n\t\tprint_lat_header(s, flags);\n\n\t/* 1st line */\n\tseq_putc(s, '#');\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tseq_puts(s, \"     TIME       \");\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tseq_puts(s, \" CPU\");\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tseq_puts(s, \"  TASK/PID       \");\n\tif (lat)\n\t\tseq_puts(s, \"||||\");\n\tif (flags & TRACE_GRAPH_PRINT_DURATION)\n\t\tseq_puts(s, \"  DURATION   \");\n\tseq_puts(s, \"               FUNCTION CALLS\\n\");\n\n\t/* 2nd line */\n\tseq_putc(s, '#');\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tseq_puts(s, \"      |         \");\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tseq_puts(s, \" |  \");\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tseq_puts(s, \"   |    |        \");\n\tif (lat)\n\t\tseq_puts(s, \"||||\");\n\tif (flags & TRACE_GRAPH_PRINT_DURATION)\n\t\tseq_puts(s, \"   |   |      \");\n\tseq_puts(s, \"               |   |   |   |\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_trace_header",
          "args": [
            "s",
            "iter"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "print_trace_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "3403-3463",
          "snippet": "void\nprint_trace_header(struct seq_file *m, struct trace_iterator *iter)\n{\n\tunsigned long sym_flags = (global_trace.trace_flags & TRACE_ITER_SYM_MASK);\n\tstruct trace_buffer *buf = iter->trace_buffer;\n\tstruct trace_array_cpu *data = per_cpu_ptr(buf->data, buf->cpu);\n\tstruct tracer *type = iter->trace;\n\tunsigned long entries;\n\tunsigned long total;\n\tconst char *name = \"preemption\";\n\n\tname = type->name;\n\n\tget_total_entries(buf, &total, &entries);\n\n\tseq_printf(m, \"# %s latency trace v1.1.5 on %s\\n\",\n\t\t   name, UTS_RELEASE);\n\tseq_puts(m, \"# -----------------------------------\"\n\t\t \"---------------------------------\\n\");\n\tseq_printf(m, \"# latency: %lu us, #%lu/%lu, CPU#%d |\"\n\t\t   \" (M:%s VP:%d, KP:%d, SP:%d HP:%d\",\n\t\t   nsecs_to_usecs(data->saved_latency),\n\t\t   entries,\n\t\t   total,\n\t\t   buf->cpu,\n#if defined(CONFIG_PREEMPT_NONE)\n\t\t   \"server\",\n#elif defined(CONFIG_PREEMPT_VOLUNTARY)\n\t\t   \"desktop\",\n#elif defined(CONFIG_PREEMPT)\n\t\t   \"preempt\",\n#else\n\t\t   \"unknown\",\n#endif\n\t\t   /* These are reserved for later use */\n\t\t   0, 0, 0, 0);\n#ifdef CONFIG_SMP\n\tseq_printf(m, \" #P:%d)\\n\", num_online_cpus());\n#else\n\tseq_puts(m, \")\\n\");\n#endif\n\tseq_puts(m, \"#    -----------------\\n\");\n\tseq_printf(m, \"#    | task: %.16s-%d \"\n\t\t   \"(uid:%d nice:%ld policy:%ld rt_prio:%ld)\\n\",\n\t\t   data->comm, data->pid,\n\t\t   from_kuid_munged(seq_user_ns(m), data->uid), data->nice,\n\t\t   data->policy, data->rt_priority);\n\tseq_puts(m, \"#    -----------------\\n\");\n\n\tif (data->critical_start) {\n\t\tseq_puts(m, \"#  => started at: \");\n\t\tseq_print_ip_sym(&iter->seq, data->critical_start, sym_flags);\n\t\ttrace_print_seq(m, &iter->seq);\n\t\tseq_puts(m, \"\\n#  => ended at:   \");\n\t\tseq_print_ip_sym(&iter->seq, data->critical_end, sym_flags);\n\t\ttrace_print_seq(m, &iter->seq);\n\t\tseq_puts(m, \"\\n#\\n\");\n\t}\n\n\tseq_puts(m, \"#\\n\");\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_set_tracer(struct trace_array *tr, const char *buf);",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid\nprint_trace_header(struct seq_file *m, struct trace_iterator *iter)\n{\n\tunsigned long sym_flags = (global_trace.trace_flags & TRACE_ITER_SYM_MASK);\n\tstruct trace_buffer *buf = iter->trace_buffer;\n\tstruct trace_array_cpu *data = per_cpu_ptr(buf->data, buf->cpu);\n\tstruct tracer *type = iter->trace;\n\tunsigned long entries;\n\tunsigned long total;\n\tconst char *name = \"preemption\";\n\n\tname = type->name;\n\n\tget_total_entries(buf, &total, &entries);\n\n\tseq_printf(m, \"# %s latency trace v1.1.5 on %s\\n\",\n\t\t   name, UTS_RELEASE);\n\tseq_puts(m, \"# -----------------------------------\"\n\t\t \"---------------------------------\\n\");\n\tseq_printf(m, \"# latency: %lu us, #%lu/%lu, CPU#%d |\"\n\t\t   \" (M:%s VP:%d, KP:%d, SP:%d HP:%d\",\n\t\t   nsecs_to_usecs(data->saved_latency),\n\t\t   entries,\n\t\t   total,\n\t\t   buf->cpu,\n#if defined(CONFIG_PREEMPT_NONE)\n\t\t   \"server\",\n#elif defined(CONFIG_PREEMPT_VOLUNTARY)\n\t\t   \"desktop\",\n#elif defined(CONFIG_PREEMPT)\n\t\t   \"preempt\",\n#else\n\t\t   \"unknown\",\n#endif\n\t\t   /* These are reserved for later use */\n\t\t   0, 0, 0, 0);\n#ifdef CONFIG_SMP\n\tseq_printf(m, \" #P:%d)\\n\", num_online_cpus());\n#else\n\tseq_puts(m, \")\\n\");\n#endif\n\tseq_puts(m, \"#    -----------------\\n\");\n\tseq_printf(m, \"#    | task: %.16s-%d \"\n\t\t   \"(uid:%d nice:%ld policy:%ld rt_prio:%ld)\\n\",\n\t\t   data->comm, data->pid,\n\t\t   from_kuid_munged(seq_user_ns(m), data->uid), data->nice,\n\t\t   data->policy, data->rt_priority);\n\tseq_puts(m, \"#    -----------------\\n\");\n\n\tif (data->critical_start) {\n\t\tseq_puts(m, \"#  => started at: \");\n\t\tseq_print_ip_sym(&iter->seq, data->critical_start, sym_flags);\n\t\ttrace_print_seq(m, &iter->seq);\n\t\tseq_puts(m, \"\\n#  => ended at:   \");\n\t\tseq_print_ip_sym(&iter->seq, data->critical_end, sym_flags);\n\t\ttrace_print_seq(m, &iter->seq);\n\t\tseq_puts(m, \"\\n#\\n\");\n\t}\n\n\tseq_puts(m, \"#\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_empty",
          "args": [
            "iter"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "trace_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "3601-3632",
          "snippet": "int trace_empty(struct trace_iterator *iter)\n{\n\tstruct ring_buffer_iter *buf_iter;\n\tint cpu;\n\n\t/* If we are looking at one CPU buffer, only check that one */\n\tif (iter->cpu_file != RING_BUFFER_ALL_CPUS) {\n\t\tcpu = iter->cpu_file;\n\t\tbuf_iter = trace_buffer_iter(iter, cpu);\n\t\tif (buf_iter) {\n\t\t\tif (!ring_buffer_iter_empty(buf_iter))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!ring_buffer_empty_cpu(iter->trace_buffer->buffer, cpu))\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tbuf_iter = trace_buffer_iter(iter, cpu);\n\t\tif (buf_iter) {\n\t\t\tif (!ring_buffer_iter_empty(buf_iter))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!ring_buffer_empty_cpu(iter->trace_buffer->buffer, cpu))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_empty(struct trace_iterator *iter)\n{\n\tstruct ring_buffer_iter *buf_iter;\n\tint cpu;\n\n\t/* If we are looking at one CPU buffer, only check that one */\n\tif (iter->cpu_file != RING_BUFFER_ALL_CPUS) {\n\t\tcpu = iter->cpu_file;\n\t\tbuf_iter = trace_buffer_iter(iter, cpu);\n\t\tif (buf_iter) {\n\t\t\tif (!ring_buffer_iter_empty(buf_iter))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!ring_buffer_empty_cpu(iter->trace_buffer->buffer, cpu))\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tbuf_iter = trace_buffer_iter(iter, cpu);\n\t\tif (buf_iter) {\n\t\t\tif (!ring_buffer_iter_empty(buf_iter))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!ring_buffer_empty_cpu(iter->trace_buffer->buffer, cpu))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nvoid print_graph_headers_flags(struct seq_file *s, u32 flags)\n{\n\tstruct trace_iterator *iter = s->private;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\n\t\tprint_trace_header(s, iter);\n\t}\n\n\t__print_graph_headers_flags(tr, s, flags);\n}"
  },
  {
    "function_name": "print_graph_headers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1372-1375",
    "snippet": "static void print_graph_headers(struct seq_file *s)\n{\n\tprint_graph_headers_flags(s, tracer_flags.val);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tracer_flags tracer_flags = {\n\t/* Don't display overruns, proc, or tail by default */\n\t.val = TRACE_GRAPH_PRINT_CPU | TRACE_GRAPH_PRINT_OVERHEAD |\n\t       TRACE_GRAPH_PRINT_DURATION | TRACE_GRAPH_PRINT_IRQS |\n\t       TRACE_GRAPH_SLEEP_TIME | TRACE_GRAPH_GRAPH_TIME,\n\t.opts = trace_opts\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_graph_headers_flags",
          "args": [
            "s",
            "tracer_flags.val"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_headers_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1377-1394",
          "snippet": "void print_graph_headers_flags(struct seq_file *s, u32 flags)\n{\n\tstruct trace_iterator *iter = s->private;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\n\t\tprint_trace_header(s, iter);\n\t}\n\n\t__print_graph_headers_flags(tr, s, flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nvoid print_graph_headers_flags(struct seq_file *s, u32 flags)\n{\n\tstruct trace_iterator *iter = s->private;\n\tstruct trace_array *tr = iter->tr;\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT) {\n\t\t/* print nothing if the buffers are empty */\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\n\t\tprint_trace_header(s, iter);\n\t}\n\n\t__print_graph_headers_flags(tr, s, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct tracer_flags tracer_flags = {\n\t/* Don't display overruns, proc, or tail by default */\n\t.val = TRACE_GRAPH_PRINT_CPU | TRACE_GRAPH_PRINT_OVERHEAD |\n\t       TRACE_GRAPH_PRINT_DURATION | TRACE_GRAPH_PRINT_IRQS |\n\t       TRACE_GRAPH_SLEEP_TIME | TRACE_GRAPH_GRAPH_TIME,\n\t.opts = trace_opts\n};\n\nstatic void print_graph_headers(struct seq_file *s)\n{\n\tprint_graph_headers_flags(s, tracer_flags.val);\n}"
  },
  {
    "function_name": "__print_graph_headers_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1335-1370",
    "snippet": "static void __print_graph_headers_flags(struct trace_array *tr,\n\t\t\t\t\tstruct seq_file *s, u32 flags)\n{\n\tint lat = tr->trace_flags & TRACE_ITER_LATENCY_FMT;\n\n\tif (lat)\n\t\tprint_lat_header(s, flags);\n\n\t/* 1st line */\n\tseq_putc(s, '#');\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tseq_puts(s, \"     TIME       \");\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tseq_puts(s, \" CPU\");\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tseq_puts(s, \"  TASK/PID       \");\n\tif (lat)\n\t\tseq_puts(s, \"||||\");\n\tif (flags & TRACE_GRAPH_PRINT_DURATION)\n\t\tseq_puts(s, \"  DURATION   \");\n\tseq_puts(s, \"               FUNCTION CALLS\\n\");\n\n\t/* 2nd line */\n\tseq_putc(s, '#');\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tseq_puts(s, \"      |         \");\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tseq_puts(s, \" |  \");\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tseq_puts(s, \"   |    |        \");\n\tif (lat)\n\t\tseq_puts(s, \"||||\");\n\tif (flags & TRACE_GRAPH_PRINT_DURATION)\n\t\tseq_puts(s, \"   |   |      \");\n\tseq_puts(s, \"               |   |   |   |\\n\");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "\"               |   |   |   |\\n\""
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "s",
            "'#'"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_lat_header",
          "args": [
            "s",
            "flags"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "print_lat_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1314-1333",
          "snippet": "static void print_lat_header(struct seq_file *s, u32 flags)\n{\n\tstatic const char spaces[] = \"                \"\t/* 16 spaces */\n\t\t\"    \"\t\t\t\t\t/* 4 spaces */\n\t\t\"                 \";\t\t\t/* 17 spaces */\n\tint size = 0;\n\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tsize += 16;\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tsize += 4;\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tsize += 17;\n\n\tseq_printf(s, \"#%.*s  _-----=> irqs-off        \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s / _----=> need-resched    \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s| / _---=> hardirq/softirq \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s|| / _--=> preempt-depth   \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s||| /                      \\n\", size, spaces);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void print_lat_header(struct seq_file *s, u32 flags)\n{\n\tstatic const char spaces[] = \"                \"\t/* 16 spaces */\n\t\t\"    \"\t\t\t\t\t/* 4 spaces */\n\t\t\"                 \";\t\t\t/* 17 spaces */\n\tint size = 0;\n\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tsize += 16;\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tsize += 4;\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tsize += 17;\n\n\tseq_printf(s, \"#%.*s  _-----=> irqs-off        \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s / _----=> need-resched    \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s| / _---=> hardirq/softirq \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s|| / _--=> preempt-depth   \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s||| /                      \\n\", size, spaces);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void __print_graph_headers_flags(struct trace_array *tr,\n\t\t\t\t\tstruct seq_file *s, u32 flags)\n{\n\tint lat = tr->trace_flags & TRACE_ITER_LATENCY_FMT;\n\n\tif (lat)\n\t\tprint_lat_header(s, flags);\n\n\t/* 1st line */\n\tseq_putc(s, '#');\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tseq_puts(s, \"     TIME       \");\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tseq_puts(s, \" CPU\");\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tseq_puts(s, \"  TASK/PID       \");\n\tif (lat)\n\t\tseq_puts(s, \"||||\");\n\tif (flags & TRACE_GRAPH_PRINT_DURATION)\n\t\tseq_puts(s, \"  DURATION   \");\n\tseq_puts(s, \"               FUNCTION CALLS\\n\");\n\n\t/* 2nd line */\n\tseq_putc(s, '#');\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tseq_puts(s, \"      |         \");\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tseq_puts(s, \" |  \");\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tseq_puts(s, \"   |    |        \");\n\tif (lat)\n\t\tseq_puts(s, \"||||\");\n\tif (flags & TRACE_GRAPH_PRINT_DURATION)\n\t\tseq_puts(s, \"   |   |      \");\n\tseq_puts(s, \"               |   |   |   |\\n\");\n}"
  },
  {
    "function_name": "print_lat_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1314-1333",
    "snippet": "static void print_lat_header(struct seq_file *s, u32 flags)\n{\n\tstatic const char spaces[] = \"                \"\t/* 16 spaces */\n\t\t\"    \"\t\t\t\t\t/* 4 spaces */\n\t\t\"                 \";\t\t\t/* 17 spaces */\n\tint size = 0;\n\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tsize += 16;\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tsize += 4;\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tsize += 17;\n\n\tseq_printf(s, \"#%.*s  _-----=> irqs-off        \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s / _----=> need-resched    \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s| / _---=> hardirq/softirq \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s|| / _--=> preempt-depth   \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s||| /                      \\n\", size, spaces);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"#%.*s||| /                      \\n\"",
            "size",
            "spaces"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void print_lat_header(struct seq_file *s, u32 flags)\n{\n\tstatic const char spaces[] = \"                \"\t/* 16 spaces */\n\t\t\"    \"\t\t\t\t\t/* 4 spaces */\n\t\t\"                 \";\t\t\t/* 17 spaces */\n\tint size = 0;\n\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tsize += 16;\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tsize += 4;\n\tif (flags & TRACE_GRAPH_PRINT_PROC)\n\t\tsize += 17;\n\n\tseq_printf(s, \"#%.*s  _-----=> irqs-off        \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s / _----=> need-resched    \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s| / _---=> hardirq/softirq \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s|| / _--=> preempt-depth   \\n\", size, spaces);\n\tseq_printf(s, \"#%.*s||| /                      \\n\", size, spaces);\n}"
  },
  {
    "function_name": "print_graph_function_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1307-1312",
    "snippet": "static enum print_line_t\nprint_graph_function_event(struct trace_iterator *iter, int flags,\n\t\t\t   struct trace_event *event)\n{\n\treturn print_graph_function(iter);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_graph_function",
          "args": [
            "iter"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1301-1305",
          "snippet": "static enum print_line_t\nprint_graph_function(struct trace_iterator *iter)\n{\n\treturn print_graph_function_flags(iter, tracer_flags.val);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tracer_flags tracer_flags = {\n\t/* Don't display overruns, proc, or tail by default */\n\t.val = TRACE_GRAPH_PRINT_CPU | TRACE_GRAPH_PRINT_OVERHEAD |\n\t       TRACE_GRAPH_PRINT_DURATION | TRACE_GRAPH_PRINT_IRQS |\n\t       TRACE_GRAPH_SLEEP_TIME | TRACE_GRAPH_GRAPH_TIME,\n\t.opts = trace_opts\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct tracer_flags tracer_flags = {\n\t/* Don't display overruns, proc, or tail by default */\n\t.val = TRACE_GRAPH_PRINT_CPU | TRACE_GRAPH_PRINT_OVERHEAD |\n\t       TRACE_GRAPH_PRINT_DURATION | TRACE_GRAPH_PRINT_IRQS |\n\t       TRACE_GRAPH_SLEEP_TIME | TRACE_GRAPH_GRAPH_TIME,\n\t.opts = trace_opts\n};\n\nstatic enum print_line_t\nprint_graph_function(struct trace_iterator *iter)\n{\n\treturn print_graph_function_flags(iter, tracer_flags.val);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_function_event(struct trace_iterator *iter, int flags,\n\t\t\t   struct trace_event *event)\n{\n\treturn print_graph_function(iter);\n}"
  },
  {
    "function_name": "print_graph_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1301-1305",
    "snippet": "static enum print_line_t\nprint_graph_function(struct trace_iterator *iter)\n{\n\treturn print_graph_function_flags(iter, tracer_flags.val);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tracer_flags tracer_flags = {\n\t/* Don't display overruns, proc, or tail by default */\n\t.val = TRACE_GRAPH_PRINT_CPU | TRACE_GRAPH_PRINT_OVERHEAD |\n\t       TRACE_GRAPH_PRINT_DURATION | TRACE_GRAPH_PRINT_IRQS |\n\t       TRACE_GRAPH_SLEEP_TIME | TRACE_GRAPH_GRAPH_TIME,\n\t.opts = trace_opts\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_graph_function_flags",
          "args": [
            "iter",
            "tracer_flags.val"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_function_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1240-1299",
          "snippet": "enum print_line_t\nprint_graph_function_flags(struct trace_iterator *iter, u32 flags)\n{\n\tstruct ftrace_graph_ent_entry *field;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tint cpu = iter->cpu;\n\tint ret;\n\n\tif (data && per_cpu_ptr(data->cpu_data, cpu)->ignore) {\n\t\tper_cpu_ptr(data->cpu_data, cpu)->ignore = 0;\n\t\treturn TRACE_TYPE_HANDLED;\n\t}\n\n\t/*\n\t * If the last output failed, there's a possibility we need\n\t * to print out the missing entry which would never go out.\n\t */\n\tif (data && data->failed) {\n\t\tfield = &data->ent;\n\t\titer->cpu = data->cpu;\n\t\tret = print_graph_entry(field, s, iter, flags);\n\t\tif (ret == TRACE_TYPE_HANDLED && iter->cpu != cpu) {\n\t\t\tper_cpu_ptr(data->cpu_data, iter->cpu)->ignore = 1;\n\t\t\tret = TRACE_TYPE_NO_CONSUME;\n\t\t}\n\t\titer->cpu = cpu;\n\t\treturn ret;\n\t}\n\n\tswitch (entry->type) {\n\tcase TRACE_GRAPH_ENT: {\n\t\t/*\n\t\t * print_graph_entry() may consume the current event,\n\t\t * thus @field may become invalid, so we need to save it.\n\t\t * sizeof(struct ftrace_graph_ent_entry) is very small,\n\t\t * it can be safely saved at the stack.\n\t\t */\n\t\tstruct ftrace_graph_ent_entry saved;\n\t\ttrace_assign_type(field, entry);\n\t\tsaved = *field;\n\t\treturn print_graph_entry(&saved, s, iter, flags);\n\t}\n\tcase TRACE_GRAPH_RET: {\n\t\tstruct ftrace_graph_ret_entry *field;\n\t\ttrace_assign_type(field, entry);\n\t\treturn print_graph_return(&field->ret, s, entry, iter, flags);\n\t}\n\tcase TRACE_STACK:\n\tcase TRACE_FN:\n\t\t/* dont trace stack and functions as comments */\n\t\treturn TRACE_TYPE_UNHANDLED;\n\n\tdefault:\n\t\treturn print_graph_comment(s, entry, iter, flags);\n\t}\n\n\treturn TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nenum print_line_t\nprint_graph_function_flags(struct trace_iterator *iter, u32 flags)\n{\n\tstruct ftrace_graph_ent_entry *field;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tint cpu = iter->cpu;\n\tint ret;\n\n\tif (data && per_cpu_ptr(data->cpu_data, cpu)->ignore) {\n\t\tper_cpu_ptr(data->cpu_data, cpu)->ignore = 0;\n\t\treturn TRACE_TYPE_HANDLED;\n\t}\n\n\t/*\n\t * If the last output failed, there's a possibility we need\n\t * to print out the missing entry which would never go out.\n\t */\n\tif (data && data->failed) {\n\t\tfield = &data->ent;\n\t\titer->cpu = data->cpu;\n\t\tret = print_graph_entry(field, s, iter, flags);\n\t\tif (ret == TRACE_TYPE_HANDLED && iter->cpu != cpu) {\n\t\t\tper_cpu_ptr(data->cpu_data, iter->cpu)->ignore = 1;\n\t\t\tret = TRACE_TYPE_NO_CONSUME;\n\t\t}\n\t\titer->cpu = cpu;\n\t\treturn ret;\n\t}\n\n\tswitch (entry->type) {\n\tcase TRACE_GRAPH_ENT: {\n\t\t/*\n\t\t * print_graph_entry() may consume the current event,\n\t\t * thus @field may become invalid, so we need to save it.\n\t\t * sizeof(struct ftrace_graph_ent_entry) is very small,\n\t\t * it can be safely saved at the stack.\n\t\t */\n\t\tstruct ftrace_graph_ent_entry saved;\n\t\ttrace_assign_type(field, entry);\n\t\tsaved = *field;\n\t\treturn print_graph_entry(&saved, s, iter, flags);\n\t}\n\tcase TRACE_GRAPH_RET: {\n\t\tstruct ftrace_graph_ret_entry *field;\n\t\ttrace_assign_type(field, entry);\n\t\treturn print_graph_return(&field->ret, s, entry, iter, flags);\n\t}\n\tcase TRACE_STACK:\n\tcase TRACE_FN:\n\t\t/* dont trace stack and functions as comments */\n\t\treturn TRACE_TYPE_UNHANDLED;\n\n\tdefault:\n\t\treturn print_graph_comment(s, entry, iter, flags);\n\t}\n\n\treturn TRACE_TYPE_HANDLED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct tracer_flags tracer_flags = {\n\t/* Don't display overruns, proc, or tail by default */\n\t.val = TRACE_GRAPH_PRINT_CPU | TRACE_GRAPH_PRINT_OVERHEAD |\n\t       TRACE_GRAPH_PRINT_DURATION | TRACE_GRAPH_PRINT_IRQS |\n\t       TRACE_GRAPH_SLEEP_TIME | TRACE_GRAPH_GRAPH_TIME,\n\t.opts = trace_opts\n};\n\nstatic enum print_line_t\nprint_graph_function(struct trace_iterator *iter)\n{\n\treturn print_graph_function_flags(iter, tracer_flags.val);\n}"
  },
  {
    "function_name": "print_graph_function_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1240-1299",
    "snippet": "enum print_line_t\nprint_graph_function_flags(struct trace_iterator *iter, u32 flags)\n{\n\tstruct ftrace_graph_ent_entry *field;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tint cpu = iter->cpu;\n\tint ret;\n\n\tif (data && per_cpu_ptr(data->cpu_data, cpu)->ignore) {\n\t\tper_cpu_ptr(data->cpu_data, cpu)->ignore = 0;\n\t\treturn TRACE_TYPE_HANDLED;\n\t}\n\n\t/*\n\t * If the last output failed, there's a possibility we need\n\t * to print out the missing entry which would never go out.\n\t */\n\tif (data && data->failed) {\n\t\tfield = &data->ent;\n\t\titer->cpu = data->cpu;\n\t\tret = print_graph_entry(field, s, iter, flags);\n\t\tif (ret == TRACE_TYPE_HANDLED && iter->cpu != cpu) {\n\t\t\tper_cpu_ptr(data->cpu_data, iter->cpu)->ignore = 1;\n\t\t\tret = TRACE_TYPE_NO_CONSUME;\n\t\t}\n\t\titer->cpu = cpu;\n\t\treturn ret;\n\t}\n\n\tswitch (entry->type) {\n\tcase TRACE_GRAPH_ENT: {\n\t\t/*\n\t\t * print_graph_entry() may consume the current event,\n\t\t * thus @field may become invalid, so we need to save it.\n\t\t * sizeof(struct ftrace_graph_ent_entry) is very small,\n\t\t * it can be safely saved at the stack.\n\t\t */\n\t\tstruct ftrace_graph_ent_entry saved;\n\t\ttrace_assign_type(field, entry);\n\t\tsaved = *field;\n\t\treturn print_graph_entry(&saved, s, iter, flags);\n\t}\n\tcase TRACE_GRAPH_RET: {\n\t\tstruct ftrace_graph_ret_entry *field;\n\t\ttrace_assign_type(field, entry);\n\t\treturn print_graph_return(&field->ret, s, entry, iter, flags);\n\t}\n\tcase TRACE_STACK:\n\tcase TRACE_FN:\n\t\t/* dont trace stack and functions as comments */\n\t\treturn TRACE_TYPE_UNHANDLED;\n\n\tdefault:\n\t\treturn print_graph_comment(s, entry, iter, flags);\n\t}\n\n\treturn TRACE_TYPE_HANDLED;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_graph_comment",
          "args": [
            "s",
            "entry",
            "iter",
            "flags"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_comment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1171-1237",
          "snippet": "static enum print_line_t\nprint_graph_comment(struct trace_seq *s, struct trace_entry *ent,\n\t\t    struct trace_iterator *iter, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long sym_flags = (tr->trace_flags & TRACE_ITER_SYM_MASK);\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_event *event;\n\tint depth = 0;\n\tint ret;\n\tint i;\n\n\tif (data)\n\t\tdepth = per_cpu_ptr(data->cpu_data, iter->cpu)->depth;\n\n\tprint_graph_prologue(iter, s, 0, 0, flags);\n\n\t/* No time */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_FULL);\n\n\t/* Indentation */\n\tif (depth > 0)\n\t\tfor (i = 0; i < (depth + 1) * TRACE_GRAPH_INDENT; i++)\n\t\t\ttrace_seq_putc(s, ' ');\n\n\t/* The comment */\n\ttrace_seq_puts(s, \"/* \");\n\n\tswitch (iter->ent->type) {\n\tcase TRACE_BPUTS:\n\t\tret = trace_print_bputs_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase TRACE_BPRINT:\n\t\tret = trace_print_bprintk_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase TRACE_PRINT:\n\t\tret = trace_print_printk_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tevent = ftrace_find_event(ent->type);\n\t\tif (!event)\n\t\t\treturn TRACE_TYPE_UNHANDLED;\n\n\t\tret = event->funcs->trace(iter, sym_flags, event);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t}\n\n\tif (trace_seq_has_overflowed(s))\n\t\tgoto out;\n\n\t/* Strip ending newline */\n\tif (s->buffer[s->seq.len - 1] == '\\n') {\n\t\ts->buffer[s->seq.len - 1] = '\\0';\n\t\ts->seq.len--;\n\t}\n\n\ttrace_seq_puts(s, \" */\\n\");\n out:\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define TRACE_GRAPH_INDENT\t2"
          ],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_INDENT\t2\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_comment(struct trace_seq *s, struct trace_entry *ent,\n\t\t    struct trace_iterator *iter, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long sym_flags = (tr->trace_flags & TRACE_ITER_SYM_MASK);\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_event *event;\n\tint depth = 0;\n\tint ret;\n\tint i;\n\n\tif (data)\n\t\tdepth = per_cpu_ptr(data->cpu_data, iter->cpu)->depth;\n\n\tprint_graph_prologue(iter, s, 0, 0, flags);\n\n\t/* No time */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_FULL);\n\n\t/* Indentation */\n\tif (depth > 0)\n\t\tfor (i = 0; i < (depth + 1) * TRACE_GRAPH_INDENT; i++)\n\t\t\ttrace_seq_putc(s, ' ');\n\n\t/* The comment */\n\ttrace_seq_puts(s, \"/* \");\n\n\tswitch (iter->ent->type) {\n\tcase TRACE_BPUTS:\n\t\tret = trace_print_bputs_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase TRACE_BPRINT:\n\t\tret = trace_print_bprintk_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase TRACE_PRINT:\n\t\tret = trace_print_printk_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tevent = ftrace_find_event(ent->type);\n\t\tif (!event)\n\t\t\treturn TRACE_TYPE_UNHANDLED;\n\n\t\tret = event->funcs->trace(iter, sym_flags, event);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t}\n\n\tif (trace_seq_has_overflowed(s))\n\t\tgoto out;\n\n\t/* Strip ending newline */\n\tif (s->buffer[s->seq.len - 1] == '\\n') {\n\t\ts->buffer[s->seq.len - 1] = '\\0';\n\t\ts->seq.len--;\n\t}\n\n\ttrace_seq_puts(s, \" */\\n\");\n out:\n\treturn trace_handle_return(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_return",
          "args": [
            "&field->ret",
            "s",
            "entry",
            "iter",
            "flags"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1102-1169",
          "snippet": "static enum print_line_t\nprint_graph_return(struct ftrace_graph_ret *trace, struct trace_seq *s,\n\t\t   struct trace_entry *ent, struct trace_iterator *iter,\n\t\t   u32 flags)\n{\n\tunsigned long long duration = trace->rettime - trace->calltime;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tpid_t pid = ent->pid;\n\tint cpu = iter->cpu;\n\tint func_match = 1;\n\tint i;\n\n\tif (check_irq_return(iter, flags, trace->depth))\n\t\treturn TRACE_TYPE_HANDLED;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\t\tint cpu = iter->cpu;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\n\t\t/*\n\t\t * Comments display at + 1 to depth. This is the\n\t\t * return from a function, we now want the comments\n\t\t * to display at the same level of the bracket.\n\t\t */\n\t\tcpu_data->depth = trace->depth - 1;\n\n\t\tif (trace->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(trace->depth < 0)) {\n\t\t\tif (cpu_data->enter_funcs[trace->depth] != trace->func)\n\t\t\t\tfunc_match = 0;\n\t\t\tcpu_data->enter_funcs[trace->depth] = 0;\n\t\t}\n\t}\n\n\tprint_graph_prologue(iter, s, 0, 0, flags);\n\n\t/* Overhead and duration */\n\tprint_graph_duration(tr, duration, s, flags);\n\n\t/* Closing brace */\n\tfor (i = 0; i < trace->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\t/*\n\t * If the return function does not have a matching entry,\n\t * then the entry was lost. Instead of just printing\n\t * the '}' and letting the user guess what function this\n\t * belongs to, write out the function name. Always do\n\t * that if the funcgraph-tail option is enabled.\n\t */\n\tif (func_match && !(flags & TRACE_GRAPH_PRINT_TAIL))\n\t\ttrace_seq_puts(s, \"}\\n\");\n\telse\n\t\ttrace_seq_printf(s, \"} /* %ps */\\n\", (void *)trace->func);\n\n\t/* Overrun */\n\tif (flags & TRACE_GRAPH_PRINT_OVERRUN)\n\t\ttrace_seq_printf(s, \" (Overruns: %lu)\\n\",\n\t\t\t\t trace->overrun);\n\n\tprint_graph_irq(iter, trace->func, TRACE_GRAPH_RET,\n\t\t\tcpu, pid, flags);\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define TRACE_GRAPH_INDENT\t2"
          ],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_INDENT\t2\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_return(struct ftrace_graph_ret *trace, struct trace_seq *s,\n\t\t   struct trace_entry *ent, struct trace_iterator *iter,\n\t\t   u32 flags)\n{\n\tunsigned long long duration = trace->rettime - trace->calltime;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tpid_t pid = ent->pid;\n\tint cpu = iter->cpu;\n\tint func_match = 1;\n\tint i;\n\n\tif (check_irq_return(iter, flags, trace->depth))\n\t\treturn TRACE_TYPE_HANDLED;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\t\tint cpu = iter->cpu;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\n\t\t/*\n\t\t * Comments display at + 1 to depth. This is the\n\t\t * return from a function, we now want the comments\n\t\t * to display at the same level of the bracket.\n\t\t */\n\t\tcpu_data->depth = trace->depth - 1;\n\n\t\tif (trace->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(trace->depth < 0)) {\n\t\t\tif (cpu_data->enter_funcs[trace->depth] != trace->func)\n\t\t\t\tfunc_match = 0;\n\t\t\tcpu_data->enter_funcs[trace->depth] = 0;\n\t\t}\n\t}\n\n\tprint_graph_prologue(iter, s, 0, 0, flags);\n\n\t/* Overhead and duration */\n\tprint_graph_duration(tr, duration, s, flags);\n\n\t/* Closing brace */\n\tfor (i = 0; i < trace->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\t/*\n\t * If the return function does not have a matching entry,\n\t * then the entry was lost. Instead of just printing\n\t * the '}' and letting the user guess what function this\n\t * belongs to, write out the function name. Always do\n\t * that if the funcgraph-tail option is enabled.\n\t */\n\tif (func_match && !(flags & TRACE_GRAPH_PRINT_TAIL))\n\t\ttrace_seq_puts(s, \"}\\n\");\n\telse\n\t\ttrace_seq_printf(s, \"} /* %ps */\\n\", (void *)trace->func);\n\n\t/* Overrun */\n\tif (flags & TRACE_GRAPH_PRINT_OVERRUN)\n\t\ttrace_seq_printf(s, \" (Overruns: %lu)\\n\",\n\t\t\t\t trace->overrun);\n\n\tprint_graph_irq(iter, trace->func, TRACE_GRAPH_RET,\n\t\t\tcpu, pid, flags);\n\n\treturn trace_handle_return(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "entry"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_graph_entry",
          "args": [
            "&saved",
            "s",
            "iter",
            "flags"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1066-1100",
          "snippet": "static enum print_line_t\nprint_graph_entry(struct ftrace_graph_ent_entry *field, struct trace_seq *s,\n\t\t\tstruct trace_iterator *iter, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct ftrace_graph_ent *call = &field->graph_ent;\n\tstruct ftrace_graph_ret_entry *leaf_ret;\n\tstatic enum print_line_t ret;\n\tint cpu = iter->cpu;\n\n\tif (check_irq_entry(iter, flags, call->func, call->depth))\n\t\treturn TRACE_TYPE_HANDLED;\n\n\tprint_graph_prologue(iter, s, TRACE_GRAPH_ENT, call->func, flags);\n\n\tleaf_ret = get_return_for_leaf(iter, field);\n\tif (leaf_ret)\n\t\tret = print_graph_entry_leaf(iter, field, leaf_ret, s, flags);\n\telse\n\t\tret = print_graph_entry_nested(iter, field, s, cpu, flags);\n\n\tif (data) {\n\t\t/*\n\t\t * If we failed to write our output, then we need to make\n\t\t * note of it. Because we already consumed our entry.\n\t\t */\n\t\tif (s->full) {\n\t\t\tdata->failed = 1;\n\t\t\tdata->cpu = cpu;\n\t\t} else\n\t\t\tdata->failed = 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_entry(struct ftrace_graph_ent_entry *field, struct trace_seq *s,\n\t\t\tstruct trace_iterator *iter, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct ftrace_graph_ent *call = &field->graph_ent;\n\tstruct ftrace_graph_ret_entry *leaf_ret;\n\tstatic enum print_line_t ret;\n\tint cpu = iter->cpu;\n\n\tif (check_irq_entry(iter, flags, call->func, call->depth))\n\t\treturn TRACE_TYPE_HANDLED;\n\n\tprint_graph_prologue(iter, s, TRACE_GRAPH_ENT, call->func, flags);\n\n\tleaf_ret = get_return_for_leaf(iter, field);\n\tif (leaf_ret)\n\t\tret = print_graph_entry_leaf(iter, field, leaf_ret, s, flags);\n\telse\n\t\tret = print_graph_entry_nested(iter, field, s, cpu, flags);\n\n\tif (data) {\n\t\t/*\n\t\t * If we failed to write our output, then we need to make\n\t\t * note of it. Because we already consumed our entry.\n\t\t */\n\t\tif (s->full) {\n\t\t\tdata->failed = 1;\n\t\t\tdata->cpu = cpu;\n\t\t} else\n\t\t\tdata->failed = 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_assign_type",
          "args": [
            "field",
            "entry"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "iter->cpu"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nenum print_line_t\nprint_graph_function_flags(struct trace_iterator *iter, u32 flags)\n{\n\tstruct ftrace_graph_ent_entry *field;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tint cpu = iter->cpu;\n\tint ret;\n\n\tif (data && per_cpu_ptr(data->cpu_data, cpu)->ignore) {\n\t\tper_cpu_ptr(data->cpu_data, cpu)->ignore = 0;\n\t\treturn TRACE_TYPE_HANDLED;\n\t}\n\n\t/*\n\t * If the last output failed, there's a possibility we need\n\t * to print out the missing entry which would never go out.\n\t */\n\tif (data && data->failed) {\n\t\tfield = &data->ent;\n\t\titer->cpu = data->cpu;\n\t\tret = print_graph_entry(field, s, iter, flags);\n\t\tif (ret == TRACE_TYPE_HANDLED && iter->cpu != cpu) {\n\t\t\tper_cpu_ptr(data->cpu_data, iter->cpu)->ignore = 1;\n\t\t\tret = TRACE_TYPE_NO_CONSUME;\n\t\t}\n\t\titer->cpu = cpu;\n\t\treturn ret;\n\t}\n\n\tswitch (entry->type) {\n\tcase TRACE_GRAPH_ENT: {\n\t\t/*\n\t\t * print_graph_entry() may consume the current event,\n\t\t * thus @field may become invalid, so we need to save it.\n\t\t * sizeof(struct ftrace_graph_ent_entry) is very small,\n\t\t * it can be safely saved at the stack.\n\t\t */\n\t\tstruct ftrace_graph_ent_entry saved;\n\t\ttrace_assign_type(field, entry);\n\t\tsaved = *field;\n\t\treturn print_graph_entry(&saved, s, iter, flags);\n\t}\n\tcase TRACE_GRAPH_RET: {\n\t\tstruct ftrace_graph_ret_entry *field;\n\t\ttrace_assign_type(field, entry);\n\t\treturn print_graph_return(&field->ret, s, entry, iter, flags);\n\t}\n\tcase TRACE_STACK:\n\tcase TRACE_FN:\n\t\t/* dont trace stack and functions as comments */\n\t\treturn TRACE_TYPE_UNHANDLED;\n\n\tdefault:\n\t\treturn print_graph_comment(s, entry, iter, flags);\n\t}\n\n\treturn TRACE_TYPE_HANDLED;\n}"
  },
  {
    "function_name": "print_graph_comment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1171-1237",
    "snippet": "static enum print_line_t\nprint_graph_comment(struct trace_seq *s, struct trace_entry *ent,\n\t\t    struct trace_iterator *iter, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long sym_flags = (tr->trace_flags & TRACE_ITER_SYM_MASK);\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_event *event;\n\tint depth = 0;\n\tint ret;\n\tint i;\n\n\tif (data)\n\t\tdepth = per_cpu_ptr(data->cpu_data, iter->cpu)->depth;\n\n\tprint_graph_prologue(iter, s, 0, 0, flags);\n\n\t/* No time */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_FULL);\n\n\t/* Indentation */\n\tif (depth > 0)\n\t\tfor (i = 0; i < (depth + 1) * TRACE_GRAPH_INDENT; i++)\n\t\t\ttrace_seq_putc(s, ' ');\n\n\t/* The comment */\n\ttrace_seq_puts(s, \"/* \");\n\n\tswitch (iter->ent->type) {\n\tcase TRACE_BPUTS:\n\t\tret = trace_print_bputs_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase TRACE_BPRINT:\n\t\tret = trace_print_bprintk_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase TRACE_PRINT:\n\t\tret = trace_print_printk_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tevent = ftrace_find_event(ent->type);\n\t\tif (!event)\n\t\t\treturn TRACE_TYPE_UNHANDLED;\n\n\t\tret = event->funcs->trace(iter, sym_flags, event);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t}\n\n\tif (trace_seq_has_overflowed(s))\n\t\tgoto out;\n\n\t/* Strip ending newline */\n\tif (s->buffer[s->seq.len - 1] == '\\n') {\n\t\ts->buffer[s->seq.len - 1] = '\\0';\n\t\ts->seq.len--;\n\t}\n\n\ttrace_seq_puts(s, \" */\\n\");\n out:\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define TRACE_GRAPH_INDENT\t2"
    ],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2123-2127",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\" */\\n\""
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event->funcs->trace",
          "args": [
            "iter",
            "sym_flags",
            "event"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_find_event",
          "args": [
            "ent->type"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_find_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_output.c",
          "lines": "668-681",
          "snippet": "struct trace_event *ftrace_find_event(int type)\n{\n\tstruct trace_event *event;\n\tunsigned key;\n\n\tkey = type & (EVENT_HASHSIZE - 1);\n\n\thlist_for_each_entry(event, &event_hash[key], node) {\n\t\tif (event->type == type)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define EVENT_HASHSIZE\t128"
          ],
          "globals_used": [
            "static struct hlist_head event_hash[EVENT_HASHSIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\n#define EVENT_HASHSIZE\t128\n\nstatic struct hlist_head event_hash[EVENT_HASHSIZE];\n\nstruct trace_event *ftrace_find_event(int type)\n{\n\tstruct trace_event *event;\n\tunsigned key;\n\n\tkey = type & (EVENT_HASHSIZE - 1);\n\n\thlist_for_each_entry(event, &event_hash[key], node) {\n\t\tif (event->type == type)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_print_printk_msg_only",
          "args": [
            "iter"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_printk_msg_only",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_output.c",
          "lines": "51-62",
          "snippet": "enum print_line_t trace_print_printk_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct print_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_puts(s, field->buf);\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nenum print_line_t trace_print_printk_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct print_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_puts(s, field->buf);\n\n\treturn trace_handle_return(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_print_bprintk_msg_only",
          "args": [
            "iter"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_bprintk_msg_only",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_output.c",
          "lines": "38-49",
          "snippet": "enum print_line_t trace_print_bprintk_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct bprint_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_bprintf(s, field->fmt, field->buf);\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nenum print_line_t trace_print_bprintk_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct bprint_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_bprintf(s, field->fmt, field->buf);\n\n\treturn trace_handle_return(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_print_bputs_msg_only",
          "args": [
            "iter"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_bputs_msg_only",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_output.c",
          "lines": "25-36",
          "snippet": "enum print_line_t trace_print_bputs_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct bputs_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_puts(s, field->str);\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nenum print_line_t trace_print_bputs_msg_only(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry = iter->ent;\n\tstruct bputs_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\ttrace_seq_puts(s, field->str);\n\n\treturn trace_handle_return(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "' '"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_duration",
          "args": [
            "tr",
            "0",
            "s",
            "flags | FLAGS_FILL_FULL"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_duration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "791-820",
          "snippet": "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_prologue",
          "args": [
            "iter",
            "s",
            "0",
            "0",
            "flags"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_prologue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "924-962",
          "snippet": "static void\nprint_graph_prologue(struct trace_iterator *iter, struct trace_seq *s,\n\t\t     int type, unsigned long addr, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct trace_array *tr = iter->tr;\n\tint cpu = iter->cpu;\n\n\t/* Pid */\n\tverif_pid(s, ent->pid, cpu, data);\n\n\tif (type)\n\t\t/* Interrupt */\n\t\tprint_graph_irq(iter, addr, type, cpu, ent->pid, flags);\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* Absolute time */\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tprint_graph_abs_time(iter->ts, s);\n\n\t/* Cpu */\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tprint_graph_cpu(s, cpu);\n\n\t/* Proc */\n\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\tprint_graph_proc(s, ent->pid);\n\t\ttrace_seq_puts(s, \" | \");\n\t}\n\n\t/* Latency format */\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\tprint_graph_lat_fmt(s, ent);\n\n\treturn;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_prologue(struct trace_iterator *iter, struct trace_seq *s,\n\t\t     int type, unsigned long addr, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct trace_array *tr = iter->tr;\n\tint cpu = iter->cpu;\n\n\t/* Pid */\n\tverif_pid(s, ent->pid, cpu, data);\n\n\tif (type)\n\t\t/* Interrupt */\n\t\tprint_graph_irq(iter, addr, type, cpu, ent->pid, flags);\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* Absolute time */\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tprint_graph_abs_time(iter->ts, s);\n\n\t/* Cpu */\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tprint_graph_cpu(s, cpu);\n\n\t/* Proc */\n\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\tprint_graph_proc(s, ent->pid);\n\t\ttrace_seq_puts(s, \" | \");\n\t}\n\n\t/* Latency format */\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\tprint_graph_lat_fmt(s, ent);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "iter->cpu"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_INDENT\t2\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_comment(struct trace_seq *s, struct trace_entry *ent,\n\t\t    struct trace_iterator *iter, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long sym_flags = (tr->trace_flags & TRACE_ITER_SYM_MASK);\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_event *event;\n\tint depth = 0;\n\tint ret;\n\tint i;\n\n\tif (data)\n\t\tdepth = per_cpu_ptr(data->cpu_data, iter->cpu)->depth;\n\n\tprint_graph_prologue(iter, s, 0, 0, flags);\n\n\t/* No time */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_FULL);\n\n\t/* Indentation */\n\tif (depth > 0)\n\t\tfor (i = 0; i < (depth + 1) * TRACE_GRAPH_INDENT; i++)\n\t\t\ttrace_seq_putc(s, ' ');\n\n\t/* The comment */\n\ttrace_seq_puts(s, \"/* \");\n\n\tswitch (iter->ent->type) {\n\tcase TRACE_BPUTS:\n\t\tret = trace_print_bputs_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase TRACE_BPRINT:\n\t\tret = trace_print_bprintk_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase TRACE_PRINT:\n\t\tret = trace_print_printk_msg_only(iter);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tevent = ftrace_find_event(ent->type);\n\t\tif (!event)\n\t\t\treturn TRACE_TYPE_UNHANDLED;\n\n\t\tret = event->funcs->trace(iter, sym_flags, event);\n\t\tif (ret != TRACE_TYPE_HANDLED)\n\t\t\treturn ret;\n\t}\n\n\tif (trace_seq_has_overflowed(s))\n\t\tgoto out;\n\n\t/* Strip ending newline */\n\tif (s->buffer[s->seq.len - 1] == '\\n') {\n\t\ts->buffer[s->seq.len - 1] = '\\0';\n\t\ts->seq.len--;\n\t}\n\n\ttrace_seq_puts(s, \" */\\n\");\n out:\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "print_graph_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1102-1169",
    "snippet": "static enum print_line_t\nprint_graph_return(struct ftrace_graph_ret *trace, struct trace_seq *s,\n\t\t   struct trace_entry *ent, struct trace_iterator *iter,\n\t\t   u32 flags)\n{\n\tunsigned long long duration = trace->rettime - trace->calltime;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tpid_t pid = ent->pid;\n\tint cpu = iter->cpu;\n\tint func_match = 1;\n\tint i;\n\n\tif (check_irq_return(iter, flags, trace->depth))\n\t\treturn TRACE_TYPE_HANDLED;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\t\tint cpu = iter->cpu;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\n\t\t/*\n\t\t * Comments display at + 1 to depth. This is the\n\t\t * return from a function, we now want the comments\n\t\t * to display at the same level of the bracket.\n\t\t */\n\t\tcpu_data->depth = trace->depth - 1;\n\n\t\tif (trace->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(trace->depth < 0)) {\n\t\t\tif (cpu_data->enter_funcs[trace->depth] != trace->func)\n\t\t\t\tfunc_match = 0;\n\t\t\tcpu_data->enter_funcs[trace->depth] = 0;\n\t\t}\n\t}\n\n\tprint_graph_prologue(iter, s, 0, 0, flags);\n\n\t/* Overhead and duration */\n\tprint_graph_duration(tr, duration, s, flags);\n\n\t/* Closing brace */\n\tfor (i = 0; i < trace->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\t/*\n\t * If the return function does not have a matching entry,\n\t * then the entry was lost. Instead of just printing\n\t * the '}' and letting the user guess what function this\n\t * belongs to, write out the function name. Always do\n\t * that if the funcgraph-tail option is enabled.\n\t */\n\tif (func_match && !(flags & TRACE_GRAPH_PRINT_TAIL))\n\t\ttrace_seq_puts(s, \"}\\n\");\n\telse\n\t\ttrace_seq_printf(s, \"} /* %ps */\\n\", (void *)trace->func);\n\n\t/* Overrun */\n\tif (flags & TRACE_GRAPH_PRINT_OVERRUN)\n\t\ttrace_seq_printf(s, \" (Overruns: %lu)\\n\",\n\t\t\t\t trace->overrun);\n\n\tprint_graph_irq(iter, trace->func, TRACE_GRAPH_RET,\n\t\t\tcpu, pid, flags);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define TRACE_GRAPH_INDENT\t2"
    ],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2123-2127",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_irq",
          "args": [
            "iter",
            "trace->func",
            "TRACE_GRAPH_RET",
            "cpu",
            "pid",
            "flags"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "714-756",
          "snippet": "static void\nprint_graph_irq(struct trace_iterator *iter, unsigned long addr,\n\t\tenum trace_type type, int cpu, pid_t pid, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\n\tif (addr < (unsigned long)__irqentry_text_start ||\n\t\taddr >= (unsigned long)__irqentry_text_end)\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {\n\t\t/* Absolute time */\n\t\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\t\tprint_graph_abs_time(iter->ts, s);\n\n\t\t/* Cpu */\n\t\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\t\tprint_graph_cpu(s, cpu);\n\n\t\t/* Proc */\n\t\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\t\tprint_graph_proc(s, pid);\n\t\t\ttrace_seq_puts(s, \" | \");\n\t\t}\n\n\t\t/* Latency format */\n\t\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\t\tprint_graph_lat_fmt(s, ent);\n\t}\n\n\t/* No overhead */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_START);\n\n\tif (type == TRACE_GRAPH_ENT)\n\t\ttrace_seq_puts(s, \"==========>\");\n\telse\n\t\ttrace_seq_puts(s, \"<==========\");\n\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_END);\n\ttrace_seq_putc(s, '\\n');\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_irq(struct trace_iterator *iter, unsigned long addr,\n\t\tenum trace_type type, int cpu, pid_t pid, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\n\tif (addr < (unsigned long)__irqentry_text_start ||\n\t\taddr >= (unsigned long)__irqentry_text_end)\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {\n\t\t/* Absolute time */\n\t\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\t\tprint_graph_abs_time(iter->ts, s);\n\n\t\t/* Cpu */\n\t\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\t\tprint_graph_cpu(s, cpu);\n\n\t\t/* Proc */\n\t\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\t\tprint_graph_proc(s, pid);\n\t\t\ttrace_seq_puts(s, \" | \");\n\t\t}\n\n\t\t/* Latency format */\n\t\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\t\tprint_graph_lat_fmt(s, ent);\n\t}\n\n\t/* No overhead */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_START);\n\n\tif (type == TRACE_GRAPH_ENT)\n\t\ttrace_seq_puts(s, \"==========>\");\n\telse\n\t\ttrace_seq_puts(s, \"<==========\");\n\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_END);\n\ttrace_seq_putc(s, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\" (Overruns: %lu)\\n\"",
            "trace->overrun"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\"}\\n\""
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "' '"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_duration",
          "args": [
            "tr",
            "duration",
            "s",
            "flags"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_duration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "791-820",
          "snippet": "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_prologue",
          "args": [
            "iter",
            "s",
            "0",
            "0",
            "flags"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_prologue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "924-962",
          "snippet": "static void\nprint_graph_prologue(struct trace_iterator *iter, struct trace_seq *s,\n\t\t     int type, unsigned long addr, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct trace_array *tr = iter->tr;\n\tint cpu = iter->cpu;\n\n\t/* Pid */\n\tverif_pid(s, ent->pid, cpu, data);\n\n\tif (type)\n\t\t/* Interrupt */\n\t\tprint_graph_irq(iter, addr, type, cpu, ent->pid, flags);\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* Absolute time */\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tprint_graph_abs_time(iter->ts, s);\n\n\t/* Cpu */\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tprint_graph_cpu(s, cpu);\n\n\t/* Proc */\n\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\tprint_graph_proc(s, ent->pid);\n\t\ttrace_seq_puts(s, \" | \");\n\t}\n\n\t/* Latency format */\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\tprint_graph_lat_fmt(s, ent);\n\n\treturn;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_prologue(struct trace_iterator *iter, struct trace_seq *s,\n\t\t     int type, unsigned long addr, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct trace_array *tr = iter->tr;\n\tint cpu = iter->cpu;\n\n\t/* Pid */\n\tverif_pid(s, ent->pid, cpu, data);\n\n\tif (type)\n\t\t/* Interrupt */\n\t\tprint_graph_irq(iter, addr, type, cpu, ent->pid, flags);\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* Absolute time */\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tprint_graph_abs_time(iter->ts, s);\n\n\t/* Cpu */\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tprint_graph_cpu(s, cpu);\n\n\t/* Proc */\n\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\tprint_graph_proc(s, ent->pid);\n\t\ttrace_seq_puts(s, \" | \");\n\t}\n\n\t/* Latency format */\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\tprint_graph_lat_fmt(s, ent);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "trace->depth < 0"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_irq_return",
          "args": [
            "iter",
            "flags",
            "trace->depth"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "1022-1064",
          "snippet": "static int\ncheck_irq_return(struct trace_iterator *iter, u32 flags, int depth)\n{\n\tint cpu = iter->cpu;\n\tint *depth_irq;\n\tstruct fgraph_data *data = iter->private;\n\n\t/*\n\t * If we are either displaying irqs, or we got called as\n\t * a graph event and private data does not exist,\n\t * then we bypass the irq check.\n\t */\n\tif ((flags & TRACE_GRAPH_PRINT_IRQS) ||\n\t    (!data))\n\t\treturn 0;\n\n\tdepth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t/*\n\t * We are not inside the irq code.\n\t */\n\tif (*depth_irq == -1)\n\t\treturn 0;\n\n\t/*\n\t * We are inside the irq code, and this is returning entry.\n\t * Let's not trace it and clear the entry depth, since\n\t * we are out of irq code.\n\t *\n\t * This condition ensures that we 'leave the irq code' once\n\t * we are out of the entry depth. Thus protecting us from\n\t * the RETURN entry loss.\n\t */\n\tif (*depth_irq >= depth) {\n\t\t*depth_irq = -1;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * We are inside the irq code, and this is not the entry.\n\t */\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic int\ncheck_irq_return(struct trace_iterator *iter, u32 flags, int depth)\n{\n\tint cpu = iter->cpu;\n\tint *depth_irq;\n\tstruct fgraph_data *data = iter->private;\n\n\t/*\n\t * If we are either displaying irqs, or we got called as\n\t * a graph event and private data does not exist,\n\t * then we bypass the irq check.\n\t */\n\tif ((flags & TRACE_GRAPH_PRINT_IRQS) ||\n\t    (!data))\n\t\treturn 0;\n\n\tdepth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t/*\n\t * We are not inside the irq code.\n\t */\n\tif (*depth_irq == -1)\n\t\treturn 0;\n\n\t/*\n\t * We are inside the irq code, and this is returning entry.\n\t * Let's not trace it and clear the entry depth, since\n\t * we are out of irq code.\n\t *\n\t * This condition ensures that we 'leave the irq code' once\n\t * we are out of the entry depth. Thus protecting us from\n\t * the RETURN entry loss.\n\t */\n\tif (*depth_irq >= depth) {\n\t\t*depth_irq = -1;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * We are inside the irq code, and this is not the entry.\n\t */\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_INDENT\t2\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_return(struct ftrace_graph_ret *trace, struct trace_seq *s,\n\t\t   struct trace_entry *ent, struct trace_iterator *iter,\n\t\t   u32 flags)\n{\n\tunsigned long long duration = trace->rettime - trace->calltime;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tpid_t pid = ent->pid;\n\tint cpu = iter->cpu;\n\tint func_match = 1;\n\tint i;\n\n\tif (check_irq_return(iter, flags, trace->depth))\n\t\treturn TRACE_TYPE_HANDLED;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\t\tint cpu = iter->cpu;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\n\t\t/*\n\t\t * Comments display at + 1 to depth. This is the\n\t\t * return from a function, we now want the comments\n\t\t * to display at the same level of the bracket.\n\t\t */\n\t\tcpu_data->depth = trace->depth - 1;\n\n\t\tif (trace->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(trace->depth < 0)) {\n\t\t\tif (cpu_data->enter_funcs[trace->depth] != trace->func)\n\t\t\t\tfunc_match = 0;\n\t\t\tcpu_data->enter_funcs[trace->depth] = 0;\n\t\t}\n\t}\n\n\tprint_graph_prologue(iter, s, 0, 0, flags);\n\n\t/* Overhead and duration */\n\tprint_graph_duration(tr, duration, s, flags);\n\n\t/* Closing brace */\n\tfor (i = 0; i < trace->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\t/*\n\t * If the return function does not have a matching entry,\n\t * then the entry was lost. Instead of just printing\n\t * the '}' and letting the user guess what function this\n\t * belongs to, write out the function name. Always do\n\t * that if the funcgraph-tail option is enabled.\n\t */\n\tif (func_match && !(flags & TRACE_GRAPH_PRINT_TAIL))\n\t\ttrace_seq_puts(s, \"}\\n\");\n\telse\n\t\ttrace_seq_printf(s, \"} /* %ps */\\n\", (void *)trace->func);\n\n\t/* Overrun */\n\tif (flags & TRACE_GRAPH_PRINT_OVERRUN)\n\t\ttrace_seq_printf(s, \" (Overruns: %lu)\\n\",\n\t\t\t\t trace->overrun);\n\n\tprint_graph_irq(iter, trace->func, TRACE_GRAPH_RET,\n\t\t\tcpu, pid, flags);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "print_graph_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1066-1100",
    "snippet": "static enum print_line_t\nprint_graph_entry(struct ftrace_graph_ent_entry *field, struct trace_seq *s,\n\t\t\tstruct trace_iterator *iter, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct ftrace_graph_ent *call = &field->graph_ent;\n\tstruct ftrace_graph_ret_entry *leaf_ret;\n\tstatic enum print_line_t ret;\n\tint cpu = iter->cpu;\n\n\tif (check_irq_entry(iter, flags, call->func, call->depth))\n\t\treturn TRACE_TYPE_HANDLED;\n\n\tprint_graph_prologue(iter, s, TRACE_GRAPH_ENT, call->func, flags);\n\n\tleaf_ret = get_return_for_leaf(iter, field);\n\tif (leaf_ret)\n\t\tret = print_graph_entry_leaf(iter, field, leaf_ret, s, flags);\n\telse\n\t\tret = print_graph_entry_nested(iter, field, s, cpu, flags);\n\n\tif (data) {\n\t\t/*\n\t\t * If we failed to write our output, then we need to make\n\t\t * note of it. Because we already consumed our entry.\n\t\t */\n\t\tif (s->full) {\n\t\t\tdata->failed = 1;\n\t\t\tdata->cpu = cpu;\n\t\t} else\n\t\t\tdata->failed = 0;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_graph_entry_nested",
          "args": [
            "iter",
            "field",
            "s",
            "cpu",
            "flags"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_entry_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "878-922",
          "snippet": "static enum print_line_t\nprint_graph_entry_nested(struct trace_iterator *iter,\n\t\t\t struct ftrace_graph_ent_entry *entry,\n\t\t\t struct trace_seq *s, int cpu, u32 flags)\n{\n\tstruct ftrace_graph_ent *call = &entry->graph_ent;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tint i;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\t\tint cpu = iter->cpu;\n\n\t\t/* If a graph tracer ignored set_graph_notrace */\n\t\tif (call->depth < -1)\n\t\t\tcall->depth += FTRACE_NOTRACE_DEPTH;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\t\tcpu_data->depth = call->depth;\n\n\t\t/* Save this function pointer to see if the exit matches */\n\t\tif (call->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(call->depth < 0))\n\t\t\tcpu_data->enter_funcs[call->depth] = call->func;\n\t}\n\n\t/* No time */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_FULL);\n\n\t/* Function */\n\tfor (i = 0; i < call->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%ps() {\\n\", (void *)call->func);\n\n\tif (trace_seq_has_overflowed(s))\n\t\treturn TRACE_TYPE_PARTIAL_LINE;\n\n\t/*\n\t * we already consumed the current entry to check the next one\n\t * and see if this is a leaf.\n\t */\n\treturn TRACE_TYPE_NO_CONSUME;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define TRACE_GRAPH_INDENT\t2"
          ],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_INDENT\t2\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_entry_nested(struct trace_iterator *iter,\n\t\t\t struct ftrace_graph_ent_entry *entry,\n\t\t\t struct trace_seq *s, int cpu, u32 flags)\n{\n\tstruct ftrace_graph_ent *call = &entry->graph_ent;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tint i;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\t\tint cpu = iter->cpu;\n\n\t\t/* If a graph tracer ignored set_graph_notrace */\n\t\tif (call->depth < -1)\n\t\t\tcall->depth += FTRACE_NOTRACE_DEPTH;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\t\tcpu_data->depth = call->depth;\n\n\t\t/* Save this function pointer to see if the exit matches */\n\t\tif (call->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(call->depth < 0))\n\t\t\tcpu_data->enter_funcs[call->depth] = call->func;\n\t}\n\n\t/* No time */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_FULL);\n\n\t/* Function */\n\tfor (i = 0; i < call->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%ps() {\\n\", (void *)call->func);\n\n\tif (trace_seq_has_overflowed(s))\n\t\treturn TRACE_TYPE_PARTIAL_LINE;\n\n\t/*\n\t * we already consumed the current entry to check the next one\n\t * and see if this is a leaf.\n\t */\n\treturn TRACE_TYPE_NO_CONSUME;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_entry_leaf",
          "args": [
            "iter",
            "field",
            "leaf_ret",
            "s",
            "flags"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_entry_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "823-876",
          "snippet": "static enum print_line_t\nprint_graph_entry_leaf(struct trace_iterator *iter,\n\t\tstruct ftrace_graph_ent_entry *entry,\n\t\tstruct ftrace_graph_ret_entry *ret_entry,\n\t\tstruct trace_seq *s, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tstruct ftrace_graph_ret *graph_ret;\n\tstruct ftrace_graph_ent *call;\n\tunsigned long long duration;\n\tint cpu = iter->cpu;\n\tint i;\n\n\tgraph_ret = &ret_entry->ret;\n\tcall = &entry->graph_ent;\n\tduration = graph_ret->rettime - graph_ret->calltime;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\n\t\t/* If a graph tracer ignored set_graph_notrace */\n\t\tif (call->depth < -1)\n\t\t\tcall->depth += FTRACE_NOTRACE_DEPTH;\n\n\t\t/*\n\t\t * Comments display at + 1 to depth. Since\n\t\t * this is a leaf function, keep the comments\n\t\t * equal to this depth.\n\t\t */\n\t\tcpu_data->depth = call->depth - 1;\n\n\t\t/* No need to keep this function around for this depth */\n\t\tif (call->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(call->depth < 0))\n\t\t\tcpu_data->enter_funcs[call->depth] = 0;\n\t}\n\n\t/* Overhead and duration */\n\tprint_graph_duration(tr, duration, s, flags);\n\n\t/* Function */\n\tfor (i = 0; i < call->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%ps();\\n\", (void *)call->func);\n\n\tprint_graph_irq(iter, graph_ret->func, TRACE_GRAPH_RET,\n\t\t\tcpu, iter->ent->pid, flags);\n\n\treturn trace_handle_return(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define TRACE_GRAPH_INDENT\t2"
          ],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_INDENT\t2\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_entry_leaf(struct trace_iterator *iter,\n\t\tstruct ftrace_graph_ent_entry *entry,\n\t\tstruct ftrace_graph_ret_entry *ret_entry,\n\t\tstruct trace_seq *s, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tstruct ftrace_graph_ret *graph_ret;\n\tstruct ftrace_graph_ent *call;\n\tunsigned long long duration;\n\tint cpu = iter->cpu;\n\tint i;\n\n\tgraph_ret = &ret_entry->ret;\n\tcall = &entry->graph_ent;\n\tduration = graph_ret->rettime - graph_ret->calltime;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\n\t\t/* If a graph tracer ignored set_graph_notrace */\n\t\tif (call->depth < -1)\n\t\t\tcall->depth += FTRACE_NOTRACE_DEPTH;\n\n\t\t/*\n\t\t * Comments display at + 1 to depth. Since\n\t\t * this is a leaf function, keep the comments\n\t\t * equal to this depth.\n\t\t */\n\t\tcpu_data->depth = call->depth - 1;\n\n\t\t/* No need to keep this function around for this depth */\n\t\tif (call->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(call->depth < 0))\n\t\t\tcpu_data->enter_funcs[call->depth] = 0;\n\t}\n\n\t/* Overhead and duration */\n\tprint_graph_duration(tr, duration, s, flags);\n\n\t/* Function */\n\tfor (i = 0; i < call->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%ps();\\n\", (void *)call->func);\n\n\tprint_graph_irq(iter, graph_ret->func, TRACE_GRAPH_RET,\n\t\t\tcpu, iter->ent->pid, flags);\n\n\treturn trace_handle_return(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_return_for_leaf",
          "args": [
            "iter",
            "field"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "get_return_for_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "632-701",
          "snippet": "static struct ftrace_graph_ret_entry *\nget_return_for_leaf(struct trace_iterator *iter,\n\t\tstruct ftrace_graph_ent_entry *curr)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct ring_buffer_iter *ring_iter = NULL;\n\tstruct ring_buffer_event *event;\n\tstruct ftrace_graph_ret_entry *next;\n\n\t/*\n\t * If the previous output failed to write to the seq buffer,\n\t * then we just reuse the data from before.\n\t */\n\tif (data && data->failed) {\n\t\tcurr = &data->ent;\n\t\tnext = &data->ret;\n\t} else {\n\n\t\tring_iter = trace_buffer_iter(iter, iter->cpu);\n\n\t\t/* First peek to compare current entry and the next one */\n\t\tif (ring_iter)\n\t\t\tevent = ring_buffer_iter_peek(ring_iter, NULL);\n\t\telse {\n\t\t\t/*\n\t\t\t * We need to consume the current entry to see\n\t\t\t * the next one.\n\t\t\t */\n\t\t\tring_buffer_consume(iter->trace_buffer->buffer, iter->cpu,\n\t\t\t\t\t    NULL, NULL);\n\t\t\tevent = ring_buffer_peek(iter->trace_buffer->buffer, iter->cpu,\n\t\t\t\t\t\t NULL, NULL);\n\t\t}\n\n\t\tif (!event)\n\t\t\treturn NULL;\n\n\t\tnext = ring_buffer_event_data(event);\n\n\t\tif (data) {\n\t\t\t/*\n\t\t\t * Save current and next entries for later reference\n\t\t\t * if the output fails.\n\t\t\t */\n\t\t\tdata->ent = *curr;\n\t\t\t/*\n\t\t\t * If the next event is not a return type, then\n\t\t\t * we only care about what type it is. Otherwise we can\n\t\t\t * safely copy the entire event.\n\t\t\t */\n\t\t\tif (next->ent.type == TRACE_GRAPH_RET)\n\t\t\t\tdata->ret = *next;\n\t\t\telse\n\t\t\t\tdata->ret.ent.type = next->ent.type;\n\t\t}\n\t}\n\n\tif (next->ent.type != TRACE_GRAPH_RET)\n\t\treturn NULL;\n\n\tif (curr->ent.pid != next->ent.pid ||\n\t\t\tcurr->graph_ent.func != next->ret.func)\n\t\treturn NULL;\n\n\t/* this is a leaf, now advance the iterator */\n\tif (ring_iter)\n\t\tring_buffer_read(ring_iter, NULL);\n\n\treturn next;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct ftrace_graph_ret_entry *\nget_return_for_leaf(struct trace_iterator *iter,\n\t\tstruct ftrace_graph_ent_entry *curr)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct ring_buffer_iter *ring_iter = NULL;\n\tstruct ring_buffer_event *event;\n\tstruct ftrace_graph_ret_entry *next;\n\n\t/*\n\t * If the previous output failed to write to the seq buffer,\n\t * then we just reuse the data from before.\n\t */\n\tif (data && data->failed) {\n\t\tcurr = &data->ent;\n\t\tnext = &data->ret;\n\t} else {\n\n\t\tring_iter = trace_buffer_iter(iter, iter->cpu);\n\n\t\t/* First peek to compare current entry and the next one */\n\t\tif (ring_iter)\n\t\t\tevent = ring_buffer_iter_peek(ring_iter, NULL);\n\t\telse {\n\t\t\t/*\n\t\t\t * We need to consume the current entry to see\n\t\t\t * the next one.\n\t\t\t */\n\t\t\tring_buffer_consume(iter->trace_buffer->buffer, iter->cpu,\n\t\t\t\t\t    NULL, NULL);\n\t\t\tevent = ring_buffer_peek(iter->trace_buffer->buffer, iter->cpu,\n\t\t\t\t\t\t NULL, NULL);\n\t\t}\n\n\t\tif (!event)\n\t\t\treturn NULL;\n\n\t\tnext = ring_buffer_event_data(event);\n\n\t\tif (data) {\n\t\t\t/*\n\t\t\t * Save current and next entries for later reference\n\t\t\t * if the output fails.\n\t\t\t */\n\t\t\tdata->ent = *curr;\n\t\t\t/*\n\t\t\t * If the next event is not a return type, then\n\t\t\t * we only care about what type it is. Otherwise we can\n\t\t\t * safely copy the entire event.\n\t\t\t */\n\t\t\tif (next->ent.type == TRACE_GRAPH_RET)\n\t\t\t\tdata->ret = *next;\n\t\t\telse\n\t\t\t\tdata->ret.ent.type = next->ent.type;\n\t\t}\n\t}\n\n\tif (next->ent.type != TRACE_GRAPH_RET)\n\t\treturn NULL;\n\n\tif (curr->ent.pid != next->ent.pid ||\n\t\t\tcurr->graph_ent.func != next->ret.func)\n\t\treturn NULL;\n\n\t/* this is a leaf, now advance the iterator */\n\tif (ring_iter)\n\t\tring_buffer_read(ring_iter, NULL);\n\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_prologue",
          "args": [
            "iter",
            "s",
            "TRACE_GRAPH_ENT",
            "call->func",
            "flags"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_prologue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "924-962",
          "snippet": "static void\nprint_graph_prologue(struct trace_iterator *iter, struct trace_seq *s,\n\t\t     int type, unsigned long addr, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct trace_array *tr = iter->tr;\n\tint cpu = iter->cpu;\n\n\t/* Pid */\n\tverif_pid(s, ent->pid, cpu, data);\n\n\tif (type)\n\t\t/* Interrupt */\n\t\tprint_graph_irq(iter, addr, type, cpu, ent->pid, flags);\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* Absolute time */\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tprint_graph_abs_time(iter->ts, s);\n\n\t/* Cpu */\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tprint_graph_cpu(s, cpu);\n\n\t/* Proc */\n\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\tprint_graph_proc(s, ent->pid);\n\t\ttrace_seq_puts(s, \" | \");\n\t}\n\n\t/* Latency format */\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\tprint_graph_lat_fmt(s, ent);\n\n\treturn;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_prologue(struct trace_iterator *iter, struct trace_seq *s,\n\t\t     int type, unsigned long addr, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct trace_array *tr = iter->tr;\n\tint cpu = iter->cpu;\n\n\t/* Pid */\n\tverif_pid(s, ent->pid, cpu, data);\n\n\tif (type)\n\t\t/* Interrupt */\n\t\tprint_graph_irq(iter, addr, type, cpu, ent->pid, flags);\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* Absolute time */\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tprint_graph_abs_time(iter->ts, s);\n\n\t/* Cpu */\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tprint_graph_cpu(s, cpu);\n\n\t/* Proc */\n\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\tprint_graph_proc(s, ent->pid);\n\t\ttrace_seq_puts(s, \" | \");\n\t}\n\n\t/* Latency format */\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\tprint_graph_lat_fmt(s, ent);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_irq_entry",
          "args": [
            "iter",
            "flags",
            "call->func",
            "call->depth"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "check_irq_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "975-1009",
          "snippet": "static int\ncheck_irq_entry(struct trace_iterator *iter, u32 flags,\n\t\tunsigned long addr, int depth)\n{\n\tint cpu = iter->cpu;\n\tint *depth_irq;\n\tstruct fgraph_data *data = iter->private;\n\n\t/*\n\t * If we are either displaying irqs, or we got called as\n\t * a graph event and private data does not exist,\n\t * then we bypass the irq check.\n\t */\n\tif ((flags & TRACE_GRAPH_PRINT_IRQS) ||\n\t    (!data))\n\t\treturn 0;\n\n\tdepth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t/*\n\t * We are inside the irq code\n\t */\n\tif (*depth_irq >= 0)\n\t\treturn 1;\n\n\tif ((addr < (unsigned long)__irqentry_text_start) ||\n\t    (addr >= (unsigned long)__irqentry_text_end))\n\t\treturn 0;\n\n\t/*\n\t * We are entering irq code.\n\t */\n\t*depth_irq = depth;\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic int\ncheck_irq_entry(struct trace_iterator *iter, u32 flags,\n\t\tunsigned long addr, int depth)\n{\n\tint cpu = iter->cpu;\n\tint *depth_irq;\n\tstruct fgraph_data *data = iter->private;\n\n\t/*\n\t * If we are either displaying irqs, or we got called as\n\t * a graph event and private data does not exist,\n\t * then we bypass the irq check.\n\t */\n\tif ((flags & TRACE_GRAPH_PRINT_IRQS) ||\n\t    (!data))\n\t\treturn 0;\n\n\tdepth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t/*\n\t * We are inside the irq code\n\t */\n\tif (*depth_irq >= 0)\n\t\treturn 1;\n\n\tif ((addr < (unsigned long)__irqentry_text_start) ||\n\t    (addr >= (unsigned long)__irqentry_text_end))\n\t\treturn 0;\n\n\t/*\n\t * We are entering irq code.\n\t */\n\t*depth_irq = depth;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_entry(struct ftrace_graph_ent_entry *field, struct trace_seq *s,\n\t\t\tstruct trace_iterator *iter, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct ftrace_graph_ent *call = &field->graph_ent;\n\tstruct ftrace_graph_ret_entry *leaf_ret;\n\tstatic enum print_line_t ret;\n\tint cpu = iter->cpu;\n\n\tif (check_irq_entry(iter, flags, call->func, call->depth))\n\t\treturn TRACE_TYPE_HANDLED;\n\n\tprint_graph_prologue(iter, s, TRACE_GRAPH_ENT, call->func, flags);\n\n\tleaf_ret = get_return_for_leaf(iter, field);\n\tif (leaf_ret)\n\t\tret = print_graph_entry_leaf(iter, field, leaf_ret, s, flags);\n\telse\n\t\tret = print_graph_entry_nested(iter, field, s, cpu, flags);\n\n\tif (data) {\n\t\t/*\n\t\t * If we failed to write our output, then we need to make\n\t\t * note of it. Because we already consumed our entry.\n\t\t */\n\t\tif (s->full) {\n\t\t\tdata->failed = 1;\n\t\t\tdata->cpu = cpu;\n\t\t} else\n\t\t\tdata->failed = 0;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "check_irq_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "1022-1064",
    "snippet": "static int\ncheck_irq_return(struct trace_iterator *iter, u32 flags, int depth)\n{\n\tint cpu = iter->cpu;\n\tint *depth_irq;\n\tstruct fgraph_data *data = iter->private;\n\n\t/*\n\t * If we are either displaying irqs, or we got called as\n\t * a graph event and private data does not exist,\n\t * then we bypass the irq check.\n\t */\n\tif ((flags & TRACE_GRAPH_PRINT_IRQS) ||\n\t    (!data))\n\t\treturn 0;\n\n\tdepth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t/*\n\t * We are not inside the irq code.\n\t */\n\tif (*depth_irq == -1)\n\t\treturn 0;\n\n\t/*\n\t * We are inside the irq code, and this is returning entry.\n\t * Let's not trace it and clear the entry depth, since\n\t * we are out of irq code.\n\t *\n\t * This condition ensures that we 'leave the irq code' once\n\t * we are out of the entry depth. Thus protecting us from\n\t * the RETURN entry loss.\n\t */\n\tif (*depth_irq >= depth) {\n\t\t*depth_irq = -1;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * We are inside the irq code, and this is not the entry.\n\t */\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic int\ncheck_irq_return(struct trace_iterator *iter, u32 flags, int depth)\n{\n\tint cpu = iter->cpu;\n\tint *depth_irq;\n\tstruct fgraph_data *data = iter->private;\n\n\t/*\n\t * If we are either displaying irqs, or we got called as\n\t * a graph event and private data does not exist,\n\t * then we bypass the irq check.\n\t */\n\tif ((flags & TRACE_GRAPH_PRINT_IRQS) ||\n\t    (!data))\n\t\treturn 0;\n\n\tdepth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t/*\n\t * We are not inside the irq code.\n\t */\n\tif (*depth_irq == -1)\n\t\treturn 0;\n\n\t/*\n\t * We are inside the irq code, and this is returning entry.\n\t * Let's not trace it and clear the entry depth, since\n\t * we are out of irq code.\n\t *\n\t * This condition ensures that we 'leave the irq code' once\n\t * we are out of the entry depth. Thus protecting us from\n\t * the RETURN entry loss.\n\t */\n\tif (*depth_irq >= depth) {\n\t\t*depth_irq = -1;\n\t\treturn 1;\n\t}\n\n\t/*\n\t * We are inside the irq code, and this is not the entry.\n\t */\n\treturn 1;\n}"
  },
  {
    "function_name": "check_irq_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "975-1009",
    "snippet": "static int\ncheck_irq_entry(struct trace_iterator *iter, u32 flags,\n\t\tunsigned long addr, int depth)\n{\n\tint cpu = iter->cpu;\n\tint *depth_irq;\n\tstruct fgraph_data *data = iter->private;\n\n\t/*\n\t * If we are either displaying irqs, or we got called as\n\t * a graph event and private data does not exist,\n\t * then we bypass the irq check.\n\t */\n\tif ((flags & TRACE_GRAPH_PRINT_IRQS) ||\n\t    (!data))\n\t\treturn 0;\n\n\tdepth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t/*\n\t * We are inside the irq code\n\t */\n\tif (*depth_irq >= 0)\n\t\treturn 1;\n\n\tif ((addr < (unsigned long)__irqentry_text_start) ||\n\t    (addr >= (unsigned long)__irqentry_text_end))\n\t\treturn 0;\n\n\t/*\n\t * We are entering irq code.\n\t */\n\t*depth_irq = depth;\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic int\ncheck_irq_entry(struct trace_iterator *iter, u32 flags,\n\t\tunsigned long addr, int depth)\n{\n\tint cpu = iter->cpu;\n\tint *depth_irq;\n\tstruct fgraph_data *data = iter->private;\n\n\t/*\n\t * If we are either displaying irqs, or we got called as\n\t * a graph event and private data does not exist,\n\t * then we bypass the irq check.\n\t */\n\tif ((flags & TRACE_GRAPH_PRINT_IRQS) ||\n\t    (!data))\n\t\treturn 0;\n\n\tdepth_irq = &(per_cpu_ptr(data->cpu_data, cpu)->depth_irq);\n\n\t/*\n\t * We are inside the irq code\n\t */\n\tif (*depth_irq >= 0)\n\t\treturn 1;\n\n\tif ((addr < (unsigned long)__irqentry_text_start) ||\n\t    (addr >= (unsigned long)__irqentry_text_end))\n\t\treturn 0;\n\n\t/*\n\t * We are entering irq code.\n\t */\n\t*depth_irq = depth;\n\treturn 1;\n}"
  },
  {
    "function_name": "print_graph_prologue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "924-962",
    "snippet": "static void\nprint_graph_prologue(struct trace_iterator *iter, struct trace_seq *s,\n\t\t     int type, unsigned long addr, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct trace_array *tr = iter->tr;\n\tint cpu = iter->cpu;\n\n\t/* Pid */\n\tverif_pid(s, ent->pid, cpu, data);\n\n\tif (type)\n\t\t/* Interrupt */\n\t\tprint_graph_irq(iter, addr, type, cpu, ent->pid, flags);\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* Absolute time */\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tprint_graph_abs_time(iter->ts, s);\n\n\t/* Cpu */\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tprint_graph_cpu(s, cpu);\n\n\t/* Proc */\n\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\tprint_graph_proc(s, ent->pid);\n\t\ttrace_seq_puts(s, \" | \");\n\t}\n\n\t/* Latency format */\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\tprint_graph_lat_fmt(s, ent);\n\n\treturn;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_graph_lat_fmt",
          "args": [
            "s",
            "ent"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_lat_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "590-594",
          "snippet": "static void print_graph_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\ttrace_seq_putc(s, ' ');\n\ttrace_print_lat_fmt(s, entry);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void print_graph_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\ttrace_seq_putc(s, ' ');\n\ttrace_print_lat_fmt(s, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\" | \""
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_proc",
          "args": [
            "s",
            "ent->pid"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "559-587",
          "snippet": "static void print_graph_proc(struct trace_seq *s, pid_t pid)\n{\n\tchar comm[TASK_COMM_LEN];\n\t/* sign + log10(MAX_INT) + '\\0' */\n\tchar pid_str[11];\n\tint spaces = 0;\n\tint len;\n\tint i;\n\n\ttrace_find_cmdline(pid, comm);\n\tcomm[7] = '\\0';\n\tsprintf(pid_str, \"%d\", pid);\n\n\t/* 1 stands for the \"-\" character */\n\tlen = strlen(comm) + strlen(pid_str) + 1;\n\n\tif (len < TRACE_GRAPH_PROCINFO_LENGTH)\n\t\tspaces = TRACE_GRAPH_PROCINFO_LENGTH - len;\n\n\t/* First spaces to align center */\n\tfor (i = 0; i < spaces / 2; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%s-%s\", comm, pid_str);\n\n\t/* Last spaces to align center */\n\tfor (i = 0; i < spaces - (spaces / 2); i++)\n\t\ttrace_seq_putc(s, ' ');\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define TRACE_GRAPH_PROCINFO_LENGTH\t14"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_PROCINFO_LENGTH\t14\n\nstatic void print_graph_proc(struct trace_seq *s, pid_t pid)\n{\n\tchar comm[TASK_COMM_LEN];\n\t/* sign + log10(MAX_INT) + '\\0' */\n\tchar pid_str[11];\n\tint spaces = 0;\n\tint len;\n\tint i;\n\n\ttrace_find_cmdline(pid, comm);\n\tcomm[7] = '\\0';\n\tsprintf(pid_str, \"%d\", pid);\n\n\t/* 1 stands for the \"-\" character */\n\tlen = strlen(comm) + strlen(pid_str) + 1;\n\n\tif (len < TRACE_GRAPH_PROCINFO_LENGTH)\n\t\tspaces = TRACE_GRAPH_PROCINFO_LENGTH - len;\n\n\t/* First spaces to align center */\n\tfor (i = 0; i < spaces / 2; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%s-%s\", comm, pid_str);\n\n\t/* Last spaces to align center */\n\tfor (i = 0; i < spaces - (spaces / 2); i++)\n\t\ttrace_seq_putc(s, ' ');\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_cpu",
          "args": [
            "s",
            "cpu"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "547-555",
          "snippet": "static void print_graph_cpu(struct trace_seq *s, int cpu)\n{\n\t/*\n\t * Start with a space character - to make it stand out\n\t * to the right a bit when trace output is pasted into\n\t * email:\n\t */\n\ttrace_seq_printf(s, \" %*d) \", max_bytes_for_cpu, cpu);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int max_bytes_for_cpu;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int max_bytes_for_cpu;\n\nstatic void print_graph_cpu(struct trace_seq *s, int cpu)\n{\n\t/*\n\t * Start with a space character - to make it stand out\n\t * to the right a bit when trace output is pasted into\n\t * email:\n\t */\n\ttrace_seq_printf(s, \" %*d) \", max_bytes_for_cpu, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_abs_time",
          "args": [
            "iter->ts",
            "s"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_abs_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "703-712",
          "snippet": "static void print_graph_abs_time(u64 t, struct trace_seq *s)\n{\n\tunsigned long usecs_rem;\n\n\tusecs_rem = do_div(t, NSEC_PER_SEC);\n\tusecs_rem /= 1000;\n\n\ttrace_seq_printf(s, \"%5lu.%06lu |  \",\n\t\t\t (unsigned long)t, usecs_rem);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void print_graph_abs_time(u64 t, struct trace_seq *s)\n{\n\tunsigned long usecs_rem;\n\n\tusecs_rem = do_div(t, NSEC_PER_SEC);\n\tusecs_rem /= 1000;\n\n\ttrace_seq_printf(s, \"%5lu.%06lu |  \",\n\t\t\t (unsigned long)t, usecs_rem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_irq",
          "args": [
            "iter",
            "addr",
            "type",
            "cpu",
            "ent->pid",
            "flags"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "714-756",
          "snippet": "static void\nprint_graph_irq(struct trace_iterator *iter, unsigned long addr,\n\t\tenum trace_type type, int cpu, pid_t pid, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\n\tif (addr < (unsigned long)__irqentry_text_start ||\n\t\taddr >= (unsigned long)__irqentry_text_end)\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {\n\t\t/* Absolute time */\n\t\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\t\tprint_graph_abs_time(iter->ts, s);\n\n\t\t/* Cpu */\n\t\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\t\tprint_graph_cpu(s, cpu);\n\n\t\t/* Proc */\n\t\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\t\tprint_graph_proc(s, pid);\n\t\t\ttrace_seq_puts(s, \" | \");\n\t\t}\n\n\t\t/* Latency format */\n\t\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\t\tprint_graph_lat_fmt(s, ent);\n\t}\n\n\t/* No overhead */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_START);\n\n\tif (type == TRACE_GRAPH_ENT)\n\t\ttrace_seq_puts(s, \"==========>\");\n\telse\n\t\ttrace_seq_puts(s, \"<==========\");\n\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_END);\n\ttrace_seq_putc(s, '\\n');\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_irq(struct trace_iterator *iter, unsigned long addr,\n\t\tenum trace_type type, int cpu, pid_t pid, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\n\tif (addr < (unsigned long)__irqentry_text_start ||\n\t\taddr >= (unsigned long)__irqentry_text_end)\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {\n\t\t/* Absolute time */\n\t\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\t\tprint_graph_abs_time(iter->ts, s);\n\n\t\t/* Cpu */\n\t\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\t\tprint_graph_cpu(s, cpu);\n\n\t\t/* Proc */\n\t\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\t\tprint_graph_proc(s, pid);\n\t\t\ttrace_seq_puts(s, \" | \");\n\t\t}\n\n\t\t/* Latency format */\n\t\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\t\tprint_graph_lat_fmt(s, ent);\n\t}\n\n\t/* No overhead */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_START);\n\n\tif (type == TRACE_GRAPH_ENT)\n\t\ttrace_seq_puts(s, \"==========>\");\n\telse\n\t\ttrace_seq_puts(s, \"<==========\");\n\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_END);\n\ttrace_seq_putc(s, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "verif_pid",
          "args": [
            "s",
            "ent->pid",
            "cpu",
            "data"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "verif_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "597-630",
          "snippet": "static void\nverif_pid(struct trace_seq *s, pid_t pid, int cpu, struct fgraph_data *data)\n{\n\tpid_t prev_pid;\n\tpid_t *last_pid;\n\n\tif (!data)\n\t\treturn;\n\n\tlast_pid = &(per_cpu_ptr(data->cpu_data, cpu)->last_pid);\n\n\tif (*last_pid == pid)\n\t\treturn;\n\n\tprev_pid = *last_pid;\n\t*last_pid = pid;\n\n\tif (prev_pid == -1)\n\t\treturn;\n/*\n * Context-switch trace line:\n\n ------------------------------------------\n | 1)  migration/0--1  =>  sshd-1755\n ------------------------------------------\n\n */\n\ttrace_seq_puts(s, \" ------------------------------------------\\n\");\n\tprint_graph_cpu(s, cpu);\n\tprint_graph_proc(s, prev_pid);\n\ttrace_seq_puts(s, \" => \");\n\tprint_graph_proc(s, pid);\n\ttrace_seq_puts(s, \"\\n ------------------------------------------\\n\\n\");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nverif_pid(struct trace_seq *s, pid_t pid, int cpu, struct fgraph_data *data)\n{\n\tpid_t prev_pid;\n\tpid_t *last_pid;\n\n\tif (!data)\n\t\treturn;\n\n\tlast_pid = &(per_cpu_ptr(data->cpu_data, cpu)->last_pid);\n\n\tif (*last_pid == pid)\n\t\treturn;\n\n\tprev_pid = *last_pid;\n\t*last_pid = pid;\n\n\tif (prev_pid == -1)\n\t\treturn;\n/*\n * Context-switch trace line:\n\n ------------------------------------------\n | 1)  migration/0--1  =>  sshd-1755\n ------------------------------------------\n\n */\n\ttrace_seq_puts(s, \" ------------------------------------------\\n\");\n\tprint_graph_cpu(s, cpu);\n\tprint_graph_proc(s, prev_pid);\n\ttrace_seq_puts(s, \" => \");\n\tprint_graph_proc(s, pid);\n\ttrace_seq_puts(s, \"\\n ------------------------------------------\\n\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_prologue(struct trace_iterator *iter, struct trace_seq *s,\n\t\t     int type, unsigned long addr, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct trace_array *tr = iter->tr;\n\tint cpu = iter->cpu;\n\n\t/* Pid */\n\tverif_pid(s, ent->pid, cpu, data);\n\n\tif (type)\n\t\t/* Interrupt */\n\t\tprint_graph_irq(iter, addr, type, cpu, ent->pid, flags);\n\n\tif (!(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* Absolute time */\n\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\tprint_graph_abs_time(iter->ts, s);\n\n\t/* Cpu */\n\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\tprint_graph_cpu(s, cpu);\n\n\t/* Proc */\n\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\tprint_graph_proc(s, ent->pid);\n\t\ttrace_seq_puts(s, \" | \");\n\t}\n\n\t/* Latency format */\n\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\tprint_graph_lat_fmt(s, ent);\n\n\treturn;\n}"
  },
  {
    "function_name": "print_graph_entry_nested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "878-922",
    "snippet": "static enum print_line_t\nprint_graph_entry_nested(struct trace_iterator *iter,\n\t\t\t struct ftrace_graph_ent_entry *entry,\n\t\t\t struct trace_seq *s, int cpu, u32 flags)\n{\n\tstruct ftrace_graph_ent *call = &entry->graph_ent;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tint i;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\t\tint cpu = iter->cpu;\n\n\t\t/* If a graph tracer ignored set_graph_notrace */\n\t\tif (call->depth < -1)\n\t\t\tcall->depth += FTRACE_NOTRACE_DEPTH;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\t\tcpu_data->depth = call->depth;\n\n\t\t/* Save this function pointer to see if the exit matches */\n\t\tif (call->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(call->depth < 0))\n\t\t\tcpu_data->enter_funcs[call->depth] = call->func;\n\t}\n\n\t/* No time */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_FULL);\n\n\t/* Function */\n\tfor (i = 0; i < call->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%ps() {\\n\", (void *)call->func);\n\n\tif (trace_seq_has_overflowed(s))\n\t\treturn TRACE_TYPE_PARTIAL_LINE;\n\n\t/*\n\t * we already consumed the current entry to check the next one\n\t * and see if this is a leaf.\n\t */\n\treturn TRACE_TYPE_NO_CONSUME;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define TRACE_GRAPH_INDENT\t2"
    ],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%ps() {\\n\"",
            "(void *)call->func"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "' '"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_duration",
          "args": [
            "tr",
            "0",
            "s",
            "flags | FLAGS_FILL_FULL"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_duration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "791-820",
          "snippet": "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "call->depth < 0"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_INDENT\t2\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_entry_nested(struct trace_iterator *iter,\n\t\t\t struct ftrace_graph_ent_entry *entry,\n\t\t\t struct trace_seq *s, int cpu, u32 flags)\n{\n\tstruct ftrace_graph_ent *call = &entry->graph_ent;\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tint i;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\t\tint cpu = iter->cpu;\n\n\t\t/* If a graph tracer ignored set_graph_notrace */\n\t\tif (call->depth < -1)\n\t\t\tcall->depth += FTRACE_NOTRACE_DEPTH;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\t\tcpu_data->depth = call->depth;\n\n\t\t/* Save this function pointer to see if the exit matches */\n\t\tif (call->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(call->depth < 0))\n\t\t\tcpu_data->enter_funcs[call->depth] = call->func;\n\t}\n\n\t/* No time */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_FULL);\n\n\t/* Function */\n\tfor (i = 0; i < call->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%ps() {\\n\", (void *)call->func);\n\n\tif (trace_seq_has_overflowed(s))\n\t\treturn TRACE_TYPE_PARTIAL_LINE;\n\n\t/*\n\t * we already consumed the current entry to check the next one\n\t * and see if this is a leaf.\n\t */\n\treturn TRACE_TYPE_NO_CONSUME;\n}"
  },
  {
    "function_name": "print_graph_entry_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "823-876",
    "snippet": "static enum print_line_t\nprint_graph_entry_leaf(struct trace_iterator *iter,\n\t\tstruct ftrace_graph_ent_entry *entry,\n\t\tstruct ftrace_graph_ret_entry *ret_entry,\n\t\tstruct trace_seq *s, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tstruct ftrace_graph_ret *graph_ret;\n\tstruct ftrace_graph_ent *call;\n\tunsigned long long duration;\n\tint cpu = iter->cpu;\n\tint i;\n\n\tgraph_ret = &ret_entry->ret;\n\tcall = &entry->graph_ent;\n\tduration = graph_ret->rettime - graph_ret->calltime;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\n\t\t/* If a graph tracer ignored set_graph_notrace */\n\t\tif (call->depth < -1)\n\t\t\tcall->depth += FTRACE_NOTRACE_DEPTH;\n\n\t\t/*\n\t\t * Comments display at + 1 to depth. Since\n\t\t * this is a leaf function, keep the comments\n\t\t * equal to this depth.\n\t\t */\n\t\tcpu_data->depth = call->depth - 1;\n\n\t\t/* No need to keep this function around for this depth */\n\t\tif (call->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(call->depth < 0))\n\t\t\tcpu_data->enter_funcs[call->depth] = 0;\n\t}\n\n\t/* Overhead and duration */\n\tprint_graph_duration(tr, duration, s, flags);\n\n\t/* Function */\n\tfor (i = 0; i < call->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%ps();\\n\", (void *)call->func);\n\n\tprint_graph_irq(iter, graph_ret->func, TRACE_GRAPH_RET,\n\t\t\tcpu, iter->ent->pid, flags);\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define TRACE_GRAPH_INDENT\t2"
    ],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2123-2127",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_irq",
          "args": [
            "iter",
            "graph_ret->func",
            "TRACE_GRAPH_RET",
            "cpu",
            "iter->ent->pid",
            "flags"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "714-756",
          "snippet": "static void\nprint_graph_irq(struct trace_iterator *iter, unsigned long addr,\n\t\tenum trace_type type, int cpu, pid_t pid, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\n\tif (addr < (unsigned long)__irqentry_text_start ||\n\t\taddr >= (unsigned long)__irqentry_text_end)\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {\n\t\t/* Absolute time */\n\t\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\t\tprint_graph_abs_time(iter->ts, s);\n\n\t\t/* Cpu */\n\t\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\t\tprint_graph_cpu(s, cpu);\n\n\t\t/* Proc */\n\t\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\t\tprint_graph_proc(s, pid);\n\t\t\ttrace_seq_puts(s, \" | \");\n\t\t}\n\n\t\t/* Latency format */\n\t\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\t\tprint_graph_lat_fmt(s, ent);\n\t}\n\n\t/* No overhead */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_START);\n\n\tif (type == TRACE_GRAPH_ENT)\n\t\ttrace_seq_puts(s, \"==========>\");\n\telse\n\t\ttrace_seq_puts(s, \"<==========\");\n\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_END);\n\ttrace_seq_putc(s, '\\n');\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_irq(struct trace_iterator *iter, unsigned long addr,\n\t\tenum trace_type type, int cpu, pid_t pid, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\n\tif (addr < (unsigned long)__irqentry_text_start ||\n\t\taddr >= (unsigned long)__irqentry_text_end)\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {\n\t\t/* Absolute time */\n\t\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\t\tprint_graph_abs_time(iter->ts, s);\n\n\t\t/* Cpu */\n\t\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\t\tprint_graph_cpu(s, cpu);\n\n\t\t/* Proc */\n\t\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\t\tprint_graph_proc(s, pid);\n\t\t\ttrace_seq_puts(s, \" | \");\n\t\t}\n\n\t\t/* Latency format */\n\t\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\t\tprint_graph_lat_fmt(s, ent);\n\t}\n\n\t/* No overhead */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_START);\n\n\tif (type == TRACE_GRAPH_ENT)\n\t\ttrace_seq_puts(s, \"==========>\");\n\telse\n\t\ttrace_seq_puts(s, \"<==========\");\n\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_END);\n\ttrace_seq_putc(s, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%ps();\\n\"",
            "(void *)call->func"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "' '"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_duration",
          "args": [
            "tr",
            "duration",
            "s",
            "flags"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_duration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "791-820",
          "snippet": "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "call->depth < 0"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_INDENT\t2\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic enum print_line_t\nprint_graph_entry_leaf(struct trace_iterator *iter,\n\t\tstruct ftrace_graph_ent_entry *entry,\n\t\tstruct ftrace_graph_ret_entry *ret_entry,\n\t\tstruct trace_seq *s, u32 flags)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct trace_array *tr = iter->tr;\n\tstruct ftrace_graph_ret *graph_ret;\n\tstruct ftrace_graph_ent *call;\n\tunsigned long long duration;\n\tint cpu = iter->cpu;\n\tint i;\n\n\tgraph_ret = &ret_entry->ret;\n\tcall = &entry->graph_ent;\n\tduration = graph_ret->rettime - graph_ret->calltime;\n\n\tif (data) {\n\t\tstruct fgraph_cpu_data *cpu_data;\n\n\t\tcpu_data = per_cpu_ptr(data->cpu_data, cpu);\n\n\t\t/* If a graph tracer ignored set_graph_notrace */\n\t\tif (call->depth < -1)\n\t\t\tcall->depth += FTRACE_NOTRACE_DEPTH;\n\n\t\t/*\n\t\t * Comments display at + 1 to depth. Since\n\t\t * this is a leaf function, keep the comments\n\t\t * equal to this depth.\n\t\t */\n\t\tcpu_data->depth = call->depth - 1;\n\n\t\t/* No need to keep this function around for this depth */\n\t\tif (call->depth < FTRACE_RETFUNC_DEPTH &&\n\t\t    !WARN_ON_ONCE(call->depth < 0))\n\t\t\tcpu_data->enter_funcs[call->depth] = 0;\n\t}\n\n\t/* Overhead and duration */\n\tprint_graph_duration(tr, duration, s, flags);\n\n\t/* Function */\n\tfor (i = 0; i < call->depth * TRACE_GRAPH_INDENT; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%ps();\\n\", (void *)call->func);\n\n\tprint_graph_irq(iter, graph_ret->func, TRACE_GRAPH_RET,\n\t\t\tcpu, iter->ent->pid, flags);\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "print_graph_duration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "791-820",
    "snippet": "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\"|  \""
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_print_graph_duration",
          "args": [
            "duration",
            "s"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_graph_duration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "758-789",
          "snippet": "void\ntrace_print_graph_duration(unsigned long long duration, struct trace_seq *s)\n{\n\tunsigned long nsecs_rem = do_div(duration, 1000);\n\t/* log10(ULONG_MAX) + '\\0' */\n\tchar usecs_str[21];\n\tchar nsecs_str[5];\n\tint len;\n\tint i;\n\n\tsprintf(usecs_str, \"%lu\", (unsigned long) duration);\n\n\t/* Print msecs */\n\ttrace_seq_printf(s, \"%s\", usecs_str);\n\n\tlen = strlen(usecs_str);\n\n\t/* Print nsecs (we don't want to exceed 7 numbers) */\n\tif (len < 7) {\n\t\tsize_t slen = min_t(size_t, sizeof(nsecs_str), 8UL - len);\n\n\t\tsnprintf(nsecs_str, slen, \"%03lu\", nsecs_rem);\n\t\ttrace_seq_printf(s, \".%s\", nsecs_str);\n\t\tlen += strlen(nsecs_str) + 1;\n\t}\n\n\ttrace_seq_puts(s, \" us \");\n\n\t/* Print remaining spaces to fit the row's width */\n\tfor (i = len; i < 8; i++)\n\t\ttrace_seq_putc(s, ' ');\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid\ntrace_print_graph_duration(unsigned long long duration, struct trace_seq *s)\n{\n\tunsigned long nsecs_rem = do_div(duration, 1000);\n\t/* log10(ULONG_MAX) + '\\0' */\n\tchar usecs_str[21];\n\tchar nsecs_str[5];\n\tint len;\n\tint i;\n\n\tsprintf(usecs_str, \"%lu\", (unsigned long) duration);\n\n\t/* Print msecs */\n\ttrace_seq_printf(s, \"%s\", usecs_str);\n\n\tlen = strlen(usecs_str);\n\n\t/* Print nsecs (we don't want to exceed 7 numbers) */\n\tif (len < 7) {\n\t\tsize_t slen = min_t(size_t, sizeof(nsecs_str), 8UL - len);\n\n\t\tsnprintf(nsecs_str, slen, \"%03lu\", nsecs_rem);\n\t\ttrace_seq_printf(s, \".%s\", nsecs_str);\n\t\tlen += strlen(nsecs_str) + 1;\n\t}\n\n\ttrace_seq_puts(s, \" us \");\n\n\t/* Print remaining spaces to fit the row's width */\n\tfor (i = len; i < 8; i++)\n\t\ttrace_seq_putc(s, ' ');\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%c \"",
            "trace_find_mark(duration)"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_mark",
          "args": [
            "duration"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_output.c",
          "lines": "529-540",
          "snippet": "char trace_find_mark(unsigned long long d)\n{\n\tint i;\n\tint size = ARRAY_SIZE(mark);\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (d > mark[i].val)\n\t\t\tbreak;\n\t}\n\n\treturn (i == size) ? ' ' : mark[i].sym;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct trace_mark {\n\tunsigned long long\tval; /* unit: nsec */\n\tchar\t\t\tsym;\n} mark[] = {\n\tMARK(1000000000ULL\t, '$'), /* 1 sec */\n\tMARK(100000000ULL\t, '@'), /* 100 msec */\n\tMARK(10000000ULL\t, '*'), /* 10 msec */\n\tMARK(1000000ULL\t\t, '#'), /* 1000 usecs */\n\tMARK(100000ULL\t\t, '!'), /* 100 usecs */\n\tMARK(10000ULL\t\t, '+'), /* 10 usecs */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic const struct trace_mark {\n\tunsigned long long\tval; /* unit: nsec */\n\tchar\t\t\tsym;\n} mark[] = {\n\tMARK(1000000000ULL\t, '$'), /* 1 sec */\n\tMARK(100000000ULL\t, '@'), /* 100 msec */\n\tMARK(10000000ULL\t, '*'), /* 10 msec */\n\tMARK(1000000ULL\t\t, '#'), /* 1000 usecs */\n\tMARK(100000ULL\t\t, '!'), /* 100 usecs */\n\tMARK(10000ULL\t\t, '+'), /* 10 usecs */\n};\n\nchar trace_find_mark(unsigned long long d)\n{\n\tint i;\n\tint size = ARRAY_SIZE(mark);\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (d > mark[i].val)\n\t\t\tbreak;\n\t}\n\n\treturn (i == size) ? ' ' : mark[i].sym;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}"
  },
  {
    "function_name": "trace_print_graph_duration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "758-789",
    "snippet": "void\ntrace_print_graph_duration(unsigned long long duration, struct trace_seq *s)\n{\n\tunsigned long nsecs_rem = do_div(duration, 1000);\n\t/* log10(ULONG_MAX) + '\\0' */\n\tchar usecs_str[21];\n\tchar nsecs_str[5];\n\tint len;\n\tint i;\n\n\tsprintf(usecs_str, \"%lu\", (unsigned long) duration);\n\n\t/* Print msecs */\n\ttrace_seq_printf(s, \"%s\", usecs_str);\n\n\tlen = strlen(usecs_str);\n\n\t/* Print nsecs (we don't want to exceed 7 numbers) */\n\tif (len < 7) {\n\t\tsize_t slen = min_t(size_t, sizeof(nsecs_str), 8UL - len);\n\n\t\tsnprintf(nsecs_str, slen, \"%03lu\", nsecs_rem);\n\t\ttrace_seq_printf(s, \".%s\", nsecs_str);\n\t\tlen += strlen(nsecs_str) + 1;\n\t}\n\n\ttrace_seq_puts(s, \" us \");\n\n\t/* Print remaining spaces to fit the row's width */\n\tfor (i = len; i < 8; i++)\n\t\ttrace_seq_putc(s, ' ');\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "' '"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\" us \""
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nsecs_str"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\".%s\"",
            "nsecs_str"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "nsecs_str",
            "slen",
            "\"%03lu\"",
            "nsecs_rem"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "sizeof(nsecs_str)",
            "8UL - len"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "usecs_str",
            "\"%lu\"",
            "(unsigned long) duration"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "duration",
            "1000"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nvoid\ntrace_print_graph_duration(unsigned long long duration, struct trace_seq *s)\n{\n\tunsigned long nsecs_rem = do_div(duration, 1000);\n\t/* log10(ULONG_MAX) + '\\0' */\n\tchar usecs_str[21];\n\tchar nsecs_str[5];\n\tint len;\n\tint i;\n\n\tsprintf(usecs_str, \"%lu\", (unsigned long) duration);\n\n\t/* Print msecs */\n\ttrace_seq_printf(s, \"%s\", usecs_str);\n\n\tlen = strlen(usecs_str);\n\n\t/* Print nsecs (we don't want to exceed 7 numbers) */\n\tif (len < 7) {\n\t\tsize_t slen = min_t(size_t, sizeof(nsecs_str), 8UL - len);\n\n\t\tsnprintf(nsecs_str, slen, \"%03lu\", nsecs_rem);\n\t\ttrace_seq_printf(s, \".%s\", nsecs_str);\n\t\tlen += strlen(nsecs_str) + 1;\n\t}\n\n\ttrace_seq_puts(s, \" us \");\n\n\t/* Print remaining spaces to fit the row's width */\n\tfor (i = len; i < 8; i++)\n\t\ttrace_seq_putc(s, ' ');\n}"
  },
  {
    "function_name": "print_graph_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "714-756",
    "snippet": "static void\nprint_graph_irq(struct trace_iterator *iter, unsigned long addr,\n\t\tenum trace_type type, int cpu, pid_t pid, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\n\tif (addr < (unsigned long)__irqentry_text_start ||\n\t\taddr >= (unsigned long)__irqentry_text_end)\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {\n\t\t/* Absolute time */\n\t\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\t\tprint_graph_abs_time(iter->ts, s);\n\n\t\t/* Cpu */\n\t\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\t\tprint_graph_cpu(s, cpu);\n\n\t\t/* Proc */\n\t\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\t\tprint_graph_proc(s, pid);\n\t\t\ttrace_seq_puts(s, \" | \");\n\t\t}\n\n\t\t/* Latency format */\n\t\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\t\tprint_graph_lat_fmt(s, ent);\n\t}\n\n\t/* No overhead */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_START);\n\n\tif (type == TRACE_GRAPH_ENT)\n\t\ttrace_seq_puts(s, \"==========>\");\n\telse\n\t\ttrace_seq_puts(s, \"<==========\");\n\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_END);\n\ttrace_seq_putc(s, '\\n');\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_duration",
          "args": [
            "tr",
            "0",
            "s",
            "flags | FLAGS_FILL_END"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_duration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "791-820",
          "snippet": "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags)\n{\n\tif (!(flags & TRACE_GRAPH_PRINT_DURATION) ||\n\t    !(tr->trace_flags & TRACE_ITER_CONTEXT_INFO))\n\t\treturn;\n\n\t/* No real adata, just filling the column with spaces */\n\tswitch (flags & TRACE_GRAPH_PRINT_FILL_MASK) {\n\tcase FLAGS_FILL_FULL:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase FLAGS_FILL_START:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase FLAGS_FILL_END:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t/* Signal a overhead of time execution to the output */\n\tif (flags & TRACE_GRAPH_PRINT_OVERHEAD)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\"<==========\""
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_lat_fmt",
          "args": [
            "s",
            "ent"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_lat_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "590-594",
          "snippet": "static void print_graph_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\ttrace_seq_putc(s, ' ');\n\ttrace_print_lat_fmt(s, entry);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void print_graph_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\ttrace_seq_putc(s, ' ');\n\ttrace_print_lat_fmt(s, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_proc",
          "args": [
            "s",
            "pid"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "559-587",
          "snippet": "static void print_graph_proc(struct trace_seq *s, pid_t pid)\n{\n\tchar comm[TASK_COMM_LEN];\n\t/* sign + log10(MAX_INT) + '\\0' */\n\tchar pid_str[11];\n\tint spaces = 0;\n\tint len;\n\tint i;\n\n\ttrace_find_cmdline(pid, comm);\n\tcomm[7] = '\\0';\n\tsprintf(pid_str, \"%d\", pid);\n\n\t/* 1 stands for the \"-\" character */\n\tlen = strlen(comm) + strlen(pid_str) + 1;\n\n\tif (len < TRACE_GRAPH_PROCINFO_LENGTH)\n\t\tspaces = TRACE_GRAPH_PROCINFO_LENGTH - len;\n\n\t/* First spaces to align center */\n\tfor (i = 0; i < spaces / 2; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%s-%s\", comm, pid_str);\n\n\t/* Last spaces to align center */\n\tfor (i = 0; i < spaces - (spaces / 2); i++)\n\t\ttrace_seq_putc(s, ' ');\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define TRACE_GRAPH_PROCINFO_LENGTH\t14"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_PROCINFO_LENGTH\t14\n\nstatic void print_graph_proc(struct trace_seq *s, pid_t pid)\n{\n\tchar comm[TASK_COMM_LEN];\n\t/* sign + log10(MAX_INT) + '\\0' */\n\tchar pid_str[11];\n\tint spaces = 0;\n\tint len;\n\tint i;\n\n\ttrace_find_cmdline(pid, comm);\n\tcomm[7] = '\\0';\n\tsprintf(pid_str, \"%d\", pid);\n\n\t/* 1 stands for the \"-\" character */\n\tlen = strlen(comm) + strlen(pid_str) + 1;\n\n\tif (len < TRACE_GRAPH_PROCINFO_LENGTH)\n\t\tspaces = TRACE_GRAPH_PROCINFO_LENGTH - len;\n\n\t/* First spaces to align center */\n\tfor (i = 0; i < spaces / 2; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%s-%s\", comm, pid_str);\n\n\t/* Last spaces to align center */\n\tfor (i = 0; i < spaces - (spaces / 2); i++)\n\t\ttrace_seq_putc(s, ' ');\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_cpu",
          "args": [
            "s",
            "cpu"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "547-555",
          "snippet": "static void print_graph_cpu(struct trace_seq *s, int cpu)\n{\n\t/*\n\t * Start with a space character - to make it stand out\n\t * to the right a bit when trace output is pasted into\n\t * email:\n\t */\n\ttrace_seq_printf(s, \" %*d) \", max_bytes_for_cpu, cpu);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int max_bytes_for_cpu;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int max_bytes_for_cpu;\n\nstatic void print_graph_cpu(struct trace_seq *s, int cpu)\n{\n\t/*\n\t * Start with a space character - to make it stand out\n\t * to the right a bit when trace output is pasted into\n\t * email:\n\t */\n\ttrace_seq_printf(s, \" %*d) \", max_bytes_for_cpu, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_abs_time",
          "args": [
            "iter->ts",
            "s"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_abs_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "703-712",
          "snippet": "static void print_graph_abs_time(u64 t, struct trace_seq *s)\n{\n\tunsigned long usecs_rem;\n\n\tusecs_rem = do_div(t, NSEC_PER_SEC);\n\tusecs_rem /= 1000;\n\n\ttrace_seq_printf(s, \"%5lu.%06lu |  \",\n\t\t\t (unsigned long)t, usecs_rem);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void print_graph_abs_time(u64 t, struct trace_seq *s)\n{\n\tunsigned long usecs_rem;\n\n\tusecs_rem = do_div(t, NSEC_PER_SEC);\n\tusecs_rem /= 1000;\n\n\ttrace_seq_printf(s, \"%5lu.%06lu |  \",\n\t\t\t (unsigned long)t, usecs_rem);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\nprint_graph_irq(struct trace_iterator *iter, unsigned long addr,\n\t\tenum trace_type type, int cpu, pid_t pid, u32 flags)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\n\tif (addr < (unsigned long)__irqentry_text_start ||\n\t\taddr >= (unsigned long)__irqentry_text_end)\n\t\treturn;\n\n\tif (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {\n\t\t/* Absolute time */\n\t\tif (flags & TRACE_GRAPH_PRINT_ABS_TIME)\n\t\t\tprint_graph_abs_time(iter->ts, s);\n\n\t\t/* Cpu */\n\t\tif (flags & TRACE_GRAPH_PRINT_CPU)\n\t\t\tprint_graph_cpu(s, cpu);\n\n\t\t/* Proc */\n\t\tif (flags & TRACE_GRAPH_PRINT_PROC) {\n\t\t\tprint_graph_proc(s, pid);\n\t\t\ttrace_seq_puts(s, \" | \");\n\t\t}\n\n\t\t/* Latency format */\n\t\tif (tr->trace_flags & TRACE_ITER_LATENCY_FMT)\n\t\t\tprint_graph_lat_fmt(s, ent);\n\t}\n\n\t/* No overhead */\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_START);\n\n\tif (type == TRACE_GRAPH_ENT)\n\t\ttrace_seq_puts(s, \"==========>\");\n\telse\n\t\ttrace_seq_puts(s, \"<==========\");\n\n\tprint_graph_duration(tr, 0, s, flags | FLAGS_FILL_END);\n\ttrace_seq_putc(s, '\\n');\n}"
  },
  {
    "function_name": "print_graph_abs_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "703-712",
    "snippet": "static void print_graph_abs_time(u64 t, struct trace_seq *s)\n{\n\tunsigned long usecs_rem;\n\n\tusecs_rem = do_div(t, NSEC_PER_SEC);\n\tusecs_rem /= 1000;\n\n\ttrace_seq_printf(s, \"%5lu.%06lu |  \",\n\t\t\t (unsigned long)t, usecs_rem);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%5lu.%06lu |  \"",
            "(unsigned long)t",
            "usecs_rem"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "t",
            "NSEC_PER_SEC"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void print_graph_abs_time(u64 t, struct trace_seq *s)\n{\n\tunsigned long usecs_rem;\n\n\tusecs_rem = do_div(t, NSEC_PER_SEC);\n\tusecs_rem /= 1000;\n\n\ttrace_seq_printf(s, \"%5lu.%06lu |  \",\n\t\t\t (unsigned long)t, usecs_rem);\n}"
  },
  {
    "function_name": "get_return_for_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "632-701",
    "snippet": "static struct ftrace_graph_ret_entry *\nget_return_for_leaf(struct trace_iterator *iter,\n\t\tstruct ftrace_graph_ent_entry *curr)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct ring_buffer_iter *ring_iter = NULL;\n\tstruct ring_buffer_event *event;\n\tstruct ftrace_graph_ret_entry *next;\n\n\t/*\n\t * If the previous output failed to write to the seq buffer,\n\t * then we just reuse the data from before.\n\t */\n\tif (data && data->failed) {\n\t\tcurr = &data->ent;\n\t\tnext = &data->ret;\n\t} else {\n\n\t\tring_iter = trace_buffer_iter(iter, iter->cpu);\n\n\t\t/* First peek to compare current entry and the next one */\n\t\tif (ring_iter)\n\t\t\tevent = ring_buffer_iter_peek(ring_iter, NULL);\n\t\telse {\n\t\t\t/*\n\t\t\t * We need to consume the current entry to see\n\t\t\t * the next one.\n\t\t\t */\n\t\t\tring_buffer_consume(iter->trace_buffer->buffer, iter->cpu,\n\t\t\t\t\t    NULL, NULL);\n\t\t\tevent = ring_buffer_peek(iter->trace_buffer->buffer, iter->cpu,\n\t\t\t\t\t\t NULL, NULL);\n\t\t}\n\n\t\tif (!event)\n\t\t\treturn NULL;\n\n\t\tnext = ring_buffer_event_data(event);\n\n\t\tif (data) {\n\t\t\t/*\n\t\t\t * Save current and next entries for later reference\n\t\t\t * if the output fails.\n\t\t\t */\n\t\t\tdata->ent = *curr;\n\t\t\t/*\n\t\t\t * If the next event is not a return type, then\n\t\t\t * we only care about what type it is. Otherwise we can\n\t\t\t * safely copy the entire event.\n\t\t\t */\n\t\t\tif (next->ent.type == TRACE_GRAPH_RET)\n\t\t\t\tdata->ret = *next;\n\t\t\telse\n\t\t\t\tdata->ret.ent.type = next->ent.type;\n\t\t}\n\t}\n\n\tif (next->ent.type != TRACE_GRAPH_RET)\n\t\treturn NULL;\n\n\tif (curr->ent.pid != next->ent.pid ||\n\t\t\tcurr->graph_ent.func != next->ret.func)\n\t\treturn NULL;\n\n\t/* this is a leaf, now advance the iterator */\n\tif (ring_iter)\n\t\tring_buffer_read(ring_iter, NULL);\n\n\treturn next;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring_buffer_read",
          "args": [
            "ring_iter",
            "NULL"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "4264-4285",
          "snippet": "struct ring_buffer_event *\nring_buffer_read(struct ring_buffer_iter *iter, u64 *ts)\n{\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n again:\n\tevent = rb_iter_peek(iter, ts);\n\tif (!event)\n\t\tgoto out;\n\n\tif (event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\trb_advance_iter(iter);\n out:\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n\n\treturn event;\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\nring_buffer_read(struct ring_buffer_iter *iter, u64 *ts)\n{\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n again:\n\tevent = rb_iter_peek(iter, ts);\n\tif (!event)\n\t\tgoto out;\n\n\tif (event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\trb_advance_iter(iter);\n out:\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n\n\treturn event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "272-275",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_peek",
          "args": [
            "iter->trace_buffer->buffer",
            "iter->cpu",
            "NULL",
            "NULL"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_peek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "4037-4062",
          "snippet": "struct ring_buffer_event *\nring_buffer_peek(struct ring_buffer *buffer, int cpu, u64 *ts,\n\t\t unsigned long *lost_events)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = buffer->buffers[cpu];\n\tstruct ring_buffer_event *event;\n\tunsigned long flags;\n\tbool dolock;\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn NULL;\n\n again:\n\tlocal_irq_save(flags);\n\tdolock = rb_reader_lock(cpu_buffer);\n\tevent = rb_buffer_peek(cpu_buffer, ts, lost_events);\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\trb_advance_reader(cpu_buffer);\n\trb_reader_unlock(cpu_buffer, dolock);\n\tlocal_irq_restore(flags);\n\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\treturn event;\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\nring_buffer_peek(struct ring_buffer *buffer, int cpu, u64 *ts,\n\t\t unsigned long *lost_events)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = buffer->buffers[cpu];\n\tstruct ring_buffer_event *event;\n\tunsigned long flags;\n\tbool dolock;\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn NULL;\n\n again:\n\tlocal_irq_save(flags);\n\tdolock = rb_reader_lock(cpu_buffer);\n\tevent = rb_buffer_peek(cpu_buffer, ts, lost_events);\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\trb_advance_reader(cpu_buffer);\n\trb_reader_unlock(cpu_buffer, dolock);\n\tlocal_irq_restore(flags);\n\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\treturn event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_consume",
          "args": [
            "iter->trace_buffer->buffer",
            "iter->cpu",
            "NULL",
            "NULL"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_consume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "4101-4137",
          "snippet": "struct ring_buffer_event *\nring_buffer_consume(struct ring_buffer *buffer, int cpu, u64 *ts,\n\t\t    unsigned long *lost_events)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event = NULL;\n\tunsigned long flags;\n\tbool dolock;\n\n again:\n\t/* might be called in atomic */\n\tpreempt_disable();\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\tgoto out;\n\n\tcpu_buffer = buffer->buffers[cpu];\n\tlocal_irq_save(flags);\n\tdolock = rb_reader_lock(cpu_buffer);\n\n\tevent = rb_buffer_peek(cpu_buffer, ts, lost_events);\n\tif (event) {\n\t\tcpu_buffer->lost_events = 0;\n\t\trb_advance_reader(cpu_buffer);\n\t}\n\n\trb_reader_unlock(cpu_buffer, dolock);\n\tlocal_irq_restore(flags);\n\n out:\n\tpreempt_enable();\n\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\treturn event;\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\nring_buffer_consume(struct ring_buffer *buffer, int cpu, u64 *ts,\n\t\t    unsigned long *lost_events)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event = NULL;\n\tunsigned long flags;\n\tbool dolock;\n\n again:\n\t/* might be called in atomic */\n\tpreempt_disable();\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\tgoto out;\n\n\tcpu_buffer = buffer->buffers[cpu];\n\tlocal_irq_save(flags);\n\tdolock = rb_reader_lock(cpu_buffer);\n\n\tevent = rb_buffer_peek(cpu_buffer, ts, lost_events);\n\tif (event) {\n\t\tcpu_buffer->lost_events = 0;\n\t\trb_advance_reader(cpu_buffer);\n\t}\n\n\trb_reader_unlock(cpu_buffer, dolock);\n\tlocal_irq_restore(flags);\n\n out:\n\tpreempt_enable();\n\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\treturn event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_iter_peek",
          "args": [
            "ring_iter",
            "NULL"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_iter_peek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "4072-4088",
          "snippet": "struct ring_buffer_event *\nring_buffer_iter_peek(struct ring_buffer_iter *iter, u64 *ts)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;\n\tstruct ring_buffer_event *event;\n\tunsigned long flags;\n\n again:\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\tevent = rb_iter_peek(iter, ts);\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\treturn event;\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\nring_buffer_iter_peek(struct ring_buffer_iter *iter, u64 *ts)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;\n\tstruct ring_buffer_event *event;\n\tunsigned long flags;\n\n again:\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\tevent = rb_iter_peek(iter, ts);\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\treturn event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_iter",
          "args": [
            "iter",
            "iter->cpu"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_iter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "583-587",
          "snippet": "static inline struct ring_buffer_iter *\ntrace_buffer_iter(struct trace_iterator *iter, int cpu)\n{\n\treturn iter->buffer_iter ? iter->buffer_iter[cpu] : NULL;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline struct ring_buffer_iter *\ntrace_buffer_iter(struct trace_iterator *iter, int cpu)\n{\n\treturn iter->buffer_iter ? iter->buffer_iter[cpu] : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct ftrace_graph_ret_entry *\nget_return_for_leaf(struct trace_iterator *iter,\n\t\tstruct ftrace_graph_ent_entry *curr)\n{\n\tstruct fgraph_data *data = iter->private;\n\tstruct ring_buffer_iter *ring_iter = NULL;\n\tstruct ring_buffer_event *event;\n\tstruct ftrace_graph_ret_entry *next;\n\n\t/*\n\t * If the previous output failed to write to the seq buffer,\n\t * then we just reuse the data from before.\n\t */\n\tif (data && data->failed) {\n\t\tcurr = &data->ent;\n\t\tnext = &data->ret;\n\t} else {\n\n\t\tring_iter = trace_buffer_iter(iter, iter->cpu);\n\n\t\t/* First peek to compare current entry and the next one */\n\t\tif (ring_iter)\n\t\t\tevent = ring_buffer_iter_peek(ring_iter, NULL);\n\t\telse {\n\t\t\t/*\n\t\t\t * We need to consume the current entry to see\n\t\t\t * the next one.\n\t\t\t */\n\t\t\tring_buffer_consume(iter->trace_buffer->buffer, iter->cpu,\n\t\t\t\t\t    NULL, NULL);\n\t\t\tevent = ring_buffer_peek(iter->trace_buffer->buffer, iter->cpu,\n\t\t\t\t\t\t NULL, NULL);\n\t\t}\n\n\t\tif (!event)\n\t\t\treturn NULL;\n\n\t\tnext = ring_buffer_event_data(event);\n\n\t\tif (data) {\n\t\t\t/*\n\t\t\t * Save current and next entries for later reference\n\t\t\t * if the output fails.\n\t\t\t */\n\t\t\tdata->ent = *curr;\n\t\t\t/*\n\t\t\t * If the next event is not a return type, then\n\t\t\t * we only care about what type it is. Otherwise we can\n\t\t\t * safely copy the entire event.\n\t\t\t */\n\t\t\tif (next->ent.type == TRACE_GRAPH_RET)\n\t\t\t\tdata->ret = *next;\n\t\t\telse\n\t\t\t\tdata->ret.ent.type = next->ent.type;\n\t\t}\n\t}\n\n\tif (next->ent.type != TRACE_GRAPH_RET)\n\t\treturn NULL;\n\n\tif (curr->ent.pid != next->ent.pid ||\n\t\t\tcurr->graph_ent.func != next->ret.func)\n\t\treturn NULL;\n\n\t/* this is a leaf, now advance the iterator */\n\tif (ring_iter)\n\t\tring_buffer_read(ring_iter, NULL);\n\n\treturn next;\n}"
  },
  {
    "function_name": "verif_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "597-630",
    "snippet": "static void\nverif_pid(struct trace_seq *s, pid_t pid, int cpu, struct fgraph_data *data)\n{\n\tpid_t prev_pid;\n\tpid_t *last_pid;\n\n\tif (!data)\n\t\treturn;\n\n\tlast_pid = &(per_cpu_ptr(data->cpu_data, cpu)->last_pid);\n\n\tif (*last_pid == pid)\n\t\treturn;\n\n\tprev_pid = *last_pid;\n\t*last_pid = pid;\n\n\tif (prev_pid == -1)\n\t\treturn;\n/*\n * Context-switch trace line:\n\n ------------------------------------------\n | 1)  migration/0--1  =>  sshd-1755\n ------------------------------------------\n\n */\n\ttrace_seq_puts(s, \" ------------------------------------------\\n\");\n\tprint_graph_cpu(s, cpu);\n\tprint_graph_proc(s, prev_pid);\n\ttrace_seq_puts(s, \" => \");\n\tprint_graph_proc(s, pid);\n\ttrace_seq_puts(s, \"\\n ------------------------------------------\\n\\n\");\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_puts",
          "args": [
            "s",
            "\"\\n ------------------------------------------\\n\\n\""
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_proc",
          "args": [
            "s",
            "pid"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "559-587",
          "snippet": "static void print_graph_proc(struct trace_seq *s, pid_t pid)\n{\n\tchar comm[TASK_COMM_LEN];\n\t/* sign + log10(MAX_INT) + '\\0' */\n\tchar pid_str[11];\n\tint spaces = 0;\n\tint len;\n\tint i;\n\n\ttrace_find_cmdline(pid, comm);\n\tcomm[7] = '\\0';\n\tsprintf(pid_str, \"%d\", pid);\n\n\t/* 1 stands for the \"-\" character */\n\tlen = strlen(comm) + strlen(pid_str) + 1;\n\n\tif (len < TRACE_GRAPH_PROCINFO_LENGTH)\n\t\tspaces = TRACE_GRAPH_PROCINFO_LENGTH - len;\n\n\t/* First spaces to align center */\n\tfor (i = 0; i < spaces / 2; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%s-%s\", comm, pid_str);\n\n\t/* Last spaces to align center */\n\tfor (i = 0; i < spaces - (spaces / 2); i++)\n\t\ttrace_seq_putc(s, ' ');\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define TRACE_GRAPH_PROCINFO_LENGTH\t14"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_PROCINFO_LENGTH\t14\n\nstatic void print_graph_proc(struct trace_seq *s, pid_t pid)\n{\n\tchar comm[TASK_COMM_LEN];\n\t/* sign + log10(MAX_INT) + '\\0' */\n\tchar pid_str[11];\n\tint spaces = 0;\n\tint len;\n\tint i;\n\n\ttrace_find_cmdline(pid, comm);\n\tcomm[7] = '\\0';\n\tsprintf(pid_str, \"%d\", pid);\n\n\t/* 1 stands for the \"-\" character */\n\tlen = strlen(comm) + strlen(pid_str) + 1;\n\n\tif (len < TRACE_GRAPH_PROCINFO_LENGTH)\n\t\tspaces = TRACE_GRAPH_PROCINFO_LENGTH - len;\n\n\t/* First spaces to align center */\n\tfor (i = 0; i < spaces / 2; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%s-%s\", comm, pid_str);\n\n\t/* Last spaces to align center */\n\tfor (i = 0; i < spaces - (spaces / 2); i++)\n\t\ttrace_seq_putc(s, ' ');\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_graph_cpu",
          "args": [
            "s",
            "cpu"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "print_graph_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "547-555",
          "snippet": "static void print_graph_cpu(struct trace_seq *s, int cpu)\n{\n\t/*\n\t * Start with a space character - to make it stand out\n\t * to the right a bit when trace output is pasted into\n\t * email:\n\t */\n\ttrace_seq_printf(s, \" %*d) \", max_bytes_for_cpu, cpu);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int max_bytes_for_cpu;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int max_bytes_for_cpu;\n\nstatic void print_graph_cpu(struct trace_seq *s, int cpu)\n{\n\t/*\n\t * Start with a space character - to make it stand out\n\t * to the right a bit when trace output is pasted into\n\t * email:\n\t */\n\ttrace_seq_printf(s, \" %*d) \", max_bytes_for_cpu, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "data->cpu_data",
            "cpu"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nverif_pid(struct trace_seq *s, pid_t pid, int cpu, struct fgraph_data *data)\n{\n\tpid_t prev_pid;\n\tpid_t *last_pid;\n\n\tif (!data)\n\t\treturn;\n\n\tlast_pid = &(per_cpu_ptr(data->cpu_data, cpu)->last_pid);\n\n\tif (*last_pid == pid)\n\t\treturn;\n\n\tprev_pid = *last_pid;\n\t*last_pid = pid;\n\n\tif (prev_pid == -1)\n\t\treturn;\n/*\n * Context-switch trace line:\n\n ------------------------------------------\n | 1)  migration/0--1  =>  sshd-1755\n ------------------------------------------\n\n */\n\ttrace_seq_puts(s, \" ------------------------------------------\\n\");\n\tprint_graph_cpu(s, cpu);\n\tprint_graph_proc(s, prev_pid);\n\ttrace_seq_puts(s, \" => \");\n\tprint_graph_proc(s, pid);\n\ttrace_seq_puts(s, \"\\n ------------------------------------------\\n\\n\");\n}"
  },
  {
    "function_name": "print_graph_lat_fmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "590-594",
    "snippet": "static void print_graph_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\ttrace_seq_putc(s, ' ');\n\ttrace_print_lat_fmt(s, entry);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_print_lat_fmt",
          "args": [
            "s",
            "entry"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "trace_print_lat_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_output.c",
          "lines": "447-498",
          "snippet": "int trace_print_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\tchar hardsoft_irq;\n\tchar need_resched;\n\tchar irqs_off;\n\tint hardirq;\n\tint softirq;\n\tint nmi;\n\n\tnmi = entry->flags & TRACE_FLAG_NMI;\n\thardirq = entry->flags & TRACE_FLAG_HARDIRQ;\n\tsoftirq = entry->flags & TRACE_FLAG_SOFTIRQ;\n\n\tirqs_off =\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF) ? 'd' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_NOSUPPORT) ? 'X' :\n\t\t'.';\n\n\tswitch (entry->flags & (TRACE_FLAG_NEED_RESCHED |\n\t\t\t\tTRACE_FLAG_PREEMPT_RESCHED)) {\n\tcase TRACE_FLAG_NEED_RESCHED | TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'N';\n\t\tbreak;\n\tcase TRACE_FLAG_NEED_RESCHED:\n\t\tneed_resched = 'n';\n\t\tbreak;\n\tcase TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'p';\n\t\tbreak;\n\tdefault:\n\t\tneed_resched = '.';\n\t\tbreak;\n\t}\n\n\thardsoft_irq =\n\t\t(nmi && hardirq)     ? 'Z' :\n\t\tnmi                  ? 'z' :\n\t\t(hardirq && softirq) ? 'H' :\n\t\thardirq              ? 'h' :\n\t\tsoftirq              ? 's' :\n\t\t                       '.' ;\n\n\ttrace_seq_printf(s, \"%c%c%c\",\n\t\t\t irqs_off, need_resched, hardsoft_irq);\n\n\tif (entry->preempt_count)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\treturn !trace_seq_has_overflowed(s);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint trace_print_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\tchar hardsoft_irq;\n\tchar need_resched;\n\tchar irqs_off;\n\tint hardirq;\n\tint softirq;\n\tint nmi;\n\n\tnmi = entry->flags & TRACE_FLAG_NMI;\n\thardirq = entry->flags & TRACE_FLAG_HARDIRQ;\n\tsoftirq = entry->flags & TRACE_FLAG_SOFTIRQ;\n\n\tirqs_off =\n\t\t(entry->flags & TRACE_FLAG_IRQS_OFF) ? 'd' :\n\t\t(entry->flags & TRACE_FLAG_IRQS_NOSUPPORT) ? 'X' :\n\t\t'.';\n\n\tswitch (entry->flags & (TRACE_FLAG_NEED_RESCHED |\n\t\t\t\tTRACE_FLAG_PREEMPT_RESCHED)) {\n\tcase TRACE_FLAG_NEED_RESCHED | TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'N';\n\t\tbreak;\n\tcase TRACE_FLAG_NEED_RESCHED:\n\t\tneed_resched = 'n';\n\t\tbreak;\n\tcase TRACE_FLAG_PREEMPT_RESCHED:\n\t\tneed_resched = 'p';\n\t\tbreak;\n\tdefault:\n\t\tneed_resched = '.';\n\t\tbreak;\n\t}\n\n\thardsoft_irq =\n\t\t(nmi && hardirq)     ? 'Z' :\n\t\tnmi                  ? 'z' :\n\t\t(hardirq && softirq) ? 'H' :\n\t\thardirq              ? 'h' :\n\t\tsoftirq              ? 's' :\n\t\t                       '.' ;\n\n\ttrace_seq_printf(s, \"%c%c%c\",\n\t\t\t irqs_off, need_resched, hardsoft_irq);\n\n\tif (entry->preempt_count)\n\t\ttrace_seq_printf(s, \"%x\", entry->preempt_count);\n\telse\n\t\ttrace_seq_putc(s, '.');\n\n\treturn !trace_seq_has_overflowed(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "' '"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void print_graph_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\ttrace_seq_putc(s, ' ');\n\ttrace_print_lat_fmt(s, entry);\n}"
  },
  {
    "function_name": "print_graph_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "559-587",
    "snippet": "static void print_graph_proc(struct trace_seq *s, pid_t pid)\n{\n\tchar comm[TASK_COMM_LEN];\n\t/* sign + log10(MAX_INT) + '\\0' */\n\tchar pid_str[11];\n\tint spaces = 0;\n\tint len;\n\tint i;\n\n\ttrace_find_cmdline(pid, comm);\n\tcomm[7] = '\\0';\n\tsprintf(pid_str, \"%d\", pid);\n\n\t/* 1 stands for the \"-\" character */\n\tlen = strlen(comm) + strlen(pid_str) + 1;\n\n\tif (len < TRACE_GRAPH_PROCINFO_LENGTH)\n\t\tspaces = TRACE_GRAPH_PROCINFO_LENGTH - len;\n\n\t/* First spaces to align center */\n\tfor (i = 0; i < spaces / 2; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%s-%s\", comm, pid_str);\n\n\t/* Last spaces to align center */\n\tfor (i = 0; i < spaces - (spaces / 2); i++)\n\t\ttrace_seq_putc(s, ' ');\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define TRACE_GRAPH_PROCINFO_LENGTH\t14"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "' '"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\"%s-%s\"",
            "comm",
            "pid_str"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pid_str"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "pid_str",
            "\"%d\"",
            "pid"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_find_cmdline",
          "args": [
            "pid",
            "comm"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_cmdline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2004-2013",
          "snippet": "void trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic arch_spinlock_t trace_cmdline_lock = __ARCH_SPIN_LOCK_UNLOCKED;\n\nvoid trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\n#define TRACE_GRAPH_PROCINFO_LENGTH\t14\n\nstatic void print_graph_proc(struct trace_seq *s, pid_t pid)\n{\n\tchar comm[TASK_COMM_LEN];\n\t/* sign + log10(MAX_INT) + '\\0' */\n\tchar pid_str[11];\n\tint spaces = 0;\n\tint len;\n\tint i;\n\n\ttrace_find_cmdline(pid, comm);\n\tcomm[7] = '\\0';\n\tsprintf(pid_str, \"%d\", pid);\n\n\t/* 1 stands for the \"-\" character */\n\tlen = strlen(comm) + strlen(pid_str) + 1;\n\n\tif (len < TRACE_GRAPH_PROCINFO_LENGTH)\n\t\tspaces = TRACE_GRAPH_PROCINFO_LENGTH - len;\n\n\t/* First spaces to align center */\n\tfor (i = 0; i < spaces / 2; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%s-%s\", comm, pid_str);\n\n\t/* Last spaces to align center */\n\tfor (i = 0; i < spaces - (spaces / 2); i++)\n\t\ttrace_seq_putc(s, ' ');\n}"
  },
  {
    "function_name": "print_graph_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "547-555",
    "snippet": "static void print_graph_cpu(struct trace_seq *s, int cpu)\n{\n\t/*\n\t * Start with a space character - to make it stand out\n\t * to the right a bit when trace output is pasted into\n\t * email:\n\t */\n\ttrace_seq_printf(s, \" %*d) \", max_bytes_for_cpu, cpu);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int max_bytes_for_cpu;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "\" %*d) \"",
            "max_bytes_for_cpu",
            "cpu"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int max_bytes_for_cpu;\n\nstatic void print_graph_cpu(struct trace_seq *s, int cpu)\n{\n\t/*\n\t * Start with a space character - to make it stand out\n\t * to the right a bit when trace output is pasted into\n\t * email:\n\t */\n\ttrace_seq_printf(s, \" %*d) \", max_bytes_for_cpu, cpu);\n}"
  },
  {
    "function_name": "graph_trace_update_thresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "539-543",
    "snippet": "static int graph_trace_update_thresh(struct trace_array *tr)\n{\n\tgraph_trace_reset(tr);\n\treturn graph_trace_init(tr);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "graph_trace_init",
          "args": [
            "tr"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "graph_trace_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "515-531",
          "snippet": "static int graph_trace_init(struct trace_array *tr)\n{\n\tint ret;\n\n\tset_graph_array(tr);\n\tif (tracing_thresh)\n\t\tret = register_ftrace_graph(&trace_graph_thresh_return,\n\t\t\t\t\t    &trace_graph_entry);\n\telse\n\t\tret = register_ftrace_graph(&trace_graph_return,\n\t\t\t\t\t    &trace_graph_entry);\n\tif (ret)\n\t\treturn ret;\n\ttracing_start_cmdline_record();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int graph_trace_init(struct trace_array *tr)\n{\n\tint ret;\n\n\tset_graph_array(tr);\n\tif (tracing_thresh)\n\t\tret = register_ftrace_graph(&trace_graph_thresh_return,\n\t\t\t\t\t    &trace_graph_entry);\n\telse\n\t\tret = register_ftrace_graph(&trace_graph_return,\n\t\t\t\t\t    &trace_graph_entry);\n\tif (ret)\n\t\treturn ret;\n\ttracing_start_cmdline_record();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "graph_trace_reset",
          "args": [
            "tr"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "graph_trace_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "533-537",
          "snippet": "static void graph_trace_reset(struct trace_array *tr)\n{\n\ttracing_stop_cmdline_record();\n\tunregister_ftrace_graph();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void graph_trace_reset(struct trace_array *tr)\n{\n\ttracing_stop_cmdline_record();\n\tunregister_ftrace_graph();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int graph_trace_update_thresh(struct trace_array *tr)\n{\n\tgraph_trace_reset(tr);\n\treturn graph_trace_init(tr);\n}"
  },
  {
    "function_name": "graph_trace_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "533-537",
    "snippet": "static void graph_trace_reset(struct trace_array *tr)\n{\n\ttracing_stop_cmdline_record();\n\tunregister_ftrace_graph();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_ftrace_graph",
          "args": [],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_graph",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "7002-7019",
          "snippet": "void unregister_ftrace_graph(void)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = (trace_func_graph_ret_t)ftrace_stub;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nvoid unregister_ftrace_graph(void)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = (trace_func_graph_ret_t)ftrace_stub;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop_cmdline_record",
          "args": [],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop_cmdline_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_switch.c",
          "lines": "134-137",
          "snippet": "void tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void graph_trace_reset(struct trace_array *tr)\n{\n\ttracing_stop_cmdline_record();\n\tunregister_ftrace_graph();\n}"
  },
  {
    "function_name": "graph_trace_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "515-531",
    "snippet": "static int graph_trace_init(struct trace_array *tr)\n{\n\tint ret;\n\n\tset_graph_array(tr);\n\tif (tracing_thresh)\n\t\tret = register_ftrace_graph(&trace_graph_thresh_return,\n\t\t\t\t\t    &trace_graph_entry);\n\telse\n\t\tret = register_ftrace_graph(&trace_graph_return,\n\t\t\t\t\t    &trace_graph_entry);\n\tif (ret)\n\t\treturn ret;\n\ttracing_start_cmdline_record();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_start_cmdline_record",
          "args": [],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start_cmdline_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_sched_switch.c",
          "lines": "129-132",
          "snippet": "void tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_ftrace_graph",
          "args": [
            "&trace_graph_return",
            "&trace_graph_entry"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "register_ftrace_graph",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6962-7000",
          "snippet": "int register_ftrace_graph(trace_func_graph_ret_t retfunc,\n\t\t\ttrace_func_graph_ent_t entryfunc)\n{\n\tint ret = 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/* we currently allow only one tracer registered at a time */\n\tif (ftrace_graph_active) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tregister_pm_notifier(&ftrace_suspend_notifier);\n\n\tftrace_graph_active++;\n\tret = start_graph_tracing();\n\tif (ret) {\n\t\tftrace_graph_active--;\n\t\tgoto out;\n\t}\n\n\tftrace_graph_return = retfunc;\n\n\t/*\n\t * Update the indirect function to the entryfunc, and the\n\t * function that gets called to the entry_test first. Then\n\t * call the update fgraph entry function to determine if\n\t * the entryfunc should be called directly or not.\n\t */\n\t__ftrace_graph_entry = entryfunc;\n\tftrace_graph_entry = ftrace_graph_entry_test;\n\tupdate_function_graph_func();\n\n\tret = ftrace_startup(&graph_ops, FTRACE_START_FUNC_RET);\nout:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nint register_ftrace_graph(trace_func_graph_ret_t retfunc,\n\t\t\ttrace_func_graph_ent_t entryfunc)\n{\n\tint ret = 0;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/* we currently allow only one tracer registered at a time */\n\tif (ftrace_graph_active) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tregister_pm_notifier(&ftrace_suspend_notifier);\n\n\tftrace_graph_active++;\n\tret = start_graph_tracing();\n\tif (ret) {\n\t\tftrace_graph_active--;\n\t\tgoto out;\n\t}\n\n\tftrace_graph_return = retfunc;\n\n\t/*\n\t * Update the indirect function to the entryfunc, and the\n\t * function that gets called to the entry_test first. Then\n\t * call the update fgraph entry function to determine if\n\t * the entryfunc should be called directly or not.\n\t */\n\t__ftrace_graph_entry = entryfunc;\n\tftrace_graph_entry = ftrace_graph_entry_test;\n\tupdate_function_graph_func();\n\n\tret = ftrace_startup(&graph_ops, FTRACE_START_FUNC_RET);\nout:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_graph_array",
          "args": [
            "tr"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "set_graph_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "497-504",
          "snippet": "void set_graph_array(struct trace_array *tr)\n{\n\tgraph_array = tr;\n\n\t/* Make graph_array visible before we start tracing */\n\n\tsmp_mb();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array *graph_array;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct trace_array *graph_array;\n\nvoid set_graph_array(struct trace_array *tr)\n{\n\tgraph_array = tr;\n\n\t/* Make graph_array visible before we start tracing */\n\n\tsmp_mb();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int graph_trace_init(struct trace_array *tr)\n{\n\tint ret;\n\n\tset_graph_array(tr);\n\tif (tracing_thresh)\n\t\tret = register_ftrace_graph(&trace_graph_thresh_return,\n\t\t\t\t\t    &trace_graph_entry);\n\telse\n\t\tret = register_ftrace_graph(&trace_graph_return,\n\t\t\t\t\t    &trace_graph_entry);\n\tif (ret)\n\t\treturn ret;\n\ttracing_start_cmdline_record();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_graph_thresh_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "506-513",
    "snippet": "static void trace_graph_thresh_return(struct ftrace_graph_ret *trace)\n{\n\tif (tracing_thresh &&\n\t    (trace->rettime - trace->calltime < tracing_thresh))\n\t\treturn;\n\telse\n\t\ttrace_graph_return(trace);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_graph_return",
          "args": [
            "trace"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "trace_graph_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "476-495",
          "snippet": "void trace_graph_return(struct ftrace_graph_ret *trace)\n{\n\tstruct trace_array *tr = graph_array;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tlong disabled;\n\tint cpu;\n\tint pc;\n\n\tlocal_irq_save(flags);\n\tcpu = raw_smp_processor_id();\n\tdata = per_cpu_ptr(tr->trace_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&data->disabled);\n\tif (likely(disabled == 1)) {\n\t\tpc = preempt_count();\n\t\t__trace_graph_return(tr, trace, flags, pc);\n\t}\n\tatomic_dec(&data->disabled);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array *graph_array;",
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct trace_array *graph_array;\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nvoid trace_graph_return(struct ftrace_graph_ret *trace)\n{\n\tstruct trace_array *tr = graph_array;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tlong disabled;\n\tint cpu;\n\tint pc;\n\n\tlocal_irq_save(flags);\n\tcpu = raw_smp_processor_id();\n\tdata = per_cpu_ptr(tr->trace_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&data->disabled);\n\tif (likely(disabled == 1)) {\n\t\tpc = preempt_count();\n\t\t__trace_graph_return(tr, trace, flags, pc);\n\t}\n\tatomic_dec(&data->disabled);\n\tlocal_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void trace_graph_thresh_return(struct ftrace_graph_ret *trace)\n{\n\tif (tracing_thresh &&\n\t    (trace->rettime - trace->calltime < tracing_thresh))\n\t\treturn;\n\telse\n\t\ttrace_graph_return(trace);\n}"
  },
  {
    "function_name": "set_graph_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "497-504",
    "snippet": "void set_graph_array(struct trace_array *tr)\n{\n\tgraph_array = tr;\n\n\t/* Make graph_array visible before we start tracing */\n\n\tsmp_mb();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array *graph_array;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct trace_array *graph_array;\n\nvoid set_graph_array(struct trace_array *tr)\n{\n\tgraph_array = tr;\n\n\t/* Make graph_array visible before we start tracing */\n\n\tsmp_mb();\n}"
  },
  {
    "function_name": "trace_graph_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "476-495",
    "snippet": "void trace_graph_return(struct ftrace_graph_ret *trace)\n{\n\tstruct trace_array *tr = graph_array;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tlong disabled;\n\tint cpu;\n\tint pc;\n\n\tlocal_irq_save(flags);\n\tcpu = raw_smp_processor_id();\n\tdata = per_cpu_ptr(tr->trace_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&data->disabled);\n\tif (likely(disabled == 1)) {\n\t\tpc = preempt_count();\n\t\t__trace_graph_return(tr, trace, flags, pc);\n\t}\n\tatomic_dec(&data->disabled);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array *graph_array;",
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&data->disabled"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_graph_return",
          "args": [
            "tr",
            "trace",
            "flags",
            "pc"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_graph_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "456-474",
          "snippet": "void __trace_graph_return(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ret *trace,\n\t\t\t\tunsigned long flags,\n\t\t\t\tint pc)\n{\n\tstruct trace_event_call *call = &event_funcgraph_exit;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ftrace_graph_ret_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ret\t\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nvoid __trace_graph_return(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ret *trace,\n\t\t\t\tunsigned long flags,\n\t\t\t\tint pc)\n{\n\tstruct trace_event_call *call = &event_funcgraph_exit;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ftrace_graph_ret_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ret\t\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "disabled == 1"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&data->disabled"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->trace_buffer.data",
            "cpu"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct trace_array *graph_array;\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nvoid trace_graph_return(struct ftrace_graph_ret *trace)\n{\n\tstruct trace_array *tr = graph_array;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tlong disabled;\n\tint cpu;\n\tint pc;\n\n\tlocal_irq_save(flags);\n\tcpu = raw_smp_processor_id();\n\tdata = per_cpu_ptr(tr->trace_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&data->disabled);\n\tif (likely(disabled == 1)) {\n\t\tpc = preempt_count();\n\t\t__trace_graph_return(tr, trace, flags, pc);\n\t}\n\tatomic_dec(&data->disabled);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "__trace_graph_return",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "456-474",
    "snippet": "void __trace_graph_return(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ret *trace,\n\t\t\t\tunsigned long flags,\n\t\t\t\tint pc)\n{\n\tstruct trace_event_call *call = &event_funcgraph_exit;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ftrace_graph_ret_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ret\t\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit_nostack",
          "args": [
            "buffer",
            "event"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit_nostack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2420-2425",
          "snippet": "void\ntrace_buffer_unlock_commit_nostack(struct ring_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *event)\n{\n\t__buffer_unlock_commit(buffer, event);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid\ntrace_buffer_unlock_commit_nostack(struct ring_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *event)\n{\n\t__buffer_unlock_commit(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_filter_check_discard",
          "args": [
            "call",
            "entry",
            "buffer",
            "event"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "call_filter_check_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "305-316",
          "snippet": "int call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct ring_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct ring_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "272-275",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_GRAPH_RET",
            "sizeof(*entry)",
            "flags",
            "pc"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2152-2159",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nvoid __trace_graph_return(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ret *trace,\n\t\t\t\tunsigned long flags,\n\t\t\t\tint pc)\n{\n\tstruct trace_event_call *call = &event_funcgraph_exit;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ftrace_graph_ret_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ret\t\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}"
  },
  {
    "function_name": "trace_graph_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "448-454",
    "snippet": "void\ntrace_graph_function(struct trace_array *tr,\n\t\tunsigned long ip, unsigned long parent_ip,\n\t\tunsigned long flags, int pc)\n{\n\t__trace_graph_function(tr, ip, flags, pc);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__trace_graph_function",
          "args": [
            "tr",
            "ip",
            "flags",
            "pc"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_graph_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "428-446",
          "snippet": "static void\n__trace_graph_function(struct trace_array *tr,\n\t\tunsigned long ip, unsigned long flags, int pc)\n{\n\tu64 time = trace_clock_local();\n\tstruct ftrace_graph_ent ent = {\n\t\t.func  = ip,\n\t\t.depth = 0,\n\t};\n\tstruct ftrace_graph_ret ret = {\n\t\t.func     = ip,\n\t\t.depth    = 0,\n\t\t.calltime = time,\n\t\t.rettime  = time,\n\t};\n\n\t__trace_graph_entry(tr, &ent, flags, pc);\n\t__trace_graph_return(tr, &ret, flags, pc);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\n__trace_graph_function(struct trace_array *tr,\n\t\tunsigned long ip, unsigned long flags, int pc)\n{\n\tu64 time = trace_clock_local();\n\tstruct ftrace_graph_ent ent = {\n\t\t.func  = ip,\n\t\t.depth = 0,\n\t};\n\tstruct ftrace_graph_ret ret = {\n\t\t.func     = ip,\n\t\t.depth    = 0,\n\t\t.calltime = time,\n\t\t.rettime  = time,\n\t};\n\n\t__trace_graph_entry(tr, &ent, flags, pc);\n\t__trace_graph_return(tr, &ret, flags, pc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nvoid\ntrace_graph_function(struct trace_array *tr,\n\t\tunsigned long ip, unsigned long parent_ip,\n\t\tunsigned long flags, int pc)\n{\n\t__trace_graph_function(tr, ip, flags, pc);\n}"
  },
  {
    "function_name": "__trace_graph_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "428-446",
    "snippet": "static void\n__trace_graph_function(struct trace_array *tr,\n\t\tunsigned long ip, unsigned long flags, int pc)\n{\n\tu64 time = trace_clock_local();\n\tstruct ftrace_graph_ent ent = {\n\t\t.func  = ip,\n\t\t.depth = 0,\n\t};\n\tstruct ftrace_graph_ret ret = {\n\t\t.func     = ip,\n\t\t.depth    = 0,\n\t\t.calltime = time,\n\t\t.rettime  = time,\n\t};\n\n\t__trace_graph_entry(tr, &ent, flags, pc);\n\t__trace_graph_return(tr, &ret, flags, pc);\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__trace_graph_return",
          "args": [
            "tr",
            "&ret",
            "flags",
            "pc"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_graph_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "456-474",
          "snippet": "void __trace_graph_return(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ret *trace,\n\t\t\t\tunsigned long flags,\n\t\t\t\tint pc)\n{\n\tstruct trace_event_call *call = &event_funcgraph_exit;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ftrace_graph_ret_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ret\t\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nvoid __trace_graph_return(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ret *trace,\n\t\t\t\tunsigned long flags,\n\t\t\t\tint pc)\n{\n\tstruct trace_event_call *call = &event_funcgraph_exit;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ftrace_graph_ret_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_RET,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ret\t\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__trace_graph_entry",
          "args": [
            "tr",
            "&ent",
            "flags",
            "pc"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_graph_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "345-365",
          "snippet": "int __trace_graph_entry(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ent *trace,\n\t\t\t\tunsigned long flags,\n\t\t\t\tint pc)\n{\n\tstruct trace_event_call *call = &event_funcgraph_entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ftrace_graph_ent_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn 0;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->graph_ent\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nint __trace_graph_entry(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ent *trace,\n\t\t\t\tunsigned long flags,\n\t\t\t\tint pc)\n{\n\tstruct trace_event_call *call = &event_funcgraph_entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ftrace_graph_ent_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn 0;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->graph_ent\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_clock_local",
          "args": [],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "trace_clock_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_clock.c",
          "lines": "32-46",
          "snippet": "u64 notrace trace_clock_local(void)\n{\n\tu64 clock;\n\n\t/*\n\t * sched_clock() is an architecture implemented, fast, scalable,\n\t * lockless clock. It is not guaranteed to be coherent across\n\t * CPUs, nor across CPU idle events.\n\t */\n\tpreempt_disable_notrace();\n\tclock = sched_clock();\n\tpreempt_enable_notrace();\n\n\treturn clock;\n}",
          "includes": [
            "#include <linux/trace_clock.h>",
            "#include <linux/ktime.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_clock.h>\n#include <linux/ktime.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/hardirq.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n\nu64 notrace trace_clock_local(void)\n{\n\tu64 clock;\n\n\t/*\n\t * sched_clock() is an architecture implemented, fast, scalable,\n\t * lockless clock. It is not guaranteed to be coherent across\n\t * CPUs, nor across CPU idle events.\n\t */\n\tpreempt_disable_notrace();\n\tclock = sched_clock();\n\tpreempt_enable_notrace();\n\n\treturn clock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nstatic void\n__trace_graph_function(struct trace_array *tr,\n\t\tunsigned long ip, unsigned long flags, int pc)\n{\n\tu64 time = trace_clock_local();\n\tstruct ftrace_graph_ent ent = {\n\t\t.func  = ip,\n\t\t.depth = 0,\n\t};\n\tstruct ftrace_graph_ret ret = {\n\t\t.func     = ip,\n\t\t.depth    = 0,\n\t\t.calltime = time,\n\t\t.rettime  = time,\n\t};\n\n\t__trace_graph_entry(tr, &ent, flags, pc);\n\t__trace_graph_return(tr, &ret, flags, pc);\n}"
  },
  {
    "function_name": "trace_graph_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "375-426",
    "snippet": "int trace_graph_entry(struct ftrace_graph_ent *trace)\n{\n\tstruct trace_array *tr = graph_array;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tlong disabled;\n\tint ret;\n\tint cpu;\n\tint pc;\n\n\tif (!ftrace_trace_task(tr))\n\t\treturn 0;\n\n\tif (ftrace_graph_ignore_func(trace))\n\t\treturn 0;\n\n\tif (ftrace_graph_ignore_irqs())\n\t\treturn 0;\n\n\t/*\n\t * Do not trace a function if it's filtered by set_graph_notrace.\n\t * Make the index of ret stack negative to indicate that it should\n\t * ignore further functions.  But it needs its own ret stack entry\n\t * to recover the original index in order to continue tracing after\n\t * returning from the function.\n\t */\n\tif (ftrace_graph_notrace_addr(trace->func))\n\t\treturn 1;\n\n\t/*\n\t * Stop here if tracing_threshold is set. We only write function return\n\t * events to the ring buffer.\n\t */\n\tif (tracing_thresh)\n\t\treturn 1;\n\n\tlocal_irq_save(flags);\n\tcpu = raw_smp_processor_id();\n\tdata = per_cpu_ptr(tr->trace_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&data->disabled);\n\tif (likely(disabled == 1)) {\n\t\tpc = preempt_count();\n\t\tret = __trace_graph_entry(tr, trace, flags, pc);\n\t} else {\n\t\tret = 0;\n\t}\n\n\tatomic_dec(&data->disabled);\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct trace_array *graph_array;",
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&data->disabled"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__trace_graph_entry",
          "args": [
            "tr",
            "trace",
            "flags",
            "pc"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_graph_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "345-365",
          "snippet": "int __trace_graph_entry(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ent *trace,\n\t\t\t\tunsigned long flags,\n\t\t\t\tint pc)\n{\n\tstruct trace_event_call *call = &event_funcgraph_entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ftrace_graph_ent_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn 0;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->graph_ent\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nint __trace_graph_entry(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ent *trace,\n\t\t\t\tunsigned long flags,\n\t\t\t\tint pc)\n{\n\tstruct trace_event_call *call = &event_funcgraph_entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ftrace_graph_ent_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn 0;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->graph_ent\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "disabled == 1"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&data->disabled"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "tr->trace_buffer.data",
            "cpu"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_graph_notrace_addr",
          "args": [
            "trace->func"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_notrace_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "893-896",
          "snippet": "static inline int ftrace_graph_notrace_addr(unsigned long addr)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline int ftrace_graph_notrace_addr(unsigned long addr)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_ignore_irqs",
          "args": [],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_ignore_irqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "367-373",
          "snippet": "static inline int ftrace_graph_ignore_irqs(void)\n{\n\tif (!ftrace_graph_skip_irqs || trace_recursion_test(TRACE_IRQ_BIT))\n\t\treturn 0;\n\n\treturn in_irq();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_graph_skip_irqs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int ftrace_graph_skip_irqs;\n\nstatic inline int ftrace_graph_ignore_irqs(void)\n{\n\tif (!ftrace_graph_skip_irqs || trace_recursion_test(TRACE_IRQ_BIT))\n\t\treturn 0;\n\n\treturn in_irq();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_ignore_func",
          "args": [
            "trace"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_ignore_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "901-907",
          "snippet": "static inline bool ftrace_graph_ignore_func(struct ftrace_graph_ent *trace)\n{\n\t/* trace it when it is-nested-in or is a function enabled. */\n\treturn !(trace->depth || ftrace_graph_addr(trace->func)) ||\n\t\t(trace->depth < 0) ||\n\t\t(fgraph_max_depth && trace->depth >= fgraph_max_depth);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool ftrace_graph_ignore_func(struct ftrace_graph_ent *trace)\n{\n\t/* trace it when it is-nested-in or is a function enabled. */\n\treturn !(trace->depth || ftrace_graph_addr(trace->func)) ||\n\t\t(trace->depth < 0) ||\n\t\t(fgraph_max_depth && trace->depth >= fgraph_max_depth);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_trace_task",
          "args": [
            "tr"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_trace_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "947-950",
          "snippet": "static inline int ftrace_trace_task(struct trace_array *tr)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline int ftrace_trace_task(struct trace_array *tr)\n{\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct trace_array *graph_array;\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nint trace_graph_entry(struct ftrace_graph_ent *trace)\n{\n\tstruct trace_array *tr = graph_array;\n\tstruct trace_array_cpu *data;\n\tunsigned long flags;\n\tlong disabled;\n\tint ret;\n\tint cpu;\n\tint pc;\n\n\tif (!ftrace_trace_task(tr))\n\t\treturn 0;\n\n\tif (ftrace_graph_ignore_func(trace))\n\t\treturn 0;\n\n\tif (ftrace_graph_ignore_irqs())\n\t\treturn 0;\n\n\t/*\n\t * Do not trace a function if it's filtered by set_graph_notrace.\n\t * Make the index of ret stack negative to indicate that it should\n\t * ignore further functions.  But it needs its own ret stack entry\n\t * to recover the original index in order to continue tracing after\n\t * returning from the function.\n\t */\n\tif (ftrace_graph_notrace_addr(trace->func))\n\t\treturn 1;\n\n\t/*\n\t * Stop here if tracing_threshold is set. We only write function return\n\t * events to the ring buffer.\n\t */\n\tif (tracing_thresh)\n\t\treturn 1;\n\n\tlocal_irq_save(flags);\n\tcpu = raw_smp_processor_id();\n\tdata = per_cpu_ptr(tr->trace_buffer.data, cpu);\n\tdisabled = atomic_inc_return(&data->disabled);\n\tif (likely(disabled == 1)) {\n\t\tpc = preempt_count();\n\t\tret = __trace_graph_entry(tr, trace, flags, pc);\n\t} else {\n\t\tret = 0;\n\t}\n\n\tatomic_dec(&data->disabled);\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_graph_ignore_irqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "367-373",
    "snippet": "static inline int ftrace_graph_ignore_irqs(void)\n{\n\tif (!ftrace_graph_skip_irqs || trace_recursion_test(TRACE_IRQ_BIT))\n\t\treturn 0;\n\n\treturn in_irq();\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ftrace_graph_skip_irqs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_irq",
          "args": [],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_recursion_test",
          "args": [
            "TRACE_IRQ_BIT"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic int ftrace_graph_skip_irqs;\n\nstatic inline int ftrace_graph_ignore_irqs(void)\n{\n\tif (!ftrace_graph_skip_irqs || trace_recursion_test(TRACE_IRQ_BIT))\n\t\treturn 0;\n\n\treturn in_irq();\n}"
  },
  {
    "function_name": "__trace_graph_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "345-365",
    "snippet": "int __trace_graph_entry(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ent *trace,\n\t\t\t\tunsigned long flags,\n\t\t\t\tint pc)\n{\n\tstruct trace_event_call *call = &event_funcgraph_entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ftrace_graph_ent_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn 0;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->graph_ent\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_buffer_unlock_commit_nostack",
          "args": [
            "buffer",
            "event"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_unlock_commit_nostack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2420-2425",
          "snippet": "void\ntrace_buffer_unlock_commit_nostack(struct ring_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *event)\n{\n\t__buffer_unlock_commit(buffer, event);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid\ntrace_buffer_unlock_commit_nostack(struct ring_buffer *buffer,\n\t\t\t\t   struct ring_buffer_event *event)\n{\n\t__buffer_unlock_commit(buffer, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_filter_check_discard",
          "args": [
            "call",
            "entry",
            "buffer",
            "event"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "call_filter_check_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "305-316",
          "snippet": "int call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct ring_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint call_filter_check_discard(struct trace_event_call *call, void *rec,\n\t\t\t      struct ring_buffer *buffer,\n\t\t\t      struct ring_buffer_event *event)\n{\n\tif (unlikely(call->flags & TRACE_EVENT_FL_FILTERED) &&\n\t    !filter_match_preds(call->filter, rec)) {\n\t\t__trace_event_discard_commit(buffer, event);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "272-275",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_buffer_lock_reserve",
          "args": [
            "buffer",
            "TRACE_GRAPH_ENT",
            "sizeof(*entry)",
            "flags",
            "pc"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "trace_buffer_lock_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2152-2159",
          "snippet": "struct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\treturn __trace_buffer_lock_reserve(buffer, type, len, flags, pc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nprint_graph_duration(struct trace_array *tr, unsigned long long duration,\n\t\t     struct trace_seq *s, u32 flags);\n\nint __trace_graph_entry(struct trace_array *tr,\n\t\t\t\tstruct ftrace_graph_ent *trace,\n\t\t\t\tunsigned long flags,\n\t\t\t\tint pc)\n{\n\tstruct trace_event_call *call = &event_funcgraph_entry;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ftrace_graph_ent_entry *entry;\n\n\tevent = trace_buffer_lock_reserve(buffer, TRACE_GRAPH_ENT,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\treturn 0;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->graph_ent\t\t\t= *trace;\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\ttrace_buffer_unlock_commit_nostack(buffer, event);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "ftrace_graph_ret_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "325-342",
    "snippet": "unsigned long ftrace_graph_ret_addr(struct task_struct *task, int *idx,\n\t\t\t\t    unsigned long ret, unsigned long *retp)\n{\n\tint task_idx;\n\n\tif (ret != (unsigned long)return_to_handler)\n\t\treturn ret;\n\n\ttask_idx = task->curr_ret_stack;\n\n\tif (!task->ret_stack || task_idx < *idx)\n\t\treturn ret;\n\n\ttask_idx -= *idx;\n\t(*idx)++;\n\n\treturn task->ret_stack[task_idx].ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nunsigned long ftrace_graph_ret_addr(struct task_struct *task, int *idx,\n\t\t\t\t    unsigned long ret, unsigned long *retp)\n{\n\tint task_idx;\n\n\tif (ret != (unsigned long)return_to_handler)\n\t\treturn ret;\n\n\ttask_idx = task->curr_ret_stack;\n\n\tif (!task->ret_stack || task_idx < *idx)\n\t\treturn ret;\n\n\ttask_idx -= *idx;\n\t(*idx)++;\n\n\treturn task->ret_stack[task_idx].ret;\n}"
  },
  {
    "function_name": "ftrace_graph_ret_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "303-323",
    "snippet": "unsigned long ftrace_graph_ret_addr(struct task_struct *task, int *idx,\n\t\t\t\t    unsigned long ret, unsigned long *retp)\n{\n\tint index = task->curr_ret_stack;\n\tint i;\n\n\tif (ret != (unsigned long)return_to_handler)\n\t\treturn ret;\n\n\tif (index < -1)\n\t\tindex += FTRACE_NOTRACE_DEPTH;\n\n\tif (index < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i <= index; i++)\n\t\tif (task->ret_stack[i].retp == retp)\n\t\t\treturn task->ret_stack[i].ret;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nunsigned long ftrace_graph_ret_addr(struct task_struct *task, int *idx,\n\t\t\t\t    unsigned long ret, unsigned long *retp)\n{\n\tint index = task->curr_ret_stack;\n\tint i;\n\n\tif (ret != (unsigned long)return_to_handler)\n\t\treturn ret;\n\n\tif (index < -1)\n\t\tindex += FTRACE_NOTRACE_DEPTH;\n\n\tif (index < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i <= index; i++)\n\t\tif (task->ret_stack[i].retp == retp)\n\t\t\treturn task->ret_stack[i].ret;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_return_to_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "251-285",
    "snippet": "unsigned long ftrace_return_to_handler(unsigned long frame_pointer)\n{\n\tstruct ftrace_graph_ret trace;\n\tunsigned long ret;\n\n\tftrace_pop_return_trace(&trace, &ret, frame_pointer);\n\ttrace.rettime = trace_clock_local();\n\tbarrier();\n\tcurrent->curr_ret_stack--;\n\t/*\n\t * The curr_ret_stack can be less than -1 only if it was\n\t * filtered out and it's about to return from the function.\n\t * Recover the index and continue to trace normal functions.\n\t */\n\tif (current->curr_ret_stack < -1) {\n\t\tcurrent->curr_ret_stack += FTRACE_NOTRACE_DEPTH;\n\t\treturn ret;\n\t}\n\n\t/*\n\t * The trace should run after decrementing the ret counter\n\t * in case an interrupt were to come in. We don't want to\n\t * lose the interrupt if max_depth is set.\n\t */\n\tftrace_graph_return(&trace);\n\n\tif (unlikely(!ret)) {\n\t\tftrace_graph_stop();\n\t\tWARN_ON(1);\n\t\t/* Might as well panic. What else to do? */\n\t\tret = (unsigned long)panic;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_graph_stop",
          "args": [],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "41-44",
          "snippet": "void ftrace_graph_stop(void)\n{\n\tkill_ftrace_graph = true;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kill_ftrace_graph;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic bool kill_ftrace_graph;\n\nvoid ftrace_graph_stop(void)\n{\n\tkill_ftrace_graph = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ret"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_graph_return",
          "args": [
            "&trace"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/membarrier.c",
          "lines": "189-219",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_clock_local",
          "args": [],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "trace_clock_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_clock.c",
          "lines": "32-46",
          "snippet": "u64 notrace trace_clock_local(void)\n{\n\tu64 clock;\n\n\t/*\n\t * sched_clock() is an architecture implemented, fast, scalable,\n\t * lockless clock. It is not guaranteed to be coherent across\n\t * CPUs, nor across CPU idle events.\n\t */\n\tpreempt_disable_notrace();\n\tclock = sched_clock();\n\tpreempt_enable_notrace();\n\n\treturn clock;\n}",
          "includes": [
            "#include <linux/trace_clock.h>",
            "#include <linux/ktime.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_clock.h>\n#include <linux/ktime.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/hardirq.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n\nu64 notrace trace_clock_local(void)\n{\n\tu64 clock;\n\n\t/*\n\t * sched_clock() is an architecture implemented, fast, scalable,\n\t * lockless clock. It is not guaranteed to be coherent across\n\t * CPUs, nor across CPU idle events.\n\t */\n\tpreempt_disable_notrace();\n\tclock = sched_clock();\n\tpreempt_enable_notrace();\n\n\treturn clock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_pop_return_trace",
          "args": [
            "&trace",
            "&ret",
            "frame_pointer"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_pop_return_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "186-245",
          "snippet": "static void\nftrace_pop_return_trace(struct ftrace_graph_ret *trace, unsigned long *ret,\n\t\t\tunsigned long frame_pointer)\n{\n\tint index;\n\n\tindex = current->curr_ret_stack;\n\n\t/*\n\t * A negative index here means that it's just returned from a\n\t * notrace'd function.  Recover index to get an original\n\t * return address.  See ftrace_push_return_trace().\n\t *\n\t * TODO: Need to check whether the stack gets corrupted.\n\t */\n\tif (index < 0)\n\t\tindex += FTRACE_NOTRACE_DEPTH;\n\n\tif (unlikely(index < 0 || index >= FTRACE_RETFUNC_DEPTH)) {\n\t\tftrace_graph_stop();\n\t\tWARN_ON(1);\n\t\t/* Might as well panic, otherwise we have no where to go */\n\t\t*ret = (unsigned long)panic;\n\t\treturn;\n\t}\n\n#ifdef HAVE_FUNCTION_GRAPH_FP_TEST\n\t/*\n\t * The arch may choose to record the frame pointer used\n\t * and check it here to make sure that it is what we expect it\n\t * to be. If gcc does not set the place holder of the return\n\t * address in the frame pointer, and does a copy instead, then\n\t * the function graph trace will fail. This test detects this\n\t * case.\n\t *\n\t * Currently, x86_32 with optimize for size (-Os) makes the latest\n\t * gcc do the above.\n\t *\n\t * Note, -mfentry does not use frame pointers, and this test\n\t *  is not needed if CC_USING_FENTRY is set.\n\t */\n\tif (unlikely(current->ret_stack[index].fp != frame_pointer)) {\n\t\tftrace_graph_stop();\n\t\tWARN(1, \"Bad frame pointer: expected %lx, received %lx\\n\"\n\t\t     \"  from func %ps return to %lx\\n\",\n\t\t     current->ret_stack[index].fp,\n\t\t     frame_pointer,\n\t\t     (void *)current->ret_stack[index].func,\n\t\t     current->ret_stack[index].ret);\n\t\t*ret = (unsigned long)panic;\n\t\treturn;\n\t}\n#endif\n\n\t*ret = current->ret_stack[index].ret;\n\ttrace->func = current->ret_stack[index].func;\n\ttrace->calltime = current->ret_stack[index].calltime;\n\ttrace->overrun = atomic_read(&current->trace_overrun);\n\ttrace->depth = index;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nftrace_pop_return_trace(struct ftrace_graph_ret *trace, unsigned long *ret,\n\t\t\tunsigned long frame_pointer)\n{\n\tint index;\n\n\tindex = current->curr_ret_stack;\n\n\t/*\n\t * A negative index here means that it's just returned from a\n\t * notrace'd function.  Recover index to get an original\n\t * return address.  See ftrace_push_return_trace().\n\t *\n\t * TODO: Need to check whether the stack gets corrupted.\n\t */\n\tif (index < 0)\n\t\tindex += FTRACE_NOTRACE_DEPTH;\n\n\tif (unlikely(index < 0 || index >= FTRACE_RETFUNC_DEPTH)) {\n\t\tftrace_graph_stop();\n\t\tWARN_ON(1);\n\t\t/* Might as well panic, otherwise we have no where to go */\n\t\t*ret = (unsigned long)panic;\n\t\treturn;\n\t}\n\n#ifdef HAVE_FUNCTION_GRAPH_FP_TEST\n\t/*\n\t * The arch may choose to record the frame pointer used\n\t * and check it here to make sure that it is what we expect it\n\t * to be. If gcc does not set the place holder of the return\n\t * address in the frame pointer, and does a copy instead, then\n\t * the function graph trace will fail. This test detects this\n\t * case.\n\t *\n\t * Currently, x86_32 with optimize for size (-Os) makes the latest\n\t * gcc do the above.\n\t *\n\t * Note, -mfentry does not use frame pointers, and this test\n\t *  is not needed if CC_USING_FENTRY is set.\n\t */\n\tif (unlikely(current->ret_stack[index].fp != frame_pointer)) {\n\t\tftrace_graph_stop();\n\t\tWARN(1, \"Bad frame pointer: expected %lx, received %lx\\n\"\n\t\t     \"  from func %ps return to %lx\\n\",\n\t\t     current->ret_stack[index].fp,\n\t\t     frame_pointer,\n\t\t     (void *)current->ret_stack[index].func,\n\t\t     current->ret_stack[index].ret);\n\t\t*ret = (unsigned long)panic;\n\t\treturn;\n\t}\n#endif\n\n\t*ret = current->ret_stack[index].ret;\n\ttrace->func = current->ret_stack[index].func;\n\ttrace->calltime = current->ret_stack[index].calltime;\n\ttrace->overrun = atomic_read(&current->trace_overrun);\n\ttrace->depth = index;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nunsigned long ftrace_return_to_handler(unsigned long frame_pointer)\n{\n\tstruct ftrace_graph_ret trace;\n\tunsigned long ret;\n\n\tftrace_pop_return_trace(&trace, &ret, frame_pointer);\n\ttrace.rettime = trace_clock_local();\n\tbarrier();\n\tcurrent->curr_ret_stack--;\n\t/*\n\t * The curr_ret_stack can be less than -1 only if it was\n\t * filtered out and it's about to return from the function.\n\t * Recover the index and continue to trace normal functions.\n\t */\n\tif (current->curr_ret_stack < -1) {\n\t\tcurrent->curr_ret_stack += FTRACE_NOTRACE_DEPTH;\n\t\treturn ret;\n\t}\n\n\t/*\n\t * The trace should run after decrementing the ret counter\n\t * in case an interrupt were to come in. We don't want to\n\t * lose the interrupt if max_depth is set.\n\t */\n\tftrace_graph_return(&trace);\n\n\tif (unlikely(!ret)) {\n\t\tftrace_graph_stop();\n\t\tWARN_ON(1);\n\t\t/* Might as well panic. What else to do? */\n\t\tret = (unsigned long)panic;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ftrace_pop_return_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "186-245",
    "snippet": "static void\nftrace_pop_return_trace(struct ftrace_graph_ret *trace, unsigned long *ret,\n\t\t\tunsigned long frame_pointer)\n{\n\tint index;\n\n\tindex = current->curr_ret_stack;\n\n\t/*\n\t * A negative index here means that it's just returned from a\n\t * notrace'd function.  Recover index to get an original\n\t * return address.  See ftrace_push_return_trace().\n\t *\n\t * TODO: Need to check whether the stack gets corrupted.\n\t */\n\tif (index < 0)\n\t\tindex += FTRACE_NOTRACE_DEPTH;\n\n\tif (unlikely(index < 0 || index >= FTRACE_RETFUNC_DEPTH)) {\n\t\tftrace_graph_stop();\n\t\tWARN_ON(1);\n\t\t/* Might as well panic, otherwise we have no where to go */\n\t\t*ret = (unsigned long)panic;\n\t\treturn;\n\t}\n\n#ifdef HAVE_FUNCTION_GRAPH_FP_TEST\n\t/*\n\t * The arch may choose to record the frame pointer used\n\t * and check it here to make sure that it is what we expect it\n\t * to be. If gcc does not set the place holder of the return\n\t * address in the frame pointer, and does a copy instead, then\n\t * the function graph trace will fail. This test detects this\n\t * case.\n\t *\n\t * Currently, x86_32 with optimize for size (-Os) makes the latest\n\t * gcc do the above.\n\t *\n\t * Note, -mfentry does not use frame pointers, and this test\n\t *  is not needed if CC_USING_FENTRY is set.\n\t */\n\tif (unlikely(current->ret_stack[index].fp != frame_pointer)) {\n\t\tftrace_graph_stop();\n\t\tWARN(1, \"Bad frame pointer: expected %lx, received %lx\\n\"\n\t\t     \"  from func %ps return to %lx\\n\",\n\t\t     current->ret_stack[index].fp,\n\t\t     frame_pointer,\n\t\t     (void *)current->ret_stack[index].func,\n\t\t     current->ret_stack[index].ret);\n\t\t*ret = (unsigned long)panic;\n\t\treturn;\n\t}\n#endif\n\n\t*ret = current->ret_stack[index].ret;\n\ttrace->func = current->ret_stack[index].func;\n\ttrace->calltime = current->ret_stack[index].calltime;\n\ttrace->overrun = atomic_read(&current->trace_overrun);\n\ttrace->depth = index;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&current->trace_overrun"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Bad frame pointer: expected %lx, received %lx\\n\"\n\t\t     \"  from func %ps return to %lx\\n\"",
            "current->ret_stack[index].fp",
            "frame_pointer",
            "(void *)current->ret_stack[index].func",
            "current->ret_stack[index].ret"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_graph_stop",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "41-44",
          "snippet": "void ftrace_graph_stop(void)\n{\n\tkill_ftrace_graph = true;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kill_ftrace_graph;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic bool kill_ftrace_graph;\n\nvoid ftrace_graph_stop(void)\n{\n\tkill_ftrace_graph = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->ret_stack[index].fp != frame_pointer"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index < 0 || index >= FTRACE_RETFUNC_DEPTH"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic void\nftrace_pop_return_trace(struct ftrace_graph_ret *trace, unsigned long *ret,\n\t\t\tunsigned long frame_pointer)\n{\n\tint index;\n\n\tindex = current->curr_ret_stack;\n\n\t/*\n\t * A negative index here means that it's just returned from a\n\t * notrace'd function.  Recover index to get an original\n\t * return address.  See ftrace_push_return_trace().\n\t *\n\t * TODO: Need to check whether the stack gets corrupted.\n\t */\n\tif (index < 0)\n\t\tindex += FTRACE_NOTRACE_DEPTH;\n\n\tif (unlikely(index < 0 || index >= FTRACE_RETFUNC_DEPTH)) {\n\t\tftrace_graph_stop();\n\t\tWARN_ON(1);\n\t\t/* Might as well panic, otherwise we have no where to go */\n\t\t*ret = (unsigned long)panic;\n\t\treturn;\n\t}\n\n#ifdef HAVE_FUNCTION_GRAPH_FP_TEST\n\t/*\n\t * The arch may choose to record the frame pointer used\n\t * and check it here to make sure that it is what we expect it\n\t * to be. If gcc does not set the place holder of the return\n\t * address in the frame pointer, and does a copy instead, then\n\t * the function graph trace will fail. This test detects this\n\t * case.\n\t *\n\t * Currently, x86_32 with optimize for size (-Os) makes the latest\n\t * gcc do the above.\n\t *\n\t * Note, -mfentry does not use frame pointers, and this test\n\t *  is not needed if CC_USING_FENTRY is set.\n\t */\n\tif (unlikely(current->ret_stack[index].fp != frame_pointer)) {\n\t\tftrace_graph_stop();\n\t\tWARN(1, \"Bad frame pointer: expected %lx, received %lx\\n\"\n\t\t     \"  from func %ps return to %lx\\n\",\n\t\t     current->ret_stack[index].fp,\n\t\t     frame_pointer,\n\t\t     (void *)current->ret_stack[index].func,\n\t\t     current->ret_stack[index].ret);\n\t\t*ret = (unsigned long)panic;\n\t\treturn;\n\t}\n#endif\n\n\t*ret = current->ret_stack[index].ret;\n\ttrace->func = current->ret_stack[index].func;\n\ttrace->calltime = current->ret_stack[index].calltime;\n\ttrace->overrun = atomic_read(&current->trace_overrun);\n\ttrace->depth = index;\n}"
  },
  {
    "function_name": "ftrace_push_return_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "121-183",
    "snippet": "int\nftrace_push_return_trace(unsigned long ret, unsigned long func, int *depth,\n\t\t\t unsigned long frame_pointer, unsigned long *retp)\n{\n\tunsigned long long calltime;\n\tint index;\n\n\tif (unlikely(ftrace_graph_is_dead()))\n\t\treturn -EBUSY;\n\n\tif (!current->ret_stack)\n\t\treturn -EBUSY;\n\n\t/*\n\t * We must make sure the ret_stack is tested before we read\n\t * anything else.\n\t */\n\tsmp_rmb();\n\n\t/* The return trace stack is full */\n\tif (current->curr_ret_stack == FTRACE_RETFUNC_DEPTH - 1) {\n\t\tatomic_inc(&current->trace_overrun);\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * The curr_ret_stack is an index to ftrace return stack of\n\t * current task.  Its value should be in [0, FTRACE_RETFUNC_\n\t * DEPTH) when the function graph tracer is used.  To support\n\t * filtering out specific functions, it makes the index\n\t * negative by subtracting huge value (FTRACE_NOTRACE_DEPTH)\n\t * so when it sees a negative index the ftrace will ignore\n\t * the record.  And the index gets recovered when returning\n\t * from the filtered function by adding the FTRACE_NOTRACE_\n\t * DEPTH and then it'll continue to record functions normally.\n\t *\n\t * The curr_ret_stack is initialized to -1 and get increased\n\t * in this function.  So it can be less than -1 only if it was\n\t * filtered out via ftrace_graph_notrace_addr() which can be\n\t * set from set_graph_notrace file in tracefs by user.\n\t */\n\tif (current->curr_ret_stack < -1)\n\t\treturn -EBUSY;\n\n\tcalltime = trace_clock_local();\n\n\tindex = ++current->curr_ret_stack;\n\tif (ftrace_graph_notrace_addr(func))\n\t\tcurrent->curr_ret_stack -= FTRACE_NOTRACE_DEPTH;\n\tbarrier();\n\tcurrent->ret_stack[index].ret = ret;\n\tcurrent->ret_stack[index].func = func;\n\tcurrent->ret_stack[index].calltime = calltime;\n#ifdef HAVE_FUNCTION_GRAPH_FP_TEST\n\tcurrent->ret_stack[index].fp = frame_pointer;\n#endif\n#ifdef HAVE_FUNCTION_GRAPH_RET_ADDR_PTR\n\tcurrent->ret_stack[index].retp = retp;\n#endif\n\t*depth = current->curr_ret_stack;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/membarrier.c",
          "lines": "189-219",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tif (atomic_read(&mm->mm_users) == 1 && get_nr_threads(p) == 1) {\n\t\t/*\n\t\t * For single mm user, single threaded process, we can\n\t\t * simply issue a memory barrier after setting\n\t\t * MEMBARRIER_STATE_GLOBAL_EXPEDITED to guarantee that\n\t\t * no memory access following registration is reordered\n\t\t * before registration.\n\t\t */\n\t\tsmp_mb();\n\t} else {\n\t\t/*\n\t\t * For multi-mm user threads, we need to ensure all\n\t\t * future scheduler executions will observe the new\n\t\t * thread flag state for this mm.\n\t\t */\n\t\tsynchronize_sched();\n\t}\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_notrace_addr",
          "args": [
            "func"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_notrace_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "893-896",
          "snippet": "static inline int ftrace_graph_notrace_addr(unsigned long addr)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline int ftrace_graph_notrace_addr(unsigned long addr)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_clock_local",
          "args": [],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "trace_clock_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_clock.c",
          "lines": "32-46",
          "snippet": "u64 notrace trace_clock_local(void)\n{\n\tu64 clock;\n\n\t/*\n\t * sched_clock() is an architecture implemented, fast, scalable,\n\t * lockless clock. It is not guaranteed to be coherent across\n\t * CPUs, nor across CPU idle events.\n\t */\n\tpreempt_disable_notrace();\n\tclock = sched_clock();\n\tpreempt_enable_notrace();\n\n\treturn clock;\n}",
          "includes": [
            "#include <linux/trace_clock.h>",
            "#include <linux/ktime.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_clock.h>\n#include <linux/ktime.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/hardirq.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n\nu64 notrace trace_clock_local(void)\n{\n\tu64 clock;\n\n\t/*\n\t * sched_clock() is an architecture implemented, fast, scalable,\n\t * lockless clock. It is not guaranteed to be coherent across\n\t * CPUs, nor across CPU idle events.\n\t */\n\tpreempt_disable_notrace();\n\tclock = sched_clock();\n\tpreempt_enable_notrace();\n\n\treturn clock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&current->trace_overrun"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ftrace_graph_is_dead()"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_graph_is_dead",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_is_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
          "lines": "28-31",
          "snippet": "bool ftrace_graph_is_dead(void)\n{\n\treturn kill_ftrace_graph;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kill_ftrace_graph;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic bool kill_ftrace_graph;\n\nbool ftrace_graph_is_dead(void)\n{\n\treturn kill_ftrace_graph;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nint\nftrace_push_return_trace(unsigned long ret, unsigned long func, int *depth,\n\t\t\t unsigned long frame_pointer, unsigned long *retp)\n{\n\tunsigned long long calltime;\n\tint index;\n\n\tif (unlikely(ftrace_graph_is_dead()))\n\t\treturn -EBUSY;\n\n\tif (!current->ret_stack)\n\t\treturn -EBUSY;\n\n\t/*\n\t * We must make sure the ret_stack is tested before we read\n\t * anything else.\n\t */\n\tsmp_rmb();\n\n\t/* The return trace stack is full */\n\tif (current->curr_ret_stack == FTRACE_RETFUNC_DEPTH - 1) {\n\t\tatomic_inc(&current->trace_overrun);\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * The curr_ret_stack is an index to ftrace return stack of\n\t * current task.  Its value should be in [0, FTRACE_RETFUNC_\n\t * DEPTH) when the function graph tracer is used.  To support\n\t * filtering out specific functions, it makes the index\n\t * negative by subtracting huge value (FTRACE_NOTRACE_DEPTH)\n\t * so when it sees a negative index the ftrace will ignore\n\t * the record.  And the index gets recovered when returning\n\t * from the filtered function by adding the FTRACE_NOTRACE_\n\t * DEPTH and then it'll continue to record functions normally.\n\t *\n\t * The curr_ret_stack is initialized to -1 and get increased\n\t * in this function.  So it can be less than -1 only if it was\n\t * filtered out via ftrace_graph_notrace_addr() which can be\n\t * set from set_graph_notrace file in tracefs by user.\n\t */\n\tif (current->curr_ret_stack < -1)\n\t\treturn -EBUSY;\n\n\tcalltime = trace_clock_local();\n\n\tindex = ++current->curr_ret_stack;\n\tif (ftrace_graph_notrace_addr(func))\n\t\tcurrent->curr_ret_stack -= FTRACE_NOTRACE_DEPTH;\n\tbarrier();\n\tcurrent->ret_stack[index].ret = ret;\n\tcurrent->ret_stack[index].func = func;\n\tcurrent->ret_stack[index].calltime = calltime;\n#ifdef HAVE_FUNCTION_GRAPH_FP_TEST\n\tcurrent->ret_stack[index].fp = frame_pointer;\n#endif\n#ifdef HAVE_FUNCTION_GRAPH_RET_ADDR_PTR\n\tcurrent->ret_stack[index].retp = retp;\n#endif\n\t*depth = current->curr_ret_stack;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ftrace_graph_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "41-44",
    "snippet": "void ftrace_graph_stop(void)\n{\n\tkill_ftrace_graph = true;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kill_ftrace_graph;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic bool kill_ftrace_graph;\n\nvoid ftrace_graph_stop(void)\n{\n\tkill_ftrace_graph = true;\n}"
  },
  {
    "function_name": "ftrace_graph_is_dead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_functions_graph.c",
    "lines": "28-31",
    "snippet": "bool ftrace_graph_is_dead(void)\n{\n\treturn kill_ftrace_graph;\n}",
    "includes": [
      "#include \"trace_output.h\"",
      "#include \"trace.h\"",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kill_ftrace_graph;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic bool kill_ftrace_graph;\n\nbool ftrace_graph_is_dead(void)\n{\n\treturn kill_ftrace_graph;\n}"
  }
]