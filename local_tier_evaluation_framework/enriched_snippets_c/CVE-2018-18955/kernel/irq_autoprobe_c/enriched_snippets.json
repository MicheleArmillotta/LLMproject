[
  {
    "function_name": "probe_irq_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/autoprobe.c",
    "lines": "157-182",
    "snippet": "int probe_irq_off(unsigned long val)\n{\n\tint i, irq_found = 0, nr_of_irqs = 0;\n\tstruct irq_desc *desc;\n\n\tfor_each_irq_desc(i, desc) {\n\t\traw_spin_lock_irq(&desc->lock);\n\n\t\tif (desc->istate & IRQS_AUTODETECT) {\n\t\t\tif (!(desc->istate & IRQS_WAITING)) {\n\t\t\t\tif (!nr_of_irqs)\n\t\t\t\t\tirq_found = i;\n\t\t\t\tnr_of_irqs++;\n\t\t\t}\n\t\t\tdesc->istate &= ~IRQS_AUTODETECT;\n\t\t\tirq_shutdown(desc);\n\t\t}\n\t\traw_spin_unlock_irq(&desc->lock);\n\t}\n\tmutex_unlock(&probing_active);\n\n\tif (nr_of_irqs > 1)\n\t\tirq_found = -irq_found;\n\n\treturn irq_found;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/async.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(probing_active);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&probing_active"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&desc->lock"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_shutdown",
          "args": [
            "desc"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "irq_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "304-324",
          "snippet": "void irq_shutdown(struct irq_desc *desc)\n{\n\tif (irqd_is_started(&desc->irq_data)) {\n\t\tdesc->depth = 1;\n\t\tif (desc->irq_data.chip->irq_shutdown) {\n\t\t\tdesc->irq_data.chip->irq_shutdown(&desc->irq_data);\n\t\t\tirq_state_set_disabled(desc);\n\t\t\tirq_state_set_masked(desc);\n\t\t} else {\n\t\t\t__irq_disable(desc, true);\n\t\t}\n\t\tirq_state_clr_started(desc);\n\t}\n\t/*\n\t * This must be called even if the interrupt was never started up,\n\t * because the activation can happen before the interrupt is\n\t * available for request/startup. It has it's own state tracking so\n\t * it's safe to call it unconditionally.\n\t */\n\tirq_domain_deactivate_irq(&desc->irq_data);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_shutdown(struct irq_desc *desc)\n{\n\tif (irqd_is_started(&desc->irq_data)) {\n\t\tdesc->depth = 1;\n\t\tif (desc->irq_data.chip->irq_shutdown) {\n\t\t\tdesc->irq_data.chip->irq_shutdown(&desc->irq_data);\n\t\t\tirq_state_set_disabled(desc);\n\t\t\tirq_state_set_masked(desc);\n\t\t} else {\n\t\t\t__irq_disable(desc, true);\n\t\t}\n\t\tirq_state_clr_started(desc);\n\t}\n\t/*\n\t * This must be called even if the interrupt was never started up,\n\t * because the activation can happen before the interrupt is\n\t * available for request/startup. It has it's own state tracking so\n\t * it's safe to call it unconditionally.\n\t */\n\tirq_domain_deactivate_irq(&desc->irq_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&desc->lock"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_irq_desc",
          "args": [
            "i",
            "desc"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/async.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic DEFINE_MUTEX(probing_active);\n\nint probe_irq_off(unsigned long val)\n{\n\tint i, irq_found = 0, nr_of_irqs = 0;\n\tstruct irq_desc *desc;\n\n\tfor_each_irq_desc(i, desc) {\n\t\traw_spin_lock_irq(&desc->lock);\n\n\t\tif (desc->istate & IRQS_AUTODETECT) {\n\t\t\tif (!(desc->istate & IRQS_WAITING)) {\n\t\t\t\tif (!nr_of_irqs)\n\t\t\t\t\tirq_found = i;\n\t\t\t\tnr_of_irqs++;\n\t\t\t}\n\t\t\tdesc->istate &= ~IRQS_AUTODETECT;\n\t\t\tirq_shutdown(desc);\n\t\t}\n\t\traw_spin_unlock_irq(&desc->lock);\n\t}\n\tmutex_unlock(&probing_active);\n\n\tif (nr_of_irqs > 1)\n\t\tirq_found = -irq_found;\n\n\treturn irq_found;\n}"
  },
  {
    "function_name": "probe_irq_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/autoprobe.c",
    "lines": "117-137",
    "snippet": "unsigned int probe_irq_mask(unsigned long val)\n{\n\tunsigned int mask = 0;\n\tstruct irq_desc *desc;\n\tint i;\n\n\tfor_each_irq_desc(i, desc) {\n\t\traw_spin_lock_irq(&desc->lock);\n\t\tif (desc->istate & IRQS_AUTODETECT) {\n\t\t\tif (i < 16 && !(desc->istate & IRQS_WAITING))\n\t\t\t\tmask |= 1 << i;\n\n\t\t\tdesc->istate &= ~IRQS_AUTODETECT;\n\t\t\tirq_shutdown(desc);\n\t\t}\n\t\traw_spin_unlock_irq(&desc->lock);\n\t}\n\tmutex_unlock(&probing_active);\n\n\treturn mask & val;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/async.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(probing_active);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&probing_active"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&desc->lock"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_shutdown",
          "args": [
            "desc"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "irq_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "304-324",
          "snippet": "void irq_shutdown(struct irq_desc *desc)\n{\n\tif (irqd_is_started(&desc->irq_data)) {\n\t\tdesc->depth = 1;\n\t\tif (desc->irq_data.chip->irq_shutdown) {\n\t\t\tdesc->irq_data.chip->irq_shutdown(&desc->irq_data);\n\t\t\tirq_state_set_disabled(desc);\n\t\t\tirq_state_set_masked(desc);\n\t\t} else {\n\t\t\t__irq_disable(desc, true);\n\t\t}\n\t\tirq_state_clr_started(desc);\n\t}\n\t/*\n\t * This must be called even if the interrupt was never started up,\n\t * because the activation can happen before the interrupt is\n\t * available for request/startup. It has it's own state tracking so\n\t * it's safe to call it unconditionally.\n\t */\n\tirq_domain_deactivate_irq(&desc->irq_data);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_shutdown(struct irq_desc *desc)\n{\n\tif (irqd_is_started(&desc->irq_data)) {\n\t\tdesc->depth = 1;\n\t\tif (desc->irq_data.chip->irq_shutdown) {\n\t\t\tdesc->irq_data.chip->irq_shutdown(&desc->irq_data);\n\t\t\tirq_state_set_disabled(desc);\n\t\t\tirq_state_set_masked(desc);\n\t\t} else {\n\t\t\t__irq_disable(desc, true);\n\t\t}\n\t\tirq_state_clr_started(desc);\n\t}\n\t/*\n\t * This must be called even if the interrupt was never started up,\n\t * because the activation can happen before the interrupt is\n\t * available for request/startup. It has it's own state tracking so\n\t * it's safe to call it unconditionally.\n\t */\n\tirq_domain_deactivate_irq(&desc->irq_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&desc->lock"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_irq_desc",
          "args": [
            "i",
            "desc"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/async.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic DEFINE_MUTEX(probing_active);\n\nunsigned int probe_irq_mask(unsigned long val)\n{\n\tunsigned int mask = 0;\n\tstruct irq_desc *desc;\n\tint i;\n\n\tfor_each_irq_desc(i, desc) {\n\t\traw_spin_lock_irq(&desc->lock);\n\t\tif (desc->istate & IRQS_AUTODETECT) {\n\t\t\tif (i < 16 && !(desc->istate & IRQS_WAITING))\n\t\t\t\tmask |= 1 << i;\n\n\t\t\tdesc->istate &= ~IRQS_AUTODETECT;\n\t\t\tirq_shutdown(desc);\n\t\t}\n\t\traw_spin_unlock_irq(&desc->lock);\n\t}\n\tmutex_unlock(&probing_active);\n\n\treturn mask & val;\n}"
  },
  {
    "function_name": "probe_irq_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/autoprobe.c",
    "lines": "30-102",
    "snippet": "unsigned long probe_irq_on(void)\n{\n\tstruct irq_desc *desc;\n\tunsigned long mask = 0;\n\tint i;\n\n\t/*\n\t * quiesce the kernel, or at least the asynchronous portion\n\t */\n\tasync_synchronize_full();\n\tmutex_lock(&probing_active);\n\t/*\n\t * something may have generated an irq long ago and we want to\n\t * flush such a longstanding irq before considering it as spurious.\n\t */\n\tfor_each_irq_desc_reverse(i, desc) {\n\t\traw_spin_lock_irq(&desc->lock);\n\t\tif (!desc->action && irq_settings_can_probe(desc)) {\n\t\t\t/*\n\t\t\t * Some chips need to know about probing in\n\t\t\t * progress:\n\t\t\t */\n\t\t\tif (desc->irq_data.chip->irq_set_type)\n\t\t\t\tdesc->irq_data.chip->irq_set_type(&desc->irq_data,\n\t\t\t\t\t\t\t IRQ_TYPE_PROBE);\n\t\t\tirq_activate_and_startup(desc, IRQ_NORESEND);\n\t\t}\n\t\traw_spin_unlock_irq(&desc->lock);\n\t}\n\n\t/* Wait for longstanding interrupts to trigger. */\n\tmsleep(20);\n\n\t/*\n\t * enable any unassigned irqs\n\t * (we must startup again here because if a longstanding irq\n\t * happened in the previous stage, it may have masked itself)\n\t */\n\tfor_each_irq_desc_reverse(i, desc) {\n\t\traw_spin_lock_irq(&desc->lock);\n\t\tif (!desc->action && irq_settings_can_probe(desc)) {\n\t\t\tdesc->istate |= IRQS_AUTODETECT | IRQS_WAITING;\n\t\t\tif (irq_activate_and_startup(desc, IRQ_NORESEND))\n\t\t\t\tdesc->istate |= IRQS_PENDING;\n\t\t}\n\t\traw_spin_unlock_irq(&desc->lock);\n\t}\n\n\t/*\n\t * Wait for spurious interrupts to trigger\n\t */\n\tmsleep(100);\n\n\t/*\n\t * Now filter out any obviously spurious interrupts\n\t */\n\tfor_each_irq_desc(i, desc) {\n\t\traw_spin_lock_irq(&desc->lock);\n\n\t\tif (desc->istate & IRQS_AUTODETECT) {\n\t\t\t/* It triggered already - consider it spurious. */\n\t\t\tif (!(desc->istate & IRQS_WAITING)) {\n\t\t\t\tdesc->istate &= ~IRQS_AUTODETECT;\n\t\t\t\tirq_shutdown(desc);\n\t\t\t} else\n\t\t\t\tif (i < 32)\n\t\t\t\t\tmask |= 1 << i;\n\t\t}\n\t\traw_spin_unlock_irq(&desc->lock);\n\t}\n\n\treturn mask;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/async.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(probing_active);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&desc->lock"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_shutdown",
          "args": [
            "desc"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "irq_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "304-324",
          "snippet": "void irq_shutdown(struct irq_desc *desc)\n{\n\tif (irqd_is_started(&desc->irq_data)) {\n\t\tdesc->depth = 1;\n\t\tif (desc->irq_data.chip->irq_shutdown) {\n\t\t\tdesc->irq_data.chip->irq_shutdown(&desc->irq_data);\n\t\t\tirq_state_set_disabled(desc);\n\t\t\tirq_state_set_masked(desc);\n\t\t} else {\n\t\t\t__irq_disable(desc, true);\n\t\t}\n\t\tirq_state_clr_started(desc);\n\t}\n\t/*\n\t * This must be called even if the interrupt was never started up,\n\t * because the activation can happen before the interrupt is\n\t * available for request/startup. It has it's own state tracking so\n\t * it's safe to call it unconditionally.\n\t */\n\tirq_domain_deactivate_irq(&desc->irq_data);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_shutdown(struct irq_desc *desc)\n{\n\tif (irqd_is_started(&desc->irq_data)) {\n\t\tdesc->depth = 1;\n\t\tif (desc->irq_data.chip->irq_shutdown) {\n\t\t\tdesc->irq_data.chip->irq_shutdown(&desc->irq_data);\n\t\t\tirq_state_set_disabled(desc);\n\t\t\tirq_state_set_masked(desc);\n\t\t} else {\n\t\t\t__irq_disable(desc, true);\n\t\t}\n\t\tirq_state_clr_started(desc);\n\t}\n\t/*\n\t * This must be called even if the interrupt was never started up,\n\t * because the activation can happen before the interrupt is\n\t * available for request/startup. It has it's own state tracking so\n\t * it's safe to call it unconditionally.\n\t */\n\tirq_domain_deactivate_irq(&desc->irq_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&desc->lock"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_irq_desc",
          "args": [
            "i",
            "desc"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1965-1972",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_activate_and_startup",
          "args": [
            "desc",
            "IRQ_NORESEND"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "irq_activate_and_startup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "295-300",
          "snippet": "int irq_activate_and_startup(struct irq_desc *desc, bool resend)\n{\n\tif (WARN_ON(irq_activate(desc)))\n\t\treturn 0;\n\treturn irq_startup(desc, resend, IRQ_START_FORCE);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_activate_and_startup(struct irq_desc *desc, bool resend)\n{\n\tif (WARN_ON(irq_activate(desc)))\n\t\treturn 0;\n\treturn irq_startup(desc, resend, IRQ_START_FORCE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_can_probe",
          "args": [
            "desc"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_can_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/settings.h",
          "lines": "126-129",
          "snippet": "static inline bool irq_settings_can_probe(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOPROBE);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_can_probe(struct irq_desc *desc)\n{\n\treturn !(desc->status_use_accessors & _IRQ_NOPROBE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_irq_desc_reverse",
          "args": [
            "i",
            "desc"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "desc->irq_data.chip->irq_set_type",
          "args": [
            "&desc->irq_data",
            "IRQ_TYPE_PROBE"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_irq_desc_reverse",
          "args": [
            "i",
            "desc"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&probing_active"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "async_synchronize_full",
          "args": [],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "async_synchronize_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
          "lines": "241-244",
          "snippet": "void async_synchronize_full(void)\n{\n\tasync_synchronize_full_domain(NULL);\n}",
          "includes": [
            "#include \"workqueue_internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/export.h>",
            "#include <linux/ktime.h>",
            "#include <linux/atomic.h>",
            "#include <linux/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nvoid async_synchronize_full(void)\n{\n\tasync_synchronize_full_domain(NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/async.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic DEFINE_MUTEX(probing_active);\n\nunsigned long probe_irq_on(void)\n{\n\tstruct irq_desc *desc;\n\tunsigned long mask = 0;\n\tint i;\n\n\t/*\n\t * quiesce the kernel, or at least the asynchronous portion\n\t */\n\tasync_synchronize_full();\n\tmutex_lock(&probing_active);\n\t/*\n\t * something may have generated an irq long ago and we want to\n\t * flush such a longstanding irq before considering it as spurious.\n\t */\n\tfor_each_irq_desc_reverse(i, desc) {\n\t\traw_spin_lock_irq(&desc->lock);\n\t\tif (!desc->action && irq_settings_can_probe(desc)) {\n\t\t\t/*\n\t\t\t * Some chips need to know about probing in\n\t\t\t * progress:\n\t\t\t */\n\t\t\tif (desc->irq_data.chip->irq_set_type)\n\t\t\t\tdesc->irq_data.chip->irq_set_type(&desc->irq_data,\n\t\t\t\t\t\t\t IRQ_TYPE_PROBE);\n\t\t\tirq_activate_and_startup(desc, IRQ_NORESEND);\n\t\t}\n\t\traw_spin_unlock_irq(&desc->lock);\n\t}\n\n\t/* Wait for longstanding interrupts to trigger. */\n\tmsleep(20);\n\n\t/*\n\t * enable any unassigned irqs\n\t * (we must startup again here because if a longstanding irq\n\t * happened in the previous stage, it may have masked itself)\n\t */\n\tfor_each_irq_desc_reverse(i, desc) {\n\t\traw_spin_lock_irq(&desc->lock);\n\t\tif (!desc->action && irq_settings_can_probe(desc)) {\n\t\t\tdesc->istate |= IRQS_AUTODETECT | IRQS_WAITING;\n\t\t\tif (irq_activate_and_startup(desc, IRQ_NORESEND))\n\t\t\t\tdesc->istate |= IRQS_PENDING;\n\t\t}\n\t\traw_spin_unlock_irq(&desc->lock);\n\t}\n\n\t/*\n\t * Wait for spurious interrupts to trigger\n\t */\n\tmsleep(100);\n\n\t/*\n\t * Now filter out any obviously spurious interrupts\n\t */\n\tfor_each_irq_desc(i, desc) {\n\t\traw_spin_lock_irq(&desc->lock);\n\n\t\tif (desc->istate & IRQS_AUTODETECT) {\n\t\t\t/* It triggered already - consider it spurious. */\n\t\t\tif (!(desc->istate & IRQS_WAITING)) {\n\t\t\t\tdesc->istate &= ~IRQS_AUTODETECT;\n\t\t\t\tirq_shutdown(desc);\n\t\t\t} else\n\t\t\t\tif (i < 32)\n\t\t\t\t\tmask |= 1 << i;\n\t\t}\n\t\traw_spin_unlock_irq(&desc->lock);\n\t}\n\n\treturn mask;\n}"
  }
]